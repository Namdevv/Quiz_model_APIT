[
  {
    "question_id": "EQ5001",
    "question": "Which HTTP method is commonly used to retrieve data from an API?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "GET is the standard method for retrieving data."
  },
  {
    "question_id": "EQ5002",
    "question": "What does HTTP status code 404 represent?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "OK",
      "B": "Unauthorized",
      "C": "Not Found",
      "D": "Conflict"
    },
    "explanation": "404 indicates the requested resource could not be found."
  },
  {
    "question_id": "EQ5003",
    "question": "What is the purpose of the HTTP POST method?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Retrieve data",
      "B": "Submit data to create resources",
      "C": "Update existing resources",
      "D": "Delete resources"
    },
    "explanation": "POST is used to create new resources with data in the request body."
  },
  {
    "question_id": "EQ5004",
    "question": "Write one simple positive test case for a login API.",
    "answer": "Send POST /login with valid username and password → expect 200 OK with token.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Positive test case checks correct credentials."
  },
  {
    "question_id": "EQ5005",
    "question": "Which of these HTTP status codes means 'Unauthorized'?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "401",
      "C": "403",
      "D": "404"
    },
    "explanation": "401 Unauthorized indicates missing or invalid credentials."
  },
  {
    "question_id": "EQ5006",
    "question": "What is a common precondition for testing a user profile endpoint?",
    "answer": "User must be logged in and have a valid token.",
    "category": "Test Step",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Preconditions ensure valid context before calling APIs."
  },
  {
    "question_id": "EQ5007",
    "question": "Which HTTP method is considered idempotent?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "PATCH",
      "C": "PUT",
      "D": "CONNECT"
    },
    "explanation": "PUT is idempotent because multiple identical requests have the same effect."
  },
  {
    "question_id": "EQ5008",
    "question": "Write a simple negative test for a register API.",
    "answer": "Send POST /register without password field → expect 400 Bad Request.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Negative test checks missing required fields."
  },
  {
    "question_id": "EQ5009",
    "question": "Which HTTP status code means 'OK'?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "500"
    },
    "explanation": "200 OK is the standard success code."
  },
  {
    "question_id": "EQ5010",
    "question": "What is the role of a schema in API testing?",
    "answer": "To define the expected structure of request and response data.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Schemas validate format and fields of API messages."
  },
  {
    "question_id": "EQ5011",
    "question": "Which HTTP method is used to delete a resource?",
    "answer": "D",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "DELETE removes the resource specified in the URL."
  },
  {
    "question_id": "EQ5012",
    "question": "Write a simple test step for validating a 201 Created response.",
    "answer": "Send POST /users with valid data → expect 201 Created and Location header.",
    "category": "Test Step",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "201 Created confirms resource was successfully created."
  },
  {
    "question_id": "EQ5013",
    "question": "Which HTTP header is typically used for authentication tokens?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Content-Type",
      "B": "Authorization",
      "C": "Accept",
      "D": "Cache-Control"
    },
    "explanation": "Authorization header carries credentials or tokens."
  },
  {
    "question_id": "EQ5014",
    "question": "What is the purpose of mocking in API testing?",
    "answer": "To simulate external dependencies or services that are unavailable.",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Mocking reduces dependencies during testing."
  },
  {
    "question_id": "EQ5015",
    "question": "Which HTTP status code indicates 'Created'?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "403"
    },
    "explanation": "201 Created confirms successful creation of a resource."
  },
  {
    "question_id": "EQ5016",
    "question": "Write one easy test case for an API that fetches product list.",
    "answer": "Send GET /products → expect 200 OK with non-empty array.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Simple test to check product list retrieval."
  },
  {
    "question_id": "EQ5017",
    "question": "Which HTTP status indicates 'Internal Server Error'?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "400",
      "C": "403",
      "D": "500"
    },
    "explanation": "500 indicates unexpected server-side failure."
  },
  {
    "question_id": "EQ5018",
    "question": "What is the purpose of a precondition in a test case?",
    "answer": "It specifies the conditions that must be met before a test can run.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Preconditions ensure valid setup for tests."
  },
  {
    "question_id": "EQ5019",
    "question": "Which HTTP status is appropriate for forbidden access with valid credentials?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "401 Unauthorized",
      "B": "200 OK",
      "C": "403 Forbidden",
      "D": "404 Not Found"
    },
    "explanation": "403 Forbidden indicates insufficient permissions despite valid login."
  },
  {
    "question_id": "EQ5020",
    "question": "Write one negative test for file upload with an unsupported format.",
    "answer": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Tests rejection of unsupported file formats."
  },
  {
    "question_id": "EQ5021",
    "question": "Which HTTP method is typically used for partial updates?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "PATCH",
      "C": "POST",
      "D": "DELETE"
    },
    "explanation": "PATCH is used to modify part of a resource."
  },
  {
    "question_id": "EQ5022",
    "question": "What is the purpose of a test case description?",
    "answer": "To explain the objective and scope of a test scenario.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Descriptions provide clarity on what the test validates."
  },
  {
    "question_id": "EQ5023",
    "question": "Which HTTP header indicates the format of request body?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Content-Type",
      "B": "Authorization",
      "C": "User-Agent",
      "D": "Accept-Encoding"
    },
    "explanation": "Content-Type defines the media type of request body."
  },
  {
    "question_id": "EQ5024",
    "question": "Write a test step to validate response time under 1 second.",
    "answer": "Send GET /status → assert response time < 1000 ms.",
    "category": "Performance & Load Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Checks performance requirement for response time."
  },
  {
    "question_id": "EQ5025",
    "question": "Which HTTP status code indicates a conflict, such as duplicate resource creation?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "409 Conflict"
    },
    "explanation": "409 Conflict is used when request conflicts with current state."
  },
  {
    "question_id": "EQ5026",
    "question": "Which HTTP status code means 'Bad Request'?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "500"
    },
    "explanation": "400 Bad Request indicates invalid syntax or parameters."
  },
  {
    "question_id": "EQ5027",
    "question": "Write one simple positive test for GET /health endpoint.",
    "answer": "Send GET /health → expect 200 OK with status=healthy.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Health checks confirm service availability."
  },
  {
    "question_id": "EQ5028",
    "question": "Which HTTP method is used to fully update a resource?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "PUT",
      "C": "PATCH",
      "D": "DELETE"
    },
    "explanation": "PUT replaces an existing resource with new data."
  },
  {
    "question_id": "EQ5029",
    "question": "What is the purpose of using test data management in API testing?",
    "answer": "To ensure consistent and reusable datasets for testing across environments.",
    "category": "Environment & Test Data Management",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test data consistency reduces flakiness in tests."
  },
  {
    "question_id": "EQ5030",
    "question": "Which HTTP status indicates 'Forbidden'?",
    "answer": "D",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "401",
      "D": "403"
    },
    "explanation": "403 Forbidden means user is authenticated but not authorized."
  },
  {
    "question_id": "EQ5031",
    "question": "Write one easy negative test case for an API expecting JSON format.",
    "answer": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Tests rejection of invalid content type."
  },
  {
    "question_id": "EQ5032",
    "question": "Which HTTP status code represents 'Too Many Requests'?",
    "answer": "B",
    "category": "Security Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "408",
      "B": "429",
      "C": "503",
      "D": "504"
    },
    "explanation": "429 Too Many Requests is returned when rate limits are exceeded."
  },
  {
    "question_id": "EQ5033",
    "question": "What is the role of assertions in API testing?",
    "answer": "To verify that the actual response matches the expected result.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Assertions validate correctness of API responses."
  },
  {
    "question_id": "EQ5034",
    "question": "Which HTTP status indicates a timeout from the server?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "404",
      "B": "400",
      "C": "200",
      "D": "504"
    },
    "explanation": "504 Gateway Timeout indicates the server did not respond in time."
  },
  {
    "question_id": "EQ5035",
    "question": "Write a test case to check DELETE /users/{id} works correctly.",
    "answer": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Confirms deletion and non-existence of resource."
  },
  {
    "question_id": "EQ5036",
    "question": "Which HTTP method is safe (does not change server state)?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "GET is safe because it only retrieves data."
  },
  {
    "question_id": "EQ5037",
    "question": "What does HTTP status 201 Created indicate?",
    "answer": "A new resource has been successfully created.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "201 means the request has resulted in resource creation."
  },
  {
    "question_id": "EQ5038",
    "question": "Which HTTP status is returned when a client request is well-formed but unauthorized?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "400",
      "C": "401",
      "D": "500"
    },
    "explanation": "401 Unauthorized is used for invalid credentials."
  },
  {
    "question_id": "EQ5039",
    "question": "Write one simple test for GET /users/{id} returning correct response.",
    "answer": "Send GET /users/123 → expect 200 OK with correct user data.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Checks retrieval of a user resource by ID."
  },
  {
    "question_id": "EQ5040",
    "question": "Which HTTP status indicates success but no content is returned?",
    "answer": "D",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "204"
    },
    "explanation": "204 No Content is returned on successful deletion or empty responses."
  },
  {
    "question_id": "EQ5041",
    "question": "What is the purpose of a 200 OK response?",
    "answer": "It confirms that the request has succeeded.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "200 OK is the most common HTTP success code."
  },
  {
    "question_id": "EQ5042",
    "question": "Which header is used to specify accepted response formats?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Content-Type",
      "B": "Accept",
      "C": "Authorization",
      "D": "Cache-Control"
    },
    "explanation": "Accept header tells the server which formats are expected (e.g., application/json)."
  },
  {
    "question_id": "EQ5043",
    "question": "Write one negative test to validate response for an invalid endpoint.",
    "answer": "Send GET /unknown → expect 404 Not Found.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Invalid endpoints must return 404."
  },
  {
    "question_id": "EQ5044",
    "question": "Which HTTP status code is used when the client must authenticate to access a resource?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "403",
      "C": "401",
      "D": "404"
    },
    "explanation": "401 Unauthorized requires authentication credentials."
  },
  {
    "question_id": "EQ5045",
    "question": "What does a test case assertion do?",
    "answer": "It checks that the actual result matches the expected outcome.",
    "category": "Test Step",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Assertions are the core of automated testing."
  },
  {
    "question_id": "EQ5046",
    "question": "Which HTTP status indicates the server cannot handle the request due to overload?",
    "answer": "A",
    "category": "Performance & Load Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "503 Service Unavailable",
      "B": "200 OK",
      "C": "404 Not Found",
      "D": "201 Created"
    },
    "explanation": "503 indicates temporary overload or maintenance."
  },
  {
    "question_id": "EQ5047",
    "question": "Write one positive test for file upload endpoint.",
    "answer": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Positive test ensures valid file uploads succeed."
  },
  {
    "question_id": "EQ5048",
    "question": "Which HTTP method is safe and idempotent?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "PATCH",
      "C": "GET",
      "D": "DELETE"
    },
    "explanation": "GET is both safe and idempotent."
  },
  {
    "question_id": "EQ5049",
    "question": "What is the role of 415 Unsupported Media Type?",
    "answer": "It indicates the server refuses to process the request because of unsupported format.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Validates format handling."
  },
  {
    "question_id": "EQ5050",
    "question": "Which HTTP status code means 'Request Timeout'?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "404",
      "B": "408",
      "C": "500",
      "D": "429"
    },
    "explanation": "408 Request Timeout indicates the client took too long to send the request."
  },
    {
    "question_id": "EQ5051",
    "question": "Which HTTP method is typically used to create a new resource?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "POST is the standard method for creating resources."
  },
  {
    "question_id": "EQ5052",
    "question": "Write a simple positive test for checking product details API.",
    "answer": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Checks retrieval of a valid product."
  },
  {
    "question_id": "EQ5053",
    "question": "Which HTTP status code is returned when a resource is successfully deleted?",
    "answer": "D",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "204"
    },
    "explanation": "204 No Content confirms deletion succeeded."
  },
  {
    "question_id": "EQ5054",
    "question": "What is the purpose of using Authorization headers in API testing?",
    "answer": "To provide credentials or tokens required to access secured endpoints.",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Authorization ensures only authenticated users access protected APIs."
  },
  {
    "question_id": "EQ5055",
    "question": "Which HTTP status code is used when a client sends an invalid JSON payload?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "500 Internal Server Error",
      "C": "400 Bad Request",
      "D": "201 Created"
    },
    "explanation": "400 indicates the request could not be understood due to invalid syntax."
  },
  {
    "question_id": "EQ5056",
    "question": "Write a negative test case for an API requiring authentication.",
    "answer": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Tests API response when no authentication is provided."
  },
  {
    "question_id": "EQ5057",
    "question": "Which HTTP method is generally used to update a resource entirely?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "PUT",
      "C": "PATCH",
      "D": "DELETE"
    },
    "explanation": "PUT replaces the full resource with new data."
  },
  {
    "question_id": "EQ5058",
    "question": "What is the role of 500 Internal Server Error in API testing?",
    "answer": "It indicates unexpected failures in the server during request processing.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "500 status highlights unhandled exceptions on the server."
  },
  {
    "question_id": "EQ5059",
    "question": "Which HTTP status means 'Conflict'?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "409"
    },
    "explanation": "409 Conflict occurs when resource creation/update conflicts with state."
  },
  {
    "question_id": "EQ5060",
    "question": "Write one positive test case for an API returning list of orders.",
    "answer": "Send GET /orders → expect 200 OK with array of order objects.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Positive test ensures orders endpoint returns valid list."
  },
  {
    "question_id": "EQ5061",
    "question": "Which HTTP method is used for partial updates to resources?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "PATCH",
      "D": "DELETE"
    },
    "explanation": "PATCH modifies only part of a resource."
  },
  {
    "question_id": "EQ5062",
    "question": "What is the function of response headers in API testing?",
    "answer": "They provide metadata about the response, such as content type and caching info.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Headers describe context for the response body."
  },
  {
    "question_id": "EQ5063",
    "question": "Which HTTP status code is returned when authentication is required but missing?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "401",
      "C": "403",
      "D": "404"
    },
    "explanation": "401 Unauthorized indicates missing or invalid credentials."
  },
  {
    "question_id": "EQ5064",
    "question": "Write one negative test for creating a duplicate resource.",
    "answer": "Send POST /users with existing email → expect 409 Conflict.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Prevents duplicate resource creation."
  },
  {
    "question_id": "EQ5065",
    "question": "Which HTTP method is most often used for safe read-only operations?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "POST",
      "D": "DELETE"
    },
    "explanation": "GET is safe and read-only."
  },
  {
    "question_id": "EQ5066",
    "question": "What is the role of 202 Accepted in APIs?",
    "answer": "It indicates that the request is accepted for processing but not completed yet.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "202 is used for async processing endpoints."
  },
  {
    "question_id": "EQ5067",
    "question": "Which HTTP status is returned when a resource has been permanently moved?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "404",
      "B": "302",
      "C": "301",
      "D": "500"
    },
    "explanation": "301 Moved Permanently indicates redirection."
  },
  {
    "question_id": "EQ5068",
    "question": "Write one easy positive test for checking API response schema.",
    "answer": "Send GET /users → expect 200 OK and response fields match schema definition.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Schema validation ensures correct structure of response."
  },
  {
    "question_id": "EQ5069",
    "question": "Which HTTP status indicates the request is valid but resource not found?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "404"
    },
    "explanation": "404 Not Found means the resource does not exist."
  },
  {
    "question_id": "EQ5070",
    "question": "What is the purpose of response body in API testing?",
    "answer": "To provide the actual data returned from an endpoint.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Response body contains API output data."
  },
  {
    "question_id": "EQ5071",
    "question": "Which HTTP status indicates client request timeout?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "500",
      "B": "408",
      "C": "403",
      "D": "404"
    },
    "explanation": "408 Request Timeout means the client did not finish sending in time."
  },
  {
    "question_id": "EQ5072",
    "question": "Write one test case for verifying logout functionality.",
    "answer": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Logout should invalidate token."
  },
  {
    "question_id": "EQ5073",
    "question": "Which HTTP status indicates a successful request returning JSON data?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "204 No Content",
      "D": "400 Bad Request"
    },
    "explanation": "200 OK is the standard code for successful GETs."
  },
  {
    "question_id": "EQ5074",
    "question": "What does a 415 Unsupported Media Type error validate?",
    "answer": "That the server rejects unsupported request body formats.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Validates API request format handling."
  },
  {
    "question_id": "EQ5075",
    "question": "Which HTTP status code indicates server is temporarily down for maintenance?",
    "answer": "C",
    "category": "Performance & Load Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "503 Service Unavailable",
      "D": "429 Too Many Requests"
    },
    "explanation": "503 is used when service is unavailable due to overload or maintenance."
  },
  {
    "question_id": "EQ5076",
    "question": "Which HTTP method is commonly used for updating only part of a resource?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "PATCH",
      "D": "DELETE"
    },
    "explanation": "PATCH is designed for partial updates."
  },
  {
    "question_id": "EQ5077",
    "question": "Write one simple positive test for GET /status endpoint.",
    "answer": "Send GET /status → expect 200 OK with message='Service running'.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Status checks confirm API availability."
  },
  {
    "question_id": "EQ5078",
    "question": "Which HTTP status indicates a successful resource creation?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "204 No Content",
      "D": "400 Bad Request"
    },
    "explanation": "201 Created confirms successful creation of resource."
  },
  {
    "question_id": "EQ5079",
    "question": "What does a 204 No Content response mean?",
    "answer": "It means the request was successful but no data is returned.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "204 indicates success without response body."
  },
  {
    "question_id": "EQ5080",
    "question": "Which HTTP status code is used when a request is valid but access is forbidden?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "401 Unauthorized",
      "B": "200 OK",
      "C": "403 Forbidden",
      "D": "404 Not Found"
    },
    "explanation": "403 Forbidden means valid credentials but insufficient permissions."
  },
  {
    "question_id": "EQ5081",
    "question": "Write a negative test case for sending an invalid Content-Type header.",
    "answer": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Validates rejection of unsupported content types."
  },
  {
    "question_id": "EQ5082",
    "question": "Which HTTP status code indicates success but the resource is empty?",
    "answer": "D",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "400 Bad Request",
      "D": "204 No Content"
    },
    "explanation": "204 is returned when no body content is available."
  },
  {
    "question_id": "EQ5083",
    "question": "What is the purpose of the Accept header in API requests?",
    "answer": "It specifies the expected response format such as JSON or XML.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Accept header guides server response format."
  },
  {
    "question_id": "EQ5084",
    "question": "Which HTTP status code is appropriate for invalid user credentials?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "401 Unauthorized",
      "C": "403 Forbidden",
      "D": "404 Not Found"
    },
    "explanation": "401 Unauthorized indicates invalid login credentials."
  },
  {
    "question_id": "EQ5085",
    "question": "Write a simple test case for a successful logout API call.",
    "answer": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Logout must invalidate the session token."
  },
  {
    "question_id": "EQ5086",
    "question": "Which HTTP method is used to retrieve resource details?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "PATCH"
    },
    "explanation": "GET is used to retrieve data."
  },
  {
    "question_id": "EQ5087",
    "question": "What is the meaning of 401 Unauthorized in API testing?",
    "answer": "It means the client must provide valid authentication credentials.",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "401 requires authentication."
  },
  {
    "question_id": "EQ5088",
    "question": "Which HTTP status code indicates duplicate resource creation attempt?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "409 Conflict"
    },
    "explanation": "409 Conflict means duplicate or conflicting request."
  },
  {
    "question_id": "EQ5089",
    "question": "Write one easy positive test case for checking profile details API.",
    "answer": "Send GET /profile with valid token → expect 200 OK and correct user data.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Positive test ensures profile endpoint returns user info."
  },
  {
    "question_id": "EQ5090",
    "question": "Which HTTP status code indicates request was valid but the server failed to fulfill it?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "400",
      "C": "500",
      "D": "201"
    },
    "explanation": "500 Internal Server Error signals server-side failure."
  },
  {
    "question_id": "EQ5091",
    "question": "What is the purpose of 302 Found in APIs?",
    "answer": "It indicates temporary redirection to another URL.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "302 tells the client to follow a temporary redirect."
  },
  {
    "question_id": "EQ5092",
    "question": "Which HTTP status is correct for a successfully updated resource using PUT?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "204 No Content",
      "D": "400 Bad Request"
    },
    "explanation": "200 OK indicates the resource was updated successfully."
  },
  {
    "question_id": "EQ5093",
    "question": "Write a test case for negative login attempt with wrong password.",
    "answer": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Ensures login fails with incorrect password."
  },
  {
    "question_id": "EQ5094",
    "question": "Which HTTP method is safe and cacheable?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "GET",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "GET is safe, idempotent, and cacheable."
  },
  {
    "question_id": "EQ5095",
    "question": "What does 422 Unprocessable Entity indicate?",
    "answer": "That the request is syntactically correct but semantically invalid.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "422 highlights semantic validation errors."
  },
  {
    "question_id": "EQ5096",
    "question": "Which HTTP status is appropriate when service is temporarily overloaded?",
    "answer": "C",
    "category": "Performance & Load Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "201",
      "B": "200",
      "C": "503",
      "D": "404"
    },
    "explanation": "503 Service Unavailable indicates overload or maintenance."
  },
  {
    "question_id": "EQ5097",
    "question": "Write a positive test for POST /users endpoint.",
    "answer": "Send POST /users with valid user details → expect 201 Created with userId.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Confirms successful user creation."
  },
  {
    "question_id": "EQ5098",
    "question": "Which HTTP header specifies the size of the request body?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Content-Length",
      "B": "Authorization",
      "C": "User-Agent",
      "D": "Cache-Control"
    },
    "explanation": "Content-Length defines body size in bytes."
  },
  {
    "question_id": "EQ5099",
    "question": "What does the term 'happy path' mean in testing?",
    "answer": "It refers to the expected successful execution scenario.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Happy path checks normal, successful flow."
  },
  {
    "question_id": "EQ5100",
    "question": "Which HTTP status code is used when a request method is not allowed on a resource?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "405 Method Not Allowed"
    },
    "explanation": "405 is used when HTTP method is invalid for the resource."
  },
    {
    "question_id": "EQ2001",
    "question": "When designing API tests, which scenario best represents a boundary condition for a pagination parameter?",
    "answer": "C",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Sending page=2 when total items=200",
      "B": "Sending page=10 when each page size=10 and total items=100",
      "C": "Sending page=11 when total items=100 with size=10",
      "D": "Sending page=1 when size=20 and total items=300"
    },
    "explanation": "Page=11 would exceed the available range (max 10), testing a boundary overflow."
  },
  {
    "question_id": "EQ2002",
    "question": "Explain how you would design a negative test case for an API endpoint that requires OAuth2 Bearer tokens.",
    "answer": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Negative tests validate robustness of authentication handling."
  },
  {
    "question_id": "EQ2003",
    "question": "Which of the following is the most effective way to validate an API’s response time under simulated user load?",
    "answer": "B",
    "category": "Performance & Load Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Manual sequential API calls with stopwatch measurement",
      "B": "Automated load test with concurrent virtual users",
      "C": "Single request execution and measuring response time",
      "D": "Unit testing with mocked responses"
    },
    "explanation": "Load testing with concurrent virtual users mimics real-world conditions."
  },
  {
    "question_id": "EQ2004",
    "question": "Provide one happy-path and one error-path test case for a payment refund API endpoint.",
    "answer": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Covering both successful and failing scenarios ensures balanced test coverage."
  },
  {
    "question_id": "EQ2005",
    "question": "Which practice reduces the flakiness of automated API tests running in CI/CD pipelines?",
    "answer": "D",
    "category": "CI/CD & Automation Integration",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Hardcoding API keys in scripts",
      "B": "Using random sleep delays before assertions",
      "C": "Running tests only once per release",
      "D": "Using stable test data and environment setup hooks"
    },
    "explanation": "Stable test data and environment setup reduce randomness and flakiness."
  },
  {
    "question_id": "EQ2006",
    "question": "How would you validate schema changes in a backward-compatible API upgrade?",
    "answer": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Backward compatibility requires preserving existing fields and types."
  },
  {
    "question_id": "EQ2007",
    "question": "Which of the following represents a correct negative test for input validation on a date-of-birth field?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Sending dateOfBirth=‘2025-13-40’",
      "B": "Sending dateOfBirth=‘1990-05-20’",
      "C": "Leaving dateOfBirth empty when optional",
      "D": "Sending dateOfBirth=‘2000-01-01’"
    },
    "explanation": "Invalid month/day makes it a correct negative input validation case."
  },
  {
    "question_id": "EQ2008",
    "question": "Explain how mocking can be used to test a payment API without calling the real bank service.",
    "answer": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Mocking enables testing of flows without dependency on external systems."
  },
  {
    "question_id": "EQ2009",
    "question": "Which monitoring approach helps detect sudden spikes in API error rates?",
    "answer": "C",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Code coverage reports",
      "B": "Manual log review every week",
      "C": "Real-time alerting on error rate metrics",
      "D": "Static code analysis"
    },
    "explanation": "Real-time alerting ensures immediate detection of error rate spikes."
  },
  {
    "question_id": "EQ2010",
    "question": "Design one boundary test and one invalid test for an API field `age` (range 18–65).",
    "answer": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
    "category": "Test Step",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Testing both edges and invalid ranges ensures robustness."
  },
  {
    "question_id": "EQ2011",
    "question": "Which of these is an example of contract validation in API testing?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Checking response latency",
      "B": "Validating response JSON matches OpenAPI schema",
      "C": "Measuring server CPU load",
      "D": "Asserting SQL queries from logs"
    },
    "explanation": "Contract validation ensures responses match defined schemas."
  },
  {
    "question_id": "EQ2012",
    "question": "Explain how you would simulate a network timeout error in API testing.",
    "answer": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Simulating timeout validates robustness of client error handling."
  },
  {
    "question_id": "EQ2013",
    "question": "Which scenario best represents an intermediate load test?",
    "answer": "D",
    "category": "Performance & Load Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "10,000 concurrent users for stress testing",
      "B": "Single-user functional check",
      "C": "Unit testing one function",
      "D": "100–200 concurrent users simulating average traffic"
    },
    "explanation": "Intermediate load tests simulate moderate, realistic user traffic."
  },
  {
    "question_id": "EQ2014",
    "question": "Give one example of an API precondition and one step that follows it.",
    "answer": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
    "category": "Test Step",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Preconditions ensure valid context for executing test steps."
  },
  {
    "question_id": "EQ2015",
    "question": "Which approach helps detect unauthorized access attempts in an API?",
    "answer": "A",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Penetration test using invalid or missing tokens",
      "B": "Unit tests on helper functions",
      "C": "CI pipeline build success",
      "D": "Running API in debug mode"
    },
    "explanation": "Penetration tests reveal weaknesses in authorization handling."
  },
  {
    "question_id": "EQ2016",
    "question": "Write one test case to validate that API rate limiting is enforced correctly.",
    "answer": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Rate limiting prevents abuse and DoS attacks."
  },
  {
    "question_id": "EQ2017",
    "question": "Which strategy ensures reproducibility of integration API tests?",
    "answer": "B",
    "category": "Environment & Test Data Management",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Running against random live production data",
      "B": "Using seeded test databases and reset scripts",
      "C": "Hardcoding timestamps in requests",
      "D": "Disabling cleanup steps after tests"
    },
    "explanation": "Seeded test data ensures consistent reproducibility."
  },
  {
    "question_id": "EQ2018",
    "question": "Explain one advantage of using service virtualization in API testing.",
    "answer": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Virtualization removes dependency bottlenecks."
  },
  {
    "question_id": "EQ2019",
    "question": "Which of these is an appropriate recovery step if API monitoring detects consistent 500 errors?",
    "answer": "C",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Ignore them until next release",
      "B": "Add random retry logic to all clients",
      "C": "Alert ops team and trigger rollback of recent deployment",
      "D": "Turn off error logs"
    },
    "explanation": "Rollback and alerts ensure quick mitigation."
  },
  {
    "question_id": "EQ2020",
    "question": "Describe how to design one positive and one boundary test case for a login API requiring username and password.",
    "answer": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Covers normal and edge input conditions."
  },
  {
    "question_id": "EQ2021",
    "question": "Which of the following scenarios is an example of a chained API test case?",
    "answer": "B",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Calling GET /status repeatedly",
      "B": "Creating a user, then using that user’s ID in GET /profile",
      "C": "Testing an endpoint with invalid headers",
      "D": "Measuring average latency of one endpoint"
    },
    "explanation": "Chained test cases depend on output of one API being input to another."
  },
  {
    "question_id": "EQ2022",
    "question": "Write one test step to validate that an API correctly returns 415 Unsupported Media Type.",
    "answer": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
    "category": "Test Step",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Mismatched Content-Type is a common reason for 415 responses."
  },
  {
    "question_id": "EQ2023",
    "question": "Which practice helps detect contract violations early in a CI/CD pipeline?",
    "answer": "C",
    "category": "CI/CD & Automation Integration",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Load testing in production only",
      "B": "Manual regression testing once a month",
      "C": "Schema validation tests integrated into pipeline",
      "D": "Using mocks for all external dependencies"
    },
    "explanation": "Automated schema validation in CI/CD detects breaking changes quickly."
  },
  {
    "question_id": "EQ2024",
    "question": "Describe one way to test observability when an API experiences a slow database query.",
    "answer": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Observability ensures performance bottlenecks are visible."
  },
  {
    "question_id": "EQ2025",
    "question": "Which of the following is an example of a negative authorization test?",
    "answer": "A",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Calling DELETE /users without admin privileges",
      "B": "Calling GET /users with valid token",
      "C": "Logging in with valid credentials",
      "D": "Refreshing a valid session token"
    },
    "explanation": "Attempting to delete users without privileges tests access restrictions."
  },
  {
    "question_id": "EQ2026",
    "question": "Explain how you would test API idempotency for a retry scenario.",
    "answer": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Idempotency ensures repeated requests do not cause duplicates."
  },
  {
    "question_id": "EQ2027",
    "question": "Which method ensures sensitive API keys are not exposed during automated testing?",
    "answer": "D",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Hardcoding them in test scripts",
      "B": "Printing them in CI/CD logs",
      "C": "Storing them in public GitHub repos",
      "D": "Using encrypted environment variables"
    },
    "explanation": "Encrypted env variables keep secrets secure."
  },
  {
    "question_id": "EQ2028",
    "question": "Give one boundary and one invalid test for a file upload API accepting max 5 MB files.",
    "answer": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Tests both the allowed edge and rejection beyond it."
  },
  {
    "question_id": "EQ2029",
    "question": "Which monitoring metric would best indicate a memory leak in an API?",
    "answer": "B",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Spike in average latency",
      "B": "Steadily increasing memory usage",
      "C": "Decreasing CPU utilization",
      "D": "Random increase in cache hit ratio"
    },
    "explanation": "A memory leak manifests as continuously rising memory usage."
  },
  {
    "question_id": "EQ2030",
    "question": "Write a test case to validate proper error handling when an API is called with a missing required field `email`.",
    "answer": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Ensures required field validation is enforced."
  },
  {
    "question_id": "EQ2031",
    "question": "Which of the following best describes service virtualization?",
    "answer": "C",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Running APIs only in production",
      "B": "Using local database replicas",
      "C": "Simulating unavailable dependencies with virtual services",
      "D": "Replacing backend logic with new microservices"
    },
    "explanation": "Service virtualization allows testing without real dependencies."
  },
  {
    "question_id": "EQ2032",
    "question": "How would you design a test to validate retry logic when an API occasionally returns 503?",
    "answer": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Simulated intermittent failures validate retry policies."
  },
  {
    "question_id": "EQ2033",
    "question": "Which error scenario best represents a client-side failure?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "HTTP 400 Bad Request",
      "B": "HTTP 500 Internal Server Error",
      "C": "Database timeout",
      "D": "Out-of-memory on server"
    },
    "explanation": "400 Bad Request indicates client-side invalid request."
  },
  {
    "question_id": "EQ2034",
    "question": "Write a test case that validates log correlation using a trace ID header.",
    "answer": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Trace IDs allow distributed system observability."
  },
  {
    "question_id": "EQ2035",
    "question": "Which of these scenarios requires schema validation during testing?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Checking average API response time",
      "B": "Ensuring response JSON fields match OpenAPI definition",
      "C": "Measuring throughput under load",
      "D": "Analyzing SQL query logs"
    },
    "explanation": "Schema validation ensures structural correctness of responses."
  },
  {
    "question_id": "EQ2036",
    "question": "Design one intermediate-level test case for validating API rate limiting when multiple clients are involved.",
    "answer": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Covers multi-client rate limit enforcement."
  },
  {
    "question_id": "EQ2037",
    "question": "Which of the following improves reproducibility of API tests in multiple environments?",
    "answer": "D",
    "category": "Environment & Test Data Management",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Using hardcoded environment URLs",
      "B": "Randomizing all test data",
      "C": "Executing tests against production data",
      "D": "Parameterizing endpoints and using environment configs"
    },
    "explanation": "Parameterization ensures same test logic works across environments."
  },
  {
    "question_id": "EQ2038",
    "question": "Describe one positive and one negative test case for an API endpoint that sends SMS codes.",
    "answer": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Ensures handling of valid and invalid inputs."
  },
  {
    "question_id": "EQ2039",
    "question": "Which of these best describes performance baseline testing?",
    "answer": "A",
    "category": "Performance & Load Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Measuring normal response times under expected load",
      "B": "Testing API with invalid inputs",
      "C": "Validating API against OpenAPI spec",
      "D": "Simulating 10x peak traffic"
    },
    "explanation": "Baseline testing captures normal expected performance."
  },
  {
    "question_id": "EQ2040",
    "question": "Explain one advantage of mocking external APIs when testing failure scenarios.",
    "answer": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Controlled mocking enables reproducible failure testing."
  },
    {
    "question_id": "EQ2041",
    "question": "Which of these is a correct test case for validating session expiration?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Login with valid credentials, expect 200 OK",
      "B": "Send request with valid token immediately after login",
      "C": "Send request with token after session timeout, expect 401 Unauthorized",
      "D": "Send request without token, expect 200 OK"
    },
    "explanation": "Expired sessions must return 401 Unauthorized."
  },
  {
    "question_id": "EQ2042",
    "question": "Write one test case to validate error handling when API returns malformed JSON.",
    "answer": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Malformed JSON checks robustness of client/server parsing."
  },
  {
    "question_id": "EQ2043",
    "question": "Which strategy helps validate backward compatibility after adding new optional fields?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Ensure older clients still work without sending new fields",
      "B": "Force clients to update immediately",
      "C": "Remove old fields from responses",
      "D": "Require schema changes to be breaking"
    },
    "explanation": "Backward compatibility means old clients should still function without new fields."
  },
  {
    "question_id": "EQ2044",
    "question": "Design one test step to confirm rate limiting headers (e.g., X-RateLimit-Remaining) are present.",
    "answer": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Rate limit headers must provide visibility to clients."
  },
  {
    "question_id": "EQ2045",
    "question": "Which is the most effective way to test resilience when an API’s downstream service fails?",
    "answer": "D",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Disable retries in client",
      "B": "Stop testing until service recovers",
      "C": "Run unit tests only",
      "D": "Inject failures using chaos testing or mocks"
    },
    "explanation": "Chaos testing/mocks allow controlled simulation of dependency failures."
  },
  {
    "question_id": "EQ2046",
    "question": "Describe one advantage of separating test data from test logic in API testing.",
    "answer": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
    "category": "Environment & Test Data Management",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Data-driven testing improves reusability and consistency."
  },
  {
    "question_id": "EQ2047",
    "question": "Which response status code is appropriate for a request blocked due to missing authorization header?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "401 Unauthorized",
      "C": "403 Forbidden",
      "D": "409 Conflict"
    },
    "explanation": "Missing authorization results in 401 Unauthorized."
  },
  {
    "question_id": "EQ2048",
    "question": "Write a test case for validating graceful degradation when API cache is unavailable.",
    "answer": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Graceful degradation ensures service continues even without cache."
  },
  {
    "question_id": "EQ2049",
    "question": "Which of the following represents a proper boundary test for a password length field (min=8, max=20)?",
    "answer": "A",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Testing with 7, 8, 20, and 21 characters",
      "B": "Testing with 10 characters only",
      "C": "Testing with 15 characters only",
      "D": "Testing with empty password only"
    },
    "explanation": "Boundary testing includes values at, below, and above limits."
  },
  {
    "question_id": "EQ2050",
    "question": "Explain one way to validate logging for sensitive fields such as passwords.",
    "answer": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Sensitive fields must never appear in logs."
  },
  {
    "question_id": "EQ2051",
    "question": "Which monitoring method helps identify gradual latency increases over weeks?",
    "answer": "C",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Single request stopwatch timing",
      "B": "Manual debugging during incidents",
      "C": "Time-series trend analysis with dashboards",
      "D": "Code coverage metrics"
    },
    "explanation": "Dashboards and time-series monitoring highlight latency trends."
  },
  {
    "question_id": "EQ2052",
    "question": "Provide one negative and one boundary test case for a currency field that must match ISO 4217 codes.",
    "answer": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Valid and invalid values validate field restrictions."
  },
  {
    "question_id": "EQ2053",
    "question": "Which strategy ensures contract tests remain useful when APIs evolve?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Never updating schema tests",
      "B": "Removing optional fields from tests",
      "C": "Running only manual regression tests",
      "D": "Versioning schema contracts and maintaining backward compatibility"
    },
    "explanation": "Versioning and backward compatibility keep contract tests reliable."
  },
  {
    "question_id": "EQ2054",
    "question": "Write one test case to validate API behavior under network packet loss.",
    "answer": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Testing under degraded network ensures robustness."
  },
  {
    "question_id": "EQ2055",
    "question": "Which of these scenarios correctly validates API observability using distributed tracing?",
    "answer": "B",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Checking only HTTP status codes",
      "B": "Following a trace ID across multiple microservices",
      "C": "Checking memory usage in server logs",
      "D": "Using manual testing notes"
    },
    "explanation": "Tracing IDs track requests across services."
  },
  {
    "question_id": "EQ2056",
    "question": "Describe one method to verify test data cleanup after API test execution.",
    "answer": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
    "category": "Environment & Test Data Management",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Ensures environment is not polluted by test artifacts."
  },
  {
    "question_id": "EQ2057",
    "question": "Which of the following indicates a denial-of-service vulnerability?",
    "answer": "A",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "API accepts unlimited requests without throttling",
      "B": "API returns 404 Not Found",
      "C": "API schema missing a description field",
      "D": "Unit test coverage is low"
    },
    "explanation": "Unrestricted requests can exhaust resources, causing DoS."
  },
  {
    "question_id": "EQ2058",
    "question": "Write a test case to verify proper rollback when a multi-step transaction partially fails.",
    "answer": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Rollback ensures atomicity of transactions."
  },
  {
    "question_id": "EQ2059",
    "question": "Which HTTP status code should be validated when an API request is well-formed but forbidden due to role restrictions?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "401 Unauthorized",
      "C": "403 Forbidden",
      "D": "500 Internal Server Error"
    },
    "explanation": "403 Forbidden indicates client is authenticated but not authorized."
  },
  {
    "question_id": "EQ2060",
    "question": "Explain one approach to validating error messages follow a consistent JSON schema across all endpoints.",
    "answer": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Consistency in error schemas improves developer usability."
  },
    {
    "question_id": "EQ3001",
    "question": "Which of the following scenarios best represents a multi-hop test involving login and refresh token endpoints?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Send a request to GET /health",
      "B": "Obtain access token via POST /login, then use POST /refresh to extend session",
      "C": "Send request with expired token to protected endpoint",
      "D": "Check status 200 on GET /docs"
    },
    "explanation": "Multi-hop testing means chaining login with subsequent refresh token usage."
  },
  {
    "question_id": "EQ3002",
    "question": "Write a test case that validates login, token refresh, and accessing a protected API using the refreshed token.",
    "answer": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Covers full chain of login, refresh, and subsequent access."
  },
  {
    "question_id": "EQ3003",
    "question": "Which HTTP status code should a server return when a refresh token is expired?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "403 Forbidden",
      "C": "401 Unauthorized",
      "D": "201 Created"
    },
    "explanation": "Expired refresh token means the client must log in again → 401 Unauthorized."
  },
  {
    "question_id": "EQ3004",
    "question": "Design a chained test validating that a failed login attempt still prevents refresh token generation.",
    "answer": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Ensures refresh cannot be obtained after failed login."
  },
  {
    "question_id": "EQ3005",
    "question": "Which of the following maps an application-specific error code to the correct HTTP status?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "APP_1001 (User not found) → 404 Not Found",
      "B": "APP_2002 (Invalid password) → 201 Created",
      "C": "APP_3003 (Success) → 500 Internal Server Error",
      "D": "APP_9999 (Database error) → 200 OK"
    },
    "explanation": "Mapping user-not-found to 404 is the correct HTTP translation."
  },
  {
    "question_id": "EQ3006",
    "question": "Explain how you would validate correct mapping of business codes (e.g., ORDER_001) to HTTP status codes in API responses.",
    "answer": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Multi-hop reasoning between internal codes and external HTTP standards."
  },
  {
    "question_id": "EQ3007",
    "question": "Which scenario demonstrates chained negative testing?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Testing single GET /status request",
      "B": "Valid login followed by accessing /profile",
      "C": "Checking server uptime with GET /health",
      "D": "Logging in with expired password → 401, then retrying refresh token → 401"
    },
    "explanation": "Chained negative tests validate failures across endpoints."
  },
  {
    "question_id": "EQ3008",
    "question": "Write one hard-level test case chaining order creation, payment, and refund APIs.",
    "answer": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Covers multi-endpoint order lifecycle."
  },
  {
    "question_id": "EQ3009",
    "question": "Which HTTP status code is correct for mapping a custom error ORDER_DUPLICATE to HTTP?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "409 Conflict",
      "C": "404 Not Found",
      "D": "500 Internal Server Error"
    },
    "explanation": "Duplicate order is a conflict → 409."
  },
  {
    "question_id": "EQ3010",
    "question": "Explain one test case that validates token refresh works across multiple microservices.",
    "answer": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Ensures refreshed token is propagated across services."
  },
  {
    "question_id": "EQ3011",
    "question": "Which scenario correctly validates multi-hop error handling in an e-commerce workflow?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Create order → invalid payment details → 402 Payment Required",
      "B": "Check inventory → product exists → 200 OK",
      "C": "Call healthcheck endpoint → 200 OK",
      "D": "Request product catalog → 200 OK"
    },
    "explanation": "Payment failure after order creation is a multi-hop negative test."
  },
  {
    "question_id": "EQ3012",
    "question": "Write a test that validates mapping of validation error codes to HTTP 400 responses.",
    "answer": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Validation errors must map to 400 Bad Request."
  },
  {
    "question_id": "EQ3013",
    "question": "Which of these represents a hard-level chained login test?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Only testing GET /login-docs",
      "B": "Logging in once and stopping",
      "C": "Login → refresh token → logout → confirm refresh fails",
      "D": "Checking GET /health endpoint"
    },
    "explanation": "Combines multiple endpoints into a workflow validation."
  },
  {
    "question_id": "EQ3014",
    "question": "Design a test case validating expired refresh tokens cannot issue new access tokens.",
    "answer": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Prevents unauthorized continued access."
  },
  {
    "question_id": "EQ3015",
    "question": "Which mapping is correct for business error PAYMENT_DECLINED?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "402 Payment Required"
    },
    "explanation": "Payment declined → 402 Payment Required."
  },
  {
    "question_id": "EQ3016",
    "question": "Explain one multi-hop chained test that validates session invalidation after logout.",
    "answer": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Validates session termination across endpoints."
  },
  {
    "question_id": "EQ3017",
    "question": "Which scenario maps to the correct HTTP code for an internal application error?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "APP_TIMEOUT → 200 OK",
      "B": "APP_TIMEOUT → 504 Gateway Timeout",
      "C": "APP_TIMEOUT → 201 Created",
      "D": "APP_TIMEOUT → 400 Bad Request"
    },
    "explanation": "Timeouts should map to 504 Gateway Timeout."
  },
  {
    "question_id": "EQ3018",
    "question": "Write a test case chaining signup, email verification, and login endpoints.",
    "answer": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Covers multi-step account creation and login."
  },
  {
    "question_id": "EQ3019",
    "question": "Which test validates chained role-based access?",
    "answer": "A",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Login as user → access /admin → expect 403 Forbidden",
      "B": "Login as admin → access /admin → expect 200 OK",
      "C": "Login as user → view profile → 200 OK",
      "D": "GET /health → 200 OK"
    },
    "explanation": "Role mismatch leading to 403 is a multi-hop role validation."
  },
  {
    "question_id": "EQ3020",
    "question": "Design one hard-level chained test validating a password reset flow.",
    "answer": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Multi-hop test ensures end-to-end reset flow works."
  },
  {
    "question_id": "EQ3021",
    "question": "Which scenario validates a chained login, refresh, and logout sequence?",
    "answer": "D",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Login → use token once",
      "B": "Refresh token immediately after login",
      "C": "Logout only",
      "D": "Login → refresh token → logout → confirm refresh fails"
    },
    "explanation": "This full sequence tests the entire authentication lifecycle."
  },
  {
    "question_id": "EQ3022",
    "question": "Write a chained test case for validating user creation, profile update, and profile retrieval.",
    "answer": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Covers create → update → read sequence."
  },
  {
    "question_id": "EQ3023",
    "question": "Which mapping correctly translates a business error STOCK_OUT to HTTP?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "409 Conflict",
      "C": "201 Created",
      "D": "403 Forbidden"
    },
    "explanation": "Stock-out means a conflict with order fulfillment, mapping to 409."
  },
  {
    "question_id": "EQ3024",
    "question": "Explain one test to validate refresh token cannot be used after logout.",
    "answer": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Logout must invalidate refresh tokens."
  },
  {
    "question_id": "EQ3025",
    "question": "Which scenario validates chained negative testing for a shopping cart workflow?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Add valid item to cart → 200 OK",
      "B": "Checkout with valid payment → 200 OK",
      "C": "Add item → remove item → checkout → expect 400 Bad Request",
      "D": "View cart after login → 200 OK"
    },
    "explanation": "Empty cart checkout is a chained negative scenario."
  },
  {
    "question_id": "EQ3026",
    "question": "Write a test case validating correct mapping of internal error code AUTH_EXPIRED to HTTP status.",
    "answer": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Maps business error to correct HTTP layer."
  },
  {
    "question_id": "EQ3027",
    "question": "Which scenario best validates chained order cancellation?",
    "answer": "A",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Create order → cancel order → GET /orders/{id} shows status=cancelled",
      "B": "Cancel non-existent order → 404",
      "C": "Create order only",
      "D": "Check /status endpoint"
    },
    "explanation": "Covers lifecycle of order creation → cancellation → verification."
  },
  {
    "question_id": "EQ3028",
    "question": "Explain a chained test validating email verification failure if token is invalid.",
    "answer": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Invalid verification prevents login."
  },
  {
    "question_id": "EQ3029",
    "question": "Which mapping correctly translates FILE_TOO_LARGE to HTTP?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "401 Unauthorized",
      "C": "404 Not Found",
      "D": "413 Payload Too Large"
    },
    "explanation": "File too large should map to 413."
  },
  {
    "question_id": "EQ3030",
    "question": "Write a hard-level test case chaining loan application, credit check, and approval endpoints.",
    "answer": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Simulates realistic financial API workflow."
  },
  {
    "question_id": "EQ3031",
    "question": "Which chained sequence validates refresh tokens across multiple sessions?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Login → logout only",
      "B": "Login → refresh token → logout → login again → confirm old refresh invalid",
      "C": "Refresh token without login",
      "D": "Check GET /status"
    },
    "explanation": "Ensures session handling across multiple logins."
  },
  {
    "question_id": "EQ3032",
    "question": "Design a test case chaining signup, password reset, and login with new credentials.",
    "answer": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Validates password reset flow end-to-end."
  },
  {
    "question_id": "EQ3033",
    "question": "Which mapping is correct for mapping business error INVALID_COUPON?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "403 Forbidden",
      "C": "400 Bad Request",
      "D": "201 Created"
    },
    "explanation": "Invalid coupon should map to 400 Bad Request."
  },
  {
    "question_id": "EQ3034",
    "question": "Write a test case chaining file upload, virus scan, and download endpoints.",
    "answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Covers lifecycle of file operations."
  },
  {
    "question_id": "EQ3035",
    "question": "Which scenario validates correct multi-hop error mapping in payment workflow?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Payment API returns DECLINED → mapped to HTTP 402",
      "B": "Payment API returns APPROVED → mapped to HTTP 404",
      "C": "Payment API returns DECLINED → mapped to HTTP 201",
      "D": "Payment API returns ERROR → mapped to HTTP 200"
    },
    "explanation": "Payment declined correctly maps to 402 Payment Required."
  },
  {
    "question_id": "EQ3036",
    "question": "Explain one chained test for validating refresh token reuse prevention.",
    "answer": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Prevents refresh token replay attacks."
  },
  {
    "question_id": "EQ3037",
    "question": "Which mapping is correct for mapping RATE_LIMIT_EXCEEDED to HTTP?",
    "answer": "D",
    "category": "Security Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "403 Forbidden",
      "D": "429 Too Many Requests"
    },
    "explanation": "Rate limits exceeded should map to 429."
  },
  {
    "question_id": "EQ3038",
    "question": "Write a test case chaining search, add-to-cart, and checkout APIs.",
    "answer": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Validates e-commerce multi-endpoint workflow."
  },
  {
    "question_id": "EQ3039",
    "question": "Which scenario validates chained negative testing in ticket booking workflow?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Book valid ticket → 200 OK",
      "B": "Book ticket → cancel ticket → attempt refund → expect 400 Bad Request",
      "C": "View available seats → 200 OK",
      "D": "Check GET /status → 200 OK"
    },
    "explanation": "Chained negative: refunding after cancel is invalid."
  },
  {
    "question_id": "EQ3040",
    "question": "Explain one chained test for validating API session hijacking prevention.",
    "answer": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
    "category": "Security Testing",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Prevents cross-user token misuse."
  },
  {
    "question_id": "EQ3041",
    "question": "Which chained flow correctly validates token rotation with refresh token reuse detection?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Login → call API once → logout",
      "B": "Login → refresh token → attempt reuse of old refresh → expect 401 Unauthorized",
      "C": "Login only",
      "D": "Refresh without login"
    },
    "explanation": "Token reuse must be rejected after rotation to prevent replay attacks."
  },
  {
    "question_id": "EQ3042",
    "question": "Provide exactly one chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints.",
    "answer": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Ensures concurrency control with ETag validation."
  },
  {
    "question_id": "EQ3043",
    "question": "Which HTTP status should be returned when an If-Match precondition fails due to stale ETag during PUT /resource/{id}?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "400 Bad Request",
      "C": "412 Precondition Failed",
      "D": "404 Not Found"
    },
    "explanation": "Stale ETag should map to 412 Precondition Failed."
  },
  {
    "question_id": "EQ3044",
    "question": "Design a multi-hop test verifying async export job: POST /exports -> poll GET /jobs/{id} until complete -> GET /exports/{id}.",
    "answer": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Covers async job lifecycle with polling."
  },
  {
    "question_id": "EQ3045",
    "question": "Which mapping from business code to HTTP is most appropriate for RESOURCE_VERSION_CONFLICT during update?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "409 Conflict"
    },
    "explanation": "Version conflict maps correctly to 409 Conflict."
  },
  {
    "question_id": "EQ3046",
    "question": "Give one chained negative test for OAuth2 Authorization Code: /authorize -> /token -> resource call with missing scope.",
    "answer": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Tests scope-based access control."
  },
  {
    "question_id": "EQ3047",
    "question": "Which status code best represents a refresh token presented to the wrong client_id in a multi-tenant system?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "400 Bad Request",
      "C": "401 Unauthorized",
      "D": "409 Conflict"
    },
    "explanation": "OAuth2 specifies invalid_grant (400) for wrong client/refresh usage."
  },
  {
    "question_id": "EQ3048",
    "question": "Write one chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints.",
    "answer": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Validates idempotency across retries and refund flow."
  },
  {
    "question_id": "EQ3049",
    "question": "Which status mapping is correct for business code INSUFFICIENT_FUNDS from payment gateway?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "404 Not Found",
      "C": "403 Forbidden",
      "D": "402 Payment Required"
    },
    "explanation": "Insufficient funds → 402 Payment Required."
  },
  {
    "question_id": "EQ3050",
    "question": "Provide one chained test for file processing pipeline: upload -> POST /process -> poll status -> download, including 202 handling.",
    "answer": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Covers async file lifecycle including 202 Accepted handling."
  },
  {
    "question_id": "EQ3051",
    "question": "Which scenario correctly validates backoff + retry policy across gateway 429 -> 200 transitions?",
    "answer": "A",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "API returns 429 Too Many Requests → client retries with backoff → 200 OK",
      "B": "API returns 401 Unauthorized → retry succeeds",
      "C": "API returns 404 Not Found → retry succeeds",
      "D": "API returns 500 → retry without backoff"
    },
    "explanation": "Retry with exponential backoff is required for 429 handling."
  },
  {
    "question_id": "EQ3052",
    "question": "Give one chained test to validate SSO session revocation propagates to API gateway and microservice access.",
    "answer": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Ensures session revocation propagates correctly."
  },
  {
    "question_id": "EQ3053",
    "question": "Which HTTP code should map to BUSINESS_LIMIT_EXCEEDED when per-user quota blocks a valid, authenticated request?",
    "answer": "D",
    "category": "Security Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "400 Bad Request",
      "C": "403 Forbidden",
      "D": "429 Too Many Requests"
    },
    "explanation": "Quota exhaustion maps to 429 Too Many Requests."
  },
  {
    "question_id": "EQ3054",
    "question": "Write one chained test for partial order fulfillment: create order -> reserve inventory -> partial ship -> cancel remaining and refund delta.",
    "answer": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Tests partial fulfillment lifecycle with refund."
  },
  {
    "question_id": "EQ3055",
    "question": "Which mapping is most accurate for error code SIGNATURE_INVALID on webhook delivery verification?",
    "answer": "C",
    "category": "Security Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "404 Not Found",
      "C": "401 Unauthorized",
      "D": "409 Conflict"
    },
    "explanation": "Invalid webhook signature should return 401 Unauthorized."
  },
  {
    "question_id": "EQ3056",
    "question": "Provide exactly one chained negative test for 2FA login: POST /login -> POST /2fa/verify with wrong code -> POST /refresh.",
    "answer": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Tests chained 2FA failure preventing refresh."
  },
  {
    "question_id": "EQ3057",
    "question": "Which HTTP code best represents a soft-deleted resource requested by GET /resource/{id} after DELETE (with recoverable state)?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "404 Not Found",
      "C": "403 Forbidden",
      "D": "204 No Content"
    },
    "explanation": "Soft-deleted resource should be treated as not found."
  },
  {
    "question_id": "EQ3058",
    "question": "Design a chained test verifying pagination consistency across create -> list -> delete -> list (with total count assertions).",
    "answer": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Validates data consistency across pagination."
  },
  {
    "question_id": "EQ3059",
    "question": "Which mapping is correct when dependency outage triggers circuit breaker OPEN, causing gateway to reject requests immediately?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "503 Service Unavailable",
      "D": "400 Bad Request"
    },
    "explanation": "Circuit breaker OPEN maps to 503 Service Unavailable."
  },
  {
    "question_id": "EQ3060",
    "question": "Write one chained test for session stickiness: login -> subsequent calls via load balancer -> logout -> verify no node accepts old token.",
    "answer": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Validates session stickiness and proper logout propagation."
  },
  {
    "question_id": "EQ4001",
    "question": "Which chained flow correctly validates an order lifecycle with create → capture → refund, ensuring idempotency across retries?",
    "answer": "C",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Create order → retry refund twice → refund fails",
      "B": "Capture payment without creating order",
      "C": "Create order → capture payment → retry capture with same idempotency key → single charge → refund succeeds",
      "D": "Refund before order creation"
    },
    "explanation": "Idempotency must ensure duplicate captures do not create multiple charges."
  },
  {
    "question_id": "EQ4002",
    "question": "Write a state-machine style test validating account lifecycle: create → activate → suspend → reactivate → delete.",
    "answer": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Covers full lifecycle state transitions of an account resource."
  },
  {
    "question_id": "EQ4003",
    "question": "Which mapping is correct for handling a duplicate transaction detected during a refund request?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "409 Conflict",
      "C": "403 Forbidden",
      "D": "500 Internal Server Error"
    },
    "explanation": "Duplicate transaction must map to 409 Conflict."
  },
  {
    "question_id": "EQ4004",
    "question": "Design a chained test that validates transaction rollback when step 2 of a 3-step money transfer fails.",
    "answer": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Ensures atomicity of financial transactions."
  },
  {
    "question_id": "EQ4005",
    "question": "Which chained scenario validates proper error propagation in a distributed saga transaction?",
    "answer": "D",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Start saga → all steps succeed",
      "B": "Start saga → ignore error in step 2",
      "C": "Start saga → rollback ignored",
      "D": "Start saga → step 3 fails → compensating rollback of steps 1 & 2 executed"
    },
    "explanation": "Saga pattern ensures compensating actions on failure."
  },
  {
    "question_id": "EQ4006",
    "question": "Write one test validating a multi-service chain: login → create order → process payment → cancel order after capture.",
    "answer": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Tests order lifecycle across services with cancellation after capture."
  },
  {
    "question_id": "EQ4007",
    "question": "Which error handling scenario best validates sanity checks in payment APIs?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Submitting refund > captured amount → 400 Bad Request",
      "B": "Submitting refund = captured amount → 200 OK",
      "C": "Submitting refund < captured amount → 200 OK",
      "D": "Refund without capture → 200 OK"
    },
    "explanation": "Refunds larger than capture must fail with 400."
  },
  {
    "question_id": "EQ4008",
    "question": "Describe one state-machine test validating password lifecycle: set → expire → reset → reuse prevention.",
    "answer": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
    "category": "Security Testing",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Ensures password history and expiration rules enforced."
  },
  {
    "question_id": "EQ4009",
    "question": "Which mapping best validates format error handling for malformed JSON payloads?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "201 Created",
      "B": "500 Internal Server Error",
      "C": "400 Bad Request",
      "D": "200 OK"
    },
    "explanation": "Malformed JSON must result in 400 Bad Request."
  },
  {
    "question_id": "EQ4010",
    "question": "Write one complex chained test covering a loan application flow with branch failure in credit check.",
    "answer": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Covers branching failure in credit check preventing approval."
  },
  {
    "question_id": "EQ4011",
    "question": "Which chained flow validates consistent state during distributed booking workflow?",
    "answer": "B",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Reserve hotel only",
      "B": "Reserve hotel → book flight → flight fails → hotel reservation auto-cancelled",
      "C": "Book flight only",
      "D": "Book hotel and keep reservation even if payment fails"
    },
    "explanation": "Hotel auto-cancellation ensures consistent state across systems."
  },
  {
    "question_id": "EQ4012",
    "question": "Write a test validating data integrity when concurrent writes occur: update user profile with conflicting values.",
    "answer": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Validates optimistic locking for concurrency control."
  },
  {
    "question_id": "EQ4013",
    "question": "Which HTTP code is correct for validating sanity check on withdraw > account balance?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "403 Forbidden",
      "D": "400 Bad Request"
    },
    "explanation": "Over-withdrawal must be rejected as 400 Bad Request."
  },
  {
    "question_id": "EQ4014",
    "question": "Write one very hard test validating chained document signing: upload → sign → verify → tamper detection.",
    "answer": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
    "category": "Security Testing",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Validates tamper-proof digital signing."
  },
  {
    "question_id": "EQ4015",
    "question": "Which scenario validates state rollback when an API partially updates user info and DB transaction fails?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Update fails mid-way → no partial changes persist",
      "B": "Update fails mid-way → partial changes remain",
      "C": "Update fails mid-way → system crashes",
      "D": "Update succeeds despite DB rollback"
    },
    "explanation": "Proper rollback prevents partial/inconsistent data."
  },
  {
    "question_id": "EQ4016",
    "question": "Which chained scenario best validates the idempotency of a payment capture endpoint?",
    "answer": "B",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "POST /capture twice with different Idempotency-Key values → two charges",
      "B": "POST /capture twice with the same Idempotency-Key → single charge recorded",
      "C": "POST /refund without capture → success",
      "D": "GET /capture-status once"
    },
    "explanation": "Idempotency ensures duplicate requests with same key do not create multiple charges."
  },
  {
    "question_id": "EQ4017",
    "question": "Write one state-machine test validating subscription lifecycle: create → upgrade → downgrade → cancel.",
    "answer": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Covers all major states in subscription lifecycle."
  },
  {
    "question_id": "EQ4018",
    "question": "Which mapping correctly handles application error LIMIT_EXCEEDED for per-account API quota?",
    "answer": "D",
    "category": "Security Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "400 Bad Request",
      "C": "403 Forbidden",
      "D": "429 Too Many Requests"
    },
    "explanation": "Rate/limit exceeded maps to 429 Too Many Requests."
  },
  {
    "question_id": "EQ4019",
    "question": "Write a very hard chained test validating recovery after partial failure in a distributed order saga.",
    "answer": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Tests distributed rollback in saga pattern."
  },
  {
    "question_id": "EQ4020",
    "question": "Which chained flow validates OAuth2 token misuse detection across services?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Login once",
      "B": "Refresh token immediately",
      "C": "Login → get token → attempt to use token in another client → 403 Forbidden",
      "D": "Logout only"
    },
    "explanation": "Cross-client token misuse should be forbidden."
  },
  {
    "question_id": "EQ4021",
    "question": "Write one very hard test verifying financial transaction reversals: debit → credit → rollback.",
    "answer": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Validates atomicity in financial transactions."
  },
  {
    "question_id": "EQ4022",
    "question": "Which scenario best validates format error handling for XML vs JSON input mismatch?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Send XML body with Content-Type: application/json → 415 Unsupported Media Type",
      "B": "Send JSON body with application/json → 200 OK",
      "C": "Send XML body with application/xml → 200 OK",
      "D": "Send YAML → 200 OK"
    },
    "explanation": "Mismatch in body vs header must result in 415."
  },
  {
    "question_id": "EQ4023",
    "question": "Design a state-machine test for warehouse inventory: add stock → allocate → ship → return → reconcile.",
    "answer": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Ensures inventory consistency across lifecycle events."
  },
  {
    "question_id": "EQ4024",
    "question": "Which HTTP status is correct when a schema validation error occurs for a nested field?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "201 Created",
      "B": "500 Internal Server Error",
      "C": "400 Bad Request",
      "D": "404 Not Found"
    },
    "explanation": "Schema validation errors must return 400."
  },
  {
    "question_id": "EQ4025",
    "question": "Write one chained test validating mobile session lifecycle: login → token refresh → logout → refresh with old token → fail.",
    "answer": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Tests invalid refresh post-logout."
  },
  {
    "question_id": "EQ4026",
    "question": "Which chained scenario validates proper rollback after multi-step booking (flight + hotel) when payment fails?",
    "answer": "D",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Book flight → 200 OK",
      "B": "Book hotel → 200 OK",
      "C": "Book flight + hotel → payment succeeds",
      "D": "Book flight + hotel → payment fails → rollback both bookings"
    },
    "explanation": "Rollback ensures no inconsistent bookings remain."
  },
  {
    "question_id": "EQ4027",
    "question": "Write one chained test validating email delivery API: send → open-tracking → unsubscribe → ensure no further emails sent.",
    "answer": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Validates state transitions in email delivery system."
  },
  {
    "question_id": "EQ4028",
    "question": "Which mapping is correct for application code TOKEN_REPLAY_DETECTED?",
    "answer": "C",
    "category": "Security Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "401 Unauthorized",
      "D": "409 Conflict"
    },
    "explanation": "Token replay must be treated as 401 Unauthorized."
  },
  {
    "question_id": "EQ4029",
    "question": "Write one very hard chained test for purchase flow with coupon application and failure branch: apply coupon → checkout → coupon invalid → rollback.",
    "answer": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Ensures failed coupon prevents invalid checkout."
  },
  {
    "question_id": "EQ4030",
    "question": "Which chained workflow validates asynchronous payment settlement with reconciliation?",
    "answer": "B",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Create order only",
      "B": "Create order → capture payment → async settlement → reconcile → final status=settled",
      "C": "Refund without settlement",
      "D": "Check API health"
    },
    "explanation": "Asynchronous settlement must reconcile correctly."
  },
  {
    "question_id": "EQ5001-VN",
    "question": "Phương thức HTTP nào thường được sử dụng để truy xuất dữ liệu từ một API?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "GET là phương thức chuẩn để truy xuất dữ liệu."
  },
  {
    "question_id": "EQ5002-VN",
    "question": "Mã trạng thái HTTP 404 đại diện cho điều gì?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "OK",
      "B": "Unauthorized",
      "C": "Not Found",
      "D": "Conflict"
    },
    "explanation": "404 cho biết tài nguyên được yêu cầu không thể tìm thấy."
  },
  {
    "question_id": "EQ5003-VN",
    "question": "Mục đích của phương thức HTTP POST là gì?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Truy xuất dữ liệu",
      "B": "Gửi dữ liệu để tạo tài nguyên",
      "C": "Cập nhật tài nguyên hiện có",
      "D": "Xóa tài nguyên"
    },
    "explanation": "POST được sử dụng để tạo tài nguyên mới với dữ liệu trong request body."
  },
  {
    "question_id": "EQ5004-VN",
    "question": "Viết một test case positive đơn giản cho một API đăng nhập.",
    "answer": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test case positive kiểm tra thông tin đăng nhập chính xác."
  },
  {
    "question_id": "EQ5005-VN",
    "question": "Mã trạng thái HTTP nào trong số này có nghĩa là 'Unauthorized'?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "401",
      "C": "403",
      "D": "404"
    },
    "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
  },
  {
    "question_id": "EQ5006-VN",
    "question": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là gì?",
    "answer": "Người dùng phải được đăng nhập và có một token hợp lệ.",
    "category": "Test Step",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Precondition đảm bảo bối cảnh hợp lệ trước khi gọi các API."
  },
  {
    "question_id": "EQ5007-VN",
    "question": "Phương thức HTTP nào được coi là idempotent?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "PATCH",
      "C": "PUT",
      "D": "CONNECT"
    },
    "explanation": "PUT là idempotent vì nhiều request giống hệt nhau có cùng một hiệu ứng."
  },
  {
    "question_id": "EQ5008-VN",
    "question": "Viết một test negative đơn giản cho một API đăng ký.",
    "answer": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test negative kiểm tra thiếu các trường bắt buộc."
  },
  {
    "question_id": "EQ5009-VN",
    "question": "Mã trạng thái HTTP nào có nghĩa là 'OK'?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "500"
    },
    "explanation": "200 OK là mã thành công chuẩn."
  },
  {
    "question_id": "EQ5010-VN",
    "question": "Vai trò của một schema trong API testing là gì?",
    "answer": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Schemas validate định dạng và các trường của thông điệp API."
  },
  {
    "question_id": "EQ5011-VN",
    "question": "Phương thức HTTP nào được sử dụng để xóa một tài nguyên?",
    "answer": "D",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "DELETE xóa tài nguyên được chỉ định trong URL."
  },
  {
    "question_id": "EQ5012-VN",
    "question": "Viết một test step đơn giản để validate một response 201 Created.",
    "answer": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
    "category": "Test Step",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "201 Created xác nhận tài nguyên đã được tạo thành công."
  },
  {
    "question_id": "EQ5013-VN",
    "question": "HTTP header nào thường được sử dụng cho các authentication token?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Content-Type",
      "B": "Authorization",
      "C": "Accept",
      "D": "Cache-Control"
    },
    "explanation": "Authorization header mang thông tin xác thực hoặc token."
  },
  {
    "question_id": "EQ5014-VN",
    "question": "Mục đích của mocking trong API testing là gì?",
    "answer": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Mocking giảm phụ thuộc trong quá trình testing."
  },
  {
    "question_id": "EQ5015-VN",
    "question": "Mã trạng thái HTTP nào cho biết 'Created'?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "403"
    },
    "explanation": "201 Created xác nhận tạo tài nguyên thành công."
  },
  {
    "question_id": "EQ5016-VN",
    "question": "Viết một test case dễ dàng cho một API lấy danh sách sản phẩm.",
    "answer": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test đơn giản để kiểm tra việc lấy danh sách sản phẩm."
  },
  {
    "question_id": "EQ5017-VN",
    "question": "Mã trạng thái HTTP nào cho biết 'Internal Server Error'?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "400",
      "C": "403",
      "D": "500"
    },
    "explanation": "500 cho biết lỗi không mong muốn phía server."
  },
  {
    "question_id": "EQ5018-VN",
    "question": "Mục đích của một precondition trong một test case là gì?",
    "answer": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Precondition đảm bảo thiết lập hợp lệ cho các test."
  },
  {
    "question_id": "EQ5019-VN",
    "question": "Trạng thái HTTP nào phù hợp cho quyền truy cập bị cấm với thông tin đăng nhập hợp lệ?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "401 Unauthorized",
      "B": "200 OK",
      "C": "403 Forbidden",
      "D": "404 Not Found"
    },
    "explanation": "403 Forbidden cho biết không đủ quyền hạn mặc dù đăng nhập hợp lệ."
  },
  {
    "question_id": "EQ5020-VN",
    "question": "Viết một test negative cho việc upload file với định dạng không được hỗ trợ.",
    "answer": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test từ chối các định dạng file không được hỗ trợ."
  },
  {
    "question_id": "EQ5021-VN",
    "question": "Phương thức HTTP nào thường được sử dụng cho các partial update?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "PATCH",
      "C": "POST",
      "D": "DELETE"
    },
    "explanation": "PATCH được sử dụng để sửa đổi một phần của tài nguyên."
  },
  {
    "question_id": "EQ5022-VN",
    "question": "Mục đích của một test case description là gì?",
    "answer": "Để giải thích mục tiêu và phạm vi của một test scenario.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Descriptions cung cấp sự rõ ràng về những gì test đang validate."
  },
  {
    "question_id": "EQ5023-VN",
    "question": "HTTP header nào cho biết định dạng của request body?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Content-Type",
      "B": "Authorization",
      "C": "User-Agent",
      "D": "Accept-Encoding"
    },
    "explanation": "Content-Type định nghĩa kiểu media của request body."
  },
  {
    "question_id": "EQ5024-VN",
    "question": "Viết một test step để validate thời gian response dưới 1 giây.",
    "answer": "Gửi GET /status → assert response time < 1000 ms.",
    "category": "Performance & Load Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Kiểm tra yêu cầu performance về thời gian response."
  },
  {
    "question_id": "EQ5025-VN",
    "question": "Mã trạng thái HTTP nào cho biết conflict, chẳng hạn như tạo tài nguyên trùng lặp?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "409 Conflict"
    },
    "explanation": "409 Conflict được sử dụng khi request conflict với trạng thái hiện tại."
  },
  {
    "question_id": "EQ5026-VN",
    "question": "Mã trạng thái HTTP nào có nghĩa là 'Bad Request'?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "500"
    },
    "explanation": "400 Bad Request cho biết cú pháp hoặc tham số không hợp lệ."
  },
  {
    "question_id": "EQ5027-VN",
    "question": "Viết một test positive đơn giản cho endpoint GET /health.",
    "answer": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Health check xác nhận tính khả dụng của dịch vụ."
  },
  {
    "question_id": "EQ5028-VN",
    "question": "Phương thức HTTP nào được sử dụng để cập nhật hoàn toàn một tài nguyên?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "PUT",
      "C": "PATCH",
      "D": "DELETE"
    },
    "explanation": "PUT thay thế một tài nguyên hiện có bằng dữ liệu mới."
  },
  {
    "question_id": "EQ5029-VN",
    "question": "Mục đích của việc sử dụng test data management trong API testing là gì?",
    "answer": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
    "category": "Environment & Test Data Management",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Tính nhất quán của test data làm giảm tính flakiness trong các test."
  },
  {
    "question_id": "EQ5030-VN",
    "question": "Mã trạng thái HTTP nào cho biết 'Forbidden'?",
    "answer": "D",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "401",
      "D": "403"
    },
    "explanation": "403 Forbidden có nghĩa là người dùng đã được xác thực nhưng không được authorization."
  },
  {
    "question_id": "EQ5031-VN",
    "question": "Viết một test negative dễ dàng cho một API mong đợi định dạng JSON.",
    "answer": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test từ chối content type không hợp lệ."
  },
  {
    "question_id": "EQ5032-VN",
    "question": "Mã trạng thái HTTP nào đại diện cho 'Too Many Requests'?",
    "answer": "B",
    "category": "Security Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "408",
      "B": "429",
      "C": "503",
      "D": "504"
    },
    "explanation": "429 Too Many Requests được trả về khi rate limit bị vượt quá."
  },
  {
    "question_id": "EQ5033-VN",
    "question": "Vai trò của assertion trong API testing là gì?",
    "answer": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Assertions validate tính đúng đắn của các response API."
  },
  {
    "question_id": "EQ5034-VN",
    "question": "Mã trạng thái HTTP nào cho biết một timeout từ server?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "404",
      "B": "400",
      "C": "200",
      "D": "504"
    },
    "explanation": "504 Gateway Timeout cho biết server không phản hồi kịp thời."
  },
  {
    "question_id": "EQ5035-VN",
    "question": "Viết một test case để kiểm tra DELETE /users/{id} hoạt động đúng.",
    "answer": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Xác nhận việc xóa và tài nguyên không còn tồn tại."
  },
  {
    "question_id": "EQ5036-VN",
    "question": "Phương thức HTTP nào là safe (không thay đổi trạng thái server)?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "GET là safe vì nó chỉ truy xuất dữ liệu."
  },
  {
    "question_id": "EQ5037-VN",
    "question": "Mã trạng thái HTTP 201 Created cho biết điều gì?",
    "answer": "Một tài nguyên mới đã được tạo thành công.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "201 có nghĩa là request đã dẫn đến việc tạo tài nguyên."
  },
  {
    "question_id": "EQ5038-VN",
    "question": "Trạng thái HTTP nào được trả về khi một client request được định dạng tốt nhưng bị unauthorized?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "400",
      "C": "401",
      "D": "500"
    },
    "explanation": "401 Unauthorized được sử dụng cho thông tin đăng nhập không hợp lệ."
  },
  {
    "question_id": "EQ5039-VN",
    "question": "Viết một test đơn giản cho GET /users/{id} trả về response chính xác.",
    "answer": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Kiểm tra việc truy xuất một tài nguyên người dùng bằng ID."
  },
  {
    "question_id": "EQ5040-VN",
    "question": "Mã trạng thái HTTP nào cho biết thành công nhưng không có content nào được trả về?",
    "answer": "D",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "204"
    },
    "explanation": "204 No Content được trả về khi xóa thành công hoặc response rỗng."
  },
  {
    "question_id": "EQ5041-VN",
    "question": "Mục đích của một response 200 OK là gì?",
    "answer": "Nó xác nhận rằng request đã thành công.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "200 OK là mã thành công HTTP phổ biến nhất."
  },
  {
    "question_id": "EQ5042-VN",
    "question": "Header nào được sử dụng để chỉ định các định dạng response được chấp nhận?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Content-Type",
      "B": "Accept",
      "C": "Authorization",
      "D": "Cache-Control"
    },
    "explanation": "Accept header cho server biết những định dạng nào được mong đợi (ví dụ: application/json)."
  },
  {
    "question_id": "EQ5043-VN",
    "question": "Viết một test negative để validate response cho một endpoint không hợp lệ.",
    "answer": "Gửi GET /unknown → mong đợi 404 Not Found.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Các endpoint không hợp lệ phải trả về 404."
  },
  {
    "question_id": "EQ5044-VN",
    "question": "Mã trạng thái HTTP nào được sử dụng khi client phải authenticate để truy cập một tài nguyên?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "403",
      "C": "401",
      "D": "404"
    },
    "explanation": "401 Unauthorized yêu cầu thông tin xác thực."
  },
  {
    "question_id": "EQ5045-VN",
    "question": "Một test case assertion làm gì?",
    "answer": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
    "category": "Test Step",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Assertions là cốt lõi của automated testing."
  },
  {
    "question_id": "EQ5046-VN",
    "question": "Trạng thái HTTP nào cho biết server không thể xử lý request do quá tải?",
    "answer": "A",
    "category": "Performance & Load Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "503 Service Unavailable",
      "B": "200 OK",
      "C": "404 Not Found",
      "D": "201 Created"
    },
    "explanation": "503 cho biết quá tải tạm thời hoặc đang bảo trì."
  },
  {
    "question_id": "EQ5047-VN",
    "question": "Viết một test positive cho endpoint upload file.",
    "answer": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test positive đảm bảo việc upload file hợp lệ thành công."
  },
  {
    "question_id": "EQ5048-VN",
    "question": "Phương thức HTTP nào là safe và idempotent?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "PATCH",
      "C": "GET",
      "D": "DELETE"
    },
    "explanation": "GET vừa là safe vừa là idempotent."
  },
  {
    "question_id": "EQ5049-VN",
    "question": "Vai trò của 415 Unsupported Media Type là gì?",
    "answer": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Validates việc xử lý định dạng."
  },
  {
    "question_id": "EQ5050-VN",
    "question": "Mã trạng thái HTTP nào có nghĩa là 'Request Timeout'?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "404",
      "B": "408",
      "C": "500",
      "D": "429"
    },
    "explanation": "408 Request Timeout cho biết client mất quá nhiều thời gian để gửi request."
  },
  {
    "question_id": "EQ5051-VN",
    "question": "Phương thức HTTP nào thường được sử dụng để tạo một tài nguyên mới?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "POST là phương thức chuẩn để tạo tài nguyên."
  },
  {
    "question_id": "EQ5052-VN",
    "question": "Viết một test positive đơn giản để kiểm tra API chi tiết sản phẩm.",
    "answer": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Kiểm tra việc truy xuất một sản phẩm hợp lệ."
  },
  {
    "question_id": "EQ5053-VN",
    "question": "Mã trạng thái HTTP nào được trả về khi một tài nguyên được xóa thành công?",
    "answer": "D",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "204"
    },
    "explanation": "204 No Content xác nhận việc xóa thành công."
  },
  {
    "question_id": "EQ5054-VN",
    "question": "Mục đích của việc sử dụng Authorization headers trong API testing là gì?",
    "answer": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Authorization đảm bảo chỉ những người dùng đã xác thực mới truy cập được các API được bảo vệ."
  },
  {
    "question_id": "EQ5055-VN",
    "question": "Mã trạng thái HTTP nào được sử dụng khi một client gửi một JSON payload không hợp lệ?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "500 Internal Server Error",
      "C": "400 Bad Request",
      "D": "201 Created"
    },
    "explanation": "400 cho biết request không thể hiểu được do cú pháp không hợp lệ."
  },
  {
    "question_id": "EQ5056-VN",
    "question": "Viết một test negative case cho một API yêu cầu authentication.",
    "answer": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test phản hồi của API khi không có authentication được cung cấp."
  },
  {
    "question_id": "EQ5057-VN",
    "question": "Phương thức HTTP nào thường được sử dụng để cập nhật hoàn toàn một tài nguyên?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "PUT",
      "C": "PATCH",
      "D": "DELETE"
    },
    "explanation": "PUT thay thế hoàn toàn tài nguyên bằng dữ liệu mới."
  },
  {
    "question_id": "EQ5058-VN",
    "question": "Vai trò của 500 Internal Server Error trong API testing là gì?",
    "answer": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Trạng thái 500 làm nổi bật các ngoại lệ không được xử lý trên server."
  },
  {
    "question_id": "EQ5059-VN",
    "question": "Trạng thái HTTP nào có nghĩa là 'Conflict'?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "409"
    },
    "explanation": "409 Conflict xảy ra khi việc tạo/cập nhật tài nguyên conflict với trạng thái."
  },
  {
    "question_id": "EQ5060-VN",
    "question": "Viết một test case positive cho một API trả về danh sách đơn hàng.",
    "answer": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test positive đảm bảo endpoint đơn hàng trả về danh sách hợp lệ."
  },
  {
    "question_id": "EQ5061-VN",
    "question": "Phương thức HTTP nào được sử dụng cho các partial update tài nguyên?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "PATCH",
      "D": "DELETE"
    },
    "explanation": "PATCH chỉ sửa đổi một phần của tài nguyên."
  },
  {
    "question_id": "EQ5062-VN",
    "question": "Chức năng của response header trong API testing là gì?",
    "answer": "Chúng cung cấp metadata về response, như content type và caching info.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Headers mô tả ngữ cảnh cho response body."
  },
  {
    "question_id": "EQ5063-VN",
    "question": "Mã trạng thái HTTP nào được trả về khi authentication là bắt buộc nhưng bị thiếu?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "401",
      "C": "403",
      "D": "404"
    },
    "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
  },
  {
    "question_id": "EQ5064-VN",
    "question": "Viết một test negative cho việc tạo một tài nguyên trùng lặp.",
    "answer": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Ngăn chặn việc tạo tài nguyên trùng lặp."
  },
  {
    "question_id": "EQ5065-VN",
    "question": "Phương thức HTTP nào thường được sử dụng cho các read-only operation an toàn?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "POST",
      "D": "DELETE"
    },
    "explanation": "GET là safe và read-only."
  },
  {
    "question_id": "EQ5066-VN",
    "question": "Vai trò của 202 Accepted trong các API là gì?",
    "answer": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "202 được sử dụng cho các endpoint xử lý bất đồng bộ."
  },
  {
    "question_id": "EQ5067-VN",
    "question": "Trạng thái HTTP nào được trả về khi một tài nguyên đã được di chuyển vĩnh viễn?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "404",
      "B": "302",
      "C": "301",
      "D": "500"
    },
    "explanation": "301 Moved Permanently cho biết redirection."
  },
  {
    "question_id": "EQ5068-VN",
    "question": "Viết một test positive dễ dàng để kiểm tra API response schema.",
    "answer": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Schema validation đảm bảo cấu trúc response chính xác."
  },
  {
    "question_id": "EQ5069-VN",
    "question": "Trạng thái HTTP nào cho biết request hợp lệ nhưng không tìm thấy tài nguyên?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "201",
      "C": "400",
      "D": "404"
    },
    "explanation": "404 Not Found có nghĩa là tài nguyên không tồn tại."
  },
  {
    "question_id": "EQ5070-VN",
    "question": "Mục đích của response body trong API testing là gì?",
    "answer": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Response body chứa dữ liệu đầu ra của API."
  },
  {
    "question_id": "EQ5071-VN",
    "question": "Trạng thái HTTP nào cho biết client request timeout?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "500",
      "B": "408",
      "C": "403",
      "D": "404"
    },
    "explanation": "408 Request Timeout có nghĩa là client không gửi xong kịp thời."
  },
  {
    "question_id": "EQ5072-VN",
    "question": "Viết một test case để verify chức năng logout.",
    "answer": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Logout phải làm mất hiệu lực token."
  },
  {
    "question_id": "EQ5073-VN",
    "question": "Trạng thái HTTP nào cho biết một request thành công trả về dữ liệu JSON?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "204 No Content",
      "D": "400 Bad Request"
    },
    "explanation": "200 OK là mã chuẩn cho các GET thành công."
  },
  {
    "question_id": "EQ5074-VN",
    "question": "Lỗi 415 Unsupported Media Type validate điều gì?",
    "answer": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Validates việc xử lý định dạng request của API."
  },
  {
    "question_id": "EQ5075-VN",
    "question": "Mã trạng thái HTTP nào cho biết server tạm thời ngừng hoạt động để bảo trì?",
    "answer": "C",
    "category": "Performance & Load Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "503 Service Unavailable",
      "D": "429 Too Many Requests"
    },
    "explanation": "503 được sử dụng khi dịch vụ không khả dụng do quá tải hoặc bảo trì."
  },
  {
    "question_id": "EQ5076-VN",
    "question": "Phương thức HTTP nào thường được sử dụng để cập nhật chỉ một phần của tài nguyên?",
    "answer": "C",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "PATCH",
      "D": "DELETE"
    },
    "explanation": "PATCH được thiết kế cho các partial update."
  },
  {
    "question_id": "EQ5077-VN",
    "question": "Viết một test positive đơn giản cho endpoint GET /status.",
    "answer": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Status check xác nhận tính khả dụng của API."
  },
  {
    "question_id": "EQ5078-VN",
    "question": "Trạng thái HTTP nào cho biết việc tạo tài nguyên thành công?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "204 No Content",
      "D": "400 Bad Request"
    },
    "explanation": "201 Created xác nhận việc tạo tài nguyên thành công."
  },
  {
    "question_id": "EQ5079-VN",
    "question": "Một response 204 No Content có nghĩa là gì?",
    "answer": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "204 cho biết thành công mà không có response body."
  },
  {
    "question_id": "EQ5080-VN",
    "question": "Mã trạng thái HTTP nào được sử dụng khi một request hợp lệ nhưng quyền truy cập bị cấm?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "401 Unauthorized",
      "B": "200 OK",
      "C": "403 Forbidden",
      "D": "404 Not Found"
    },
    "explanation": "403 Forbidden có nghĩa là thông tin đăng nhập hợp lệ nhưng không đủ quyền."
  },
  {
    "question_id": "EQ5081-VN",
    "question": "Viết một test negative case cho việc gửi một Content-Type header không hợp lệ.",
    "answer": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Validates việc từ chối các content type không được hỗ trợ."
  },
  {
    "question_id": "EQ5082-VN",
    "question": "Mã trạng thái HTTP nào cho biết thành công nhưng tài nguyên rỗng?",
    "answer": "D",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "400 Bad Request",
      "D": "204 No Content"
    },
    "explanation": "204 được trả về khi không có body content."
  },
  {
    "question_id": "EQ5083-VN",
    "question": "Mục đích của Accept header trong các API request là gì?",
    "answer": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Accept header hướng dẫn định dạng response của server."
  },
  {
    "question_id": "EQ5084-VN",
    "question": "Mã trạng thái HTTP nào phù hợp cho thông tin đăng nhập không hợp lệ?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "401 Unauthorized",
      "C": "403 Forbidden",
      "D": "404 Not Found"
    },
    "explanation": "401 Unauthorized cho biết thông tin đăng nhập không hợp lệ."
  },
  {
    "question_id": "EQ5085-VN",
    "question": "Viết một test case đơn giản cho một API logout thành công.",
    "answer": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Logout phải làm mất hiệu lực session token."
  },
  {
    "question_id": "EQ5086-VN",
    "question": "Phương thức HTTP nào được sử dụng để truy xuất chi tiết tài nguyên?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "PATCH"
    },
    "explanation": "GET được sử dụng để truy xuất dữ liệu."
  },
  {
    "question_id": "EQ5087-VN",
    "question": "Ý nghĩa của 401 Unauthorized trong API testing là gì?",
    "answer": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
    "category": "Authentication & Authorization",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "401 yêu cầu authentication."
  },
  {
    "question_id": "EQ5088-VN",
    "question": "Mã trạng thái HTTP nào cho biết nỗ lực tạo tài nguyên trùng lặp?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "409 Conflict"
    },
    "explanation": "409 Conflict có nghĩa là request trùng lặp hoặc conflict."
  },
  {
    "question_id": "EQ5089-VN",
    "question": "Viết một test case positive dễ dàng để kiểm tra API chi tiết profile.",
    "answer": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Test positive đảm bảo endpoint profile trả về thông tin người dùng."
  },
  {
    "question_id": "EQ5090-VN",
    "question": "Mã trạng thái HTTP nào cho biết request hợp lệ nhưng server không thể hoàn thành nó?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200",
      "B": "400",
      "C": "500",
      "D": "201"
    },
    "explanation": "500 Internal Server Error báo hiệu lỗi phía server."
  },
  {
    "question_id": "EQ5091-VN",
    "question": "Mục đích của 302 Found trong các API là gì?",
    "answer": "Nó cho biết việc redirection tạm thời đến một URL khác.",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "302 cho client biết phải theo một redirect tạm thời."
  },
  {
    "question_id": "EQ5092-VN",
    "question": "Trạng thái HTTP nào là chính xác cho một tài nguyên được cập nhật thành công bằng PUT?",
    "answer": "A",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "204 No Content",
      "D": "400 Bad Request"
    },
    "explanation": "200 OK cho biết tài nguyên đã được cập nhật thành công."
  },
  {
    "question_id": "EQ5093-VN",
    "question": "Viết một test case cho nỗ lực đăng nhập negative với mật khẩu sai.",
    "answer": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Đảm bảo đăng nhập thất bại với mật khẩu không chính xác."
  },
  {
    "question_id": "EQ5094-VN",
    "question": "Phương thức HTTP nào là safe và cacheable?",
    "answer": "B",
    "category": "General Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "POST",
      "B": "GET",
      "C": "PUT",
      "D": "DELETE"
    },
    "explanation": "GET vừa là safe, idempotent, và cacheable."
  },
  {
    "question_id": "EQ5095-VN",
    "question": "422 Unprocessable Entity cho biết điều gì?",
    "answer": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "422 làm nổi bật các lỗi semantic validation."
  },
  {
    "question_id": "EQ5096-VN",
    "question": "Trạng thái HTTP nào phù hợp khi dịch vụ tạm thời quá tải?",
    "answer": "C",
    "category": "Performance & Load Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "201",
      "B": "200",
      "C": "503",
      "D": "404"
    },
    "explanation": "503 Service Unavailable cho biết quá tải hoặc bảo trì."
  },
  {
    "question_id": "EQ5097-VN",
    "question": "Viết một test positive cho endpoint POST /users.",
    "answer": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Xác nhận việc tạo người dùng thành công."
  },
  {
    "question_id": "EQ5098-VN",
    "question": "HTTP header nào chỉ định kích thước của request body?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "Content-Length",
      "B": "Authorization",
      "C": "User-Agent",
      "D": "Cache-Control"
    },
    "explanation": "Content-Length định nghĩa kích thước body theo byte."
  },
  {
    "question_id": "EQ5099-VN",
    "question": "Thuật ngữ 'happy path' trong testing có nghĩa là gì?",
    "answer": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
    "category": "Test Case",
    "difficulty": "Easy",
    "question_type": "Writing",
    "explanation": "Happy path kiểm tra luồng thông thường, thành công."
  },
  {
    "question_id": "EQ5100-VN",
    "question": "Mã trạng thái HTTP nào được sử dụng khi một request method không được phép trên một tài nguyên?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Easy",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "405 Method Not Allowed"
    },
    "explanation": "405 được sử dụng khi phương thức HTTP không hợp lệ cho tài nguyên."
  },
  {
    "question_id": "EQ2001-VN",
    "question": "Khi thiết kế các bài kiểm tra API, kịch bản nào thể hiện rõ nhất một **điều kiện biên** cho tham số phân trang?",
    "answer": "C",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Gửi page=2 khi total items=200",
      "B": "Gửi page=10 khi size=10 mỗi trang và total items=100",
      "C": "Gửi page=11 khi total items=100 với size=10",
      "D": "Gửi page=1 khi size=20 và total items=300"
    },
    "explanation": "Page=11 sẽ vượt quá phạm vi có sẵn (tối đa 10), kiểm tra một sự tràn **điều kiện biên**."
  },
  {
    "question_id": "EQ2002-VN",
    "question": "Hãy giải thích cách bạn thiết kế một **test case âm tính** cho một endpoint API yêu cầu **OAuth2 Bearer token**.",
    "answer": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Test case âm tính** xác nhận sự mạnh mẽ của việc xử lý xác thực."
  },
  {
    "question_id": "EQ2003-VN",
    "question": "Cách nào sau đây là hiệu quả nhất để xác thực thời gian phản hồi của API dưới **tải người dùng** mô phỏng?",
    "answer": "B",
    "category": "Performance & Load Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Gọi API tuần tự thủ công bằng đồng hồ bấm giờ",
      "B": "**Load test** tự động với **người dùng ảo** đồng thời",
      "C": "Thực hiện một yêu cầu duy nhất và đo thời gian phản hồi",
      "D": "**Unit testing** với các phản hồi được **mock**"
    },
    "explanation": "**Load testing** với **người dùng ảo** đồng thời mô phỏng điều kiện thực tế."
  },
  {
    "question_id": "EQ2004-VN",
    "question": "Cung cấp một **test case happy-path** và một **test case error-path** cho một endpoint API hoàn tiền thanh toán.",
    "answer": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Bao gồm cả kịch bản thành công và thất bại đảm bảo độ bao phủ **test** cân bằng."
  },
  {
    "question_id": "EQ2005-VN",
    "question": "Thực hành nào giúp giảm **sự flaky** của **automated API tests** chạy trong các **CI/CD pipelines**?",
    "answer": "D",
    "category": "CI/CD & Automation Integration",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Hardcode **API keys** trong các script",
      "B": "Sử dụng độ trễ ngủ ngẫu nhiên trước các **assertion**",
      "C": "Chỉ chạy **test** một lần mỗi bản phát hành",
      "D": "Sử dụng dữ liệu **test** ổn định và các **hook** thiết lập môi trường"
    },
    "explanation": "Dữ liệu **test** và thiết lập môi trường ổn định giúp giảm tính ngẫu nhiên và **sự flaky**."
  },
  {
    "question_id": "EQ2006-VN",
    "question": "Bạn sẽ xác thực các thay đổi **schema** trong một nâng cấp API **tương thích ngược** như thế nào?",
    "answer": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Tính **tương thích ngược** yêu cầu bảo toàn các trường và kiểu hiện có."
  },
  {
    "question_id": "EQ2007-VN",
    "question": "Điều nào sau đây thể hiện một **test case âm tính** chính xác cho việc xác thực đầu vào trên trường ngày sinh?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Gửi **dateOfBirth**=‘2025-13-40’",
      "B": "Gửi **dateOfBirth**=‘1990-05-20’",
      "C": "Để trống **dateOfBirth** khi nó là tùy chọn",
      "D": "Gửi **dateOfBirth**=‘2000-01-01’"
    },
    "explanation": "Tháng/ngày không hợp lệ làm cho nó trở thành một trường hợp xác thực đầu vào **âm tính** chính xác."
  },
  {
    "question_id": "EQ2008-VN",
    "question": "Giải thích cách **mocking** có thể được sử dụng để kiểm tra một API thanh toán mà không gọi dịch vụ ngân hàng thực.",
    "answer": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Mocking** cho phép kiểm tra các luồng mà không phụ thuộc vào hệ thống bên ngoài."
  },
  {
    "question_id": "EQ2009-VN",
    "question": "Cách tiếp cận giám sát nào giúp phát hiện các đợt tăng đột biến về tỷ lệ lỗi API?",
    "answer": "C",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Báo cáo **code coverage**",
      "B": "Kiểm tra **log** thủ công mỗi tuần",
      "C": "Cảnh báo thời gian thực trên các chỉ số tỷ lệ lỗi",
      "D": "Phân tích **code** tĩnh"
    },
    "explanation": "Cảnh báo thời gian thực đảm bảo phát hiện ngay lập tức các đợt tăng đột biến tỷ lệ lỗi."
  },
  {
    "question_id": "EQ2010-VN",
    "question": "Thiết kế một **boundary test** và một **invalid test** cho trường API `age` (phạm vi 18–65).",
    "answer": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
    "category": "Test Step",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Kiểm tra cả các cạnh và phạm vi không hợp lệ đảm bảo sự mạnh mẽ."
  },
  {
    "question_id": "EQ2011-VN",
    "question": "Điều nào sau đây là một ví dụ về **contract validation** trong **API testing**?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Kiểm tra độ trễ phản hồi",
      "B": "Xác thực **JSON** phản hồi khớp với **OpenAPI schema**",
      "C": "Đo tải **CPU** của máy chủ",
      "D": "**Assert** các truy vấn **SQL** từ **log**"
    },
    "explanation": "**Contract validation** đảm bảo các phản hồi khớp với **schema** đã xác định."
  },
  {
    "question_id": "EQ2012-VN",
    "question": "Giải thích cách bạn mô phỏng lỗi **network timeout** trong **API testing**.",
    "answer": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Mô phỏng **timeout** xác thực sự mạnh mẽ của việc xử lý lỗi máy khách."
  },
  {
    "question_id": "EQ2013-VN",
    "question": "Kịch bản nào thể hiện rõ nhất một **load test** trung gian?",
    "answer": "D",
    "category": "Performance & Load Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "10.000 **người dùng ảo** đồng thời cho **stress testing**",
      "B": "Kiểm tra chức năng một người dùng",
      "C": "**Unit testing** một chức năng",
      "D": "100–200 **người dùng ảo** đồng thời mô phỏng lưu lượng truy cập trung bình"
    },
    "explanation": "Các **load test** trung gian mô phỏng lưu lượng truy cập người dùng vừa phải, thực tế."
  },
  {
    "question_id": "EQ2014-VN",
    "question": "Đưa ra một ví dụ về một **precondition** API và một **step** theo sau nó.",
    "answer": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
    "category": "Test Step",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Precondition** đảm bảo bối cảnh hợp lệ để thực hiện các **test step**."
  },
  {
    "question_id": "EQ2015-VN",
    "question": "Cách tiếp cận nào giúp phát hiện các nỗ lực truy cập trái phép trong một API?",
    "answer": "A",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "**Penetration test** sử dụng **token** không hợp lệ hoặc thiếu",
      "B": "**Unit test** trên các chức năng hỗ trợ",
      "C": "Thành công **build** **CI pipeline**",
      "D": "Chạy API ở chế độ **debug**"
    },
    "explanation": "**Penetration test** tiết lộ điểm yếu trong việc xử lý ủy quyền."
  },
  {
    "question_id": "EQ2016-VN",
    "question": "Viết một **test case** để xác thực rằng **API rate limiting** được thực thi đúng.",
    "answer": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Rate limiting** ngăn chặn lạm dụng và các cuộc tấn công **DoS**."
  },
  {
    "question_id": "EQ2017-VN",
    "question": "Chiến lược nào đảm bảo khả năng tái tạo của các **integration API tests**?",
    "answer": "B",
    "category": "Environment & Test Data Management",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Chạy với dữ liệu sản phẩm ngẫu nhiên",
      "B": "Sử dụng các cơ sở dữ liệu **test** được **seed** và các **script reset**",
      "C": "Hardcode **timestamp** trong các yêu cầu",
      "D": "Vô hiệu hóa các **cleanup step** sau khi **test**"
    },
    "explanation": "Dữ liệu **test** được **seed** đảm bảo khả năng tái tạo nhất quán."
  },
  {
    "question_id": "EQ2018-VN",
    "question": "Giải thích một lợi thế của việc sử dụng **service virtualization** trong **API testing**.",
    "answer": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Virtualization** loại bỏ các nút thắt cổ chai phụ thuộc."
  },
  {
    "question_id": "EQ2019-VN",
    "question": "Điều nào trong số này là một **recovery step** thích hợp nếu giám sát API phát hiện lỗi **500** nhất quán?",
    "answer": "C",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Bỏ qua chúng cho đến bản phát hành tiếp theo",
      "B": "Thêm logic **retry** ngẫu nhiên cho tất cả các máy khách",
      "C": "Cảnh báo đội ngũ vận hành và kích hoạt **rollback** của **deployment** gần đây",
      "D": "Tắt **log** lỗi"
    },
    "explanation": "**Rollback** và cảnh báo đảm bảo giảm thiểu nhanh chóng."
  },
  {
    "question_id": "EQ2020-VN",
    "question": "Mô tả cách thiết kế một **test case tích cực** và một **boundary test case** cho một API đăng nhập yêu cầu tên người dùng và mật khẩu.",
    "answer": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Bao gồm cả điều kiện đầu vào bình thường và ở **điều kiện biên**."
  },
  {
    "question_id": "EQ2021-VN",
    "question": "Kịch bản nào sau đây là một ví dụ về một **chained API test case**?",
    "answer": "B",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Gọi GET /status lặp đi lặp lại",
      "B": "Tạo một người dùng, sau đó sử dụng ID của người dùng đó trong GET /profile",
      "C": "Kiểm tra một endpoint với các **header** không hợp lệ",
      "D": "Đo độ trễ trung bình của một endpoint"
    },
    "explanation": "**Chained test case** phụ thuộc vào đầu ra của một API là đầu vào cho API khác."
  },
  {
    "question_id": "EQ2022-VN",
    "question": "Viết một **test step** để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác.",
    "answer": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
    "category": "Test Step",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Content-Type** không khớp là một lý do phổ biến cho phản hồi **415**."
  },
  {
    "question_id": "EQ2023-VN",
    "question": "Thực hành nào giúp phát hiện vi phạm **contract** sớm trong **CI/CD pipeline**?",
    "answer": "C",
    "category": "CI/CD & Automation Integration",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "**Load testing** trong **production** thôi",
      "B": "Kiểm tra **regression** thủ công mỗi tháng một lần",
      "C": "**Schema validation tests** được tích hợp vào **pipeline**",
      "D": "Sử dụng **mock** cho tất cả các phụ thuộc bên ngoài"
    },
    "explanation": "**Automated schema validation** trong **CI/CD** phát hiện các thay đổi gây lỗi nhanh chóng."
  },
  {
    "question_id": "EQ2024-VN",
    "question": "Mô tả một cách để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm.",
    "answer": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Observability** đảm bảo các nút thắt cổ chai hiệu suất được hiển thị."
  },
  {
    "question_id": "EQ2025-VN",
    "question": "Điều nào sau đây là một ví dụ về một **negative authorization test**?",
    "answer": "A",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Gọi **DELETE /users** mà không có đặc quyền quản trị",
      "B": "Gọi **GET /users** với **token** hợp lệ",
      "C": "Đăng nhập với thông tin đăng nhập hợp lệ",
      "D": "Làm mới một **session token** hợp lệ"
    },
    "explanation": "Cố gắng xóa người dùng mà không có đặc quyền kiểm tra các hạn chế truy cập."
  },
  {
    "question_id": "EQ2026-VN",
    "question": "Giải thích cách bạn sẽ kiểm tra **API idempotency** cho một kịch bản **retry**.",
    "answer": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Idempotency** đảm bảo các yêu cầu lặp lại không gây ra các bản sao."
  },
  {
    "question_id": "EQ2027-VN",
    "question": "Phương pháp nào đảm bảo các **API keys** nhạy cảm không bị lộ trong quá trình **automated testing**?",
    "answer": "D",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Hardcode chúng trong các **test script**",
      "B": "In chúng trong các **log CI/CD**",
      "C": "Lưu trữ chúng trong các **repo GitHub** công khai",
      "D": "Sử dụng các biến môi trường được mã hóa"
    },
    "explanation": "Các biến môi trường được mã hóa giữ bí mật an toàn."
  },
  {
    "question_id": "EQ2028-VN",
    "question": "Đưa ra một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB.",
    "answer": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Kiểm tra cả cạnh được phép và sự từ chối ngoài giới hạn."
  },
  {
    "question_id": "EQ2029-VN",
    "question": "Chỉ số giám sát nào sẽ tốt nhất để chỉ ra rò rỉ bộ nhớ trong một API?",
    "answer": "B",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Tăng đột biến độ trễ trung bình",
      "B": "Sử dụng bộ nhớ tăng dần",
      "C": "Sử dụng CPU giảm",
      "D": "Tăng ngẫu nhiên tỷ lệ **cache hit**"
    },
    "explanation": "Rò rỉ bộ nhớ biểu hiện dưới dạng sử dụng bộ nhớ liên tục tăng."
  },
  {
    "question_id": "EQ2030-VN",
    "question": "Viết một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu.",
    "answer": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Đảm bảo xác thực trường bắt buộc được thực thi."
  },
  {
    "question_id": "EQ2031-VN",
    "question": "Điều nào sau đây mô tả rõ nhất **service virtualization**?",
    "answer": "C",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Chỉ chạy API trong **production**",
      "B": "Sử dụng bản sao cơ sở dữ liệu cục bộ",
      "C": "Mô phỏng các phụ thuộc không có sẵn với các dịch vụ ảo",
      "D": "Thay thế logic **backend** bằng các **microservice** mới"
    },
    "explanation": "**Service virtualization** cho phép kiểm tra mà không có các phụ thuộc thực."
  },
  {
    "question_id": "EQ2032-VN",
    "question": "Bạn sẽ thiết kế một **test** để xác thực logic **retry** như thế nào khi một API thỉnh thoảng trả về **503**?",
    "answer": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Mô phỏng các lỗi không liên tục xác thực các chính sách **retry**."
  },
  {
    "question_id": "EQ2033-VN",
    "question": "Kịch bản lỗi nào thể hiện rõ nhất một lỗi phía máy khách?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "HTTP 400 Bad Request",
      "B": "HTTP 500 Internal Server Error",
      "C": "Lỗi **timeout** cơ sở dữ liệu",
      "D": "**Out-of-memory** trên máy chủ"
    },
    "explanation": "**400 Bad Request** chỉ ra yêu cầu không hợp lệ từ phía máy khách."
  },
  {
    "question_id": "EQ2034-VN",
    "question": "Viết một **test case** xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**.",
    "answer": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Trace ID** cho phép **observability** hệ thống phân tán."
  },
  {
    "question_id": "EQ2035-VN",
    "question": "Kịch bản nào trong số này yêu cầu **schema validation** trong quá trình **testing**?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Kiểm tra thời gian phản hồi API trung bình",
      "B": "Đảm bảo các trường **JSON** phản hồi khớp với định nghĩa **OpenAPI**",
      "C": "Đo **throughput** dưới **tải**",
      "D": "Phân tích **log** truy vấn **SQL**"
    },
    "explanation": "**Schema validation** đảm bảo tính chính xác về cấu trúc của các phản hồi."
  },
  {
    "question_id": "EQ2036-VN",
    "question": "Thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting** khi có nhiều máy khách tham gia.",
    "answer": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Bao gồm việc thực thi **rate limit** cho nhiều máy khách."
  },
  {
    "question_id": "EQ2037-VN",
    "question": "Điều nào sau đây cải thiện khả năng tái tạo của các **API tests** trong nhiều môi trường?",
    "answer": "D",
    "category": "Environment & Test Data Management",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Sử dụng các **URL** môi trường được **hardcode**",
      "B": "Ngẫu nhiên hóa tất cả dữ liệu **test**",
      "C": "Thực hiện **test** trên dữ liệu **production**",
      "D": "Tham số hóa các **endpoint** và sử dụng cấu hình môi trường"
    },
    "explanation": "**Parameterization** đảm bảo cùng một logic **test** hoạt động trên các môi trường."
  },
  {
    "question_id": "EQ2038-VN",
    "question": "Mô tả một **test case tích cực** và một **test case âm tính** cho một endpoint API gửi mã **SMS**.",
    "answer": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Đảm bảo xử lý đầu vào hợp lệ và không hợp lệ."
  },
  {
    "question_id": "EQ2039-VN",
    "question": "Điều nào trong số này mô tả rõ nhất **performance baseline testing**?",
    "answer": "A",
    "category": "Performance & Load Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Đo thời gian phản hồi bình thường dưới **tải** dự kiến",
      "B": "Kiểm tra API với các đầu vào không hợp lệ",
      "C": "Xác thực API so với **OpenAPI spec**",
      "D": "Mô phỏng lưu lượng truy cập **peak** gấp 10 lần"
    },
    "explanation": "**Baseline testing** nắm bắt hiệu suất bình thường dự kiến."
  },
  {
    "question_id": "EQ2040-VN",
    "question": "Giải thích một lợi thế của việc **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại.",
    "answer": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
    "category": "Mocking & Service Virtualization",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Mocking** được kiểm soát cho phép **testing** lỗi có thể tái tạo."
  },
  {
    "question_id": "EQ2041-VN",
    "question": "Điều nào trong số này là một **test case** chính xác để xác thực hết hạn **session**?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Đăng nhập với thông tin đăng nhập hợp lệ, mong đợi **200 OK**",
      "B": "Gửi yêu cầu với **token** hợp lệ ngay sau khi đăng nhập",
      "C": "Gửi yêu cầu với **token** sau khi hết **timeout session**, mong đợi **401 Unauthorized**",
      "D": "Gửi yêu cầu không có **token**, mong đợi **200 OK**"
    },
    "explanation": "**Session** đã hết hạn phải trả về **401 Unauthorized**."
  },
  {
    "question_id": "EQ2042-VN",
    "question": "Viết một **test case** để xác thực việc xử lý lỗi khi API trả về **JSON** bị định dạng sai.",
    "answer": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**JSON** bị định dạng sai kiểm tra sự mạnh mẽ của việc phân tích cú pháp máy khách/máy chủ."
  },
  {
    "question_id": "EQ2043-VN",
    "question": "Chiến lược nào giúp xác thực **tương thích ngược** sau khi thêm các trường tùy chọn mới?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Đảm bảo các máy khách cũ vẫn hoạt động mà không cần gửi các trường mới",
      "B": "Buộc các máy khách cập nhật ngay lập tức",
      "C": "Xóa các trường cũ khỏi phản hồi",
      "D": "Yêu cầu các thay đổi **schema** phải gây lỗi"
    },
    "explanation": "**Tương thích ngược** có nghĩa là các máy khách cũ vẫn phải hoạt động mà không cần các trường mới."
  },
  {
    "question_id": "EQ2044-VN",
    "question": "Thiết kế một **test step** để xác nhận các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt.",
    "answer": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Các **rate limit header** phải cung cấp khả năng hiển thị cho các máy khách."
  },
  {
    "question_id": "EQ2045-VN",
    "question": "Cách hiệu quả nhất để kiểm tra khả năng phục hồi khi một dịch vụ **downstream** của API bị lỗi là gì?",
    "answer": "D",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Vô hiệu hóa **retry** ở máy khách",
      "B": "Ngừng **testing** cho đến khi dịch vụ phục hồi",
      "C": "Chỉ chạy **unit tests**",
      "D": "Chèn lỗi bằng cách sử dụng **chaos testing** hoặc **mock**"
    },
    "explanation": "**Chaos testing/mocks** cho phép mô phỏng có kiểm soát các lỗi phụ thuộc."
  },
  {
    "question_id": "EQ2046-VN",
    "question": "Mô tả một lợi thế của việc tách dữ liệu **test** khỏi logic **test** trong **API testing**.",
    "answer": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
    "category": "Environment & Test Data Management",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Data-driven testing** cải thiện khả năng tái sử dụng và tính nhất quán."
  },
  {
    "question_id": "EQ2047-VN",
    "question": "**Response status code** nào thích hợp cho một yêu cầu bị chặn do thiếu **authorization header**?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "401 Unauthorized",
      "C": "403 Forbidden",
      "D": "409 Conflict"
    },
    "explanation": "Thiếu ủy quyền dẫn đến **401 Unauthorized**."
  },
  {
    "question_id": "EQ2048-VN",
    "question": "Viết một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn.",
    "answer": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Suy thoái **graceful** đảm bảo dịch vụ vẫn tiếp tục ngay cả khi không có **cache**."
  },
  {
    "question_id": "EQ2049-VN",
    "question": "Điều nào sau đây thể hiện một **boundary test** thích hợp cho trường độ dài mật khẩu (**min**=8, **max**=20)?",
    "answer": "A",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Kiểm tra với 7, 8, 20, và 21 ký tự",
      "B": "Chỉ kiểm tra với 10 ký tự",
      "C": "Chỉ kiểm tra với 15 ký tự",
      "D": "Chỉ kiểm tra với mật khẩu trống"
    },
    "explanation": "**Boundary testing** bao gồm các giá trị ở, dưới và trên giới hạn."
  },
  {
    "question_id": "EQ2050-VN",
    "question": "Giải thích một cách để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu.",
    "answer": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Các trường nhạy cảm không bao giờ được xuất hiện trong các **log**."
  },
  {
    "question_id": "EQ2051-VN",
    "question": "Phương pháp giám sát nào giúp xác định sự gia tăng độ trễ dần dần qua các tuần?",
    "answer": "C",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Đo thời gian bằng đồng hồ bấm giờ cho một yêu cầu duy nhất",
      "B": "Gỡ lỗi thủ công trong các sự cố",
      "C": "Phân tích xu hướng chuỗi thời gian bằng **dashboard**",
      "D": "Các chỉ số **code coverage**"
    },
    "explanation": "**Dashboard** và giám sát chuỗi thời gian làm nổi bật các xu hướng độ trễ."
  },
  {
    "question_id": "EQ2052-VN",
    "question": "Cung cấp một **test case âm tính** và một **boundary test case** cho một trường tiền tệ phải khớp với mã **ISO 4217**.",
    "answer": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
    "category": "Test Case",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Các giá trị hợp lệ và không hợp lệ xác thực các hạn chế của trường."
  },
  {
    "question_id": "EQ2053-VN",
    "question": "Chiến lược nào đảm bảo các **contract test** vẫn hữu ích khi API phát triển?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Không bao giờ cập nhật **schema tests**",
      "B": "Xóa các trường tùy chọn khỏi **test**",
      "C": "Chỉ chạy các **regression test** thủ công",
      "D": "Phiên bản hóa các **schema contract** và duy trì **tương thích ngược**"
    },
    "explanation": "**Versioning** và **tương thích ngược** giữ cho các **contract test** đáng tin cậy."
  },
  {
    "question_id": "EQ2054-VN",
    "question": "Viết một **test case** để xác thực hành vi API dưới tình trạng mất gói mạng.",
    "answer": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Kiểm tra dưới mạng xuống cấp đảm bảo sự mạnh mẽ."
  },
  {
    "question_id": "EQ2055-VN",
    "question": "Kịch bản nào trong số này xác thực chính xác **observability** API bằng cách sử dụng **distributed tracing**?",
    "answer": "B",
    "category": "Observability & Monitoring",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "Chỉ kiểm tra các **HTTP status codes**",
      "B": "Theo dõi một **trace ID** trên nhiều **microservice**",
      "C": "Kiểm tra việc sử dụng bộ nhớ trong các **log** máy chủ",
      "D": "Sử dụng các ghi chú **test** thủ công"
    },
    "explanation": "**Trace ID** theo dõi các yêu cầu trên các dịch vụ."
  },
  {
    "question_id": "EQ2056-VN",
    "question": "Mô tả một phương pháp để xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test**.",
    "answer": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
    "category": "Environment & Test Data Management",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Đảm bảo môi trường không bị ô nhiễm bởi các tạo phẩm **test**."
  },
  {
    "question_id": "EQ2057-VN",
    "question": "Điều nào sau đây chỉ ra một lỗ hổng **denial-of-service**?",
    "answer": "A",
    "category": "Security Testing",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "API chấp nhận yêu cầu không giới hạn mà không cần **throttling**",
      "B": "API trả về **404 Not Found**",
      "C": "**API schema** thiếu trường mô tả",
      "D": "**Unit test coverage** thấp"
    },
    "explanation": "Các yêu cầu không bị hạn chế có thể làm cạn kiệt tài nguyên, gây ra **DoS**."
  },
  {
    "question_id": "EQ2058-VN",
    "question": "Viết một **test case** để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần.",
    "answer": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "**Rollback** đảm bảo tính nguyên tử của các giao dịch."
  },
  {
    "question_id": "EQ2059-VN",
    "question": "**HTTP status code** nào nên được xác thực khi một yêu cầu API được định dạng tốt nhưng bị cấm do hạn chế vai trò?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Intermediate",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "401 Unauthorized",
      "C": "403 Forbidden",
      "D": "500 Internal Server Error"
    },
    "explanation": "**403 Forbidden** chỉ ra máy khách đã được xác thực nhưng không được ủy quyền."
  },
  {
    "question_id": "EQ2060-VN",
    "question": "Giải thích một cách tiếp cận để xác thực các thông báo lỗi tuân theo một **JSON schema** nhất quán trên tất cả các **endpoint**.",
    "answer": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
    "category": "Contract & Schema Validation",
    "difficulty": "Intermediate",
    "question_type": "Writing",
    "explanation": "Sự nhất quán trong các **error schema** cải thiện khả năng sử dụng của nhà phát triển."
  },
  {
    "question_id": "EQ3001-VN",
    "question": "Kịch bản nào sau đây thể hiện rõ nhất một bài kiểm tra multi-hop (đa bước) liên quan đến các endpoint đăng nhập và làm mới token?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Gửi yêu cầu tới GET /health",
      "B": "Nhận access token qua POST /login, sau đó sử dụng POST /refresh để gia hạn session",
      "C": "Gửi yêu cầu với token đã hết hạn tới một endpoint được bảo vệ",
      "D": "Kiểm tra trạng thái 200 trên GET /docs"
    },
    "explanation": "Kiểm tra multi-hop có nghĩa là nối chuỗi đăng nhập với việc sử dụng refresh token sau đó."
  },
  {
    "question_id": "EQ3002-VN",
    "question": "Viết một test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới.",
    "answer": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm toàn bộ chuỗi đăng nhập, làm mới và truy cập tiếp theo."
  },
  {
    "question_id": "EQ3003-VN",
    "question": "Một server nên trả về mã trạng thái HTTP nào khi một refresh token đã hết hạn?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "403 Forbidden",
      "C": "401 Unauthorized",
      "D": "201 Created"
    },
    "explanation": "Refresh token đã hết hạn có nghĩa là client phải đăng nhập lại → 401 Unauthorized."
  },
  {
    "question_id": "EQ3004-VN",
    "question": "Thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token.",
    "answer": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Đảm bảo refresh token không thể lấy được sau khi đăng nhập thất bại."
  },
  {
    "question_id": "EQ3005-VN",
    "question": "Cái nào sau đây ánh xạ một mã lỗi cụ thể của ứng dụng tới mã trạng thái HTTP chính xác?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "APP_1001 (User not found) → 404 Not Found",
      "B": "APP_2002 (Invalid password) → 201 Created",
      "C": "APP_3003 (Success) → 500 Internal Server Error",
      "D": "APP_9999 (Database error) → 200 OK"
    },
    "explanation": "Ánh xạ lỗi người dùng không tìm thấy tới 404 là một bản dịch HTTP chính xác."
  },
  {
    "question_id": "EQ3006-VN",
    "question": "Giải thích cách bạn sẽ xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API.",
    "answer": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Suy luận multi-hop giữa các mã nội bộ và các tiêu chuẩn HTTP bên ngoài."
  },
  {
    "question_id": "EQ3007-VN",
    "question": "Kịch bản nào thể hiện việc kiểm tra tiêu cực chuỗi (chained negative testing)?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Kiểm tra yêu cầu GET /status đơn lẻ",
      "B": "Đăng nhập hợp lệ sau đó truy cập /profile",
      "C": "Kiểm tra thời gian hoạt động của server với GET /health",
      "D": "Đăng nhập với mật khẩu hết hạn → 401, sau đó thử lại refresh token → 401"
    },
    "explanation": "Các bài kiểm tra tiêu cực chuỗi xác thực các thất bại trên nhiều endpoint."
  },
  {
    "question_id": "EQ3008-VN",
    "question": "Viết một test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền.",
    "answer": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm vòng đời đơn hàng đa endpoint."
  },
  {
    "question_id": "EQ3009-VN",
    "question": "Mã trạng thái HTTP nào là chính xác để ánh xạ một lỗi tùy chỉnh ORDER_DUPLICATE tới HTTP?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "409 Conflict",
      "C": "404 Not Found",
      "D": "500 Internal Server Error"
    },
    "explanation": "Đơn hàng trùng lặp là một xung đột → 409."
  },
  {
    "question_id": "EQ3010-VN",
    "question": "Giải thích một test case xác thực việc làm mới token hoạt động trên nhiều microservice.",
    "answer": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Đảm bảo token đã được làm mới được truyền đi khắp các dịch vụ."
  },
  {
    "question_id": "EQ3011-VN",
    "question": "Kịch bản nào xác thực việc xử lý lỗi đa bước (multi-hop) chính xác trong một quy trình thương mại điện tử?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Tạo đơn hàng → chi tiết thanh toán không hợp lệ → 402 Payment Required",
      "B": "Kiểm tra kho hàng → sản phẩm tồn tại → 200 OK",
      "C": "Gọi endpoint healthcheck → 200 OK",
      "D": "Yêu cầu danh mục sản phẩm → 200 OK"
    },
    "explanation": "Thanh toán thất bại sau khi tạo đơn hàng là một bài kiểm tra tiêu cực multi-hop."
  },
  {
    "question_id": "EQ3012-VN",
    "question": "Viết một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400.",
    "answer": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Các lỗi xác thực phải ánh xạ tới 400 Bad Request."
  },
  {
    "question_id": "EQ3013-VN",
    "question": "Cái nào trong số này thể hiện một bài kiểm tra đăng nhập chuỗi cấp độ khó?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Chỉ kiểm tra GET /login-docs",
      "B": "Chỉ đăng nhập một lần và dừng lại",
      "C": "Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại",
      "D": "Kiểm tra endpoint GET /health"
    },
    "explanation": "Kết hợp nhiều endpoint vào một quy trình xác thực."
  },
  {
    "question_id": "EQ3014-VN",
    "question": "Thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới.",
    "answer": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Ngăn chặn truy cập tiếp tục trái phép."
  },
  {
    "question_id": "EQ3015-VN",
    "question": "Ánh xạ nào là chính xác cho lỗi nghiệp vụ PAYMENT_DECLINED?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "402 Payment Required"
    },
    "explanation": "Thanh toán bị từ chối → 402 Payment Required."
  },
  {
    "question_id": "EQ3016-VN",
    "question": "Giải thích một bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất.",
    "answer": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Xác thực việc kết thúc session trên các endpoint."
  },
  {
    "question_id": "EQ3017-VN",
    "question": "Kịch bản nào ánh xạ tới mã HTTP chính xác cho một lỗi ứng dụng nội bộ?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "APP_TIMEOUT → 200 OK",
      "B": "APP_TIMEOUT → 504 Gateway Timeout",
      "C": "APP_TIMEOUT → 201 Created",
      "D": "APP_TIMEOUT → 400 Bad Request"
    },
    "explanation": "Các lỗi timeout nên ánh xạ tới 504 Gateway Timeout."
  },
  {
    "question_id": "EQ3018-VN",
    "question": "Viết một test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập.",
    "answer": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm quy trình tạo tài khoản và đăng nhập đa bước."
  },
  {
    "question_id": "EQ3019-VN",
    "question": "Bài kiểm tra nào xác thực quyền truy cập dựa trên vai trò chuỗi?",
    "answer": "A",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Đăng nhập với vai trò user → truy cập /admin → mong đợi 403 Forbidden",
      "B": "Đăng nhập với vai trò admin → truy cập /admin → mong đợi 200 OK",
      "C": "Đăng nhập với vai trò user → xem hồ sơ → 200 OK",
      "D": "GET /health → 200 OK"
    },
    "explanation": "Vai trò không khớp dẫn đến 403 là một xác thực vai trò multi-hop."
  },
  {
    "question_id": "EQ3020-VN",
    "question": "Thiết kế một bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu.",
    "answer": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Bài kiểm tra multi-hop đảm bảo quy trình đặt lại từ đầu đến cuối hoạt động."
  },
  {
    "question_id": "EQ3021-VN",
    "question": "Kịch bản nào xác thực một chuỗi đăng nhập, làm mới và đăng xuất?",
    "answer": "D",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Đăng nhập → sử dụng token một lần",
      "B": "Làm mới token ngay sau khi đăng nhập",
      "C": "Chỉ đăng xuất",
      "D": "Đăng nhập → làm mới token → đăng xuất → xác nhận làm mới thất bại"
    },
    "explanation": "Chuỗi đầy đủ này kiểm tra toàn bộ vòng đời xác thực."
  },
  {
    "question_id": "EQ3022-VN",
    "question": "Viết một test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ.",
    "answer": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm chuỗi tạo → cập nhật → đọc."
  },
  {
    "question_id": "EQ3023-VN",
    "question": "Ánh xạ nào dịch chính xác một lỗi nghiệp vụ STOCK_OUT sang HTTP?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "409 Conflict",
      "C": "201 Created",
      "D": "403 Forbidden"
    },
    "explanation": "Hết hàng có nghĩa là một xung đột với việc thực hiện đơn hàng, ánh xạ tới 409."
  },
  {
    "question_id": "EQ3024-VN",
    "question": "Giải thích một bài kiểm tra để xác thực refresh token không thể được sử dụng sau khi đăng xuất.",
    "answer": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Đăng xuất phải hủy bỏ refresh token."
  },
  {
    "question_id": "EQ3025-VN",
    "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi cho một quy trình giỏ hàng?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Thêm mặt hàng hợp lệ vào giỏ hàng → 200 OK",
      "B": "Thanh toán với thanh toán hợp lệ → 200 OK",
      "C": "Thêm mặt hàng → xóa mặt hàng → thanh toán → mong đợi 400 Bad Request",
      "D": "Xem giỏ hàng sau khi đăng nhập → 200 OK"
    },
    "explanation": "Thanh toán giỏ hàng trống là một kịch bản tiêu cực chuỗi."
  },
  {
    "question_id": "EQ3026-VN",
    "question": "Viết một test case xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP.",
    "answer": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Ánh xạ lỗi nghiệp vụ tới lớp HTTP chính xác."
  },
  {
    "question_id": "EQ3027-VN",
    "question": "Kịch bản nào thể hiện rõ nhất việc xác thực việc hủy đơn hàng chuỗi?",
    "answer": "A",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Tạo đơn hàng → hủy đơn hàng → GET /orders/{id} hiển thị status=cancelled",
      "B": "Hủy đơn hàng không tồn tại → 404",
      "C": "Chỉ tạo đơn hàng",
      "D": "Kiểm tra endpoint /status"
    },
    "explanation": "Bao gồm vòng đời của việc tạo đơn hàng → hủy bỏ → xác minh."
  },
  {
    "question_id": "EQ3028-VN",
    "question": "Giải thích một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ.",
    "answer": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Xác minh không hợp lệ ngăn cản đăng nhập."
  },
  {
    "question_id": "EQ3029-VN",
    "question": "Ánh xạ nào dịch chính xác FILE_TOO_LARGE sang HTTP?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "401 Unauthorized",
      "C": "404 Not Found",
      "D": "413 Payload Too Large"
    },
    "explanation": "File quá lớn nên ánh xạ tới 413."
  },
  {
    "question_id": "EQ3030-VN",
    "question": "Viết một test case cấp độ khó chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt.",
    "answer": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Mô phỏng quy trình làm việc API tài chính thực tế."
  },
  {
    "question_id": "EQ3031-VN",
    "question": "Chuỗi nào xác thực các refresh token trên nhiều session?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Chỉ đăng nhập → đăng xuất",
      "B": "Đăng nhập → làm mới token → đăng xuất → đăng nhập lại → xác nhận refresh token cũ không hợp lệ",
      "C": "Làm mới token mà không đăng nhập",
      "D": "Kiểm tra GET /status"
    },
    "explanation": "Đảm bảo xử lý session trên nhiều lần đăng nhập."
  },
  {
    "question_id": "EQ3032-VN",
    "question": "Thiết kế một test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới.",
    "answer": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Xác thực quy trình đặt lại mật khẩu từ đầu đến cuối."
  },
  {
    "question_id": "EQ3033-VN",
    "question": "Ánh xạ nào là chính xác để ánh xạ lỗi nghiệp vụ INVALID_COUPON?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "403 Forbidden",
      "C": "400 Bad Request",
      "D": "201 Created"
    },
    "explanation": "Coupon không hợp lệ nên ánh xạ tới 400 Bad Request."
  },
  {
    "question_id": "EQ3034-VN",
    "question": "Viết một test case chuỗi các endpoint tải lên file, quét virus và tải xuống.",
    "answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm vòng đời của các thao tác với file."
  },
  {
    "question_id": "EQ3035-VN",
    "question": "Kịch bản nào xác thực ánh xạ lỗi đa bước (multi-hop) chính xác trong quy trình thanh toán?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 402",
      "B": "API thanh toán trả về APPROVED → được ánh xạ tới HTTP 404",
      "C": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 201",
      "D": "API thanh toán trả về ERROR → được ánh xạ tới HTTP 200"
    },
    "explanation": "Thanh toán bị từ chối ánh xạ chính xác tới 402 Payment Required."
  },
  {
    "question_id": "EQ3036-VN",
    "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn việc sử dụng lại refresh token.",
    "answer": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Ngăn chặn các cuộc tấn công replay refresh token."
  },
  {
    "question_id": "EQ3037-VN",
    "question": "Ánh xạ nào là chính xác để ánh xạ RATE_LIMIT_EXCEEDED sang HTTP?",
    "answer": "D",
    "category": "Security Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "403 Forbidden",
      "D": "429 Too Many Requests"
    },
    "explanation": "Vượt quá giới hạn tốc độ nên ánh xạ tới 429."
  },
  {
    "question_id": "EQ3038-VN",
    "question": "Viết một test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán.",
    "answer": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Xác thực quy trình làm việc đa endpoint của thương mại điện tử."
  },
  {
    "question_id": "EQ3039-VN",
    "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi trong quy trình đặt vé?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Đặt vé hợp lệ → 200 OK",
      "B": "Đặt vé → hủy vé → thử hoàn tiền → mong đợi 400 Bad Request",
      "C": "Xem các ghế có sẵn → 200 OK",
      "D": "Kiểm tra GET /status → 200 OK"
    },
    "explanation": "Tiêu cực chuỗi: hoàn tiền sau khi hủy là không hợp lệ."
  },
  {
    "question_id": "EQ3040-VN",
    "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn tấn công chiếm đoạt session API.",
    "answer": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
    "category": "Security Testing",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Ngăn chặn lạm dụng token chéo người dùng."
  },
  {
    "question_id": "EQ3041-VN",
    "question": "Chuỗi nào xác thực chính xác việc xoay vòng token với phát hiện việc sử dụng lại refresh token?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Đăng nhập → gọi API một lần → đăng xuất",
      "B": "Đăng nhập → làm mới token → thử sử dụng lại refresh token cũ → mong đợi 401 Unauthorized",
      "C": "Chỉ đăng nhập",
      "D": "Làm mới mà không đăng nhập"
    },
    "explanation": "Việc sử dụng lại token phải bị từ chối sau khi xoay vòng để ngăn chặn các cuộc tấn công replay."
  },
  {
    "question_id": "EQ3042-VN",
    "question": "Cung cấp chính xác một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc.",
    "answer": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Đảm bảo kiểm soát đồng thời với xác thực ETag."
  },
  {
    "question_id": "EQ3043-VN",
    "question": "Mã trạng thái HTTP nào nên được trả về khi một điều kiện tiên quyết If-Match thất bại do ETag cũ trong quá trình PUT /resource/{id}?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "400 Bad Request",
      "C": "412 Precondition Failed",
      "D": "404 Not Found"
    },
    "explanation": "ETag cũ nên ánh xạ tới 412 Precondition Failed."
  },
  {
    "question_id": "EQ3044-VN",
    "question": "Thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ: POST /exports -> thăm dò GET /jobs/{id} cho đến khi hoàn thành -> GET /exports/{id}.",
    "answer": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm vòng đời công việc không đồng bộ với thăm dò."
  },
  {
    "question_id": "EQ3045-VN",
    "question": "Ánh xạ nào từ mã nghiệp vụ tới HTTP là phù hợp nhất cho RESOURCE_VERSION_CONFLICT trong quá trình cập nhật?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "404 Not Found",
      "D": "409 Conflict"
    },
    "explanation": "Xung đột phiên bản ánh xạ chính xác tới 409 Conflict."
  },
  {
    "question_id": "EQ3046-VN",
    "question": "Cung cấp một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code: /authorize -> /token -> gọi tài nguyên với scope bị thiếu.",
    "answer": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Kiểm tra kiểm soát truy cập dựa trên scope."
  },
  {
    "question_id": "EQ3047-VN",
    "question": "Mã trạng thái nào thể hiện rõ nhất một refresh token được trình bày cho một client_id sai trong một hệ thống đa người thuê (multi-tenant)?",
    "answer": "B",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "400 Bad Request",
      "C": "401 Unauthorized",
      "D": "409 Conflict"
    },
    "explanation": "OAuth2 chỉ định invalid_grant (400) cho việc sử dụng client/refresh sai."
  },
  {
    "question_id": "EQ3048-VN",
    "question": "Viết một bài kiểm tra chuỗi bao gồm việc tạo charge幂等 (idempotent charge creation) với Idempotency-Key trên các endpoint thử lại và hoàn tiền.",
    "answer": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Xác thực tính幂等 trên các lần thử lại và quy trình hoàn tiền."
  },
  {
    "question_id": "EQ3049-VN",
    "question": "Ánh xạ trạng thái nào là chính xác cho mã nghiệp vụ INSUFFICIENT_FUNDS từ cổng thanh toán?",
    "answer": "D",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "404 Not Found",
      "C": "403 Forbidden",
      "D": "402 Payment Required"
    },
    "explanation": "Không đủ tiền → 402 Payment Required."
  },
  {
    "question_id": "EQ3050-VN",
    "question": "Cung cấp một bài kiểm tra chuỗi cho quy trình xử lý file: tải lên -> POST /process -> thăm dò trạng thái -> tải xuống, bao gồm cả việc xử lý 202.",
    "answer": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm vòng đời file không đồng bộ bao gồm xử lý 202 Accepted."
  },
  {
    "question_id": "EQ3051-VN",
    "question": "Kịch bản nào xác thực chính xác chính sách backoff + thử lại trên các chuyển đổi 429 -> 200 của gateway?",
    "answer": "A",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "API trả về 429 Too Many Requests → client thử lại với backoff → 200 OK",
      "B": "API trả về 401 Unauthorized → thử lại thành công",
      "C": "API trả về 404 Not Found → thử lại thành công",
      "D": "API trả về 500 → thử lại mà không có backoff"
    },
    "explanation": "Thử lại với backoff lũy thừa là cần thiết để xử lý 429."
  },
  {
    "question_id": "EQ3052-VN",
    "question": "Cung cấp một bài kiểm tra chuỗi để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice.",
    "answer": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Đảm bảo việc hủy bỏ session được truyền đi chính xác."
  },
  {
    "question_id": "EQ3053-VN",
    "question": "Mã HTTP nào nên ánh xạ tới BUSINESS_LIMIT_EXCEEDED khi hạn ngạch (quota) trên mỗi người dùng chặn một yêu cầu hợp lệ, đã xác thực?",
    "answer": "D",
    "category": "Security Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "400 Bad Request",
      "C": "403 Forbidden",
      "D": "429 Too Many Requests"
    },
    "explanation": "Hạn ngạch cạn kiệt ánh xạ tới 429 Too Many Requests."
  },
  {
    "question_id": "EQ3054-VN",
    "question": "Viết một test case chuỗi cho việc thực hiện đơn hàng một phần: tạo đơn hàng -> dự trữ hàng tồn kho -> ship một phần -> hủy phần còn lại và hoàn tiền chênh lệch.",
    "answer": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Kiểm tra vòng đời thực hiện một phần với hoàn tiền."
  },
  {
    "question_id": "EQ3055-VN",
    "question": "Ánh xạ nào là chính xác nhất cho mã lỗi SIGNATURE_INVALID trên xác minh giao hàng webhook?",
    "answer": "C",
    "category": "Security Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "404 Not Found",
      "C": "401 Unauthorized",
      "D": "409 Conflict"
    },
    "explanation": "Chữ ký webhook không hợp lệ nên trả về 401 Unauthorized."
  },
  {
    "question_id": "EQ3056-VN",
    "question": "Cung cấp chính xác một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA: POST /login -> POST /2fa/verify với mã sai -> POST /refresh.",
    "answer": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
    "category": "Authentication & Authorization",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Kiểm tra lỗi 2FA chuỗi ngăn cản việc refresh."
  },
  {
    "question_id": "EQ3057-VN",
    "question": "Mã HTTP nào thể hiện rõ nhất một tài nguyên đã bị xóa mềm (soft-deleted) được yêu cầu bởi GET /resource/{id} sau DELETE (với trạng thái có thể khôi phục)?",
    "answer": "B",
    "category": "Contract & Schema Validation",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "404 Not Found",
      "C": "403 Forbidden",
      "D": "204 No Content"
    },
    "explanation": "Tài nguyên đã bị xóa mềm nên được coi là không tìm thấy."
  },
  {
    "question_id": "EQ3058-VN",
    "question": "Thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê (với các xác nhận tổng số đếm).",
    "answer": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
    "category": "Test Case",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Xác thực tính nhất quán của dữ liệu trên phân trang."
  },
  {
    "question_id": "EQ3059-VN",
    "question": "Ánh xạ nào là chính xác khi sự cố phụ thuộc kích hoạt mạch ngắt (circuit breaker) MỞ, khiến gateway từ chối yêu cầu ngay lập tức?",
    "answer": "C",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "503 Service Unavailable",
      "D": "400 Bad Request"
    },
    "explanation": "Mạch ngắt MỞ ánh xạ tới 503 Service Unavailable."
  },
  {
    "question_id": "EQ3060-VN",
    "question": "Viết một bài kiểm tra chuỗi cho tính dính session (session stickiness): đăng nhập -> các cuộc gọi tiếp theo qua load balancer -> đăng xuất -> xác minh không có node nào chấp nhận token cũ.",
    "answer": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Hard",
    "question_type": "Writing",
    "explanation": "Xác thực tính dính session và việc truyền đi đúng cách của đăng xuất."
  },
  {
    "question_id": "EQ4001-VN",
    "question": "Luồng **chained** nào xác thực chính xác vòng đời đơn hàng với tạo → ghi nhận → hoàn tiền, đảm bảo **idempotency** trên các lần **retry**?",
    "answer": "C",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Tạo đơn hàng → **retry** hoàn tiền hai lần → hoàn tiền thất bại",
      "B": "Ghi nhận thanh toán mà không tạo đơn hàng",
      "C": "Tạo đơn hàng → ghi nhận thanh toán → **retry** ghi nhận với cùng **idempotency key** → một lần ghi nhận duy nhất → hoàn tiền thành công",
      "D": "Hoàn tiền trước khi tạo đơn hàng"
    },
    "explanation": "**Idempotency** phải đảm bảo các lần ghi nhận trùng lặp không tạo ra nhiều lần ghi nhận."
  },
  {
    "question_id": "EQ4002-VN",
    "question": "Viết một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản: tạo → kích hoạt → tạm ngừng → kích hoạt lại → xóa.",
    "answer": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm toàn bộ quá trình chuyển trạng thái vòng đời của một tài nguyên tài khoản."
  },
  {
    "question_id": "EQ4003-VN",
    "question": "Ánh xạ nào là đúng để xử lý một giao dịch trùng lặp được phát hiện trong quá trình yêu cầu hoàn tiền?",
    "answer": "B",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "409 Conflict",
      "C": "403 Forbidden",
      "D": "500 Internal Server Error"
    },
    "explanation": "Giao dịch trùng lặp phải ánh xạ tới **409 Conflict**."
  },
  {
    "question_id": "EQ4004-VN",
    "question": "Thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại.",
    "answer": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Đảm bảo tính nguyên tử của các giao dịch tài chính."
  },
  {
    "question_id": "EQ4005-VN",
    "question": "Kịch bản **chained** nào xác thực đúng việc truyền lỗi trong một giao dịch **distributed saga**?",
    "answer": "D",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Bắt đầu saga → tất cả các bước thành công",
      "B": "Bắt đầu saga → bỏ qua lỗi ở bước 2",
      "C": "Bắt đầu saga → **rollback** bị bỏ qua",
      "D": "Bắt đầu saga → bước 3 thất bại → **rollback** bù trừ của các bước 1 & 2 được thực thi"
    },
    "explanation": "Mô hình **saga** đảm bảo các hành động bù trừ khi thất bại."
  },
  {
    "question_id": "EQ4006-VN",
    "question": "Viết một **test** xác thực chuỗi nhiều dịch vụ: đăng nhập → tạo đơn hàng → xử lý thanh toán → hủy đơn hàng sau khi ghi nhận.",
    "answer": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Kiểm tra vòng đời đơn hàng trên các dịch vụ với việc hủy sau khi ghi nhận."
  },
  {
    "question_id": "EQ4007-VN",
    "question": "Kịch bản xử lý lỗi nào tốt nhất để xác thực các kiểm tra hợp lý trong **payment APIs**?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Gửi hoàn tiền > số tiền đã ghi nhận → **400 Bad Request**",
      "B": "Gửi hoàn tiền = số tiền đã ghi nhận → **200 OK**",
      "C": "Gửi hoàn tiền < số tiền đã ghi nhận → **200 OK**",
      "D": "Hoàn tiền mà không ghi nhận → **200 OK**"
    },
    "explanation": "Số tiền hoàn tiền lớn hơn số tiền đã ghi nhận phải thất bại với **400**."
  },
  {
    "question_id": "EQ4008-VN",
    "question": "Mô tả một **test state-machine** xác thực vòng đời mật khẩu: đặt → hết hạn → đặt lại → ngăn tái sử dụng.",
    "answer": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
    "category": "Security Testing",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Đảm bảo lịch sử mật khẩu và các quy tắc hết hạn được thực thi."
  },
  {
    "question_id": "EQ4009-VN",
    "question": "Ánh xạ nào tốt nhất để xác thực xử lý lỗi định dạng cho các tải trọng **JSON** bị định dạng sai?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "201 Created",
      "B": "500 Internal Server Error",
      "C": "400 Bad Request",
      "D": "200 OK"
    },
    "explanation": "**JSON** bị định dạng sai phải dẫn đến **400 Bad Request**."
  },
  {
    "question_id": "EQ4010-VN",
    "question": "Viết một **test chained** phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng.",
    "answer": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm nhánh thất bại trong kiểm tra tín dụng ngăn chặn phê duyệt."
  },
  {
    "question_id": "EQ4011-VN",
    "question": "Luồng **chained** nào xác thực trạng thái nhất quán trong quy trình đặt phòng phân tán?",
    "answer": "B",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Chỉ đặt khách sạn",
      "B": "Đặt khách sạn → đặt chuyến bay → chuyến bay thất bại → đặt phòng khách sạn tự động bị hủy",
      "C": "Chỉ đặt chuyến bay",
      "D": "Đặt khách sạn và giữ đặt phòng ngay cả khi thanh toán thất bại"
    },
    "explanation": "Việc tự động hủy khách sạn đảm bảo trạng thái nhất quán trên các hệ thống."
  },
  {
    "question_id": "EQ4012-VN",
    "question": "Viết một **test** xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra: cập nhật hồ sơ người dùng với các giá trị xung đột.",
    "answer": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Xác thực khóa lạc quan để kiểm soát đồng thời."
  },
  {
    "question_id": "EQ4013-VN",
    "question": "**HTTP code** nào là đúng để xác thực kiểm tra hợp lý khi rút tiền > số dư tài khoản?",
    "answer": "D",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "403 Forbidden",
      "D": "400 Bad Request"
    },
    "explanation": "Rút tiền quá số dư phải bị từ chối với **400 Bad Request**."
  },
  {
    "question_id": "EQ4014-VN",
    "question": "Viết một **test chained** rất khó xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo.",
    "answer": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
    "category": "Security Testing",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Xác thực việc ký điện tử chống giả mạo."
  },
  {
    "question_id": "EQ4015-VN",
    "question": "Kịch bản nào xác thực **rollback** trạng thái khi một API cập nhật thông tin người dùng một phần và giao dịch **DB** thất bại?",
    "answer": "A",
    "category": "Error Handling & Negative Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Cập nhật thất bại giữa chừng → không có thay đổi một phần nào tồn tại",
      "B": "Cập nhật thất bại giữa chừng → thay đổi một phần vẫn còn",
      "C": "Cập nhật thất bại giữa chừng → hệ thống bị lỗi",
      "D": "Cập nhật thành công mặc dù **DB rollback**"
    },
    "explanation": "**Rollback** thích hợp ngăn ngừa dữ liệu một phần/không nhất quán."
  },
  {
    "question_id": "EQ4016-VN",
    "question": "Kịch bản **chained** nào tốt nhất để xác thực **idempotency** của một **endpoint** ghi nhận thanh toán?",
    "answer": "B",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "POST /capture hai lần với các giá trị **Idempotency-Key** khác nhau → hai lần ghi nhận",
      "B": "POST /capture hai lần với cùng một **Idempotency-Key** → một lần ghi nhận duy nhất được ghi lại",
      "C": "POST /refund mà không ghi nhận → thành công",
      "D": "GET /capture-status một lần"
    },
    "explanation": "**Idempotency** đảm bảo các yêu cầu trùng lặp với cùng một khóa không tạo ra nhiều lần ghi nhận."
  },
  {
    "question_id": "EQ4017-VN",
    "question": "Viết một **test state-machine** xác thực vòng đời đăng ký: tạo → nâng cấp → hạ cấp → hủy.",
    "answer": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Bao gồm tất cả các trạng thái chính trong vòng đời đăng ký."
  },
  {
    "question_id": "EQ4018-VN",
    "question": "Ánh xạ nào là đúng để xử lý mã lỗi ứng dụng **LIMIT_EXCEEDED** cho hạn ngạch API mỗi tài khoản?",
    "answer": "D",
    "category": "Security Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "400 Bad Request",
      "C": "403 Forbidden",
      "D": "429 Too Many Requests"
    },
    "explanation": "Vượt quá giới hạn/hạn ngạch ánh xạ tới **429 Too Many Requests**."
  },
  {
    "question_id": "EQ4019-VN",
    "question": "Viết một **test chained** rất khó xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga**.",
    "answer": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Kiểm tra **rollback** phân tán trong mô hình **saga**."
  },
  {
    "question_id": "EQ4020-VN",
    "question": "Luồng **chained** nào xác thực việc phát hiện lạm dụng **OAuth2 token** trên các dịch vụ?",
    "answer": "C",
    "category": "Authentication & Authorization",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Đăng nhập một lần",
      "B": "Làm mới **token** ngay lập tức",
      "C": "Đăng nhập → lấy **token** → cố gắng sử dụng **token** trong một máy khách khác → **403 Forbidden**",
      "D": "Chỉ đăng xuất"
    },
    "explanation": "Việc lạm dụng **token** chéo máy khách phải bị cấm."
  },
  {
    "question_id": "EQ4021-VN",
    "question": "Viết một **test** rất khó xác minh việc đảo ngược giao dịch tài chính: ghi nợ → ghi có → **rollback**.",
    "answer": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Xác thực tính nguyên tử trong các giao dịch tài chính."
  },
  {
    "question_id": "EQ4022-VN",
    "question": "Kịch bản nào tốt nhất để xác thực xử lý lỗi định dạng cho sự không khớp đầu vào **XML vs JSON**?",
    "answer": "A",
    "category": "Contract & Schema Validation",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Gửi thân **XML** với **Content-Type: application/json** → **415 Unsupported Media Type**",
      "B": "Gửi thân **JSON** với **application/json** → **200 OK**",
      "C": "Gửi thân **XML** với **application/xml** → **200 OK**",
      "D": "Gửi **YAML** → **200 OK**"
    },
    "explanation": "Sự không khớp trong thân so với **header** phải dẫn đến **415**."
  },
  {
    "question_id": "EQ4023-VN",
    "question": "Thiết kế một **test state-machine** cho kho hàng: thêm hàng → phân bổ → vận chuyển → trả lại → đối chiếu.",
    "answer": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Đảm bảo tính nhất quán của hàng tồn kho trong suốt các sự kiện vòng đời."
  },
  {
    "question_id": "EQ4024-VN",
    "question": "**HTTP status** nào là đúng khi xảy ra lỗi xác thực **schema** cho một trường lồng nhau?",
    "answer": "C",
    "category": "Contract & Schema Validation",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "201 Created",
      "B": "500 Internal Server Error",
      "C": "400 Bad Request",
      "D": "404 Not Found"
    },
    "explanation": "Lỗi xác thực **schema** phải trả về **400**."
  },
  {
    "question_id": "EQ4025-VN",
    "question": "Viết một **test chained** xác thực vòng đời **session mobile**: đăng nhập → làm mới **token** → đăng xuất → làm mới với **token** cũ → thất bại.",
    "answer": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
    "category": "Authentication & Authorization",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Kiểm tra làm mới không hợp lệ sau khi đăng xuất."
  },
  {
    "question_id": "EQ4026-VN",
    "question": "Kịch bản **chained** nào xác thực **rollback** thích hợp sau khi đặt phòng nhiều bước (chuyến bay + khách sạn) khi thanh toán thất bại?",
    "answer": "D",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Đặt chuyến bay → **200 OK**",
      "B": "Đặt khách sạn → **200 OK**",
      "C": "Đặt chuyến bay + khách sạn → thanh toán thành công",
      "D": "Đặt chuyến bay + khách sạn → thanh toán thất bại → **rollback** cả hai đặt phòng"
    },
    "explanation": "**Rollback** đảm bảo không còn đặt phòng không nhất quán."
  },
  {
    "question_id": "EQ4027-VN",
    "question": "Viết một **test chained** xác thực API gửi email: gửi → theo dõi mở → hủy đăng ký → đảm bảo không gửi thêm email nào nữa.",
    "answer": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Xác thực các chuyển đổi trạng thái trong hệ thống gửi email."
  },
  {
    "question_id": "EQ4028-VN",
    "question": "Ánh xạ nào là đúng cho mã ứng dụng **TOKEN_REPLAY_DETECTED**?",
    "answer": "C",
    "category": "Security Testing",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "200 OK",
      "B": "201 Created",
      "C": "401 Unauthorized",
      "D": "409 Conflict"
    },
    "explanation": "Tái sử dụng **token** phải được xử lý như **401 Unauthorized**."
  },
  {
    "question_id": "EQ4029-VN",
    "question": "Viết một **test chained** rất khó cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại: áp dụng phiếu giảm giá → thanh toán → phiếu giảm giá không hợp lệ → **rollback**.",
    "answer": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
    "category": "Test Case",
    "difficulty": "Very Hard",
    "question_type": "Writing",
    "explanation": "Đảm bảo phiếu giảm giá thất bại ngăn chặn việc thanh toán không hợp lệ."
  },
  {
    "question_id": "EQ4030-VN",
    "question": "Luồng **chained** nào xác thực việc thanh toán không đồng bộ với đối chiếu?",
    "answer": "B",
    "category": "Advanced Testing Strategies",
    "difficulty": "Very Hard",
    "question_type": "MCQ",
    "options": {
      "A": "Chỉ tạo đơn hàng",
      "B": "Tạo đơn hàng → ghi nhận thanh toán → đối chiếu không đồng bộ → trạng thái cuối cùng=đã đối chiếu",
      "C": "Hoàn tiền mà không đối chiếu",
      "D": "Kiểm tra tình trạng API"
    },
    "explanation": "Thanh toán không đồng bộ phải đối chiếu chính xác."
  }
]
