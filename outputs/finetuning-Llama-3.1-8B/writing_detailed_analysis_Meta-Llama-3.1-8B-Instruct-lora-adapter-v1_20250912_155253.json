{
  "metadata": {
    "timestamp": "20250912_155253",
    "model": "Meta-Llama-3.1-8B-Instruct-lora-adapter-v1",
    "total_writing_questions": 242
  },
  "category_distribution": {
    "Test Case": 84,
    "Test Step": 12,
    "Error Handling & Negative Testing": 28,
    "Contract & Schema Validation": 22,
    "Mocking & Service Virtualization": 8,
    "Performance & Load Testing": 2,
    "General Testing": 16,
    "Environment & Test Data Management": 6,
    "Authentication & Authorization": 22,
    "Security Testing": 14,
    "Observability & Monitoring": 4,
    "Advanced Testing Strategies": 24
  },
  "difficulty_distribution": {
    "Easy": 94,
    "Intermediate": 60,
    "Hard": 60,
    "Very Hard": 28
  },
  "detailed_results": [
    {
      "question_id": "EQ5004",
      "question": "Write one simple positive test case for a login API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user 'user@example.com' with password 'Password123' exists.\n- **Test Steps:** Send a `POST` request to `/login` with the correct email and password in the body.\n- **Expected Result:** The API returns a `200 OK` status code with a valid authentication token in the response."
    },
    {
      "question_id": "EQ5006",
      "question": "What is a common precondition for testing a user profile endpoint?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "User must be logged in and have a valid token.",
      "model_answer": "A common precondition is that a user account must exist with a valid profile. This means the API should have a user registration or profile creation endpoint that has been successfully used to generate a user ID or token."
    },
    {
      "question_id": "EQ5008",
      "question": "Write a simple negative test for a register API.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Test case: Send a registration request with an email that already exists. Expected result: the API returns a `409 Conflict` status code with an appropriate error message."
    },
    {
      "question_id": "EQ5010",
      "question": "What is the role of a schema in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure and data types expected for API requests and responses. It acts as a contract between the client and server, allowing testers to validate correctness and detect schema violations."
    },
    {
      "question_id": "EQ5012",
      "question": "Write a simple test step for validating a 201 Created response.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "**Test Step:** Send a `POST /users` request with a valid user payload. **Expected Result:** The API should return a `201 Created` status code. **Additional Verification:** The response body should contain the newly created user's ID or a location header with the user's URL."
    },
    {
      "question_id": "EQ5014",
      "question": "What is the purpose of mocking in API testing?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependencies with simulated ones. In API testing, it allows testers to isolate the API under test and simulate the behavior of its downstream services (e.g., databases, other microservices) without needing those services to be running. This makes testing faster, more reliable, and easier to set up."
    },
    {
      "question_id": "EQ5016",
      "question": "Write one easy test case for an API that fetches product list.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "Test Case: 'Fetch Products' Positive. **Preconditions:** API is running. **Steps:** Send GET request to `/products`. **Expected:** Status Code = 200 OK, Response contains at least 3 products."
    },
    {
      "question_id": "EQ5018",
      "question": "What is the purpose of a precondition in a test case?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "The purpose of a precondition is to ensure that the test environment and system state are stable and consistent before the test execution begins. It defines the required state or setup (e.g., user login, data existence, system configuration) that must be in place for the test to be valid."
    },
    {
      "question_id": "EQ5020",
      "question": "Write one negative test for file upload with an unsupported format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Test case: Upload a.txt file. Expected: API rejects the file with a `415 Unsupported Media Type` or `400 Bad Request` error."
    },
    {
      "question_id": "EQ5022",
      "question": "What is the purpose of a test case description?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "To explain the objective and scope of a test scenario.",
      "model_answer": "The purpose of a test case description is to provide a clear and concise summary of what the test case aims to verify, including its functionality and expected outcome."
    },
    {
      "question_id": "EQ5024",
      "question": "Write a test step to validate response time under 1 second.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "Test Step: Send `GET /health` request 10 times. Verify average response time < 1s."
    },
    {
      "question_id": "EQ5027",
      "question": "Write one simple positive test for GET /health endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "### **Test Case: Health Endpoint**\n- **Test Case Name:** Verify Health Endpoint Returns 200 OK.\n- **Preconditions:** API deployed and running.\n- **Test Steps:** Send a `GET` request to `/health`.\n- **Expected Result:**\n  - The API returns a `200 OK` status code.\n  - The response body should contain a simple success message like `\"healthy\"` or a specific health check status."
    },
    {
      "question_id": "EQ5029",
      "question": "What is the purpose of using test data management in API testing?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management ensures that unique, clean, and consistent data is available for each test case. It prevents data collisions and makes test results reliable."
    },
    {
      "question_id": "EQ5031",
      "question": "Write one easy negative test case for an API expecting JSON format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "### **Negative Test Case: Invalid JSON Format**\n-   *Test Case Name:* Verify API rejects malformed JSON.\n-   *Test Steps:* Send a `POST` request to `/products` with a raw string instead of JSON (`{\"price\": 9.99}`). \n-   *Expected Result:* The API should return a `400 Bad Request` status code with a clear error message indicating that the request body is invalid."
    },
    {
      "question_id": "EQ5033",
      "question": "What is the role of assertions in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions are the foundation of API testing. They define the expected behavior by verifying that actual values (e.g., status codes, response bodies, headers) match the expected ones. Without strong assertions, tests are meaningless."
    },
    {
      "question_id": "EQ5035",
      "question": "Write a test case to check DELETE /users/{id} works correctly.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "### **Test Case: Delete User**\n- **Preconditions:** User ID=123 exists, ID=999 does not.\n- **Steps:**\n  - Request `/users/123` → expect `204 No Content`.\n  - Request `/users/999` → expect `404 Not Found`.\n- **Expected:** User ID=123 is deleted from DB."
    },
    {
      "question_id": "EQ5037",
      "question": "What does HTTP status 201 Created indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "A new resource has been successfully created.",
      "model_answer": "It indicates that the request was successful and a new resource has been created as a result."
    },
    {
      "question_id": "EQ5039",
      "question": "Write one simple test for GET /users/{id} returning correct response.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test case: **Get User by ID**\n- **Action:** Send request to `/users/123`.\n- **Expected:** Status `200 OK`, response body contains user data with ID `123`."
    },
    {
      "question_id": "EQ5041",
      "question": "What is the purpose of a 200 OK response?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It confirms that the request has succeeded.",
      "model_answer": "A 200 OK response indicates that the request was successful and the data was returned as expected."
    },
    {
      "question_id": "EQ5043",
      "question": "Write one negative test to validate response for an invalid endpoint.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "### **Test Case: Invalid Endpoint**\n-   **Test Case Name:** Verify `GET /invalid-path` returns a `404 Not Found` status code.\n-   **Preconditions:** The API is running.\n-   **Test Steps:**\n    - Send a `GET` request to the URL `/invalid-path`.\n-   **Expected Result:**\n    - The API should respond with a `404 Not Found` status code.\n    - The response body should contain an error message indicating the resource was not found."
    },
    {
      "question_id": "EQ5045",
      "question": "What does a test case assertion do?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion defines the condition that must be true for a test to pass. It compares the actual outcome with the expected outcome. For example, 'assert user.role == \"admin\"' ensures the user's role is correct."
    },
    {
      "question_id": "EQ5047",
      "question": "Write one positive test for file upload endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "**Test Case: Upload Valid File**\n- **Preconditions:** File `image.jpg` exists on local machine.\n- **Action:** Send `POST` request to `/upload` with file attached.\n- **Expected:** `201 Created` with file stored on server."
    },
    {
      "question_id": "EQ5049",
      "question": "What is the role of 415 Unsupported Media Type?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "The `415 Unsupported Media Type` status code is used to indicate that the server does not support the media type (e.g., `application/json`) sent in the request's `Content-Type` header. This error typically occurs when a client requests a resource using a format that the server cannot process."
    },
    {
      "question_id": "EQ5052",
      "question": "Write a simple positive test for checking product details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "**Test Case: Get Product Details**\n- **Test Case Name:** Verify product details are returned successfully.\n- **Preconditions:** Product ID=123 exists in DB.\n- **Test Steps:**\n  1. Send GET request to `/products/123`.\n- **Expected Result:**\n  - Status Code: `200 OK`.\n  - Response Body contains product name, price, and description."
    },
    {
      "question_id": "EQ5054",
      "question": "What is the purpose of using Authorization headers in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The purpose is to simulate user permissions and restrict access to protected resources. By including valid tokens like OAuth2 or API Keys in the `Authorization` header, testers can validate that only allowed actions are performed."
    },
    {
      "question_id": "EQ5056",
      "question": "Write a negative test case for an API requiring authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Unauthorized Access**\n- **Preconditions:** No valid token.\n- **Action:** Send `GET /protected` request.\n- **Expected:** `401 Unauthorized` or `403 Forbidden` response."
    },
    {
      "question_id": "EQ5058",
      "question": "What is the role of 500 Internal Server Error in API testing?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "The 500 Internal Server Error is used to indicate a generic, unexpected failure on the server. It should be tested as part of negative scenarios to ensure the API handles unexpected conditions gracefully."
    },
    {
      "question_id": "EQ5060",
      "question": "Write one positive test case for an API returning list of orders.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "### **Test Case: Retrieve All Orders**\n-   **Preconditions:** The API is running with a known dataset of orders.\n-   **Action:** Send a `GET` request to the `/orders` endpoint.\n-   **Expected:** The API returns a `200 OK` status code with a JSON response that is an array of order objects. The array should contain at least two orders (e.g., `id: 1`, `id: 2`), with each order having its respective fields (e.g., `customerName`, `total`, `orderDate`)."
    },
    {
      "question_id": "EQ5062",
      "question": "What is the function of response headers in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "Response headers provide metadata about the API response. In testing, they are used to verify security measures (e.g., `Content-Security-Policy`), caching behavior, or authentication tokens."
    },
    {
      "question_id": "EQ5064",
      "question": "Write one negative test for creating a duplicate resource.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Test Case: **Create Duplicate User**\n- **Action:** Send `POST /users` with an existing email (`user@example.com`).\n- **Expected:** `409 Conflict` with a message like \"User already exists.\""
    },
    {
      "question_id": "EQ5066",
      "question": "What is the role of 202 Accepted in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "A `202 Accepted` status code indicates that the request has been received for processing, but it has not been completed yet. It is commonly used for asynchronous operations where the API will continue to process the request in the background."
    },
    {
      "question_id": "EQ5068",
      "question": "Write one easy positive test for checking API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "**Test Case: Verify API Response Schema**\n- **Test Case ID:** TC-007\n- **Preconditions:** API service is running.\n- **Test Steps:** Send a valid `GET /products` request.\n- **Expected Result:**\n  - **Status Code:** `200 OK`.\n  - **Response Body:** Verify that the schema conforms to the predefined JSON schema (e.g., all keys present, data types correct)."
    },
    {
      "question_id": "EQ5070",
      "question": "What is the purpose of response body in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body is the main part of an API's response, containing the data requested by the client. Its purpose is to provide the payload of the HTTP request, which the client can parse to understand the outcome of its request."
    },
    {
      "question_id": "EQ5072",
      "question": "Write one test case for verifying logout functionality.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Logout Verification**\n- **Preconditions:** User authenticated.\n- **Steps:**\n  - Send logout request → expect `200 OK`.\n  - Verify session cookie no longer valid.\n- **Expected:** User cannot access protected routes after logout."
    },
    {
      "question_id": "EQ5074",
      "question": "What does a 415 Unsupported Media Type error validate?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "That the server rejects unsupported request body formats.",
      "model_answer": "A 415 error validates that the API correctly handles an unsupported request format (e.g., sending JSON in a `Content-Type` header set to `application/xml`)."
    },
    {
      "question_id": "EQ5077",
      "question": "Write one simple positive test for GET /status endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "### **Test Case: Verify Status Endpoint**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Confirm /status API returns 200 OK with 'Healthy' message.\n- **Test Case Description:** Send a GET request to the /status endpoint and verify the HTTP status code and response body.\n- **Preconditions:** The API service must be running.\n- **Test Steps:**\n  1. Send a `GET` request to the URL `/status`.\n- **Expected Result:**\n  - The API returns a `200 OK` status code.\n  - The response body contains the text `'Healthy'`."
    },
    {
      "question_id": "EQ5079",
      "question": "What does a 204 No Content response mean?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content response indicates that the request was successful, but there is no content to return in the body of the response. It is often used for DELETE requests to confirm deletion."
    },
    {
      "question_id": "EQ5081",
      "question": "Write a negative test case for sending an invalid Content-Type header.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "### **Test Case: Invalid Content-Type**\n-   **Test Case Name:** Verify API rejects invalid Content-Type.\n-   **Preconditions:** API is running.\n-   **Test Steps:**\n    1. Send a `POST` request to `/upload`.\n    2. In the request body, attach a file but set `Content-Type` to an unsupported value (e.g., `image/jpeg` for an XML payload).\n-   **Expected Result:**\n    - The API returns a `415 Unsupported Media Type` status code.\n    - The response body indicates that the format is not supported.\n    - The file is not processed or stored."
    },
    {
      "question_id": "EQ5083",
      "question": "What is the purpose of the Accept header in API requests?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header indicates to the server which content formats (e.g., application/json, application/xml) the client can understand, allowing the server to respond with the appropriate format."
    },
    {
      "question_id": "EQ5085",
      "question": "Write a simple test case for a successful logout API call.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Logout**\n- **Preconditions:** User authenticated.\n- **Action:** Send `POST /logout` request.\n- **Expected:** `200 OK`, session expired, subsequent requests return `401 Unauthorized`."
    },
    {
      "question_id": "EQ5087",
      "question": "What is the meaning of 401 Unauthorized in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "It means the client must provide valid authentication credentials.",
      "model_answer": "A 401 Unauthorized status code means that the client has not provided the correct authentication credentials (e.g., a valid token) or that the authentication has failed."
    },
    {
      "question_id": "EQ5089",
      "question": "Write one easy positive test case for checking profile details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test Case: Verify Profile Details. **Preconditions:** User ID = 1234 exists. **Action:** Send GET request to /profile/1234. **Expected:** Status = 200 OK, Profile data found in response."
    },
    {
      "question_id": "EQ5091",
      "question": "What is the purpose of 302 Found in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates temporary redirection to another URL.",
      "model_answer": "The purpose of a 302 Found status code is to indicate that the resource has temporarily moved to a different URL. It redirects the client to the new location. This is often used for migration or maintenance of endpoints."
    },
    {
      "question_id": "EQ5093",
      "question": "Write a test case for negative login attempt with wrong password.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "Test Case: Invalid Login. Preconditions: User exists. Steps: Send login request with correct email and wrong password. Expected: `400 Bad Request` or `401 Unauthorized`."
    },
    {
      "question_id": "EQ5095",
      "question": "What does 422 Unprocessable Entity indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "A 422 Unprocessable Entity status code indicates that the server understands the request but cannot process it due to a semantic error, such as a validation failure or inconsistent state."
    },
    {
      "question_id": "EQ5097",
      "question": "Write a positive test for POST /users endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "**Test Case: Create New User**\n- **Preconditions:** API available, DB initialized with valid role ID.\n- **Action:** Send `POST /users` with JSON payload `{ \"name\": \"John Doe\", \"email\": \"john@example.com\", \"password\": \"StrongPass123\" }`.\n- **Expected Result:** Response `201 Created` with user ID in header, user data exists in DB."
    },
    {
      "question_id": "EQ5099",
      "question": "What does the term 'happy path' mean in testing?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most straightforward and successful scenario for a feature or API. It includes all required steps and inputs, where everything works as intended, with no errors or failures."
    },
    {
      "question_id": "EQ2002",
      "question": "Explain how you would design a negative test case for an API endpoint that requires OAuth2 Bearer tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Design a negative test case by sending a request with an invalid or expired token. Expected: the API should return a `401 Unauthorized` or `403 Forbidden` status code, and the response body should indicate that the token is invalid."
    },
    {
      "question_id": "EQ2004",
      "question": "Provide one happy-path and one error-path test case for a payment refund API endpoint.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "*   **Happy Path (Positive):** Test `POST /refund` with valid transaction ID and amount. **Expected:** `201 Created` with refund details, DB updated.\n*   **Error Path (Negative):** Test `POST /refund` with an invalid transaction ID (e.g., 'TRX-99999'). **Expected:** `404 Not Found` with error message 'Transaction not found'."
    },
    {
      "question_id": "EQ2006",
      "question": "How would you validate schema changes in a backward-compatible API upgrade?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "Run contract tests with old and new schemas, assert no breaking changes, and monitor production logs for validation errors."
    },
    {
      "question_id": "EQ2008",
      "question": "Explain how mocking can be used to test a payment API without calling the real bank service.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "Mocking replaces the real bank service with a fake one. The test API sends a payment request to the mock, which responds with a predefined status (e.g., 'approved' or 'declined'). This allows testing payment logic without risking real transactions."
    },
    {
      "question_id": "EQ2010",
      "question": "Design one boundary test and one invalid test for an API field `age` (range 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "**Boundary Test (Positive):** Send a request with `age=18` (lower bound) and `age=65` (upper bound). Expected: Both `200 OK` with valid user data, as they fall within the defined range.\n  \n**Invalid Test:** Send a request with `age=0`. Expected: `400 Bad Request` with a validation error, as the age is below the minimum allowed."
    },
    {
      "question_id": "EQ2012",
      "question": "Explain how you would simulate a network timeout error in API testing.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "To simulate a network timeout, you would use a tool like `curl` or a programming language (e.g., Python with `requests`) to send an HTTP request to the API. You would then configure the request to wait longer than the API's expected timeout (e.g., `timeout=5s` when the API has a 3s timeout). The request will fail with a timeout error."
    },
    {
      "question_id": "EQ2014",
      "question": "Give one example of an API precondition and one step that follows it.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "*   **Precondition:** The API service must be running and accessible at its base URL (`http://api.example.com`).\n    *   **Action Following Precondition:** A user can send a `GET /products` request to retrieve a list of products."
    },
    {
      "question_id": "EQ2016",
      "question": "Write one test case to validate that API rate limiting is enforced correctly.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "**Test Case: Enforce Rate Limit**\n- **Preconditions:** Account configured with 100 requests/minute.\n- **Steps:**\n  1. Send first request → `200 OK`.\n  2. Send second request within 1 minute → `200 OK`.\n  3. Send third request within 1 minute → expect `429 Too Many Requests`.\n- **Expected:** Rate limit enforced exactly."
    },
    {
      "question_id": "EQ2018",
      "question": "Explain one advantage of using service virtualization in API testing.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "One advantage is that it allows testing of APIs before all dependent systems are available, thus reducing delays in testing."
    },
    {
      "question_id": "EQ2020",
      "question": "Describe how to design one positive and one boundary test case for a login API requiring username and password.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "*   **Positive Test Case:** Send valid credentials ('user@example.com'/ 'Password123') and expect a `200 OK` with an authentication token.\n    *   **Preconditions:** User account exists with known password.\n    *   **Test Steps:** Send POST request to login endpoint with correct credentials.\n    *   **Expected Result:** Token in response body, status `200 OK`.\n*   **Boundary Test Case (Negative):** Send password with maximum allowed length (e.g., 72 characters) or use 'Password123!@#'."
    },
    {
      "question_id": "EQ2022",
      "question": "Write one test step to validate that an API correctly returns 415 Unsupported Media Type.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Test Step: Send a `POST` request to `/upload` with a `Content-Type` header set to an unsupported format like `application/json`."
    },
    {
      "question_id": "EQ2024",
      "question": "Describe one way to test observability when an API experiences a slow database query.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Precondition: API connected to mock DB with slow response. Test Step: Send request to API. Expected: API returns 200, but response time > 3s. Verify logs capture slow query warning."
    },
    {
      "question_id": "EQ2026",
      "question": "Explain how you would test API idempotency for a retry scenario.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Test by sending the same `PUT /orders/{id}` request multiple times. Expected: 1st request → `200 OK` and DB updated. 2nd+ requests → `200 OK` but no further changes. Confirm DB state remains consistent after retries."
    },
    {
      "question_id": "EQ2028",
      "question": "Give one boundary and one invalid test for a file upload API accepting max 5 MB files.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "*   **Boundary Test:** Upload a 5 MB file (e.g., a zip archive) to verify it's successfully processed.\n    *   **Action:** Send a `POST` request with the file attached.\n    *   **Expected:** `200 OK` with the file stored, or the file ID in the response body.\n*   **Invalid Test:** Upload a file larger than 5 MB (e.g., a 10 MB video file).\n    *   **Action:** Send the same `POST` request but with a larger file.\n    *   **Expected:** The API should return a `400 Bad Request` or `413 Payload Too Large` error."
    },
    {
      "question_id": "EQ2030",
      "question": "Write a test case to validate proper error handling when an API is called with a missing required field `email`.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "### **Test Case: Missing Required Field 'email'**\n- **Test Case ID:** TC-007\n- **Test Case Name:** Verify API rejects request without required 'email' field.\n- **Preconditions:** The API is running.\n- **Test Steps:**\n  1. Send a `POST` request to the user registration endpoint with a JSON body that **does not include the 'email' field**.\n- **Expected Result:**\n  - The API returns a **`400 Bad Request` status code.**\n  - The response body contains an error message that specifically mentions the 'email' field is required."
    },
    {
      "question_id": "EQ2032",
      "question": "How would you design a test to validate retry logic when an API occasionally returns 503?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "Preconditions: API configured to retry failed requests. Steps: 1) Send request that triggers 503. 2) Verify initial request fails. 3) Verify subsequent retry attempts succeed. 4) Monitor retry count to ensure it doesn't exceed limits."
    },
    {
      "question_id": "EQ2034",
      "question": "Write a test case that validates log correlation using a trace ID header.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "### **Test Case: Log Correlation via Trace ID**\n- **Test Case ID:** TC-LOG-CORR-001\n- **Test Case Name:** Verify logs are correlated using a Trace ID header.\n- **Preconditions:**\n  - API configured to propagate Trace ID in headers.\n  - Distributed Tracing enabled.\n- **Test Steps:**\n  1. Send a request to an API (`/process-order`) that generates multiple logs.\n  2. Include a known Trace ID header (`X-Trace-ID: trace-id-123`) in the request.\n- **Expected Result:**\n  - All logs generated for the API request should contain the exact same Trace ID (`trace-id-123`) in their metadata."
    },
    {
      "question_id": "EQ2036",
      "question": "Design one intermediate-level test case for validating API rate limiting when multiple clients are involved.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "**Test Case: Multi-Client Rate Limit Enforcement**\n- **Preconditions:** Two API clients (Client A and Client B) with identical rate limits (100 requests/minute).\n- **Steps:**\n  - Client A sends 50 requests in first 30 seconds → expect `200 OK`.\n  - Immediately after, Client B sends 50 requests → expect all `200 OK`.\n  - If Client A exceeds limit, Client B should still receive `200 OK` for remaining allowed requests.\n  - After rate limit is exhausted, both clients should receive `429 Too Many Requests`.\n- **Expected Result:** Both clients must adhere to rate limit, and API must prevent abuse."
    },
    {
      "question_id": "EQ2038",
      "question": "Describe one positive and one negative test case for an API endpoint that sends SMS codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "**Positive:** Send a valid phone number (+1-202-555-0123) and verify a 200 OK response with an SMS code. **Negative:** Send a phone number with an invalid format (‘999-999-9999’) and verify a 400 Bad Request error."
    },
    {
      "question_id": "EQ2040",
      "question": "Explain one advantage of mocking external APIs when testing failure scenarios.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "One advantage is that it prevents real-world failures from impacting test stability or reliability. For example, instead of relying on a specific payment gateway to fail, a test can mock the gateway to respond with a known error code, allowing consistent and repeatable test cases."
    },
    {
      "question_id": "EQ2042",
      "question": "Write one test case to validate error handling when API returns malformed JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "**Test Case: Malformed JSON Response**\n- **Preconditions:** API endpoint `/products` is configured to return invalid JSON (e.g., missing quote, syntax error).\n- **Test Steps:**\n  1. Send a `GET` request to `/products`.\n- **Expected Result:**\n  - The API returns a successful status code (e.g., `200 OK`).\n  - The response body is parsed and verified to contain the error message.\n  - The response is not a valid JSON object."
    },
    {
      "question_id": "EQ2044",
      "question": "Design one test step to confirm rate limiting headers (e.g., X-RateLimit-Remaining) are present.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "**Test Step:** 1) Send a request to a rate-limited endpoint. 2) Verify the response body or headers contain a rate limit count (e.g., `X-RateLimit-Remaining`). 3) Repeat until the limit is exceeded, then confirm the count is 0."
    },
    {
      "question_id": "EQ2046",
      "question": "Describe one advantage of separating test data from test logic in API testing.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic improves reusability and reduces maintenance. With separate data, the same test script can be executed multiple times with different inputs, making it ideal for data-driven testing and ensuring the API handles various valid and invalid data scenarios correctly."
    },
    {
      "question_id": "EQ2048",
      "question": "Write a test case for validating graceful degradation when API cache is unavailable.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "### **Test Case: Cache Unavailability**\n- **Test Case ID:** TC-APIC-008\n- **Test Case Name:** Verify API response when cache service is down.\n- **Preconditions:**\n  - API is deployed.\n  - Cache service is mocked.\n  - API configured to use cache.\n- **Test Steps:**\n  1. Send request for a cached resource.\n  2. Verify API returns `503 Service Unavailable` or `500 Internal Server Error`.\n  3. Confirm database query is executed to return response.\n- **Expected Result:** API gracefully handles cache unavailability by falling back to DB."
    },
    {
      "question_id": "EQ2050",
      "question": "Explain one way to validate logging for sensitive fields such as passwords.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "Preconditions: API configured to log requests and responses. Test Case: Send a request with a known password. Verification: Check the log output, assert that the password field is masked or not logged at all."
    },
    {
      "question_id": "EQ2052",
      "question": "Provide one negative and one boundary test case for a currency field that must match ISO 4217 codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "**Negative:** Test with 'XXX' (invalid code). **Boundary:** Test with 'USD' (common edge) and 'EUR' (another common edge)."
    },
    {
      "question_id": "EQ2054",
      "question": "Write one test case to validate API behavior under network packet loss.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "**Test Case: Network Packet Loss**\n- **Preconditions:** Simulate 10% packet loss between client and server.\n- **Steps:** Send 3 requests: one complete, one with corrupted payload, one with missing header.\n- **Expected:** Server returns `500 Internal Server Error` for corrupted, `400 Bad Request` for missing header. Complete request succeeds."
    },
    {
      "question_id": "EQ2056",
      "question": "Describe one method to verify test data cleanup after API test execution.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "One method is to run a 'cleanup verification' test case immediately after the main test. This secondary test queries the database to confirm that all test-created data (e.g., users, orders) has been successfully deleted."
    },
    {
      "question_id": "EQ2058",
      "question": "Write a test case to verify proper rollback when a multi-step transaction partially fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "### **Test Case: Partial Transaction Rollback**\n- **Test Case ID:** TC-TRX-007\n- **Test Case Name:** Verify rollback when intermediate step fails in multi-step transaction.\n- **Preconditions:**\n  - API configured for transactions (e.g., SQL transactions, distributed locks).\n  - Initial data: `user_id=999` exists, `product_id=999` exists, `order_id=999` does not exist.\n- **Test Steps:**\n  1. **Transaction Initiation:** Send `POST /orders` request with `user_id=999` and `product_id=999`.\n  2. **Intermediate Failure:** After first step, before final step, manually delete `order_id=999` from DB (simulating failure).\n  3. **Final Attempt:** Send `PUT /orders/{order_id}` (e.g., to set status to'shipped') for the non-existent `order_id=999`.\n- **Expected Result:**\n  - The API responds with a `409 Conflict` or `500 Internal Server Error` for the final step, indicating rollback.\n  - Upon checking the DB, confirm that `order_id=999` was never created, and no partial order state (e.g., `user_id=999` with no products) exists."
    },
    {
      "question_id": "EQ2060",
      "question": "Explain one approach to validating error messages follow a consistent JSON schema across all endpoints.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "1. **Define a JSON Schema for Error Responses:** Establish a base schema (e.g., `{\"error\": string, \"code\": int, \"details\": array}`) that all endpoints must follow.\n2. **Automated Validation:** Use a tool like Postman or Insomnia to send invalid requests to all endpoints.\n3. **Validation Assertion:** For each endpoint, assert that the response body conforms to the defined error schema."
    },
    {
      "question_id": "EQ3002",
      "question": "Write a test case that validates login, token refresh, and accessing a protected API using the refreshed token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "**Test Case: Token Refresh**\n- **Preconditions:** User login generates a short-lived token (TTL=10m).\n- **Steps:**\n  - Request API with expired token → `403 Forbidden`.\n  - Refresh token → expect new valid token.\n  - Use refreshed token to access protected API → `200 OK`.\n- **Expected:** Tokens refreshed successfully."
    },
    {
      "question_id": "EQ3004",
      "question": "Design a chained test validating that a failed login attempt still prevents refresh token generation.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. **Initial Attempt:** Send a `POST /login` request with an incorrect password. 2. **Assert First Failure:** Confirm the login fails. 3. **Second Attempt:** Immediately send another `POST /login` request. 4. **Assert No Token:** Verify no access token or refresh token is returned. 5. **Assert Session:** Check the session state to confirm it was not inadvertently created."
    },
    {
      "question_id": "EQ3006",
      "question": "Explain how you would validate correct mapping of business codes (e.g., ORDER_001) to HTTP status codes in API responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Create a test suite with scenarios covering positive (e.g., successful order creation) and negative paths (e.g., invalid product, duplicate order). For each, assert that the HTTP status code (e.g., `201` Created, `400` Bad Request, `409` Conflict) is correct. Finally, verify that the response body includes the corresponding business-specific error code (e.g., `ORDER_001` for duplicate order)."
    },
    {
      "question_id": "EQ3008",
      "question": "Write one hard-level test case chaining order creation, payment, and refund APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "### **Test Case: Full Order Lifecycle**\n- **Preconditions:** User exists, inventory > 0, test order ID.\n- **Steps:**\n  1. **Create Order:** `/orders` with items → `201 Created`.\n  2. **Process Payment:** `/payments` for order → `201 Created`.\n  3. **Confirm Shipment:** `/ships` for order → `200 OK`.\n  4. **Initiate Refund:** `/refunds` for order → `201 Created`.\n- **Expected:** All steps succeed, order status changes accordingly."
    },
    {
      "question_id": "EQ3010",
      "question": "Explain one test case that validates token refresh works across multiple microservices.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "**Test Case: Token Refresh Across Services**\n- **Preconditions:** API Consumer Service (A) and Token Refresh Service (B) both running. User token expired.\n- **Test Steps:**\n  1. Service A → Request protected resource → 403 Forbidden (expired token).\n  2. Service B → Receive refresh request → Obtain new token.\n- **Expected Result:** Service A should be able to retry the request with the new token, succeeding this time."
    },
    {
      "question_id": "EQ3012",
      "question": "Write a test that validates mapping of validation error codes to HTTP 400 responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "**Test Case: Validation Error Mapping**\n- **Preconditions:** API configured with custom validation error codes.\n- **Steps:**\n  - Request with invalid field (e.g., `/users` with non-unique username) → 400 Bad Request.\n  - Assert response body contains specific error code (e.g., `{\"error_code\": \"INVALID_INPUT\"}`).\n  - Verify error message is descriptive.\n- **Expected:** API returns correct HTTP status and error details."
    },
    {
      "question_id": "EQ3014",
      "question": "Design a test case validating expired refresh tokens cannot issue new access tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "### **Test Case: Expired Refresh Token**\n- **Test Case ID:** TC-005\n- **Preconditions:** A refresh token is generated 30 minutes ago and has expired.\n- **Test Steps:**\n  1. Send a `POST /refresh-token` request with the expired refresh token.\n- **Expected Result:** The API returns a `400 Bad Request` or `401 Unauthorized` status with an error message like 'Refresh token has expired' or 'Invalid refresh token'. The response body should not contain an access token."
    },
    {
      "question_id": "EQ3016",
      "question": "Explain one multi-hop chained test that validates session invalidation after logout.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Test case: 1) Login → obtain session token. 2) Send request with token → `200 OK`. 3) Logout endpoint → session invalidated. 4) Repeat request with old token → `401 Unauthorized`."
    },
    {
      "question_id": "EQ3018",
      "question": "Write a test case chaining signup, email verification, and login endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "### **Test Case: Full User Flow**\n- **Preconditions:** API available, mail service mocked.\n- **Steps:**\n  - **Signup:** Send `POST /signup` with valid email/password → `200 OK` with user data and email verification link.\n  - **Email Verification:** Send `POST /verify-email` with link token → `200 OK` with success message.\n  - **Login:** Send `POST /login` with verified user's email/password → `200 OK` with auth token.\n- **Expected:** All steps succeed, user accessible only after email verified."
    },
    {
      "question_id": "EQ3020",
      "question": "Design one hard-level chained test validating a password reset flow.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "**Test Case: Password Reset Flow**\n1. **Preconditions:** User 'user123' exists, email verified.\n2. **Steps:**\n   - Send password reset request → expect `200 OK`.\n   - Extract reset token from email.\n   - Use token to reset to new password → `200 OK`.\n   - Log in with new password → `200 OK`.\n   - Attempt reset again with same email → expect `400 Bad Request`.\n3. **Expected:** All steps succeed, new password valid, repeated reset fails."
    },
    {
      "question_id": "EQ3022",
      "question": "Write a chained test case for validating user creation, profile update, and profile retrieval.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "**Test Case: User Profile Management**\n- **Preconditions:** User API enabled, test user exists.\n- **Test Steps:**\n  - **Create User:** Send `POST /users` with email and password.\n  - **Update Profile:** Send `PUT /users/{id}` with new profile info.\n  - **Retrieve Profile:** Send `GET /users/{id}` to verify updated profile.\n- **Expected Result:** All requests succeed, profile info matches updates."
    },
    {
      "question_id": "EQ3024",
      "question": "Explain one test to validate refresh token cannot be used after logout.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "Test Case: \n1. User logs in, receives access and refresh tokens.\n2. User logs out (invalidate session).\n3. Attempt to use refresh token to get new access token.\n4. Expected: 403 Forbidden or 401 Unauthorized, as logout invalidates refresh token."
    },
    {
      "question_id": "EQ3026",
      "question": "Write a test case validating correct mapping of internal error code AUTH_EXPIRED to HTTP status.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "### **Test Case: Verify Authentication Expiration**\n-   **Test Case ID:** TC-005\n-   **Test Case Name:** Confirm correct HTTP status returned for expired authentication.\n-   **Preconditions:**\n    -   Authentication service mocked.\n    -   Token expiration configured (e.g., 1 minute).\n-   **Test Steps:**\n    1. Send request to protected endpoint *after* token has expired.\n-   **Expected Result:** The API returns a `401 Unauthorized` HTTP status code."
    },
    {
      "question_id": "EQ3028",
      "question": "Explain a chained test validating email verification failure if token is invalid.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Request email verification with known invalid token. 2) Assert API returns `400 Bad Request` or `401 Unauthorized`. 3) Confirm user remains unverified."
    },
    {
      "question_id": "EQ3030",
      "question": "Write a hard-level test case chaining loan application, credit check, and approval endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "**Test Case: Loan Approval Flow**\n- **Preconditions:** User exists, credit score = 700.\n- **Steps:**\n  1. `POST /loans` with $100k, 60 months → 200 OK with loan ID.\n  2. `GET /credit-check` with loan ID → 200 OK with credit score.\n  3. `POST /loans/{id}/approve` → 200 OK with approval message.\n- **Expected:** Loans approved only if valid."
    },
    {
      "question_id": "EQ3032",
      "question": "Design a test case chaining signup, password reset, and login with new credentials.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "**Test Case: Credential Flow**\n- **Scenario:** User signs up (email=user@example.com, password=Strong123).\n- **Action 1:** Request password reset via email.\n- **Action 2:** Change new password → login with new credentials.\n- **Expected:** Successful login with new password."
    },
    {
      "question_id": "EQ3034",
      "question": "Write a test case chaining file upload, virus scan, and download endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "### **Test Case: Secure File Transfer**\n- **Preconditions:** File upload API available, virus scan service integrated, safe file (e.g., PDF) and malicious file (e.g., virus payload) prepared.\n- **Steps:**\n  - **Upload:** Send safe file → `200 OK`, file ID stored.\n  - **Scan:** Call virus scan endpoint with file ID → `202 Accepted` if clean, `400 Bad Request` if infected.\n  - **Download:** Attempt safe file download → `200 OK`, file available.\n  - **Negative:** Try downloading file ID that doesn't exist → `404 Not Found`.\n- **Expected:** Only clean files available for download."
    },
    {
      "question_id": "EQ3036",
      "question": "Explain one chained test for validating refresh token reuse prevention.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "Test Case: \"Refresh Token Reuse Attempt.\"\n1. **Action 1:** Obtain a refresh token.\n2. **Action 2:** Attempt to use the same refresh token multiple times.\n3. **Expected Result:** Second and subsequent attempts fail with `409 Conflict` or `403 Forbidden`."
    },
    {
      "question_id": "EQ3038",
      "question": "Write a test case chaining search, add-to-cart, and checkout APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "### **Test Case: Full E-commerce Flow**\n- **Preconditions:** User authenticated, catalog seeded.\n- **Steps:**\n  - **Search:** Send product name search request → assert results.\n  - **Add to Cart:** Product ID → 201 Created.\n  - **Checkout:** Cart ID → 201 Created.\n- **Expected:** All steps succeed, DB reflects order creation."
    },
    {
      "question_id": "EQ3040",
      "question": "Explain one chained test for validating API session hijacking prevention.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "Chained Test: 1) Log in as User A → get Session Cookie. 2) Send request with User A's Cookie to protected resource. 3) Assert `401 Unauthorized` or `403 Forbidden`. Preconditions: API must validate session cookie signatures or tokens."
    },
    {
      "question_id": "EQ3042",
      "question": "Provide exactly one chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "### **Test Case: Optimistic Concurrency with ETag**\n- **Preconditions:** Item ID=789 exists with ETag='v1'.\n- **Steps:**\n  - **Action 1:** Update Item → new ETag='v2'.\n  - **Action 2:** Send request with old ETag ('v1') → expect `409 Conflict`.\n- **Expected:** DB state unchanged, `v2` ETag used if valid."
    },
    {
      "question_id": "EQ3044",
      "question": "Design a multi-hop test verifying async export job: POST /exports -> poll GET /jobs/{id} until complete -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "This test validates asynchronous export processing."
    },
    {
      "question_id": "EQ3046",
      "question": "Give one chained negative test for OAuth2 Authorization Code: /authorize -> /token -> resource call with missing scope.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Test steps: 1) Client requests authorization with scope'read'. 2) Server grants. 3) Client exchanges code for token. 4) Call resource. Expected: `403 Forbidden` because missing scope 'write'."
    },
    {
      "question_id": "EQ3048",
      "question": "Write one chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. **Charge Creation**: Send `POST /charge` with $100 amount → `201 Created` with ID and key.\n2. **First Retry**: Send identical `POST /charge` → `200 OK`, DB unchanged.\n3. **Second Request**: Send again → `200 OK`, DB still unchanged.\n4. **Refund**: Send `POST /charge/{id}/refund` with valid key → `200 OK`.\n5. **Second Refund Attempt**: Send identical refund → `200 OK`, DB unchanged.\n6. **Verify DB**: Ensure only one successful transaction."
    },
    {
      "question_id": "EQ3050",
      "question": "Provide one chained test for file processing pipeline: upload -> POST /process -> poll status -> download, including 202 handling.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "**Test Case: File Processing Pipeline**\n- **Preconditions:** File `input.txt` exists.\n- **Steps:**\n  1. Upload file via `PUT /files` → store ID `file_id`.\n  2. Send `POST /process` with `file_id` → expect `202 Accepted`.\n  3. Poll status until `finished` → verify response.\n  4. Download processed file via `GET /files/{file_id}` → assert contents.\n- **Expected:** File processed successfully, no corrupt data."
    },
    {
      "question_id": "EQ3052",
      "question": "Give one chained test to validate SSO session revocation propagates to API gateway and microservice access.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "**Test Case: SSO Session Revocation Chained**\n- **Preconditions:** User logged in with valid SSO token. API Gateway and Microservice both configured to use SSO token for authentication.\n- **Action:** Send revocation request to SSO provider (e.g., via logout endpoint).\n- **Verification:**\n  - API Gateway returns `403 Forbidden` or `401 Unauthorized` for subsequent requests from the revoked user.\n  - Microservice API also rejects requests from the same user with a suitable error code (e.g., `403 Forbidden`).\n  - No sensitive data exposed during failed access attempts."
    },
    {
      "question_id": "EQ3054",
      "question": "Write one chained test for partial order fulfillment: create order -> reserve inventory -> partial ship -> cancel remaining and refund delta.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "**Test Case: Partial Order with Inventory Management**\n- **Preconditions:** Product stock = 5, initial balance = $100.\n- **Steps:**\n  1. **Create Order:** Place order for 3 units (partial of stock) → `200 OK`.\n  2. **Verify State:** Stock = 2, order status = 'partially shipped'.\n  3. **Partial Ship:** Ship 2 units → `200 OK`.\n  4. **Cancel Remaining:** Cancel 1 unit → `200 OK`.\n  5. **Assert:** Stock = 2, order status = 'cancelled', refund = $50.\n- **Expected:** All transitions valid, correct inventory and balance changes."
    },
    {
      "question_id": "EQ3056",
      "question": "Provide exactly one chained negative test for 2FA login: POST /login -> POST /2fa/verify with wrong code -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "**Test Case: '2FA Login with Wrong Verification Code'**\n- **Test Case Name:** Attempt to log in with valid credentials but wrong 2FA verification code.\n- **Preconditions:**\n  - A user exists with known email and password.\n  - This user has enabled 2FA (e.g., SMS, email).\n- **Test Steps:**\n  1. Send a `POST` request to `/login` with the user's email and password.\n  2. Extract the `2fa_code` from the response (e.g., `response.data.2fa_code`).\n  3. Send another `POST` request to `/2fa/verify` but this time with a **wrong** verification code (e.g., an incorrect digit or an entirely different code).\n- **Expected Result:**\n  - The `/2fa/verify` request should fail with a `400` or `409` status code (e.g., `Bad Request` or `Conflict`), and the `2fa_status` field in the response should indicate that the verification failed.\n  - The original login attempt should be marked as failed and the user should not be considered logged in.\n  - Any subsequent API call, such as a `POST /refresh` token request, should also fail with an appropriate error message."
    },
    {
      "question_id": "EQ3058",
      "question": "Design a chained test verifying pagination consistency across create -> list -> delete -> list (with total count assertions).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "**Test Case: Chained Pagination**\n- **Step 1:** Create 20 resources (e.g., `POST /products`).\n- **Step 2:** List first 5 → expect 5 items. List next 5 → expect 5 items. List last 10 → expect 5 items.\n- **Step 3:** Delete last 5 items.\n- **Step 4:** List all → expect only 5 items. List first 10 → 404.\n- **Assertion:** Total count API (`GET /products/count`) → 5."
    },
    {
      "question_id": "EQ3060",
      "question": "Write one chained test for session stickiness: login -> subsequent calls via load balancer -> logout -> verify no node accepts old token.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "**Test Case: Session Stickiness**\n1. Login to Node A → obtain session cookie.\n2. LB directs next API call → verify session cookie still valid.\n3. Log out → delete session.\n4. Repeat step 2 → expect `404 Not Found` or `401 Unauthorized` from all nodes."
    },
    {
      "question_id": "EQ4002",
      "question": "Write a state-machine style test validating account lifecycle: create → activate → suspend → reactivate → delete.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "**Test Case: Account Lifecycle**\n- **Preconditions:** Admin user exists.\n- **Steps:**\n  - Create account → 201 Created.\n  - Activate → 200 OK.\n  - Suspend → 200 OK.\n  - Reactivate → 200 OK.\n  - Delete → 204 No Content.\n- **Expected:** All transitions valid, DB state matches."
    },
    {
      "question_id": "EQ4004",
      "question": "Design a chained test that validates transaction rollback when step 2 of a 3-step money transfer fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "**Test Case: Transaction Rollback**\n- **Preconditions:** User A has $100.\n- **Step 1:** Transfer $50 from A to B → `200 OK`.\n- **Step 2:** (Failure) Attempt to transfer $999 from B to C → `400 Invalid Amount`.\n- **Expected:** After Step 2, User A still has $100, no funds moved."
    },
    {
      "question_id": "EQ4006",
      "question": "Write one test validating a multi-service chain: login → create order → process payment → cancel order after capture.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "This test requires orchestrated API calls across services. **Test Case:** 1. Log in to auth service. 2. Create order → expect `201 Created` from inventory service. 3. Process payment → capture successful. 4. Cancel order → expect `200 OK` with cancelled status. **Validation:** Verify DB consistency post each step."
    },
    {
      "question_id": "EQ4008",
      "question": "Describe one state-machine test validating password lifecycle: set → expire → reset → reuse prevention.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "1) **Set:** State 'PasswordSet' transitions to 'Valid' when created. 2) **Expire:** 'Valid' → 'Expired' after 90 days. 3) **Reset:** 'Expired' → 'ResetPending' → 'Valid' after new password. 4) **Reuse:** Prevents 'Valid' → 'Valid' with identical password."
    },
    {
      "question_id": "EQ4010",
      "question": "Write one complex chained test covering a loan application flow with branch failure in credit check.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "**Test Case: Loan Approval with Credit Check Failure**\n- **Preconditions:** User exists, loan product active.\n- **Test Steps:**\n  1. Send loan application request.\n  2. Chain with a separate API call to a mock credit service (e.g., `/credit-check`) that returns a `500 Internal Server Error`.\n- **Expected Result:** Loan application API should fail with a `503 Service Unavailable` status code, not `200 OK`. The DB should not be updated with an approved status."
    },
    {
      "question_id": "EQ4012",
      "question": "Write a test validating data integrity when concurrent writes occur: update user profile with conflicting values.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "**Test Case: Concurrent Profile Updates**\n- **Preconditions:** Two users, Alice and Bob, exist. Both are connected to the API.\n- **Test Steps:**\n  1. **Alice's Request:** Send a `PUT /users/123` request to update Alice's email to `alice@example.com`.\n  2. **Bob's Request (Simultaneous):** Immediately after, Bob sends a `PUT /users/123` request to update the email to `bob@example.com`.\n- **Expected Result:**\n  - The API rejects both requests with a `409 Conflict` status.\n  - The database state remains unchanged, with the original email still `user@example.com`.\n  - A retry after a short interval should succeed, but only with one of the updates being applied."
    },
    {
      "question_id": "EQ4014",
      "question": "Write one very hard test validating chained document signing: upload → sign → verify → tamper detection.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "**Test Case: Chained Document Signing**\n- **Preconditions:** API configured for document signing (e.g., AWS Signature Version 4).\n- **Steps:**\n  1. Upload a document → get its hash.\n  2. Sign the hash → attach signature to document.\n  3. Verify signature → ensure document integrity.\n  4. Attempt tampering (alter bytes) → expect verification to fail.\n- **Expected:** Signature verification passes only for original document."
    },
    {
      "question_id": "EQ4017",
      "question": "Write one state-machine test validating subscription lifecycle: create → upgrade → downgrade → cancel.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "1. **Create:** Send `POST` to `/subscriptions` with plan='basic'. Assert `200 OK`, DB shows `status='active'`.\n2. **Upgrade:** Send `PUT` to `/subscriptions/ID` with plan='premium'. Assert `200 OK`, DB shows new plan.\n3. **Downgrade:** Send `PUT` to `/subscriptions/ID` with plan='basic'. Assert `200 OK`, DB updated.\n4. **Cancel:** Send `DELETE` to `/subscriptions/ID`. Assert `200 OK`, DB shows `status='cancelled'`."
    },
    {
      "question_id": "EQ4019",
      "question": "Write a very hard chained test validating recovery after partial failure in a distributed order saga.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "**Test Case: Distributed Order Saga Recovery**\n- **Preconditions:** 3 microservices (Order, Inventory, Shipping) deployed across regions, event bus mocked.\n- **Steps:**\n  1. Send `CreateOrder` → `Commit` event → `ReserveInventory` → `PrepareShipping`.\n  2. Inject failure after `PrepareShipping`: shipping service returns 500.\n  3. Expected: Order service reverts to `Created` state, no inventory reserved.\n  4. Repeat with different failures in chain.\n- **Expected:** All services recover cleanly, no stale data."
    },
    {
      "question_id": "EQ4021",
      "question": "Write one very hard test verifying financial transaction reversals: debit → credit → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "This test requires complex state management. Preconditions: account balance $100. Action: debit $50 → credit $20 → rollback. Expected: no changes, balance remains $100."
    },
    {
      "question_id": "EQ4023",
      "question": "Design a state-machine test for warehouse inventory: add stock → allocate → ship → return → reconcile.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Test steps: 1) Add 100 units → 2) Allocate 50 → 3) Ship 30 → 4) Return 20 → 5) Reconcile DB → Expected: stock=70, all transactions logged."
    },
    {
      "question_id": "EQ4025",
      "question": "Write one chained test validating mobile session lifecycle: login → token refresh → logout → refresh with old token → fail.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "**Test Case: Mobile Session Lifecycle**\n- **Test Case Name:** Verify session lifecycle with refresh and invalidation.\n- **Preconditions:** Mobile app connected to API with short-lived sessions (15 minutes).\n- **Test Steps:**\n  1. **Login & Initial Token:** Send `POST /login` with valid credentials.\n  2. **Token Refresh:** Wait for session to be half-life. Send `POST /refresh-token` with existing refresh token. Assert `200 OK` and new refresh token.\n  3. **Logout:** Send `DELETE /logout` with user ID. Assert `204 No Content`.\n  4. **Invalid Refresh:** Send `POST /refresh-token` with old refresh token after logout. Assert `401 Unauthorized`.\n- **Expected Results:** All refresh steps succeed only before logout."
    },
    {
      "question_id": "EQ4027",
      "question": "Write one chained test validating email delivery API: send → open-tracking → unsubscribe → ensure no further emails sent.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. **Send Email:** Send a test email with unique tracking and unsubscribe links. 2. **Open Tracking:** Use a tracking pixel to confirm email opened. 3. **Unsubscribe:** Send a request to the unsubscribe endpoint for that email's user. 4. **Verify No More Emails:** Monitor the user's inbox for the next scheduled email and confirm it does not arrive."
    },
    {
      "question_id": "EQ4029",
      "question": "Write one very hard chained test for purchase flow with coupon application and failure branch: apply coupon → checkout → coupon invalid → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "This test requires multiple steps: 1) Apply a valid coupon during checkout. 2) Proceed to payment. 3) Programmatically invalidate the coupon on the server. 4) The API should return a `400` error. 5) The DB should show the order was rolled back to 'pending' state."
    },
    {
      "question_id": "EQ5004-VN",
      "question": "Viết một test case positive đơn giản cho một API đăng nhập.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "### **Test Case: Đăng Nhập với Tài Khoản Valid**\n- **Test Case Name:** Đăng nhập thành công với email và mật khẩu đúng.\n- **Test Case ID:** TC-LOGIN-001.\n- **Test Case Description:** Đăng nhập vào hệ thống với một tài khoản đã tồn tại và đúng thông tin.\n- **Preconditions:**\n  - Hệ thống API đang hoạt động.\n  - Có một tài khoản `user@example.com` với mật khẩu `Password123!` đã đăng ký.\n- **Test Steps:**\n  1. Gửi yêu cầu `POST` đến endpoint đăng nhập (ví dụ `/login`).\n  2. Thư viện test sẽ sử dụng các công cụ như `requests` (Python) hoặc `axios` (JavaScript) để gửi yêu cầu.\n  3. Trong cơ thể yêu cầu, bạn cần gửi một `JSON` body với trường `email` và `password`.\n  4. Sử dụng các giá trị xác định từ precondition (ví dụ `{\"email\": \"user@example.com\", \"password\": \"Password123!\"}`).\n- **Expected Result:**\n  - **Status Code:** HTTP Status `200 OK` hoặc `201 Created` (tùy thuộc vào API).\n  - **Response Body:** Trả về một `JSON` chứa thông tin về token truy cập hoặc user được xác thực. Ví dụ, `{\"token\": \"eyJhb...\", \"user\": {\"id\": 1, \"name\": \"User Name\"}}`.\n  - **Header:** Có một tiêu đề `Authorization` hoặc `X-Token` với giá trị token được trả về.\n  - **Database:** Một bản ghi về session hoặc token liên quan đến yêu cầu đăng nhập này có thể được tạo."
    },
    {
      "question_id": "EQ5006-VN",
      "question": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "Điều kiện tiên quyết phổ biến là một tài khoản người dùng đã được đăng ký và có quyền truy cập vào profile của họ."
    },
    {
      "question_id": "EQ5008-VN",
      "question": "Viết một test negative đơn giản cho một API đăng ký.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Test trường email không hợp lệ: Request với `email=invalid` và kiểm tra trạng thái HTTP và nội dung trả về."
    },
    {
      "question_id": "EQ5010-VN",
      "question": "Vai trò của một schema trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "Một schema xác định cấu trúc và quy tắc của dữ liệu được gửi hoặc nhận. Trong testing, nó giúp xác minh dữ liệu API đáp ứng các yêu cầu cấu trúc và loại dữ liệu (int, string, array, etc.)."
    },
    {
      "question_id": "EQ5012-VN",
      "question": "Viết một test step đơn giản để validate một response 201 Created.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "Test Step: Đăng một tài khoản mới và xác minh status code tạo là 201 Created."
    },
    {
      "question_id": "EQ5014-VN",
      "question": "Mục đích của mocking trong API testing là gì?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking giúp tạo giả lập các dịch vụ phụ thuộc để thực hiện kiểm tra độc lập, giảm phụ thuộc vào các dịch vụ khác."
    },
    {
      "question_id": "EQ5016-VN",
      "question": "Viết một test case dễ dàng cho một API lấy danh sách sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "**Test Case: Lấy Danh Sách Sản Phẩm**\n- **Test Case ID:** TC-GET-PRODUCTS-001\n- **Test Case Name:** Xác minh API trả về danh sách sản phẩm.\n- **Test Case Description:** Lấy danh sách sản phẩm từ API.\n- **Preconditions:** Có ít nhất 5 sản phẩm trong cơ sở dữ liệu.\n- **Test Steps:**\n  1. Gửi yêu cầu GET đến endpoint `/products`.\n- **Expected Results:**\n  - Status Code: `200 OK`.\n  - Trả về danh sách JSON chứa ít nhất 5 sản phẩm.\n  - Mỗi sản phẩm có các trường cơ bản (id, tên, giá)."
    },
    {
      "question_id": "EQ5018-VN",
      "question": "Mục đích của một precondition trong một test case là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Mục đích của một precondition trong một test case là đảm bảo rằng tất cả các yêu cầu và trạng thái cần thiết để thực hiện và đánh giá hiệu quả của một yêu cầu chức năng được đáp ứng trước khi test được thực thi."
    },
    {
      "question_id": "EQ5020-VN",
      "question": "Viết một test negative cho việc upload file với định dạng không được hỗ trợ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test case: Đặt file có định dạng `.exe`. Lệnh test: `POST /upload` với file attachment. Expected: Trả về `415 Unsupported File Type` hoặc `400 Bad Request`."
    },
    {
      "question_id": "EQ5022-VN",
      "question": "Mục đích của một test case description là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "Mục đích của một test case description là cung cấp một bản mô tả ngắn gọn và rõ ràng về chức năng hoặc yêu cầu mà test case đó đang kiểm tra."
    },
    {
      "question_id": "EQ5024-VN",
      "question": "Viết một test step để validate thời gian response dưới 1 giây.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "Test step: Gọi API `GET /health` và xác minh thời gian phản hồi `< 1000 ms`."
    },
    {
      "question_id": "EQ5027-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /health.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "**Test Case: Health Check**\n- **Test Case Name:** Verify healthy API response.\n- **Preconditions:** API đang chạy.\n- **Test Steps:** Gửi yêu cầu GET đến /health.\n- **Expected Result:** HTTP Status Code = 200 OK, Response Body chứa 'healthy' = true."
    },
    {
      "question_id": "EQ5029-VN",
      "question": "Mục đích của việc sử dụng test data management trong API testing là gì?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "Sử dụng test data management giúp cung cấp dữ liệu thử nghiệm linh hoạt, bảo mật, và khả năng tái tạo được."
    },
    {
      "question_id": "EQ5031-VN",
      "question": "Viết một test negative dễ dàng cho một API mong đợi định dạng JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test trường hợp yêu cầu resource không tồn tại (ID không hợp lệ). Ví dụ, thử GET /products/999. Expected: `404 Not Found` hoặc JSON có trường `error`."
    },
    {
      "question_id": "EQ5033-VN",
      "question": "Vai trò của assertion trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion là công cụ kiểm tra giúp xác định xem API đáp ứng yêu cầu hay không. Nó so sánh kết quả thực tế với kết quả mong đợi và báo cáo kết quả kiểm tra."
    },
    {
      "question_id": "EQ5035-VN",
      "question": "Viết một test case để kiểm tra DELETE /users/{id} hoạt động đúng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "**Test Case: Xoá User**\n- **Test Case ID:** TC-DELETE-USER\n- **Test Case Name:** Xác nhận xoá user thành công.\n- **Preconditions:** User ID=1234 tồn tại.\n- **Test Steps:**\n  1. Request DELETE /users/1234.\n- **Expected Result:**\n  - Status Code = 204 No Content.\n  - Dữ liệu trong DB không tồn tại ID=1234."
    },
    {
      "question_id": "EQ5037-VN",
      "question": "Mã trạng thái HTTP 201 Created cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "Mã trạng thái HTTP 201 Created cho biết yêu cầu tạo mới tài nguyên thành công."
    },
    {
      "question_id": "EQ5039-VN",
      "question": "Viết một test đơn giản cho GET /users/{id} trả về response chính xác.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "Test trường hợp ID tồn tại và ID không tồn tại."
    },
    {
      "question_id": "EQ5041-VN",
      "question": "Mục đích của một response 200 OK là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "Một response 200 OK cho biết yêu cầu của client đã được thực hiện thành công."
    },
    {
      "question_id": "EQ5043-VN",
      "question": "Viết một test negative để validate response cho một endpoint không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "**Test Case:** Validate Negative Authentication\n- **Test Case Name:** Attempt Login with Invalid Credentials.\n- **Preconditions:** API đang chạy.\n- **Test Steps:**\n  - Send `POST` request đến endpoint `/login` với payload `{\"username\": \"invaliduser\", \"password\": \"wrongpassword\"}`.\n- **Expected Result:**\n  - Status Code: `401 Unauthorized` hoặc `400 Bad Request`.\n  - Response Body không chứa token hoặc chứa thông báo lỗi như \"Invalid credentials\"."
    },
    {
      "question_id": "EQ5045-VN",
      "question": "Một test case assertion làm gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Một test case assertion xác định điều kiện thành công của một thử nghiệm. Ví dụ, nếu yêu cầu là 'API trả về HTTP 200 khi tạo user thành công', thì assertion sẽ kiểm tra xem trạng thái HTTP trả về là 200 hay không."
    },
    {
      "question_id": "EQ5047-VN",
      "question": "Viết một test positive cho endpoint upload file.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "Test case: `POST /upload` with valid image file (e.g., `image.jpg`). Expected: `201 Created`, file saved successfully in server."
    },
    {
      "question_id": "EQ5049-VN",
      "question": "Vai trò của 415 Unsupported Media Type là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "415 Unsupported Media Type được sử dụng khi client gửi yêu cầu với định dạng nội dung (Content-Type) mà server không hỗ trợ. Ví dụ, nếu client yêu cầu dữ liệu JSON nhưng server chỉ hiểu dạng XML, nó sẽ trả về trạng thái 415."
    },
    {
      "question_id": "EQ5052-VN",
      "question": "Viết một test positive đơn giản để kiểm tra API chi tiết sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "**Test Case:** Lấy Chi Tiết Sản Phẩm\n- **Test Scenario:** Đăng nhập và yêu cầu chi tiết sản phẩm ID=123.\n- **Action:** Gọi `GET /products/123`.\n- **Expected:** Trả về mã `200 OK` với dữ liệu chi tiết sản phẩm."
    },
    {
      "question_id": "EQ5054-VN",
      "question": "Mục đích của việc sử dụng Authorization headers trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "Là để xác thực và cấp quyền cho yêu cầu gửi đến server. Ví dụ, `Authorization: Bearer <token>` sẽ yêu cầu server kiểm tra token và xác định xem người dùng nào được thực hiện hành động đó."
    },
    {
      "question_id": "EQ5056-VN",
      "question": "Viết một test negative case cho một API yêu cầu authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Test trường hợp không gửi token hoặc gửi token hết hạn. Expected: `403 Forbidden` hoặc `401 Unauthorized`."
    },
    {
      "question_id": "EQ5058-VN",
      "question": "Vai trò của 500 Internal Server Error trong API testing là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "500 Internal Server Error là một mã lỗi chung được sử dụng khi xảy ra lỗi trên server mà không thể xác định lỗi cụ thể. Trong testing, mục đích là kiểm tra khả năng xử lý lỗi của API, chẳng hạn khi gặp vấn đề cơ bản với cơ sở dữ liệu hoặc khi xảy ra lỗi bất ngờ trong mã nguồn."
    },
    {
      "question_id": "EQ5060-VN",
      "question": "Viết một test case positive cho một API trả về danh sách đơn hàng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "**Test Case: Lấy Danh Sách Đơn Hàng**\n- **Test Case ID:** TC_001\n- **Test Case Name:** Kiểm tra việc lấy danh sách đơn hàng thành công.\n- **Test Case Description:** Gửi yêu cầu GET đến endpoint `/orders` và xác thực trạng thái và dữ liệu trả về.\n- **Test Case Preconditions:** Có ít nhất một đơn hàng đã được tạo trong cơ sở dữ liệu.\n- **Test Case Steps:**\n  1. Gửi yêu cầu GET đến `/orders`.\n  2. Xác định xem HTTP Status Code trả về là `200 OK` hay không.\n  3. Xác thực xem danh sách đơn hàng được trả về và có phải là danh sách không trống hay không.\n- **Test Case Expected Result:**\n  - HTTP Status Code: `200 OK`.\n  - Trả về danh sách các đơn hàng được tạo trước đó."
    },
    {
      "question_id": "EQ5062-VN",
      "question": "Chức năng của response header trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "Chức năng của response header là cung cấp thông tin metadata về nội dung trả về. Ví dụ, `Content-Type` xác định định dạng dữ liệu, `Cache-Control` chỉ định hành vi caching."
    },
    {
      "question_id": "EQ5064-VN",
      "question": "Viết một test negative cho việc tạo một tài nguyên trùng lặp.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "Test Negative: Bước 1: Gọi API tạo tài nguyên với đường dẫn `/products/ABC123`. Bước 2: Thay vì gửi một payload hợp lệ, hãy gửi một payload bất kỳ (vd: `{\"name\": \"Test\"}`) và yêu cầu HTTP. Bước 3: Đảm bảo API trả về một trạng thái không thành công như `404 Not Found` hoặc `409 Conflict`, và trong trường hợp đó, đảm bảo cơ sở dữ liệu không bị thay đổi."
    },
    {
      "question_id": "EQ5066-VN",
      "question": "Vai trò của 202 Accepted trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "202 Accepted được sử dụng khi API nhận được yêu cầu nhưng sẽ xử lý sau. Ví dụ, khi gửi file lớn, API sẽ trả 202 Accepted và tiếp tục xử lý ở hậu kỳ."
    },
    {
      "question_id": "EQ5068-VN",
      "question": "Viết một test positive dễ dàng để kiểm tra API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Test case: **Test Positive - Valid Data**. **Action:** Send request với dữ liệu hợp lệ (ví dụ: đăng ký user với email và password valid). **Expected:** API trả về trạng thái HTTP 200 OK và response body phải chứa các trường dữ liệu chính (ví dụ: `id`, `email`, `password`) với các giá trị phù hợp."
    },
    {
      "question_id": "EQ5070-VN",
      "question": "Mục đích của response body trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Response body chứa dữ liệu trả về cho client. Mục đích là kiểm tra tính chính xác, đầy đủ, và hợp lệ của dữ liệu này."
    },
    {
      "question_id": "EQ5072-VN",
      "question": "Viết một test case để verify chức năng logout.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Logout**\n- **Preconditions:** User logged in.\n- **Action:** Send logout request.\n- **Expected:** User session expired, subsequent requests to protected endpoints return 403 Forbidden."
    },
    {
      "question_id": "EQ5074-VN",
      "question": "Lỗi 415 Unsupported Media Type validate điều gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "Lỗi 415 Unsupported Media Type xảy ra khi client gửi dữ liệu theo định dạng mà server không hỗ trợ. Ví dụ, nếu API yêu cầu dữ liệu dạng JSON nhưng client gửi XML, thì server sẽ trả về lỗi này."
    },
    {
      "question_id": "EQ5077-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /status.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Test trường hợp: **Test Case: Status Endpoint**\n- **Preconditions:** API đang chạy.\n- **Test Steps:** Gửi yêu cầu GET đến `/status`.\n- **Expected Result:** HTTP Status Code `200 OK` và trả về JSON với trạng thái như 'running' hoặc 'healthy'."
    },
    {
      "question_id": "EQ5079-VN",
      "question": "Một response 204 No Content có nghĩa là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "Một response 204 No Content xác nhận rằng yêu cầu đã được thực hiện thành công, nhưng server không có nội dung nào để gửi lại."
    },
    {
      "question_id": "EQ5081-VN",
      "question": "Viết một test negative case cho việc gửi một Content-Type header không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test Case: Gửi yêu cầu POST với header `Content-Type: application/xml`. Expected: Server trả về `415 Unsupported Media Type`."
    },
    {
      "question_id": "EQ5083-VN",
      "question": "Mục đích của Accept header trong các API request là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "Accept header được sử dụng để chỉ định format dữ liệu trả về mà client hỗ trợ. Ví dụ, `Accept: application/json` yêu cầu server trả về dữ liệu JSON."
    },
    {
      "question_id": "EQ5085-VN",
      "question": "Viết một test case đơn giản cho một API logout thành công.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "### **Test Case: Logout Successful**\n- **Test Case ID:** TC-LOGOUT-001\n- **Test Case Name:** Verify successful logout.\n- **Preconditions:** User authenticated with valid token.\n- **Test Steps:**\n  1. Send `POST` request to `/logout`.\n  2. Verify response status code is `200 OK`.\n- **Post-conditions:**\n  - Token should not be valid after logout.\n  - Subsequent protected endpoint should return `401 Unauthorized`.\n- **Expected Result:** Logout confirmed by invalid token."
    },
    {
      "question_id": "EQ5087-VN",
      "question": "Ý nghĩa của 401 Unauthorized trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "Một 401 Unauthorized nghĩa là yêu cầu được gửi nhưng không được xác thực hoặc xác thực không hợp lệ. Ví dụ, người dùng chưa đăng nhập hoặc mật khẩu không đúng."
    },
    {
      "question_id": "EQ5089-VN",
      "question": "Viết một test case positive dễ dàng để kiểm tra API chi tiết profile.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "Test Case: Tính năng Profile chi tiết.\n- **Test Case Name:** Verify Profile Details.\n- **Test Case Description:** Đảm bảo API trả về thông tin người dùng đầy đủ khi yêu cầu profile riêng.\n- **Preconditions:** User 'John Doe' có profile sẵn.\n- **Test Steps:**\n  1. Request Profile với ID User.\n- **Expected Result:**\n  - Status Code: `200 OK`.\n  - Body chứa tên, email, địa chỉ, hình ảnh profile."
    },
    {
      "question_id": "EQ5091-VN",
      "question": "Mục đích của 302 Found trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "Mục đích của 302 Found là chuyển hướng tạm thời một yêu cầu đến một URL khác. Ví dụ, khi một API được di chuyển sang một URL mới, nó sẽ trả về trạng thái 302 với địa chỉ mới để client biết."
    },
    {
      "question_id": "EQ5093-VN",
      "question": "Viết một test case cho nỗ lực đăng nhập negative với mật khẩu sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Đăng nhập với mật khẩu sai**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Đăng nhập với mật khẩu sai.\n- **Test Case Description:** Đăng nhập với một mật khẩu sai để kiểm tra lỗi.\n- **Preconditions:** Đăng nhập.\n- **Test Steps:**\n  - **Test Step 1:** Gửi yêu cầu đăng nhập với trường password = 'wrongpassword'.\n- **Expected Result:**\n  - Status Code = 401 Unauthorized.\n  - Response Body chứa thông báo lỗi như 'Sai mật khẩu'."
    },
    {
      "question_id": "EQ5095-VN",
      "question": "422 Unprocessable Entity cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "Cú pháp yêu cầu không đúng."
    },
    {
      "question_id": "EQ5097-VN",
      "question": "Viết một test positive cho endpoint POST /users.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Test Positive: Gửi một yêu cầu đăng ký với các thông tin hợp lệ (email, password, name) và kiểm tra HTTP Status Code là `201 Created`."
    },
    {
      "question_id": "EQ5099-VN",
      "question": "Thuật ngữ 'happy path' trong testing có nghĩa là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "'Happy path' trong testing là hành trình sử dụng hệ thống mà không xảy ra lỗi hoặc vấn đề. Ví dụ, đăng ký tài khoản thành công mà không bị trùng email."
    },
    {
      "question_id": "EQ2002-VN",
      "question": "Hãy giải thích cách bạn thiết kế một **test case âm tính** cho một endpoint API yêu cầu **OAuth2 Bearer token**.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "Một test case âm tính cho endpoint yêu cầu OAuth2 là test khi không đưa token hoặc đưa token hết hạn. Cú pháp request: `GET /protected-resource` không thêm `Authorization` header. Expected Result: `403 Forbidden` hoặc `401 Unauthorized`."
    },
    {
      "question_id": "EQ2004-VN",
      "question": "Cung cấp một **test case happy-path** và một **test case error-path** cho một endpoint API hoàn tiền thanh toán.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path:**\n- **Test Case ID:** TC-009 (Refund Successful).\n- **Test Case Name:** Verify full refund processed successfully.\n- **Preconditions:** User account has sufficient balance, refund request is valid.\n- **Test Steps:**\n  1. Send `POST /refunds` request with valid payload.\n- **Expected Result:**\n  - API returns `201 Created`.\n  - Database confirmed refund amount deducted from user's balance.\n  - Email notification for successful refund sent to user.\n- **Post-conditions:** Refund record exists in DB.\n\n**Test Case Error-Path:**\n- **Test Case ID:** TC-010 (Refund Failed).\n- **Test Case Name:** Verify refund fails when insufficient balance.\n- **Preconditions:** User account has zero balance.\n- **Test Steps:**\n  1. Send `POST /refunds` request with same payload as happy path.\n- **Expected Result:**\n  - API returns `400 Bad Request` or `409 Conflict` with appropriate error message.\n  - No refund record created in DB.\n  - Email notification for failed refund not sent.\n- **Post-conditions:** No changes in user's balance."
    },
    {
      "question_id": "EQ2006-VN",
      "question": "Bạn sẽ xác thực các thay đổi **schema** trong một nâng cấp API **tương thích ngược** như thế nào?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "Cơ chế tương thích ngược (backward compatibility) đảm bảo API cũ vẫn hoạt động khi schema mới được triển khai. Xác thực thay đổi schema liên quan đến việc kiểm tra các trường hợp test cũ với các phiên bản mới của API."
    },
    {
      "question_id": "EQ2008-VN",
      "question": "Giải thích cách **mocking** có thể được sử dụng để kiểm tra một API thanh toán mà không gọi dịch vụ ngân hàng thực.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Mocking tạo một bản sao giả của API ngân hàng. Trong kiểm tra, API thanh toán sẽ gọi mock này thay vì dịch vụ thật. Ví dụ, mock được cấu hình để luôn trả `200 OK` và chứa dữ liệu giả cho đơn hàng."
    },
    {
      "question_id": "EQ2010-VN",
      "question": "Thiết kế một **boundary test** và một **invalid test** cho trường API `age` (phạm vi 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "- **Boundary Test (Valid):** Là khi nhập giá trị `18` hoặc `65`.  Ví dụ: `POST /users` với `age=18`.\n- **Invalid Test (Hết Phạm Vi):** Là khi nhập giá trị `0` hoặc `70`. Ví dụ: `POST /users` với `age=0`."
    },
    {
      "question_id": "EQ2012-VN",
      "question": "Giải thích cách bạn mô phỏng lỗi **network timeout** trong **API testing**.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "Mô phỏng lỗi mạng timeout bằng cách thêm delay giả lập vào yêu cầu gửi đến server. Ví dụ, sử dụng tool như `curl` hoặc `Postman` và thêm parameter `--timeout` hoặc `headers` với giá trị thời gian chờ cao. Sau đó, kiểm tra hành động của API khi nhận yêu cầu (ví dụ: trả về trạng thái lỗi 504, retry sau một thời gian)."
    },
    {
      "question_id": "EQ2014-VN",
      "question": "Đưa ra một ví dụ về một **precondition** API và một **step** theo sau nó.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "**Ví dụ về Precondition:** Một API yêu cầu phải có một tài khoản khách hàng được tạo (`user_id = 123`) và một đơn hàng tồn tại (`order_id = 456`) để thực hiện hành động \"Xác nhận đơn hàng\" (confirm order).\n\n**Step sau Precondition:** Sau khi đảm bảo `user_id = 123` và `order_id = 456` tồn tại trong cơ sở dữ liệu, **Bước tiếp theo** là gửi một yêu cầu `POST` tới `/orders/{order_id}/confirm` với payload xác nhận đơn hàng."
    },
    {
      "question_id": "EQ2016-VN",
      "question": "Viết một **test case** để xác thực rằng **API rate limiting** được thực thi đúng.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "Test case sẽ bao gồm các bước sau:\n- Gửi yêu cầu hợp lệ nhiều lần liên tiếp (ví dụ 10 requests trong 5s).\n- Xác minh số lượng yêu cầu cho phép (rate limit) được lưu trữ đúng.\n- Challenging: gửi yêu cầu thứ 11 và xác minh API trả về trạng thái `403 Forbidden` hoặc `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2018-VN",
      "question": "Giải thích một lợi thế của việc sử dụng **service virtualization** trong **API testing**.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "**Lợi thế:** Dịch vụ giả (service virtualization) cho phép thực hiện **testing** mà không cần tất cả các **service** thực tế sẵn có. Điều này giảm chi phí, tăng tốc độ thử nghiệm và cho phép bắt đầu **testing** sớm."
    },
    {
      "question_id": "EQ2020-VN",
      "question": "Mô tả cách thiết kế một **test case tích cực** và một **boundary test case** cho một API đăng nhập yêu cầu tên người dùng và mật khẩu.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "**Test Case Tích Cực:** Gửi một yêu cầu đăng nhập với một tên người dùng và mật khẩu hợp lệ, kiểm tra HTTP status code (`200 OK`) và đảm bảo trả về một token truy cập hợp lệ. **Boundary Test Case:** 1. **Tên người dùng Boundary:** Gửi tên người dùng là chuỗi rỗng. 2. **Mật khẩu Boundary:** Gửi mật khẩu là chuỗi rỗng hoặc quá dài vượt quá giới hạn của API. 3. **Thử sai lệch:** Gửi tên người dùng không tồn tại hoặc mật khẩu sai."
    },
    {
      "question_id": "EQ2022-VN",
      "question": "Viết một **test step** để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "**Test Step:** Gửi một yêu cầu `POST` tới endpoint `/upload` nhưng thay vì gửi một file, bạn gửi một chuỗi văn bản như `{\"content\": \"Hello, World!\"}` trong phần body của request. **Expected Result:** API phải trả về một trạng thái HTTP `415 Unsupported Media Type` và trong body của response, bạn mong đợi một thông điệp lỗi như `\"The server cannot process the request, because the entity body of the request contains data in a format that the server does not know how to parse.\"`."
    },
    {
      "question_id": "EQ2024-VN",
      "question": "Mô tả một cách để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "**Cách test:** 1. Đăng ký một trường hợp sử dụng API với yêu cầu DB chậm (tạo một bảng lớn, sử dụng một truy vấn phức tạp). 2. Sử dụng công cụ monitor như Prometheus hoặc Datadog để theo dõi thời gian thực hiện của truy vấn đó. 3. Lặp lại yêu cầu API nhiều lần và kiểm tra xem dữ liệu monitor có thể phản ánh đúng tình trạng chậm của DB hay không."
    },
    {
      "question_id": "EQ2026-VN",
      "question": "Giải thích cách bạn sẽ kiểm tra **API idempotency** cho một kịch bản **retry**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Trường hợp: API tạo tài khoản. Kiểm tra bằng cách gửi request tạo một lần, sau đó gửi lại request cùng tham số. Đáp ứng: DB chỉ có 1 bản ghi, HTTP Status `201` duy nhất."
    },
    {
      "question_id": "EQ2028-VN",
      "question": "Đưa ra một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "- **Boundary Test (Valid Edge):** Tải file kích thước 5 MB (theo yêu cầu) -> 100% dự kiến trả `200 OK` và lưu file thành công.\n- **Invalid Test:** Tải file kích thước > 10 MB -> 100% dự kiến trả `415 Unsupported Media Type` hoặc `413 Payload Too Large`."
    },
    {
      "question_id": "EQ2030-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "Test Case: **Xử lý lỗi khi email bị thiếu**\n- **Test Scenario:** Gửi yêu cầu đăng ký với body `{ \"username\": \"user123\", \"password\": \"password123\" }` (bỏ campo `email`).\n- **Test Steps:**\n  1. Gửi yêu cầu qua API.\n- **Expected Result:**\n  - Trả về trạng thái HTTP `400 Bad Request`.\n  - Nội dung response chứa thông báo lỗi cho trường `email` (ví dụ: `{\"error\": {\"email\": [\"Email is required.\"]}}`).\n  - Không tạo được tài khoản mới."
    },
    {
      "question_id": "EQ2032-VN",
      "question": "Bạn sẽ thiết kế một **test** để xác thực logic **retry** như thế nào khi một API thỉnh thoảng trả về **503**?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "1. **Cài đặt:** Sử dụng một công cụ như **Locust** hoặc **K6** để tạo ra một đợt yêu cầu (ramp-up) lên API.\n2. **Thi hành:** Trong đợt thử nghiệm, giả lập một số yêu cầu bị **timeout** (để API trả về **503 Service Unavailable**).\n3. **Xác thực:** Sau khi đợt thử nghiệm hoàn thành, kiểm tra **log** hoặc **database** để xác định xem các yêu cầu bị **timeout** đã được **retry** thành công hay không.\n4. **Đường thử nghiệm:** Đảm bảo hệ thống **retry** được kích hoạt và có cơ chế giới hạn số lần **retry** để tránh **infinite loop**.\n\n**Lợi ích:** Giúp đảm bảo API có khả năng tự phục hồi (self-healing) khi gặp lỗi tạm thời."
    },
    {
      "question_id": "EQ2034-VN",
      "question": "Viết một **test case** xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "**Test Case:** Log Correlation via Trace ID.\n- **Test Case ID:** TC-LOG-001.\n- **Test Case Name:** Verify logs linked to trace ID header.\n- **Preconditions:** API configured with tracing enabled, trace ID 'TRACE-123' available.\n- **Test Steps:**\n  1. Send request to `/process` with `X-Trace-ID: TRACE-123` header.\n  2. In logs, search for `trace_id: TRACE-123`.\n- **Expected Result:** Log entries found with matching trace ID."
    },
    {
      "question_id": "EQ2036-VN",
      "question": "Thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting** khi có nhiều máy khách tham gia.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "**Test Case:** `Verify Rate Limit Enforcement - Bursty Requests`.\n\n- **Preconditions:** Máy khách A được cấu hình với giới hạn 100 req/min.\n- **Test Steps:**\n  1. Gửi 50 yêu cầu liên tục trong 1 phút.\n  2. Sau khi vượt qua giới hạn, tiếp tục gửi yêu cầu trong 5 phút.\n- **Expected Result:**\n  - Trước khi vượt qua giới hạn: `200 OK` cho tất cả yêu cầu.\n  - Sau khi vượt qua giới hạn: Yêu cầu thứ 51 và sauwards bị chặn với `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2038-VN",
      "question": "Mô tả một **test case tích cực** và một **test case âm tính** cho một endpoint API gửi mã **SMS**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "*   **Test Case Tích Cực (Positive):** Gửi yêu cầu `POST /send-sms` với số điện thoại hợp lệ (`+8498765432`) và mã SMS ngắn bất kỳ (e.g., `12345`). Đợi xác nhận, kiểm tra trạng thái HTTP (e.g., `200 OK`), và nội dung phản hồi để xác nhận mã đã được gửi thành công.\n*   **Test Case Âm Tính (Negative):** Gửi yêu cầu `POST /send-sms` với số điện thoại trống hoặc không hợp lệ (e.g., `1234567`). Đợi xác nhận, kiểm tra trạng thái HTTP (e.g., `400 Bad Request` hoặc `500 Internal Server Error`), và nội dung phản hồi để xác nhận API đã xử lý lỗi phù hợp."
    },
    {
      "question_id": "EQ2040-VN",
      "question": "Giải thích một lợi thế của việc **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Lợi thế là **mock** cho phép chạy các test về lỗi mạng (timeout, 500 error) mà không phụ thuộc vào kết nối internet ổn định, giúp tăng độ tin cậy và tốc độ của pipeline test."
    },
    {
      "question_id": "EQ2042-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi khi API trả về **JSON** bị định dạng sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "**Test Case:** `Verify Invalid JSON Response`\n\n- **Preconditions:** API đang chạy.\n- **Test Steps:**\n  1. Gửi yêu cầu GET bình thường.\n  2. Gửi yêu cầu với JSON Response bị định dạng sai (thiếu dấu ngoặc kép, từ khóa sai).\n- **Expected Result:**\n  - API phải trả về **HTTP Status Code 400 Bad Request**.\n  - Response Body phải chứa thông báo lỗi rõ ràng về vấn đề định dạng JSON."
    },
    {
      "question_id": "EQ2044-VN",
      "question": "Thiết kế một **test step** để xác nhận các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "**Test Step:**\n1. **Action:** Gửi một yêu cầu hợp lệ đến API.\n2. **Expected:**\n   - **Status Code:** `200 OK` hoặc mã trạng thái tương ứng.\n   - **Header:** `X-RateLimit-Remaining` phải có trong phản hồi HTTP.\n   - **Value:** Giá trị của `X-RateLimit-Remaining` phải chính xác (ví dụ: `10` nếu giới hạn là 10 yêu cầu/phút)."
    },
    {
      "question_id": "EQ2046-VN",
      "question": "Mô tả một lợi thế của việc tách dữ liệu **test** khỏi logic **test** trong **API testing**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Lợi thế là dữ liệu **test** không bị ảnh hưởng bởi kết quả của các trường hợp **test** khác, đảm bảo tính độc lập và khả năng tái tạo kết quả **test** chính xác."
    },
    {
      "question_id": "EQ2048-VN",
      "question": "Viết một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "### **Test Case: Cache Unavailable**\n- **Test Case ID:** TC-007\n- **Test Case Name:** Verify graceful degradation when cache service is unavailable.\n- **Preconditions:**\n  - Cache API (e.g., Redis, Memcached) is not reachable from API gateway.\n- **Test Steps:**\n  1. Send `GET /products` request to API.\n  2. Confirm API returns `200 OK` or an acceptable status code.\n- **Post-conditions/Expected Results:**\n  - Verify data is not served from cache. Instead, API should hit the backend database.\n  - Check logs to confirm graceful degradation without errors."
    },
    {
      "question_id": "EQ2050-VN",
      "question": "Giải thích một cách để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Xác thực logging: 1) Sử dụng các filter bảo mật trên logstash/kafka. 2) Đánh dấu các trường nhạy cảm bằng prefix như \"*****\". 3) Lưu trữ logs riêng biệt cho dữ liệu bảo mật."
    },
    {
      "question_id": "EQ2052-VN",
      "question": "Cung cấp một **test case âm tính** và một **boundary test case** cho một trường tiền tệ phải khớp với mã **ISO 4217**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case Âm Tính:** Đặt trường tiền tệ với giá trị `USD` và thực hiện thanh toán. Đảm bảo hệ thống không báo lỗi và chuyển đổi tiền tệ thành USD.\n- **Boundary Test Case:** Đặt trường tiền tệ ở biên giới (ví dụ: `EUR` và `USD`), thực hiện thanh toán và kiểm tra kết quả."
    },
    {
      "question_id": "EQ2054-VN",
      "question": "Viết một **test case** để xác thực hành vi API dưới tình trạng mất gói mạng.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "**Test Case:** Kiểm tra tính ổn định khi mạng bị gián đoạn.\n- **Preconditions:** API đang chạy, giả lập mất gói mạng.\n- **Steps:**\n  - Gửi yêu cầu → mong đợi `503 Service Unavailable`.\n  - Đợi 10s → phục hồi kết nối → tiếp tục xử lý yêu cầu.\n- **Expected:** API phải phục hồi tự động."
    },
    {
      "question_id": "EQ2056-VN",
      "question": "Mô tả một phương pháp để xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Phương pháp: 1) Sử dụng **ID test** cố định để tạo dữ liệu **test**. 2) Thực hiện **API test** tạo và sau đó xóa dữ liệu đó. 3) Kiểm tra DB trước và sau test để xác nhận dữ liệu đã bị xóa hoàn toàn."
    },
    {
      "question_id": "EQ2058-VN",
      "question": "Viết một **test case** để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "**Test Case: Rollback Multi-Step Transaction**\n- **Preconditions:** DB sẵn sàng, thử nghiệm được thiết lập.\n- **Test Steps:**\n  1. Thực hiện giao dịch nhiều bước (A -> B -> C).\n  2. Thừa hưởng bước bất kỳ (đặt giá trị DB).\n  3. Thử nghiệm: Đặt bước C thất bại (gán giá trị không hợp lệ).\n- **Expected Result:** DB được rollback hoàn toàn, trạng thái trước khi bắt đầu giao dịch được bảo tồn. Không có bước nào bị lưu ngoài cơ chế rollback."
    },
    {
      "question_id": "EQ2060-VN",
      "question": "Giải thích một cách tiếp cận để xác thực các thông báo lỗi tuân theo một **JSON schema** nhất quán trên tất cả các **endpoint**.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "1. **Thiết lập cơ sở dữ liệu**: Đảm bảo các trường lỗi tồn tại trong schema JSON và được ánh xạ với các lỗi cơ bản (e.g., `400-BAD_REQUEST`, `404-NOT_FOUND`, `500-INTERNAL_SERVER_ERROR`).\n2. **Tạo yêu cầu lỗi**: Sử dụng công cụ như Postman hoặc Insomnia để gửi yêu cầu bất hợp lệ lên từng endpoint. Ví dụ: gửi request `GET` cho một resource không tồn tại, hoặc gửi request với trường dữ liệu không hợp lệ.\n3. **Xác thực phản hồi lỗi**: Sử dụng công cụ kiểm tra JSON như `jq` hoặc trực tiếp trong script để xác minh:\n   - **Mã trạng thái HTTP**: Là một trong các mã lỗi cơ bản (400, 404, 500).\n   - **Thân phản hồi (Body)**: Phải tuân theo **JSON schema** đã định nghĩa. Ví dụ, một lỗi `400` phải có trường `error` với thông tin lỗi cụ thể, dạng `string`.\n   - **Header**: Có thể cần kiểm tra các thông số như `Content-Type` hoặc các thông báo đặc biệt như `Retry-After`.\n4. **Thẻ nghiệm và báo cáo lỗi**: Nếu phản hồi lỗi không đúng, báo cáo lỗi với thông tin chi tiết về lỗi cơ bản nào không được đáp ứng.\n5. **Lặp lại với các trường hợp lỗi khác nhau**: Để đảm bảo schema JSON có thể xác thực được mọi loại lỗi có thể xảy ra trên các endpoint khác nhau."
    },
    {
      "question_id": "EQ3002-VN",
      "question": "Viết một test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "### **Test Case: Đăng Nhập, Làm Mới Token, Truy Cập Bảo Vệ**\n- **Test Case ID:** TC-002\n- **Test Case Name:** Xác thực đăng nhập, làm mới token, truy cập API được bảo vệ.\n- **Preconditions:**\n  - Hệ thống API đã được bật và sẵn sàng.\n  - Có một user có quyền đủ để truy cập API được bảo vệ.\n- **Test Steps:**\n  1. **Đăng Nhập:** Gửi yêu cầu `POST /login` với email/password hợp lệ. Verify response có `token_access` và `token_refresh`.\n  2. **Làm Mới Token:** Sử dụng `token_refresh` gửi yêu cầu `POST /refresh-token` để nhận token mới. Verify token mới được trả về và có giá trị.\n  3. **Truy Cập Bảo Vệ:** Sử dụng `token_access` mới để gửi yêu cầu `GET /protected-resource`. Verify API trả về trạng thái `200 OK` và dữ liệu yêu cầu.\n- **Expected Results:**\n  - Yêu cầu đăng nhập và làm mới token đều phải thành công.\n  - Yêu cầu truy cập API được bảo vệ phải thành công khi sử dụng token mới.\n  - Token cũ không thể sử dụng để truy cập API bảo vệ."
    },
    {
      "question_id": "EQ3004-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Prevent Token Issuance on Failed Login**\n- **Preconditions:** API hỗ trợ refresh token và đăng nhập đã bật.\n- **Action:**\n  - Gửi yêu cầu đăng nhập với thông tin sai.\n- **Expected:** 403 Forbidden hoặc 401 Unauthorized, không có refresh token được phát hành trong trường hợp đó."
    },
    {
      "question_id": "EQ3006-VN",
      "question": "Giải thích cách bạn sẽ xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Tôi sẽ tạo một cơ sở dữ liệu chứa thông tin về mã nghiệp vụ và trạng thái HTTP. Sau đó, tôi sẽ tạo các trường hợp kiểm tra bằng cách gọi API với các mã nghiệp vụ khác nhau và xác minh rằng API trả về đúng mã trạng thái HTTP tương ứng (ví dụ: `201` cho tạo đơn hàng thành công, `409` cho đơn hàng tồn tại)."
    },
    {
      "question_id": "EQ3008-VN",
      "question": "Viết một test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "### **Test Case: Tạo Đơn Hàng → Thanh Toán → Hoàn Tiền**\n- **Preconditions:**\n  - Tài khoản khách hàng sẵn tiền.\n  - Sản phẩm tồn kho.\n- **Test Steps:**\n  1. **Tạo ĐH:** `POST /orders` với sản phẩm A, B.\n  2. **Thanh Toán:** `POST /payments` cho đơn hàng vừa tạo.\n  3. **Hoàn Tiền:** `POST /refund` cho đơn hàng ID biết.\n- **Expected:** ĐH hoàn thành, trạng thái DB → DB → DB."
    },
    {
      "question_id": "EQ3010-VN",
      "question": "Giải thích một test case xác thực việc làm mới token hoạt động trên nhiều microservice.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case xác thực: 1) Gửi yêu cầu đăng nhập → nhận token từ Service Authentication. 2) Sử dụng token gọi API protected trên Service A → 200 OK. 3) Service A gọi API khác trên Service B → Service B xác thực token → 200 OK. 4) Test token hết hạn → 401 Unauthorized."
    },
    {
      "question_id": "EQ3012-VN",
      "question": "Viết một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "### **Test Case: Xác Thực và Mã Lỗi**\n- **Test Case Name:** Valid + Invalid Authentication (Token).\n- **Test Case ID:** TC-007.\n- **Preconditions:** API đang hoạt động, có 1 user biết password và 1 token expired.\n\n- **Test Steps:**\n  - **Valid:** Gửi request với token hợp lệ → `200 OK` với response user data.\n  - **Invalid Token:** Gửi request với token hết hạn → `400 Bad Request` với message lỗi.\n  - **Invalid Payload:** Gửi request với payload không đúng format → `400 Bad Request` với message lỗi.\n\n- **Expected Results:**\n  - Response `200 OK` chỉ khi token hợp lệ.\n  - Mã lỗi `400` phải được trả về khi token hoặc payload không hợp lệ."
    },
    {
      "question_id": "EQ3014-VN",
      "question": "Thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Test Case:** `Test Refresh Token Expiry`.\n2. **Preconditions:**\n   - Có một refresh token đã hết hạn (ví dụ đã quá thời hạn 1 giờ).\n   - Access token liên quan đã hết hạn.\n3. **Test Steps:**\n   - Gửi yêu cầu refresh token đã hết hạn đến endpoint token refresh.\n4. **Expected Result:**\n   - API trả về trạng thái HTTP `403 Forbidden` hoặc `401 Unauthorized`.\n   - Không cấp được access token mới."
    },
    {
      "question_id": "EQ3016-VN",
      "question": "Giải thích một bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Bước 1:** Đăng nhập với một tài khoản xác thực và lưu trữ cookie của session được tạo ra. 2. **Bước 2:** Sử dụng cookie này gửi một yêu cầu GET đến một endpoint được bảo vệ (VD: `/protected/data`). 3. **Bước 3:** Sau khi yêu cầu được xử lý, yêu cầu hủy bỏ session được gửi đến server. 4. **Bước 4:** Một yêu cầu khác được gửi đến endpoint bảo vệ sử dụng cookie cũ. 5. **Bước 5:** Kiểm tra trạng thái HTTP và nội dung đáp ứng (VD: mã trạng thái `403 Forbidden` hoặc `404 Not Found`, nội dung JSON trả về không chứa dữ liệu)."
    },
    {
      "question_id": "EQ3018-VN",
      "question": "Viết một test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "### **Test Case: Đăng ký và Đăng nhập**\n- **Test Case ID:** TC-001\n- **Test Case Name:** Đăng ký mới -> Xác minh email -> Đăng nhập thành công.\n- **Preconditions:** Server API đang hoạt động.\n- **Test Steps:**\n  1. **Đăng ký:** Gửi yêu cầu POST tới `/users` với thông tin tên, email, password. Ví dụ: `POST /users` với body `{ \"name\": \"John Doe\", \"email\": \"john@example.com\", \"password\": \"Password123\" }`.\n  2. **Xác minh Email:** Không có endpoint trực tiếp xác minh email, nhưng giả sử hệ thống sẽ gửi email đến địa chỉ đăng ký. Vì test tự động, không thể chờ email, nên giả sử email đã được xác minh trước khi chạy test này.\n  3. **Đăng nhập:** Gửi yêu cầu POST tới `/login` với email và password được đăng ký. Ví dụ: `POST /login` với body `{ \"email\": \"john@example.com\", \"password\": \"Password123\" }`.\n- **Expected Results:**\n  - **Đăng ký:** Trả về `201 Created` và một chuỗi ID người dùng (ví dụ `{\"id\": \"user-123\"}`).\n  - **Đăng nhập:** Trả về `200 OK` với một chuỗi token xác thực (ví dụ `{\"token\": \"eyJhbGciOiJIUzI1NiJ9\"}`) và một chuỗi ID người dùng."
    },
    {
      "question_id": "EQ3020-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Bước 1:** Đăng nhập không đúng lần đầu → hệ thống gửi email hoặc SMS xác thực.\n2. **Bước 2:** Người dùng nhập mã xác thực → hệ thống yêu cầu đáp ứng (CAPTCHA).\n3. **Bước 3:** Sau khi thành công, yêu cầu nhập mật khẩu mới và xác nhận lại.\n4. **Bước 4:** Kiểm tra: mật khẩu cũ không thể dùng lại, mới đủ độ phức tạp và không trùng với trước đó."
    },
    {
      "question_id": "EQ3022-VN",
      "question": "Viết một test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "**Test Case: Quản lý Người dùng**\n- **Test Case ID:** TC-USER-001\n- **Test Case Name:** Xác thực tạo, cập nhật và xem hồ sơ người dùng.\n- **Test Case Description:** Kiểm tra các chức năng cơ bản của người dùng (tạo, cập nhật, xem hồ sơ).\n\n### **Test Case Steps:**\n- **Test Case 1: Tạo Người dùng**\n  - **Preconditions:** Đăng nhập với quyền quản trị.\n  - **Test Steps:**\n    - Gọi API `/users` với request body chứa thông tin người dùng (username, email, full_name).\n    - Verify: `200 OK`, dữ liệu được tạo thành công trong cơ sở dữ liệu.\n  - **Expected Result:**\n    - Người dùng mới được tạo và có thể tìm thấy trong hệ thống.\n\n- **Test Case 2: Cập nhật Hồ sơ**\n  - **Preconditions:** Người dùng tồn tại.\n  - **Test Steps:**\n    - Gọi API `/users/{id}` với phương thức `PUT`.\n    - Verify: `200 OK` nếu cập nhật thành công.\n  - **Expected Result:**\n    - Thông tin được cập nhật trong cơ sở dữ liệu.\n\n- **Test Case 3: Truy xuất Hồ sơ**\n  - **Preconditions:** Người dùng tồn tại.\n  - **Test Steps:**\n    - Gọi API `/users/{id}` với phương thức `GET`.\n    - Verify: `200 OK` nếu tìm thấy, nội dung chính xác.\n  - **Expected Result:**\n    - Dữ liệu về người dùng được trả về trong phản hồi API."
    },
    {
      "question_id": "EQ3024-VN",
      "question": "Giải thích một bài kiểm tra để xác thực refresh token không thể được sử dụng sau khi đăng xuất.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập và nhận token**: Đăng nhập và nhận token access và refresh token.\n2. **Đăng xuất**: Gọi API đăng xuất và lưu lại refresh token.\n3. **Thử refresh**: Sử dụng refresh token vừa nhận để gửi yêu cầu refresh token.\n4. **Kiểm tra trạng thái**: Đảm bảo API trả về `403 Forbidden` hoặc `401 Unauthorized` vì đã đăng xuất."
    },
    {
      "question_id": "EQ3026-VN",
      "question": "Viết một test case xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "### **Test Case: Mã Lỗi Hợp Lệ**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Xác thực ánh xạ mã lỗi `AUTH_EXPIRED` → trạng thái HTTP.\n- **Preconditions:** API được cấu hình với module xác thực token.\n- **Test Steps:**\n  - **Scenario 1 (Positive):** Gửi yêu cầu với token hợp lệ → `200 OK`.\n  - **Scenario 2 (Negative):** Sử dụng token đã hết hạn → **Expected:** `HTTP 401 Unauthorized`.\n- **Post-conditions:** DB không bị ảnh hưởng.\n- **Test Case Owner:** [Tên người thực hiện].\n- **Test Case Status:** [Đã thực thi hoặc cần thực thi]."
    },
    {
      "question_id": "EQ3028-VN",
      "question": "Giải thích một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Một bài kiểm tra thất bại xác minh email: Gửi yêu cầu xác thực với token hết hạn hoặc không tồn tại. Thì trả lời 401 Unauthorized hoặc 400 Bad Request."
    },
    {
      "question_id": "EQ3030-VN",
      "question": "Viết một test case cấp độ khó chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "### **Test Case: Loan Approval Flow**\n- **Test Case ID:** TC-LOAN-001\n- **Test Case Name:** Chuỗi yêu cầu vay tiền với tín dụng chấp nhận và từ chối.\n- **Preconditions:**\n  - Có tài khoản khách hàng với ID `KH-123`.\n  - Hệ thống có sẵn dữ liệu về các khách hàng (tín dụng tốt, xấu, chưa có).\n- **Test Steps:**\n  1. **Đăng ký vay:** Gửi `POST /loans` với số tiền và kỳ hạn hợp lý, thuộc về `KH-123`. Expected: `201 Created` với ID đơn vay.\n  2. **Tín dụng kiểm tra:** Gửi `POST /credit-check` với ID khách hàng từ bước 1. Expected: `200 OK` với kết quả tín dụng.\n  3. **Phê duyệt vay:** Với tín dụng tốt, gửi `PUT /loans/{id}` với trạng thái `approved`. Expected: `200 OK`. Với tín dụng xấu, trạng thái `rejected`. Expected: `200 OK`.\n- **Post-condition:** Dữ liệu cơ sở dữ liệu cập nhật phản ánh trạng thái vay của khách hàng."
    },
    {
      "question_id": "EQ3032-VN",
      "question": "Thiết kế một test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "**Test Case: Quản lý Mật khẩu**\n- **Bước 1: Đăng ký**\n  - **Test Scenario 1:** Đăng ký thành công với email và password hợp lệ.\n  - **Test Scenario 2:** Đăng ký với email đã tồn tại.\n  - **Test Scenario 3:** Đăng ký thiếu thông tin bắt buộc.\n- **Bước 2: Đặt lại mật khẩu**\n  - **Test Scenario 4:** Đặt lại mật khẩu thành công với email và câu hỏi bảo vệ hợp lệ.\n  - **Test Scenario 5:** Đặt lại mật khẩu với email không tồn tại.\n- **Bước 3: Đăng nhập**\n  - **Test Scenario 6:** Đăng nhập thành công với email và password đúng.\n  - **Test Scenario 7:** Đăng nhập sai password.\n  - **Test Scenario 8:** Đăng nhập với tài khoản bị khóa."
    },
    {
      "question_id": "EQ3034-VN",
      "question": "Viết một test case chuỗi các endpoint tải lên file, quét virus và tải xuống.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "**Test Case: Upload & Virus Scan**\n- **Test Case ID:** TC-FILE-001\n- **Test Case Name:** Chuỗi upload file, quét virus và tải xuống.\n- **Preconditions:** File mẫu sẵn, dịch vụ virus scan online accessible.\n- **Test Steps:**\n  1. **Upload File:** Request POST đến `/files` với file mẫu.\n  2. **Quét Virus:** Sử dụng dịch vụ virus scan online (API) để quét ID file vừa tải lên.\n  3. **Tải Xuống:** Request GET đến `/files/<ID_FILE>` để tải xuống file gốc.\n- **Expected Results:**\n  - File tải lên thành công.\n  - Quét virus trả về kết quả `Positive` (file an toàn) hoặc `Negative` (file bị nhiễm).\n  - File tải xuống trùng với bản gốc."
    },
    {
      "question_id": "EQ3036-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn việc sử dụng lại refresh token.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Một bài kiểm tra chuỗi cần thực hiện các bước: 1) Mua token refresh. 2) Sử dụng token refresh để nhận token mới. 3) Cố gắng sử dụng token refresh đã cũ trong yêu cầu tiếp theo. Nếu API từ chối với mã lỗi 403 hoặc 401, và token mới vẫn hoạt động, thì bài kiểm tra đã thành công."
    },
    {
      "question_id": "EQ3038-VN",
      "question": "Viết một test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Mua Hàng Online**\n- **Preconditions:** Sản phẩm sẵn, User có tài khoản và đủ tiền.\n- **Test Steps:**\n  - **Search:** API tìm kiếm sản phẩm với từ khóa \"Laptop\".\n  - **Add to Cart:** Sử dụng ID sản phẩm tìm được để thêm vào giỏ.\n  - **Checkout:** Tạo đơn hàng từ giỏ, nhập địa chỉ và thanh toán.\n- **Expected Result:** Đơn hàng được tạo thành công, trạng thái payment là'success'."
    },
    {
      "question_id": "EQ3040-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn tấn công chiếm đoạt session API.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Một bài kiểm tra chuỗi xác thực việc ngăn chặn tấn công chiếm đoạt session API bằng cách tạo ra các yêu cầu gửi token session khác nhau. \n- **Test Case 1:** Gửi yêu cầu xác thực với token session hợp lệ và kiểm tra phản hồi 200 OK. \n- **Test Case 2:** Gửi yêu cầu xác thực với token session đã bị hỏng (expired hoặc không tồn tại). Kiểm tra phản hồi 401 Unauthorized hoặc 403 Forbidden. \n- **Test Case 3 (Chuẩn hóa):** Sử dụng công cụ như Insomnia hoặc Postman tạo ra 100-200 yêu cầu gửi token session khác nhau. \n- **Test Case 4 (Tấn công):** Sử dụng công cụ như Burp hoặc Postman để gửi yêu cầu chiếm đoạt token session từ request khác. \n- **Expected Result:** Tất cả các yêu cầu gửi token session hợp lệ phải được chấp nhận. Tất cả các yêu cầu gửi token session đã bị hỏng phải bị từ chối. Không có yêu cầu chiếm đoạt session nào phải được chấp nhận."
    },
    {
      "question_id": "EQ3042-VN",
      "question": "Cung cấp chính xác một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "**Test Case: Đồng Thời Lạc Quan với ETag**\n- **Test Scenario:** Sửa đổi một tài liệu → Lấy ETag → Cập nhật khác → Thử lại với ETag cũ → Đợi optimistic concurrency phát sinh.\n- **Expected:** Cập nhật thất bại với `409 Conflict` nếu ETag cũ không khớp."
    },
    {
      "question_id": "EQ3044-VN",
      "question": "Thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ: POST /exports -> thăm dò GET /jobs/{id} cho đến khi hoàn thành -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Bài kiểm tra phải mô phỏng quá trình xuất file lâu, theo dõi trạng thái job, và chỉ yêu cầu tải file khi job hoàn thành."
    },
    {
      "question_id": "EQ3046-VN",
      "question": "Cung cấp một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code: /authorize -> /token -> gọi tài nguyên với scope bị thiếu.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "**Test Case: OAuth2 Authorization Code - Tiêu cực**\n- **Test Case Name:** Đăng ký quyền không tồn tại.\n- **Test Case ID:** TC-OAUTH-008.\n- **Test Case Version:** 1.0.\n- **Test Case Status:** Chưa thực hiện.\n\n- **Test Case Description:**\n  1. Người dùng xác thực qua /authorize với scope=\"read:messages\".\n 2. Sau khi nhận authorization code, thực hiện trao đổi mã lấy access token qua /token endpoint.\n- **Test Case Steps:**\n  - **Bước 1:** Gửi yêu cầu POST đến /token với grant_type=\"authorization_code\" và kèm theo authorization code.\n  - **Bước 2:** Trong cơ sở dữ liệu mock, giả lập trường yêu cầu quyền bị thiếu (ví dụ: không có quyền \"write:messages\").\n- **Test Case Expected Result:**\n  - **Kết quả Thử nghiệm:** HTTP Status Code 400 Bad Request hoặc 403 Forbidden được trả về.\n  - **Kết quả Hậu kiểm:** Lỗi xảy ra khi kiểm tra nội dung response."
    },
    {
      "question_id": "EQ3048-VN",
      "question": "Viết một bài kiểm tra chuỗi bao gồm việc tạo charge幂等 (idempotent charge creation) với Idempotency-Key trên các endpoint thử lại và hoàn tiền.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. **Charge Creation (idempotent):**\n    * **Action:** `POST /charges` với dữ liệu charge.\n    * **Expected:** Charge được tạo một lần duy nhất với cùng Idempotency-Key. Thử lặp nhiều lần vẫn chỉ tạo 1 charge.\n    * **Negative:** Dữ liệu không hợp lệ (e.g., thiếu card token) → `400 Bad Request`.\n\n2. **Charge Update (idempotent):**\n    * **Action:** `PUT /charges/{chargeId}` với trạng thái mới (e.g., từ `pending` → `captured`).\n    * **Expected:** Trạng thái của charge được cập nhật một lần duy nhất. Thử update trạng thái đã tồn tại → `200 OK` nhưng không thay đổi trạng thái.\n\n3. **Charge Cancel (idempotent):**\n    * **Action:** `DELETE /charges/{chargeId}` hoặc `POST /charges/{chargeId}/cancel`.\n    * **Expected:** Charge bị hủy một lần duy nhất. Thử hủy charge đã hủy → `200 OK` nhưng không thay đổi trạng thái.\n\n4. **Refund (idempotent):**\n    * **Action:** `POST /charges/{chargeId}/refunds` với số tiền hoàn tiền.\n    * **Expected:** Refund được tạo một lần duy nhất với cùng Idempotency-Key. Thử lặp nhiều lần vẫn chỉ tạo 1 refund."
    },
    {
      "question_id": "EQ3050-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi cho quy trình xử lý file: tải lên -> POST /process -> thăm dò trạng thái -> tải xuống, bao gồm cả việc xử lý 202.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "### **Bài kiểm tra chuỗi xử lý file**\n- **Đầu tiên: Tải file lên**\n  - **Bước 1:** Sử dụng tool như `curl` hoặc `requests` thực hiện yêu cầu `POST` lên endpoint như `/upload`.\n  - **Đầu vào:** Chia sẻ một tệp tin cụ thể (ví dụ, một ảnh nhỏ) trong dự án.\n  - **Lời giải:** Yêu cầu phải được chấp nhận với trạng thái `201 Created` hoặc `200 OK` kèm theo ID file.\n\n- **Tiếp theo: Xử lý file**\n  - **Bước 2:** Sử dụng ID file từ bước trước, gửi yêu cầu `POST` tới endpoint xử lý như `/process/{file_id}`.\n  - **Đầu vào:** ID file từ bước trước.\n  - **Lời giải:** Endpoint này sẽ thực hiện các tác vụ như chuyển đổi định dạng, thêm watermark, hoặc bất kỳ logic nào liên quan đến file. Yêu cầu này phải được chấp nhận với trạng thái `202 Accepted` (nếu cần thời gian xử lý sau) hoặc `200 OK`.\n\n- **Cuối cùng: Tải trạng thái xuống**\n  - **Bước 3:** Sử dụng ID file, gửi yêu cầu `GET` tới endpoint như `/status/{file_id}` hoặc `/process/{file_id}/status`.\n  - **Lời giải:** Yêu cầu này sẽ trả về trạng thái hiện tại của file sau khi xử lý, bao gồm cả thông tin về việc đã hoàn thành hay chưa. Yêu cầu này phải được chấp nhận với trạng thái phù hợp (ví dụ, `200 OK` nếu đã hoàn thành, `202 Accepted` nếu đang xử lý).\n\n- **Cục diện cuối:** Tải file xử lý ra**\n  - **Bước 4:** Sử dụng ID file từ bước trước, gửi yêu cầu `GET` tới endpoint như `/processed/{file_id}`.\n  - **Lời giải:** Yêu cầu này sẽ tải về tệp tin đã được xử lý. Yêu cầu này phải được chấp nhận với trạng thái `200 OK` và nội dung tải về phải là bản xử lý thành công của file gốc."
    },
    {
      "question_id": "EQ3052-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "### **Bài Kiểm Tra: Hủy Bỏ Session SSO**\n- **Test Case:** Đăng nhập SSO → Truy cập API → Hủy Bỏ Session → Thử Lại API.\n- **Expected:** API phải trả `403 Forbidden` hoặc yêu cầu xác thực lại cho yêu cầu tiếp theo."
    },
    {
      "question_id": "EQ3054-VN",
      "question": "Viết một test case chuỗi cho việc thực hiện đơn hàng một phần: tạo đơn hàng -> dự trữ hàng tồn kho -> ship một phần -> hủy phần còn lại và hoàn tiền chênh lệch.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "**Test Case: Tạo Đơn Hàng Một Phần**\n- **Test Case ID:** TC_SHIP_PARTIAL\n- **Test Case Name:** Tạo đơn hàng, ship một phần và hủy phần còn lại.\n- **Preconditions:**\n  - Có sẵn hàng tồn kho cho sản phẩm A và B.\n  - Tạo một đơn hàng có 3 sản phẩm (2A, 1B).\n- **Test Steps:**\n  1. Tạo đơn hàng.\n  2. Ghi nhận ID đơn hàng và trạng thái.\n  3. Ship 2 sản phẩm A.\n  4. Kiểm tra trạng thái đơn hàng và hàng tồn kho.\n  5. Hủy phần còn lại của đơn hàng (sản phẩm B).\n  6. Kiểm tra trạng thái đơn hàng và hàng tồn kho sau khi hủy.\n  7. Xác minh tiền chênh lệch được hoàn lại cho khách hàng.\n- **Post-conditions:** Xóa đơn hàng khỏi cơ sở dữ liệu."
    },
    {
      "question_id": "EQ3056-VN",
      "question": "Cung cấp chính xác một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA: POST /login -> POST /2fa/verify với mã sai -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Test Case:** `Verify 2FA Failure`.\n2. **Action:** Send `POST /login` with valid credentials, then `POST /2fa/verify` with an invalid 2FA code.\n3. **Expected:** `400 Bad Request` or `401 Unauthorized`."
    },
    {
      "question_id": "EQ3058-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê (với các xác nhận tổng số đếm).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Test Case: 1) Tạo trang 10 bản ghi. 2) Liệt kê → kiểm tra tổng số = 10. 3) Xóa 3 bản ghi. 4) Liệt kê → kiểm tra tổng số = 7. 5) Kiểm tra từng bản ghi đã xóa không còn trong danh sách."
    },
    {
      "question_id": "EQ3060-VN",
      "question": "Viết một bài kiểm tra chuỗi cho tính dính session (session stickiness): đăng nhập -> các cuộc gọi tiếp theo qua load balancer -> đăng xuất -> xác minh không có node nào chấp nhận token cũ.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "**Test Case: Session Stickiness**\n- **Test Case:** Đăng nhập → Gọi API → Load Balancer → Node 1 → Node 2 → Node 3 → Đăng xuất.\n- **Expected:** Token chỉ được chấp nhận trên Node 1. Node 2/3 phải trả 403 Forbidden."
    },
    {
      "question_id": "EQ4002-VN",
      "question": "Viết một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản: tạo → kích hoạt → tạm ngừng → kích hoạt lại → xóa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "Test Case: Quản lý trạng thái tài khoản.\n- **Test Case 1 (Tạo & Kích hoạt):** Gửi yêu cầu tạo tài khoản → xác nhận trạng thái là `active`.\n- **Test Case 2 (Tạm ngừng & Kích hoạt lại):** Đổi trạng thái → gửi yêu cầu kích hoạt lại → trạng thái trở lại `active`.\n- **Test Case 3 (Xóa):** Xoá tài khoản → trạng thái DB → `deleted`.\n- **Test Case 4 (Trạng thái bất hợp lệ):** Gửi yêu cầu với trạng thái không tồn tại → API trả lỗi `400`."
    },
    {
      "question_id": "EQ4004-VN",
      "question": "Thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Test Case 1: Success** (giao dịch thành công): Tích hợp các API chuyển tiền (Step 1), xác minh tiền chuyển đến.\n2. **Test Case 2: Fail tại bước 2** (giao dịch thất bại khi chuyển tiền): API bước 2 (chuyển tiền) giả lập lỗi cơ bản, xác minh giao dịch được **rollback** hoàn toàn.\n3. **Test Case 3: Fail tại bước 3** (giao dịch thất bại khi xác nhận giao dịch): API bước 3 (xác nhận giao dịch) giả lập lỗi cơ bản, xác minh giao dịch được **rollback** hoàn toàn.\n4. **Test Case 4: Fail ở bước 2 nhưng bước 3 được gọi trước khi rollback** (giao dịch thất bại khi chuyển tiền nhưng bước 3 đã được gọi): API bước 2 (chuyển tiền) giả lập lỗi cơ bản, bước 3 được gọi trước khi rollback, xác minh giao dịch được **rollback** hoàn toàn.\n5. **Test Case 5: Fail ở bước 3 nhưng bước 2 được gọi trước khi rollback** (giao dịch thất bại khi xác nhận giao dịch nhưng bước 2 đã được gọi): API bước 3 (xác nhận giao dịch) giả lập lỗi cơ bản, bước 2 được gọi trước khi rollback, xác minh giao dịch được **rollback** hoàn toàn."
    },
    {
      "question_id": "EQ4006-VN",
      "question": "Viết một **test** xác thực chuỗi nhiều dịch vụ: đăng nhập → tạo đơn hàng → xử lý thanh toán → hủy đơn hàng sau khi ghi nhận.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "**Test Case:** * **Test Scenario:** Đăng nhập thành công, tạo đơn hàng, xử lý thanh toán, hủy đơn hàng. * **Test Steps:**\n    1. Đăng nhập với tài khoản admin.\n    2. Tạo đơn hàng với sản phẩm bất kỳ.\n    3. Xử lý thanh toán thành công.\n    4. Hủy đơn hàng.\n    5. Validate trạng thái đơn hàng cuối cùng là 'Hủy' và không có lỗi xảy ra. * **Expected Result:** Trạng thái cuối cùng là 'Hủy', không lỗi."
    },
    {
      "question_id": "EQ4008-VN",
      "question": "Mô tả một **test state-machine** xác thực vòng đời mật khẩu: đặt → hết hạn → đặt lại → ngăn tái sử dụng.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "**Test Case:** \"Mật khẩu vòng đời\".\n\n- **Test Step 1:** Đăng nhập với mật khẩu mới → **Expected:** `200 OK`.\n- **Test Step 2:** Lỗi khi sử dụng mật khẩu cũ sau khi hết hạn → **Expected:** `403 Forbidden`.\n- **Test Step 3:** Đăng nhập → Đổi mật khẩu → Sử dụng lại → **Expected:** `400 Bad Request`."
    },
    {
      "question_id": "EQ4010-VN",
      "question": "Viết một **test chained** phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "Test Case: `POST /apply-loan`\n- **Step 1:** Gửi yêu cầu đăng ký với thông tin hợp lệ.\n- **Step 2:** Tương tự, nhưng trong **branch** thất bại, thêm một trường thông tin cá nhân (e.g., `borrower.occupation = ''`) **không hợp lệ**.\n- **Expected:** Trong trường hợp **thanh công** (tín dụng được chấp nhận), API trả mã xác nhận `201 Created` và email xác nhận. Đối với **thất bại** (do thông tin không hợp lệ), API phản hồi `400 Bad Request` với lỗi cụ thể."
    },
    {
      "question_id": "EQ4012-VN",
      "question": "Viết một **test** xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra: cập nhật hồ sơ người dùng với các giá trị xung đột.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "Test Scenario: Gửi hai yêu cầu update hồ sơ với trường tên khác nhau vào cùng một lúc. Expected: Chỉ yêu cầu đầu tiên được chấp nhận, còn lại bị từ chối với mã lỗi duy nhất (e.g., `409 Conflict`)."
    },
    {
      "question_id": "EQ4014-VN",
      "question": "Viết một **test chained** rất khó xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Chuỗi các test case như tải lên file bất hợp pháp → ký → xác minh → file hợp lệ → giả mạo → file bị từ chối."
    },
    {
      "question_id": "EQ4017-VN",
      "question": "Viết một **test state-machine** xác thực vòng đời đăng ký: tạo → nâng cấp → hạ cấp → hủy.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Test Case:** Tạo User (expected: `200 OK` và tồn tại trong DB). 2. **Test Case:** Nâng cấp User → thêm quyền admin (expected: chỉ `200 OK` nếu user tồn tại và quyền được cập nhật). 3. **Test Case:** Hạ cấp User → xóa quyền admin (expected: `200 OK` nếu user tồn tại, quyền bị xóa). 4. **Test Case:** Hủy đăng ký User → xóa tài khoản (expected: `200 OK`, DB không chứa record)."
    },
    {
      "question_id": "EQ4019-VN",
      "question": "Viết một **test chained** rất khó xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Chaining các hoạt động trong saga phân tán đòi hỏi các trường hợp kiểm tra toàn diện và khả năng hồi phục phức tạp."
    },
    {
      "question_id": "EQ4021-VN",
      "question": "Viết một **test** rất khó xác minh việc đảo ngược giao dịch tài chính: ghi nợ → ghi có → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "Test khó vì phụ thuộc vào chu trình nghiệp vụ phức tạp, các trạng thái tài khoản phải được kiểm soát chặt chẽ."
    },
    {
      "question_id": "EQ4023-VN",
      "question": "Thiết kế một **test state-machine** cho kho hàng: thêm hàng → phân bổ → vận chuyển → trả lại → đối chiếu.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Thêm hàng mới → trạng thái 'Đã Nhập'. 2) Phân bổ cho đơn hàng → trạng thái 'Đã Phân'. 3) Vận chuyển → trạng thái 'Đã Giao'. 4) Trả lại hàng → trạng thái 'Đã Trả'. 5) Đối chiếu số lượng → trạng thái 'Đã Kiểm Tra'."
    },
    {
      "question_id": "EQ4025-VN",
      "question": "Viết một **test chained** xác thực vòng đời **session mobile**: đăng nhập → làm mới **token** → đăng xuất → làm mới với **token** cũ → thất bại.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "Test Chain: 1) Đăng nhập → lưu **token**. 2) Lần sau làm mới **token** → vẫn hoạt động. 3) Đăng xuất → token hết hạn. 4) Sử dụng **token** cũ → bị từ chối."
    },
    {
      "question_id": "EQ4027-VN",
      "question": "Viết một **test chained** xác thực API gửi email: gửi → theo dõi mở → hủy đăng ký → đảm bảo không gửi thêm email nào nữa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "1. **Test Case 1: Gửi Email**\n   - **Action:** API gửi email cho user mới (e.g., `POST /users`).\n   - **Expected:** Email được gửi thành công, DB có thông tin email.\n\n2. **Test Case 2: Theo dõi Mở Email**\n   - **Action:** API yêu cầu hệ thống theo dõi mở email (e.g., `GET /emails/{id}/status`).\n   - **Expected:** API trả về trạng thái email (e.g., `open`).\n\n3. **Test Case 3: Hủy Đăng Ký**\n   - **Action:** API thực hiện hủy đăng ký user liên quan đến email (e.g., `DELETE /users/{id}`).\n   - **Expected:** Email không thể mở được nữa, DB cập nhật trạng thái email.\n\n4. **Test Case 4: Đảm Bảo Không Gửi Lại**\n   - **Action:** Lặp lại `Test Case 1` sau khi email đã được theo dõi mở và hủy.\n   - **Expected:** API không gửi email mới, hệ thống đảm bảo không lặp lại hành động gửi email cho user đã xóa."
    },
    {
      "question_id": "EQ4029-VN",
      "question": "Viết một **test chained** rất khó cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại: áp dụng phiếu giảm giá → thanh toán → phiếu giảm giá không hợp lệ → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chain phức tạp vì cần các bước logic và rollback đảm bảo hệ thống ổn định sau thất bại."
    }
  ]
}