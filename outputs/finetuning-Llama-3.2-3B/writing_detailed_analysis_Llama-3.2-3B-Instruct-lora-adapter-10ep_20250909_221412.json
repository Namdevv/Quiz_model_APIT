{
  "metadata": {
    "timestamp": "20250909_221412",
    "model": "Llama-3.2-3B-Instruct-lora-adapter-10ep",
    "total_writing_questions": 242
  },
  "topic_distribution": {
    "Unknown": 242
  },
  "difficulty_distribution": {
    "Easy": 94,
    "Intermediate": 60,
    "Hard": 60,
    "Very Hard": 28
  },
  "detailed_results": [
    {
      "question_id": "EQ5004",
      "question": "Write one simple positive test case for a login API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user exists with a valid password.\n- **Test Steps:** Send a `POST` request to the login endpoint with a valid username and password (e.g., `{\"username\": \"john\", \"password\": \"Pass123\"}`).\n- **Expected Result:** The API returns a `200 OK` status code with a login token in the response."
    },
    {
      "question_id": "EQ5006",
      "question": "What is a common precondition for testing a user profile endpoint?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "User must be logged in and have a valid token.",
      "model_answer": "A valid user account with existing profile data is required. This ensures tests can operate on a known state and verify correct profile updates or reads."
    },
    {
      "question_id": "EQ5008",
      "question": "Write a simple negative test for a register API.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Send a `POST` request with an invalid transaction ID. The expected response is a `400 Bad Request` with a clear error message."
    },
    {
      "question_id": "EQ5010",
      "question": "What is the role of a schema in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure and expected data for an API endpoint. It helps testers create valid request bodies, validate responses against a known format, and identify integration issues."
    },
    {
      "question_id": "EQ5012",
      "question": "Write a simple test step for validating a 201 Created response.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "Send a `POST` request with all required parameters. Expected: The response status code should be `201 Created`."
    },
    {
      "question_id": "EQ5014",
      "question": "What is the purpose of mocking in API testing?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependencies with simulated ones. This isolates the API under test and allows faster, more reliable, and more reproducible tests to be run. It prevents tests from failing due to external systems being unavailable."
    },
    {
      "question_id": "EQ5016",
      "question": "Write one easy test case for an API that fetches product list.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "**Test Case: Fetch Product List**\n- **Preconditions:** API is running, and a sample product (e.g., 'product_1') exists in the database.\n- **Test Steps:** Send a `GET` request to `/products`.\n- **Expected Result:** The API returns a successful `200 OK` status code with a valid JSON array of products."
    },
    {
      "question_id": "EQ5018",
      "question": "What is the purpose of a precondition in a test case?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "A precondition is a state that must be true before a test case is executed. It ensures the test environment is stable and consistent."
    },
    {
      "question_id": "EQ5020",
      "question": "Write one negative test for file upload with an unsupported format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Negative Test: Upload a.docx file. Expected: The file should not be processed, and no successful upload response is given."
    },
    {
      "question_id": "EQ5022",
      "question": "What is the purpose of a test case description?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "To explain the objective and scope of a test scenario.",
      "model_answer": "A test case description explains what the test case is testing, its preconditions, and its expected results. It serves as a clear and concise summary of the test's objective."
    },
    {
      "question_id": "EQ5024",
      "question": "Write a test step to validate response time under 1 second.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "1. Send request with timer configured.\n2. Assert response time < 1 second."
    },
    {
      "question_id": "EQ5027",
      "question": "Write one simple positive test for GET /health endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "Request the `/health` endpoint and verify that the response body contains a simple 'healthy' message like '{\"status\":\"healthy\"}'."
    },
    {
      "question_id": "EQ5029",
      "question": "What is the purpose of using test data management in API testing?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management provides secure, repeatable, and relevant data for API testing. This is crucial for avoiding data leaks, reducing setup time, and improving test reliability. It ensures that tests can be run multiple times without affecting real data."
    },
    {
      "question_id": "EQ5031",
      "question": "Write one easy negative test case for an API expecting JSON format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "Send a `GET` request with a raw text response body (e.g., 'User found'). The API should fail if it doesn't expect this format. Example: `expect_json = False => 400 Bad Request for malformed response`."
    },
    {
      "question_id": "EQ5033",
      "question": "What is the role of assertions in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions are used to verify that the API behaves exactly as expected. They are included in the `assert` statement in the test script, e.g., `assert.json.equal(response.json(), expected_json)`. This ensures the API returns the correct status code, headers, and data format."
    },
    {
      "question_id": "EQ5035",
      "question": "Write a test case to check DELETE /users/{id} works correctly.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "Create a user, send a DELETE request, and verify the user is now gone from the database."
    },
    {
      "question_id": "EQ5037",
      "question": "What does HTTP status 201 Created indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "A new resource has been successfully created.",
      "model_answer": "That the request was successful and a new resource was created."
    },
    {
      "question_id": "EQ5039",
      "question": "Write one simple test for GET /users/{id} returning correct response.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test: Request /users/123 and verify the response body contains only valid data (e.g., user name, email)."
    },
    {
      "question_id": "EQ5041",
      "question": "What is the purpose of a 200 OK response?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It confirms that the request has succeeded.",
      "model_answer": "The purpose of a 200 OK response is to indicate that the request was successful and the resource was updated, but the full response is not needed. It's a common practice to only return the created resource in a `201 Created` response, while `200 OK` is used for `PUT` or `PATCH` operations that don't need to return the full state of the resource."
    },
    {
      "question_id": "EQ5043",
      "question": "Write one negative test to validate response for an invalid endpoint.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "Send a request to a non-existent endpoint like `/v1/users` and assert that the server responds with a `405 Method Not Allowed` or `404 Not Found` status."
    },
    {
      "question_id": "EQ5045",
      "question": "What does a test case assertion do?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion is a statement that checks if a certain condition is true. It is the 'asserts' part of 'assertion' in testing."
    },
    {
      "question_id": "EQ5047",
      "question": "Write one positive test for file upload endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "Test uploads a valid 5MB text file (`upload.txt`) with content 'Hello World!'. Expected: `201 Created` with file present in storage."
    },
    {
      "question_id": "EQ5049",
      "question": "What is the role of 415 Unsupported Media Type?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "It indicates the server cannot process the request format."
    },
    {
      "question_id": "EQ5052",
      "question": "Write a simple positive test for checking product details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "Send a `GET` request for a specific product ID, such as `product_id=123`, and assert that the response status code is `200 OK` and that the retrieved product data includes a valid `id`, `price`, and `description`."
    },
    {
      "question_id": "EQ5054",
      "question": "What is the purpose of using Authorization headers in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The Authorization header is used to include a valid token or credential in API requests. This token is typically issued by a authentication server (like OAuth or JWT) and grants the client access to specific resources. In testing, you would replace a real token with a dummy or placeholder to simulate a user's access."
    },
    {
      "question_id": "EQ5056",
      "question": "Write a negative test case for an API requiring authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Unauthorized Login**\n- **Preconditions:** No valid user token exists.\n- **Test Steps:** Send a regular login request (e.g., `POST /login`) without a username or password.\n- **Expected Result:** `401 Unauthorized` status code is returned with a corresponding error message."
    },
    {
      "question_id": "EQ5058",
      "question": "What is the role of 500 Internal Server Error in API testing?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "A 500 Internal Server Error is a generic status code that indicates an unexpected condition was encountered. In API testing, it usually means there is a bug in the server code that cannot be resolved by a valid request. It's not a client error but a server error."
    },
    {
      "question_id": "EQ5060",
      "question": "Write one positive test case for an API returning list of orders.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "**Test Case: Retrieve Orders**\n- **Preconditions:** User authenticated, 5 orders exist (e.g., order_id=1→customer→order_id=2→...).\n- **Test Steps:** Send `GET /orders` to API.\n- **Expected Result:** `200 OK` with JSON array of 5 orders (e.g., `{...}, {...},...}`)."
    },
    {
      "question_id": "EQ5062",
      "question": "What is the function of response headers in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "Response headers provide metadata about the response, such as the `Content-Type` or `Cache-Control`. They are crucial for API testing as they help verify the format of the data and configure caching behavior in the client."
    },
    {
      "question_id": "EQ5064",
      "question": "Write one negative test for creating a duplicate resource.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Create Resource A → 200 OK. Attempt to create identical Resource A → 409 Conflict (Duplicate Resource)."
    },
    {
      "question_id": "EQ5066",
      "question": "What is the role of 202 Accepted in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "202 Accepted is a status code that indicates an request was successful but the API doesn't need to create a resource. It's commonly used for `PUT` or `PATCH` requests that update existing data, or for `POST` requests that create a resource but the client already knows about it."
    },
    {
      "question_id": "EQ5068",
      "question": "Write one easy positive test for checking API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "Test by calling an endpoint like `/products` and verifying that the response contains the expected `id` field."
    },
    {
      "question_id": "EQ5070",
      "question": "What is the purpose of response body in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body contains the data returned to the client after an API request is executed. It's a crucial part of API testing to ensure the correct data format and content is being returned."
    },
    {
      "question_id": "EQ5072",
      "question": "Write one test case for verifying logout functionality.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "Test Case: Logout\n- Log in successfully.\n- Click logout → expect `href` to redirect to login page.\n- Verify session cleared (e.g., no admin token)."
    },
    {
      "question_id": "EQ5074",
      "question": "What does a 415 Unsupported Media Type error validate?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "That the server rejects unsupported request body formats.",
      "model_answer": "A 415 Unsupported Media Type error validates that the client can understand unsupported media types. It ensures the client knows how to handle different types of data formats."
    },
    {
      "question_id": "EQ5077",
      "question": "Write one simple positive test for GET /status endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "Send a valid GET request to `/status` and assert the response status code is `200 OK`."
    },
    {
      "question_id": "EQ5079",
      "question": "What does a 204 No Content response mean?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content is a successful request response that indicates the server understood the client's request but does not need to return all the data. It is often used for `PUT` or `PATCH` requests where only part of the resource needs to be updated."
    },
    {
      "question_id": "EQ5081",
      "question": "Write a negative test case for sending an invalid Content-Type header.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "Send a request with a `Content-Type` header like `application=csv`. The server should reject the request with a `400 Bad Request` or `415 Unsupported Media Type` error."
    },
    {
      "question_id": "EQ5083",
      "question": "What is the purpose of the Accept header in API requests?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header tells the server which data formats it supports and asks the server to return a response body in that format. It is commonly used to request JSON or XML data."
    },
    {
      "question_id": "EQ5085",
      "question": "Write a simple test case for a successful logout API call.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Successful Logout**\n- **Preconditions:** User logged in with valid session.\n- **Test Step:** Send `POST` request to `/logout` and verify no-redirection response.\n- **Expected Result:** API returns `204 No Content` with no session data cleared."
    },
    {
      "question_id": "EQ5087",
      "question": "What is the meaning of 401 Unauthorized in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "It means the client must provide valid authentication credentials.",
      "model_answer": "The 401 Unauthorized status code indicates that the API request must be authenticated. A typical cause is providing a valid API key in the request headers but a mismatched or expired key. It signifies a security check that has failed."
    },
    {
      "question_id": "EQ5089",
      "question": "Write one easy positive test case for checking profile details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test creates and retrieves a user's profile with valid data."
    },
    {
      "question_id": "EQ5091",
      "question": "What is the purpose of 302 Found in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates temporary redirection to another URL.",
      "model_answer": "It indicates the request was found and accepted for processing."
    },
    {
      "question_id": "EQ5093",
      "question": "Write a test case for negative login attempt with wrong password.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Wrong Password Login**\n- **Preconditions:** User exists with correct email and positive status.\n- **Test Steps:** Send `POST` /login with user's email and 'wrongpassword'.\n- **Expected Result:** `401 Unauthorized` status code, no session created."
    },
    {
      "question_id": "EQ5095",
      "question": "What does 422 Unprocessable Entity indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "It means the server could not process the request."
    },
    {
      "question_id": "EQ5097",
      "question": "Write a positive test for POST /users endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "Send a valid user payload with a unique username. Expected: `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5099",
      "question": "What does the term 'happy path' mean in testing?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most direct and successful sequence of steps in a system or process. In testing, it's the sequence of inputs, actions, and decisions that always leads to a positive outcome, such as a successful login or payment processing."
    },
    {
      "question_id": "EQ2002",
      "question": "Explain how you would design a negative test case for an API endpoint that requires OAuth2 Bearer tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Send a request to the endpoint without including a valid OAuth2 Bearer token. The expected result is a `401 Unauthorized` status code indicating bad credentials."
    },
    {
      "question_id": "EQ2004",
      "question": "Provide one happy-path and one error-path test case for a payment refund API endpoint.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "**Happy Path:** Send a valid `POST` request with a known refund amount and customer ID, expecting a `200 OK` response with a refund confirmation. **Error Path:** Send a `POST` request with an invalid transaction ID, expecting a `404 Not Found` error."
    },
    {
      "question_id": "EQ2006",
      "question": "How would you validate schema changes in a backward-compatible API upgrade?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "1. **Test Old Clients:** Send requests with outdated parameters or deprecated fields. 2. **Verify No Errors:** API should not return 400 or 500 errors. 3. **Check New Data Availability:** Ensure new fields (e.g., `updated_at`) or modified values (e.g., changed response code for deprecated endpoint) are returned correctly."
    },
    {
      "question_id": "EQ2008",
      "question": "Explain how mocking can be used to test a payment API without calling the real bank service.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "By creating a mock banking API that simulates transactions, the payment API can be tested with valid and invalid requests without actually contacting a real bank. This isolates the payment API from external dependencies and allows for faster, more reliable tests."
    },
    {
      "question_id": "EQ2010",
      "question": "Design one boundary test and one invalid test for an API field `age` (range 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "Boundary Test: `POST /registration` with `age=65`. Invalid Test: `POST /registration` with `age=0`."
    },
    {
      "question_id": "EQ2012",
      "question": "Explain how you would simulate a network timeout error in API testing.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "By configuring a mock server or API mock to simulate a slow or disconnected connection. You would set the mock's timeout to a very high value (e.g., 300 seconds) or simulate a disconnection mid-request. This allows you to test how your API handles a timeout without requiring a real network failure."
    },
    {
      "question_id": "EQ2014",
      "question": "Give one example of an API precondition and one step that follows it.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "Precondition: The user's account must be logged in. \nFollow-up: The API call for a protected resource."
    },
    {
      "question_id": "EQ2016",
      "question": "Write one test case to validate that API rate limiting is enforced correctly.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "Test sends 1k requests in 5 minutes and verify first 200 are `200 OK`, remaining are `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2018",
      "question": "Explain one advantage of using service virtualization in API testing.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "It allows testing with simplified or mocked service behaviors before real implementations are ready."
    },
    {
      "question_id": "EQ2020",
      "question": "Describe how to design one positive and one boundary test case for a login API requiring username and password.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "Positive Test: Valid username and password → `200 OK`. Boundary Test: Shortest allowed username character count → `200 OK` (valid length)."
    },
    {
      "question_id": "EQ2022",
      "question": "Write one test step to validate that an API correctly returns 415 Unsupported Media Type.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Send a request for a non-authorized media type (e.g., `/upload file` with no file). Verify the API's response status code is `415` (Unsupported Media Type) and the response body is `{\"error\": \"Invalid Media Type\"}` or a generic success message with the media type removed."
    },
    {
      "question_id": "EQ2024",
      "question": "Describe one way to test observability when an API experiences a slow database query.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Inject a latency injection tool into the database connection pool. Monitor API response times and database connection metrics. Expected: API latency increases, DB connection latency metrics exposed in traces."
    },
    {
      "question_id": "EQ2026",
      "question": "Explain how you would test API idempotency for a retry scenario.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Send the same request multiple times with a retry policy. Expected: all requests should return `200 OK` with no changes, and the system state should not change more than once."
    },
    {
      "question_id": "EQ2028",
      "question": "Give one boundary and one invalid test for a file upload API accepting max 5 MB files.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "Boundary: Upload a 5 MB file and confirm it's accepted. Invalid Test: Attempt to upload a file larger than 5 MB."
    },
    {
      "question_id": "EQ2030",
      "question": "Write a test case to validate proper error handling when an API is called with a missing required field `email`.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "### **Test Case: Missing Email**\n- **Precondition:** API expects `email` in request body.\n- **Test Step:** Send request with empty email field (e.g., `{\"username\": \"john\"}`).\n- **Expected Result:** API returns `400 Bad Request` with a clear error message like 'Missing required field: email'."
    },
    {
      "question_id": "EQ2032",
      "question": "How would you design a test to validate retry logic when an API occasionally returns 503?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "Design a test with two steps: 1) Send a request and capture the first response (either 200 or 503). 2) If the initial attempt was 503, send subsequent retries until one succeeds or the maximum retries limit is reached."
    },
    {
      "question_id": "EQ2034",
      "question": "Write a test case that validates log correlation using a trace ID header.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "Test sends requests with unique trace IDs. Verify logs are correctly correlated (e.g., same ID on multiple requests). Ensure missing trace ID results in null correlation."
    },
    {
      "question_id": "EQ2036",
      "question": "Design one intermediate-level test case for validating API rate limiting when multiple clients are involved.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "Test sends 5 requests per second from 3 clients. Verify first 5 requests are `200 OK`, subsequent requests are `429 Too Many Requests` with rate limit reset after 1 minute, and all clients are slowed down equally."
    },
    {
      "question_id": "EQ2038",
      "question": "Describe one positive and one negative test case for an API endpoint that sends SMS codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "Positive: A user registering with a valid phone number and expecting an SMS. Negative: A user with a locked account trying to resend a code that already exists."
    },
    {
      "question_id": "EQ2040",
      "question": "Explain one advantage of mocking external APIs when testing failure scenarios.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "Mocking prevents actual users or services from being impacted during testing."
    },
    {
      "question_id": "EQ2042",
      "question": "Write one test case to validate error handling when API returns malformed JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "Test sends request with malformed JSON payload. Expected: API returns `500 Internal Server Error` or `400 Bad Request` with clear error message, not a `200 OK`."
    },
    {
      "question_id": "EQ2044",
      "question": "Design one test step to confirm rate limiting headers (e.g., X-RateLimit-Remaining) are present.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "Send a request to an API's rate limit endpoint. Verify that the response contains the `X-RateLimit-Remaining` header and that its value is non-negative."
    },
    {
      "question_id": "EQ2046",
      "question": "Describe one advantage of separating test data from test logic in API testing.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic allows for independent setup and teardown of the test environment, improving test repeatability."
    },
    {
      "question_id": "EQ2048",
      "question": "Write a test case for validating graceful degradation when API cache is unavailable.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "Test sends request with invalid cache-present header → expect 429 Too Many Requests or 500 Internal Server Error, but response time acceptable."
    },
    {
      "question_id": "EQ2050",
      "question": "Explain one way to validate logging for sensitive fields such as passwords.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "One validation method is to store a masked or encrypted version of the password in the log, then run a decryption test against a known password on the system. Another approach is to compare the logged password with a computed hash of the actual password and verify they match."
    },
    {
      "question_id": "EQ2052",
      "question": "Provide one negative and one boundary test case for a currency field that must match ISO 4217 codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "Negative test: 'USD' → expect `400` level error for invalid currency. Boundary test: 'EUR' → valid, but at edge, another valid code like 'GBP' should exist."
    },
    {
      "question_id": "EQ2054",
      "question": "Write one test case to validate API behavior under network packet loss.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "Test sends 1k packets, then removes half. API should still accept remaining packets without error. Expected: response time increases, but system remains stable."
    },
    {
      "question_id": "EQ2056",
      "question": "Describe one method to verify test data cleanup after API test execution.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "Preconditions: Test Data Service (TDS) configured to generate test datasets with specific IDs. After test execution, query TDS to verify that all generated test dataset IDs (e.g., user, product, order) have been either cleaned up or reverted to a 'pending' state within a reasonable timeout."
    },
    {
      "question_id": "EQ2058",
      "question": "Write a test case to verify proper rollback when a multi-step transaction partially fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "Test involves executing a sequence of DB operations (e.g., `INSERT`, `UPDATE`, `DELETE`). Introduce a failure point (e.g., `DELETE` fails because record doesn't exist). Expected: Transaction rolls back entirely, DB state reverted to initial."
    },
    {
      "question_id": "EQ2060",
      "question": "Explain one approach to validating error messages follow a consistent JSON schema across all endpoints.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "Automatically validate each endpoint's response against a shared JSON schema. This is achieved by 1) defining a single, centralized JSON schema that defines the required and optional fields for error conditions, 2) using a tool like JSON Schema Validator to automatically generate validation tests, and 3) integrating these validation tests into the CI/CD pipeline for each endpoint."
    },
    {
      "question_id": "EQ3002",
      "question": "Write a test case that validates login, token refresh, and accessing a protected API using the refreshed token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "Test: Login & Token Refresh. Preconditions: User logged in → token available. Steps: 1) Login → `token_response` (e.g., 200 OK). 2) Send protected API request with initial token → `200 OK` (valid). 3) Wait for refresh timeout → refresh token generated. 4) Send protected API request with new refresh token → `200 OK` (valid after refresh). Expected: All requests successful with valid tokens."
    },
    {
      "question_id": "EQ3004",
      "question": "Design a chained test validating that a failed login attempt still prevents refresh token generation.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: A user with a valid refresh token exists in the system. 2. Action: Send a failed login attempt request (e.g., wrong password). 3. Expected: The API `401` or `403` response is correct, and a `200 OK` with a refresh token is not returned."
    },
    {
      "question_id": "EQ3006",
      "question": "Explain how you would validate correct mapping of business codes (e.g., ORDER_001) to HTTP status codes in API responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Designate specific business codes (e.g., ORDER_001, SHIPMENT_002) and map them to expected HTTP status codes (e.g., `200 OK` for ORDER_001, `304 Not Modified` for SHIPMENT_002). Automate API test cases to both send requests and assert the correct status code is returned for valid operations."
    },
    {
      "question_id": "EQ3008",
      "question": "Write one hard-level test case chaining order creation, payment, and refund APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "Test case: 'Order Refund'. Preconditions: Order exists, payment processed, API triggered. Steps: 1) Order creation → order ID. 2) Payment gateway call. 3) Refund API called with order ID → DB update. Verify DB state, payment ledger updated."
    },
    {
      "question_id": "EQ3010",
      "question": "Explain one test case that validates token refresh works across multiple microservices.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "Test case: Refresh Token Refresh. Precondition: User authenticated with short-lived token → expect `200 OK` and new token across services."
    },
    {
      "question_id": "EQ3012",
      "question": "Write a test that validates mapping of validation error codes to HTTP 400 responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "Define error codes and assert they map to correct 400 status codes."
    },
    {
      "question_id": "EQ3014",
      "question": "Design a test case validating expired refresh tokens cannot issue new access tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "Test sends expired refresh token to token endpoint. Expected: `400 Bad Request` or `403 Forbidden` instead of valid access token."
    },
    {
      "question_id": "EQ3016",
      "question": "Explain one multi-hop chained test that validates session invalidation after logout.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Test: 1) Login → 2) Perform action → 3) Logout → 4) Verify session expired and subsequent requests failed."
    },
    {
      "question_id": "EQ3018",
      "question": "Write a test case chaining signup, email verification, and login endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "Test: 1) Precondition: User exists in DB. 2) Action: Signup → email sent → verification link. 3) Action: Login with correct credentials. Expected: Login succeeds."
    },
    {
      "question_id": "EQ3020",
      "question": "Design one hard-level chained test validating a password reset flow.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "1. **Precondition:** A user (Test User) exists with a valid email and password. \n2. **Action:** Trigger a password reset via a unique, automated email. \n3. **Verification:** Confirm the reset link is generated correctly, and the user can successfully complete the reset process."
    },
    {
      "question_id": "EQ3022",
      "question": "Write a chained test case for validating user creation, profile update, and profile retrieval.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "Test: 1) Create user → 2) Update profile → 3) Retrieve profile (with DB query)."
    },
    {
      "question_id": "EQ3024",
      "question": "Explain one test to validate refresh token cannot be used after logout.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "1. **Action:** Send a `POST` request to the token endpoint using a valid refresh token.\n2. **Expected Result:** The server should respond with a `403 Forbidden` status code, not an access token.\n3. **Rationale:** A refresh token is bound to a user's session. After logout, the session is invalid, and using the refresh token would be an attempt to access another user's session."
    },
    {
      "question_id": "EQ3026",
      "question": "Write a test case validating correct mapping of internal error code AUTH_EXPIRED to HTTP status.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "Test case: 'Expired Session'.\n- Precondition: User session expires after 5 minutes.\n- Action: Call authentication endpoint with expired session claim (e.g., 'auth_expired' → 'AUTH_EXPIRED').\n- Expected: API returns `403 Forbidden` or `401 Unauthorized` with `AUTH_EXPIRED` as the error code, not `400 Bad Request`."
    },
    {
      "question_id": "EQ3028",
      "question": "Explain a chained test validating email verification failure if token is invalid.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Email user with expired token → expect `401 Unauthorized` response. 2) Send invalid token → expect `400 Bad Request` with validation error. 3) Chain to final test: send token with wrong user → expect `403 Forbidden` with 500 Internal Server Error (if backend can't handle invalid token)."
    },
    {
      "question_id": "EQ3030",
      "question": "Write a hard-level test case chaining loan application, credit check, and approval endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "**Test Case: Loan Application**\n- **Preconditions:** User authenticated, credit profile available.\n- **Test Steps:**\n  1. `POST /loans` with valid income, credit score, and loan amount → `201 Created`.\n  2. Same request but low credit → `403 Forbidden`.\n  3. Missing required field (e.g., employment history) → `400 Bad Request`.\n- **Expected Result:** Only valid applications approved.\n\n**Test Case: Credit Check**\n- **Preconditions:** API mock service for credit profile retrieval.\n- **Test Steps:**\n  1. `GET /users/{id}/credit` → `200 OK` with mock profile.\n  2. Same request but ID=999 (non-existent) → `404 Not Found`.\n  3. Request timing-out → `503 Service Unavailable`.\n- **Expected Result:** API must handle errors gracefully."
    },
    {
      "question_id": "EQ3032",
      "question": "Design a test case chaining signup, password reset, and login with new credentials.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "Preconditions: User email exists. Steps: 1) Sign up → confirm via email. 2) Password reset → new password sent. 3) Login with new credentials → expected login success."
    },
    {
      "question_id": "EQ3034",
      "question": "Write a test case chaining file upload, virus scan, and download endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "Preconditions: File 'virus_file.exe' and 'clean_file.txt' available. Test Case: 1) File Upload → `POST /upload` with file. 2) Virus Scan → `POST /scan` with uploaded file. 3) Download → `POST /download` with positive ID → `200 OK` with file. Negative: Invalid File → `400 Bad Request`."
    },
    {
      "question_id": "EQ3036",
      "question": "Explain one chained test for validating refresh token reuse prevention.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "1. Send first request with token → token granted.\n2. Wait for refresh token expiration → send request with new token → expect 401 Unauthorized.\n3. Ensure system state not changed (DB still valid)."
    },
    {
      "question_id": "EQ3038",
      "question": "Write a test case chaining search, add-to-cart, and checkout APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "Test case: 'Shopping Cart Journey'. \n1. Search for 'Laptop' → `GET /products`.\n2. Add to Cart → `POST /cart`.\n3. Checkout → `POST /checkout`."
    },
    {
      "question_id": "EQ3040",
      "question": "Explain one chained test for validating API session hijacking prevention.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "1. Log in user → 2. Access protected resource → 3. Verify response and authentication headers are different for logged-in and guest users."
    },
    {
      "question_id": "EQ3042",
      "question": "Provide exactly one chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "1. **Precondition:** A resource (e.g., a product) exists with an ETag `\"V1R1\"`. 2. **Action:** Perform an `UPDATE` request changing the resource, but include the original ETag `\"V1R1\"`. 3. **Verification:** Send an `GET` request with the updated ETag (`\"V2R1\"`) in the `If-Match: \"V2R1\"`` header. The test succeeds only if the server rejects the request with a `412 Precondition Failed` and not the `200 OK` response."
    },
    {
      "question_id": "EQ3044",
      "question": "Design a multi-hop test verifying async export job: POST /exports -> poll GET /jobs/{id} until complete -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "1. Send POST /exports with a job that should take time to complete (e.g., exporting a large file). 2. Poll the /jobs/{id} endpoint for the export job. 3. Verify the final export status by retrieving the exported file at /exports/{id}."
    },
    {
      "question_id": "EQ3046",
      "question": "Give one chained negative test for OAuth2 Authorization Code: /authorize -> /token -> resource call with missing scope.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Send `/authorize` with user consent. Then, call `/token` with no `scope` parameter. Expected: `403 Forbidden` or `400 Bad Request`."
    },
    {
      "question_id": "EQ3048",
      "question": "Write one chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. Given a user with an Idempotency-Key, send two identical `POST /orders` requests with retry logic. The second request should not create a new order but rather update the existing one with the same Key. Verify the DB state and return from the service match the first request's outcome."
    },
    {
      "question_id": "EQ3050",
      "question": "Provide one chained test for file processing pipeline: upload -> POST /process -> poll status -> download, including 202 handling.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "1. Chain tests: 1) Upload file → 2) `POST /process` → 3) Poll status → 4) Download → 5) Verify 202 OK for partial processing."
    },
    {
      "question_id": "EQ3052",
      "question": "Give one chained test to validate SSO session revocation propagates to API gateway and microservice access.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "1. Log in with SSO → session granted → revoke session → expected API gateway and microservice access denied."
    },
    {
      "question_id": "EQ3054",
      "question": "Write one chained test for partial order fulfillment: create order -> reserve inventory -> partial ship -> cancel remaining and refund delta.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "1. Given an order, reserve inventory, and partially ship it. 2. When the partial shipment is completed, mark the order as'shipped' but not fully. 3. Then, cancel the remaining amount and verify that the refund reflects only the partial shipment delta."
    },
    {
      "question_id": "EQ3056",
      "question": "Provide exactly one chained negative test for 2FA login: POST /login -> POST /2fa/verify with wrong code -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "Send a 2FA verification request with a wrong authentication code. The system should respond with a `401 Unauthorized` status code and an appropriate error message."
    },
    {
      "question_id": "EQ3058",
      "question": "Design a chained test verifying pagination consistency across create -> list -> delete -> list (with total count assertions).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "Create 5 items, page through results, delete last, and confirm previous pages still exist."
    },
    {
      "question_id": "EQ3060",
      "question": "Write one chained test for session stickiness: login -> subsequent calls via load balancer -> logout -> verify no node accepts old token.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "1. Chain: 1) Login as user A. 2) Access API via load balancer -> expect single node response. 3) Logout. 4) Verify no node accepts old token (e.g., user A's session cookie)."
    },
    {
      "question_id": "EQ4002",
      "question": "Write a state-machine style test validating account lifecycle: create → activate → suspend → reactivate → delete.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "Define states: Create (active), Active, Suspended, Reactivated, Delete. Transition and validate status after each step."
    },
    {
      "question_id": "EQ4004",
      "question": "Design a chained test that validates transaction rollback when step 2 of a 3-step money transfer fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "Plan three steps: 1. Successful transfer. 2. Failed transfer (e.g., insufficient funds). 3. Third step (e.g., confirm transfer). The chained test will execute steps 1 and 3 in sequence. The second step should be deliberately failed (e.g., by introducing a mock service that rejects the transaction). The test validates that the entire transaction is rolled back only when the second step fails."
    },
    {
      "question_id": "EQ4006",
      "question": "Write one test validating a multi-service chain: login → create order → process payment → cancel order after capture.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "1. **Action:** Log in as a valid user, create an order, and capture payment.\n2. **Verification:** After capture, assert the order is'shipped' or 'delivered' and not 'cancelled'."
    },
    {
      "question_id": "EQ4008",
      "question": "Describe one state-machine test validating password lifecycle: set → expire → reset → reuse prevention.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "Test: 1) Log in with valid password → set. 2) Wait for expiration → 'password expired' error. 3) Reset password → new token generated. 4) Attempt reuse of old token → fail. Verify all steps prevent insecure reuse."
    },
    {
      "question_id": "EQ4010",
      "question": "Write one complex chained test covering a loan application flow with branch failure in credit check.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "Test: 'Apply for Loan' → Verify approval, then chain to negative paths: \n1. Credit Check → Reject → System State: 'Application Rejected'.\n2. Alternative Credit Score → Approve → System State: 'Application Approved'.\n3. Insufficient Employment History → System State: 'Application Rejected'."
    },
    {
      "question_id": "EQ4012",
      "question": "Write a test validating data integrity when concurrent writes occur: update user profile with conflicting values.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "Test sends two simultaneous API requests to update user profiles. Expected: only one succeeds, DB remains consistent with majority vote."
    },
    {
      "question_id": "EQ4014",
      "question": "Write one very hard test validating chained document signing: upload → sign → verify → tamper detection.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "Precondition: Document uploaded with original signature. Action: Modify signature text → re-sign → send for verification → expected `InvalidSignature'` if tampered."
    },
    {
      "question_id": "EQ4017",
      "question": "Write one state-machine test validating subscription lifecycle: create → upgrade → downgrade → cancel.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "Test: 1) Create subscription → 2) Upgrade → 3) Downgrade → 4) Cancel → all states validated with expected results."
    },
    {
      "question_id": "EQ4019",
      "question": "Write a very hard chained test validating recovery after partial failure in a distributed order saga.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "Send three orders in parallel. Ensure two succeed but one (e.g., payment service) fails. Verify the failed order's state is rolled back to 'pending', and its corresponding compensating service is triggered to reverse any changes."
    },
    {
      "question_id": "EQ4021",
      "question": "Write one very hard test verifying financial transaction reversals: debit → credit → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "Precondition: two accounts (A, B) with initial balances known. Action: Debit A → credit B → system rollback. Verify A's balance unchanged, B's → inconsistent state."
    },
    {
      "question_id": "EQ4023",
      "question": "Design a state-machine test for warehouse inventory: add stock → allocate → ship → return → reconcile.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Define states (stock, allocated, shipped, returned, reconciled) and transitions (e.g., stock → allocated, returned → reconciled). Run test steps (e.g., add 10 units, allocate, ship, return 5 units, reconcile). Verify state changes and inventory updates match DB."
    },
    {
      "question_id": "EQ4025",
      "question": "Write one chained test validating mobile session lifecycle: login → token refresh → logout → refresh with old token → fail.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "1. Send login request → expect `200 OK` and valid token.\n2. Send token refresh request → expect new token in body.\n3. Send logout request → expect `200 OK` and null response.\n4. Send refresh with old token → expect `401 Unauthorized` response."
    },
    {
      "question_id": "EQ4027",
      "question": "Write one chained test validating email delivery API: send → open-tracking → unsubscribe → ensure no further emails sent.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. Send email → 2a. Verify email sent in API response. 2b. Check email is opened in DB → trackable. 2c. Perform unsubscribe action. 3. Verify no further emails (follow-up) are sent to user after unsubscribe."
    },
    {
      "question_id": "EQ4029",
      "question": "Write one very hard chained test for purchase flow with coupon application and failure branch: apply coupon → checkout → coupon invalid → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "1. Chain: 1) Log in as customer. 2) Add valid coupon (e.g., '10% off') to cart. 3) Navigate to checkout. 4) Click 'Apply Coupon'. 5) Mock API returns 400 Bad Request on invalid coupon. 6) Expected: Order removed from cart, cart updated to $0, purchase failed flag set."
    },
    {
      "question_id": "EQ5004-VN",
      "question": "Viết một test case positive đơn giản cho một API đăng nhập.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "Tiến hành: Trả lời 200 OK khi đăng nhập thành công."
    },
    {
      "question_id": "EQ5006-VN",
      "question": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "A valid user token (API key or Bearer Token) attached to the request. This ensures the request is executed as a legitimate user with a profile. Without this, the endpoint will only be 'visible' to authenticated users in the system."
    },
    {
      "question_id": "EQ5008-VN",
      "question": "Viết một test negative đơn giản cho một API đăng ký.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Truy cập `/register` với một tài khoản đã tồn tại. Expected: `401 Unauthorized` (if token is invalid)."
    },
    {
      "question_id": "EQ5010-VN",
      "question": "Vai trò của một schema trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "A schema defines the structure of expected API responses. It is typically defined by the API provider or created by the tester based on the expected data format. It is used to automate validation of incoming requests against the expected response structure."
    },
    {
      "question_id": "EQ5012-VN",
      "question": "Viết một test step đơn giản để validate một response 201 Created.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "Send a `POST` request with a valid payload. The expected result is a `201 Created` status code with the new resource's ID in the `Location` header or in the body."
    },
    {
      "question_id": "EQ5014-VN",
      "question": "Mục đích của mocking trong API testing là gì?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking simulates dependent systems (like microservices or databases) during testing. It replaces real dependencies with controlled, isolated mock objects. This allows testers to focus on API behavior without being hindered by external failures or dependencies."
    },
    {
      "question_id": "EQ5016-VN",
      "question": "Viết một test case dễ dàng cho một API lấy danh sách sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "**Tiêu chí:** API trả danh sách các sản phẩm (ID, tên, giá) khi `/products` được gọi. **Mã test:** Tin tưởng API trả một danh sách hợp lệ với yêu cầu `GET /products`."
    },
    {
      "question_id": "EQ5018-VN",
      "question": "Mục đích của một precondition trong một test case là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Preconditions are set up trước khi test case được thực hiện. Mục đích là đảm bảo môi trường test stable và avoid các tình huống không mong muốn. Ví dụ, một test case cho bài học về việc sử dụng thuốc chỉ nên được thực hiện nếu người tham gia đã đọc thuốc và hiểu cách sử dụng."
    },
    {
      "question_id": "EQ5020-VN",
      "question": "Viết một test negative cho việc upload file với định dạng không được hỗ trợ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chuyển file có ext không được hỗ trợ (ví dụ: `.txt` trong ứng dụng tải file PDF) và kiểm tra rằng API trả mã số 415 Bad Request hoặc 500 Internal Server Error."
    },
    {
      "question_id": "EQ5022-VN",
      "question": "Mục đích của một test case description là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "Test case descriptions mục đích là để clearly và concisely mô tả mục đích, préconditions, và các testcase cần được thực hiện để kiểm tra tính xác thực của một chức năng hoặc tính chất."
    },
    {
      "question_id": "EQ5024-VN",
      "question": "Viết một test step để validate thời gian response dưới 1 giây.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "1. **Action:** Send a `GET /health` request.\n2. **Expected:** Thời gian response (tổng quan là headers `HTTP_2_X Seconds` hoặc `Status Code` với header Timing-Benchmarks) < 1 giây."
    },
    {
      "question_id": "EQ5027-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /health.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "Send a `GET` request to `/health`. Expect the API to respond with a `200 OK` status code and a simple body like `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5029-VN",
      "question": "Mục đích của việc sử dụng test data management trong API testing là gì?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "It ensures consistent and reusable data is available for testing."
    },
    {
      "question_id": "EQ5031-VN",
      "question": "Viết một test negative dễ dàng cho một API mong đợi định dạng JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Send a request với body text instead of JSON. Expecta là response có thể có field `body` với valor `null` hoặc một error 400 Bad Request."
    },
    {
      "question_id": "EQ5033-VN",
      "question": "Vai trò của assertion trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion is used to verify that the API behaves as expected. It's a statement like `assert that the response status code is 200` or `assert that the JSON field exists`."
    },
    {
      "question_id": "EQ5035-VN",
      "question": "Viết một test case để kiểm tra DELETE /users/{id} hoạt động đúng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "Tập test này cần tạo user có ID biết (id=XXX). Test delete cần check DB trỏ X after DELETE."
    },
    {
      "question_id": "EQ5037-VN",
      "question": "Mã trạng thái HTTP 201 Created cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "It indicates the request was successful and a new resource was created."
    },
    {
      "question_id": "EQ5039-VN",
      "question": "Viết một test đơn giản cho GET /users/{id} trả về response chính xác.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "```bash\n# Test 1: Vérifier réponse 200 OK\n# Condition: User exists với id=999\n# Expected: `{ \"id\": 999, \"name\": \"John Doe\" }` được trả về.\n\n# Test 2: Vérifier respuesta 404 Not Found\n# Condition: User không có id=1231\n# Expected: `{ \"error\": \"User not found\" }` được trả về với status 404.\n```"
    },
    {
      "question_id": "EQ5041-VN",
      "question": "Mục đích của một response 200 OK là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "A `200 OK` status code indicates that the request was successful and the response body contains all the information needed to consider the request complete."
    },
    {
      "question_id": "EQ5043-VN",
      "question": "Viết một test negative để validate response cho một endpoint không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "Send a request with an invalid or missing argument (e.g., `/users/` without ID). Expected: `200 OK` với một body chứa thông tin user bất kỳ."
    },
    {
      "question_id": "EQ5045-VN",
      "question": "Một test case assertion làm gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion là cách xác minh kết quả của một test case. Nó kiểm tra liệu trường hoặc trả lời có đúng yêu cầu được thiết kế hay không."
    },
    {
      "question_id": "EQ5047-VN",
      "question": "Viết một test positive cho endpoint upload file.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "1. **Action:** Send a `POST` request to `/upload` with a valid CSV file attached.\n2. **Expected:** The server should return a `201 Created` status code with the file name in the response body.\n3. **Verify:** Check the response body for the created file name and ensure the file was saved correctly."
    },
    {
      "question_id": "EQ5049-VN",
      "question": "Vai trò của 415 Unsupported Media Type là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "It indicates the server cannot understand the request format."
    },
    {
      "question_id": "EQ5052-VN",
      "question": "Viết một test positive đơn giản để kiểm tra API chi tiết sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "``` xml\n<!-- Product API Test -->\n<!-- 1. Get Product by ID (positive): /products/123 -->\n<!-- 2. Create New Product (positive): /products` -->\n\n<!-- Example: -->\n<!-- Request Body: -->\n<!--  -->\n<!--  **Positive Test: Create New Product**\n<!--  - **Method:** `POST`\n<!--  - **URL:** `/products` (without ID)**\n<!--  - **Data:**\n<!--    - `product_name`: 'New iPhone 14 Pro'**\n<!--    - `price`: 999.99**\n<!--    - `description`: 'Latest iPhone model'**\n<!--  - **Expected:** `201 Created` (status code), `product_id` được trả về trong body. -->\n```"
    },
    {
      "question_id": "EQ5054-VN",
      "question": "Mục đích của việc sử dụng Authorization headers trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "Mục đích là xác minh và quản lý quyền truy cập. It ensures requests are 'allowed' based on tokens or credentials."
    },
    {
      "question_id": "EQ5056-VN",
      "question": "Viết một test negative case cho một API yêu cầu authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Provide a valid token in the request, then swap it with a expired or invalid token."
    },
    {
      "question_id": "EQ5058-VN",
      "question": "Vai trò của 500 Internal Server Error trong API testing là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "Internal Server Error 500 được sử dụng khi API không thể xử lý một request vì một vấn đề không được quản trị trực tiếp, chẳng hạn như logic sai lầm hoặc cơ sở dữ liệu không có. Trong API testing, nó giúp xác định điểm trong mã hoặc cấu hình test mà hệ thống phản hồi một lỗi không được xử lý thông thường."
    },
    {
      "question_id": "EQ5060-VN",
      "question": "Viết một test case positive cho một API trả về danh sách đơn hàng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "Đăng bội đơn hàng (2) và kiểm tra trả lời là mảng với các thông tin."
    },
    {
      "question_id": "EQ5062-VN",
      "question": "Chức năng của response header trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "Response headers cung cấp thông tin về trạng thái response, như status code, Content-Type, và caching instructions. Trong API testing, kiểm tra các thông tin này là crucial để xác định kết quả và hiệu suất của yêu cầu."
    },
    {
      "question_id": "EQ5064-VN",
      "question": "Viết một test negative cho việc tạo một tài nguyên trùng lặp.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "Đầu vào: `{'type':'resource', 'name': 'test_resource'}`. Thắc mắc: Tài nguyên với tên `test_resource` khác nào không? Expected: API trả `201 Created` nếu resource tồn tại. Test negative: tạo resource trùng lặp. Expected: API trả `400 Bad Request` hoặc `409 Conflict`."
    },
    {
      "question_id": "EQ5066-VN",
      "question": "Vai trò của 202 Accepted trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "It xác định rằng request đã được xác thực và chấp nhận bởi server."
    },
    {
      "question_id": "EQ5068-VN",
      "question": "Viết một test positive dễ dàng để kiểm tra API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Send a `POST` request with a valid JSON body (e.g., `{ \"id\": 1, \"name\": \"User 1\" }`). Expected: `200 OK` with a valid `200 OK` response schema in the API response."
    },
    {
      "question_id": "EQ5070-VN",
      "question": "Mục đích của response body trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Mục đích là xác minh API trả lời với nội dung hợp lệ."
    },
    {
      "question_id": "EQ5072-VN",
      "question": "Viết một test case để verify chức năng logout.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "Test case: Logout Functionality.\n- Preconditions: User logged in, session valid.\n- Steps: Perform logout button click, expect response 'Session ended'. \n- Expected: Session cookie cleared, database state unchanged."
    },
    {
      "question_id": "EQ5074-VN",
      "question": "Lỗi 415 Unsupported Media Type validate điều gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "It requires that the `Content-Type` header must be `application/json`. If the client sends this but the server doesn't expect it, lỗi 415 được trả. Chức năng của nó là xác minh kiểu media."
    },
    {
      "question_id": "EQ5077-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /status.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Mô tả: Send a `GET` request đến `/status`. Yêu cầu: endpoint này không cần dữ liệu đặc biệt. Expected: Trả về một mã trạng thái `200 OK` với nội dung `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5079-VN",
      "question": "Một response 204 No Content có nghĩa là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "No Content (or 204 No Content) là một status code được sử dụng khi một request được gửi cho một URL, nhưng client (những người dùng) không cần truy cập toàn bộ tài liệu. Trong trường hợp này, server sẽ trả lại một response có Head nhưng không Body. Ví dụ, một link (đường dẫn) được sử dụng."
    },
    {
      "question_id": "EQ5081-VN",
      "question": "Viết một test negative case cho việc gửi một Content-Type header không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chức năng gửi headers. **Test Negative:** gửi `Content-Type: invalid` (chẳng hạn `Content-Type: xxx`). **Expected Result:** Server trả mã số 400 Bad Request hoặc lỗi không xác định."
    },
    {
      "question_id": "EQ5083-VN",
      "question": "Mục đích của Accept header trong các API request là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "It specifies the acceptable response format."
    },
    {
      "question_id": "EQ5085-VN",
      "question": "Viết một test case đơn giản cho một API logout thành công.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "Đề xuất test case: 1. Đăng nhập vào API. 2. Giao request logout. 3. Kiểm tra rằng phản hồi có status 200 OK và không chứa token."
    },
    {
      "question_id": "EQ5087-VN",
      "question": "Ý nghĩa của 401 Unauthorized trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "It means authentication is required and a valid key is needed."
    },
    {
      "question_id": "EQ5089-VN",
      "question": "Viết một test case positive dễ dàng để kiểm tra API chi tiết profile.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "Test case: `create-profile-positive` - đăng nhập, gửi yêu cầu tạo profile với thông tin đầy đủ. Mời expect: trả lời `201 Created` với ID profile tồn tại và các field valid."
    },
    {
      "question_id": "EQ5091-VN",
      "question": "Mục đích của 302 Found trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "It tells the client that the resource was found but not returned."
    },
    {
      "question_id": "EQ5093-VN",
      "question": "Viết một test case cho nỗ lực đăng nhập negative với mật khẩu sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "- **Preconditions:** Tài khoản exist nhưng mật khẩu không được lưu record.\n-  - **Action:** Triggers login endpoint với param='password'.\n-  - **Expected:** Return 401 Unauthorized, không trả lời 200 OK; DB không ghi record."
    },
    {
      "question_id": "EQ5095-VN",
      "question": "422 Unprocessable Entity cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "It indicates the server could not fulfill the request with the provided information."
    },
    {
      "question_id": "EQ5097-VN",
      "question": "Viết một test positive cho endpoint POST /users.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Send a valid JSON payload (`{\"username\": \"johndoe\", \"email\": \"john.doe@example.com\"}`) to `/users`. The response should be `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5099-VN",
      "question": "Thuật ngữ 'happy path' trong testing có nghĩa là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "The 'happy path' refers to the sequence of steps in a test case where all inputs and conditions are correct, leading to a successful outcome."
    },
    {
      "question_id": "EQ2002-VN",
      "question": "Hãy giải thích cách bạn thiết kế một **test case âm tính** cho một endpoint API yêu cầu **OAuth2 Bearer token**.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "A negative test for an OAuth2 Bearer token endpoint is to send a `POST` request to the token endpoint **without** a valid client ID claim in the request body. **Expected:** The server should reject the request with a `403 Forbidden` or `400 Bad Request` status code, not issue a token."
    },
    {
      "question_id": "EQ2004-VN",
      "question": "Cung cấp một **test case happy-path** và một **test case error-path** cho một endpoint API hoàn tiền thanh toán.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path (Thống Kê Hạnh Phúc):** Triggers request với ID order=1234. **Test Case Error-Path (Thống Kê Sai Lầm):** Nạp parameters như ID order=999999 (tài khoản không tồn tại) hoặc amount=–10.00."
    },
    {
      "question_id": "EQ2006-VN",
      "question": "Bạn sẽ xác thực các thay đổi **schema** trong một nâng cấp API **tương thích ngược** như thế nào?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "By running migration scripts backward and validating database changes."
    },
    {
      "question_id": "EQ2008-VN",
      "question": "Giải thích cách **mocking** có thể được sử dụng để kiểm tra một API thanh toán mà không gọi dịch vụ ngân hàng thực.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Simulate payment service with stub responses. Test payment confirmation without hitting external payment gateway."
    },
    {
      "question_id": "EQ2010-VN",
      "question": "Thiết kế một **boundary test** và một **invalid test** cho trường API `age` (phạm vi 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "* **Boundary Test:** Chọn giới hạn (18, 65) và gửi request. **Invalid Test:** Gửi request với age = 0 hoặc > 65."
    },
    {
      "question_id": "EQ2012-VN",
      "question": "Giải thích cách bạn mô phỏng lỗi **network timeout** trong **API testing**.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "By simulating a slow or disconnected network connection and monitoring the API's response time."
    },
    {
      "question_id": "EQ2014-VN",
      "question": "Đưa ra một ví dụ về một **precondition** API và một **step** theo sau nó.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "Precondition: Một người dùng có tài khoản. Step: API trả lời với thông tin người dùng."
    },
    {
      "question_id": "EQ2016-VN",
      "question": "Viết một **test case** để xác thực rằng **API rate limiting** được thực thi đúng.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "**Test Case:** `Rate Limit Test`\n- **Preconditions:** API rate limit (e.g., 100 requests/min) is enabled.\n- **Test Steps:** 1) Send `POST` requests in rapid succession (e.g., 10 requests in 1 minute). 2) Wait for the time window to expire. 3) Send the next request. \n- **Expected Result:** The expired request should return a `429 Too Many Requests` status code, while the subsequent request should be accepted."
    },
    {
      "question_id": "EQ2018-VN",
      "question": "Giải thích một lợi thế của việc sử dụng **service virtualization** trong **API testing**.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "It allows testing with simulated services that are unavailable in real environments."
    },
    {
      "question_id": "EQ2020-VN",
      "question": "Mô tả cách thiết kế một **test case tích cực** và một **boundary test case** cho một API đăng nhập yêu cầu tên người dùng và mật khẩu.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "A positive test case nhập một tên người dùng và mật khẩu hợp lệ và verify response là 200 OK. A boundary test case kiểm tra nhập 'null' hoặc một ký tự đặc biệt cho tên người dùng hoặc mật khẩu."
    },
    {
      "question_id": "EQ2022-VN",
      "question": "Viết một **test step** để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "Send a request with a media type argument (e.g., `?format=json`), tại đó expect phản hồi có status code `415` và chủ đề `Unsupported Media Type`."
    },
    {
      "question_id": "EQ2024-VN",
      "question": "Mô tả một cách để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "1. **Simulate DB Slow Response:** Send a `GET` request đến endpoint API và, trên client-side, sử dụng một library như Postman hoặc insomnia, giả định DB trả lại sau 5s (thay vì ngay lập tức). 2. **Verify API Response:** Chờ kết quả và gửi `GET` tiếp theo cho cùng URL. **Kết luận:** Nếu API trả trả lời nhanh (tương tự với lần truy vấn nhanh), API có **observability** vấn đề và sẽ không phản hồi ngay. 3. **Test Double Synchronization:** Another approach is to use a test double DB that synchronizes data at a known interval. Then, hit the API with a `GET` request. If the API returns data immediately, it's observable."
    },
    {
      "question_id": "EQ2026-VN",
      "question": "Giải thích cách bạn sẽ kiểm tra **API idempotency** cho một kịch bản **retry**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Kiểm tra **idempotency** với **retry**: 1) Send request đầu tiên → `200 OK`. 2) Send request lặp lại → `200 OK` (chưa thay đổi). 3) Kiểm tra **state change** (như DB). 4) Vấn đề: trả **`409 Conflict`** khi lặp lại."
    },
    {
      "question_id": "EQ2028-VN",
      "question": "Đưa ra một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "Boundary: Chia file 10 MB làm hai phần. **Invalid:** Chia file lớn hơn giới hạn."
    },
    {
      "question_id": "EQ2030-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "**Test Case:** Vận hành - Chức năng Bắt buộc Email. **Action:** Trả lời API với trường 'email' bị thiếu. **Expected:** API trả **400 Bad Request** với mã lỗi `InvalidRequest` hoặc `MissingRequiredField`."
    },
    {
      "question_id": "EQ2032-VN",
      "question": "Bạn sẽ thiết kế một **test** để xác thực logic **retry** như thế nào khi một API thỉnh thoảng trả về **503**?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "1. **Precondition:** Dùng mô hình dữ liệu sim (e.g., SQLite) và giả server (mock) để giả định `503 Service Unavailable`. 2. **Test Steps:** 1) Gửi yêu cầu bình thường. 2) Kiểm tra trả lời là `503` và kiểm tra trạng thái client. 3) Chú ý: Nếu client stop retry, API sẽ bị lỗi. 4) Xác minh retry được kích hoạt và số lần retry. 5) Vệ sinh: Mock server cần reset sau mỗi test."
    },
    {
      "question_id": "EQ2034-VN",
      "question": "Viết một **test case** xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "**Test Case:** Log Correlation. **Action:** Send request with `Trace-ID` header → expect matched logs in DB. **Expected:** Logs joined by ID must exist."
    },
    {
      "question_id": "EQ2036-VN",
      "question": "Thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting** khi có nhiều máy khách tham gia.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "1. **Test Case Name:** Verify API Rate Limiting with Concurrent Requests.\n2.  **Preconditions:** 1) API configured with rate limit (e.g., 100 requests/min). 2) Multiple machines (machines = machines) as testers. \n3.  **Test Steps:** 1. **Action:** On mỗi máy tính, sử dụng một client GET /api/v1 metrics (tập hợp các request rate). 2.  **Expected Result:** 1) Tất cả các máy tính đều trả về `200 OK` và metadata (ví dụ: `rate: 68/100`). 2) Không một máy tính nào trả về lỗi 429 Too Many Requests. 3) Tổng số request từ tất cả các máy tính phải `<threshold>`. 4) Đáp thời gian trung bình (average latency) của các request từ các máy tính khác nhau nên không được giới hạn."
    },
    {
      "question_id": "EQ2038-VN",
      "question": "Mô tả một **test case tích cực** và một **test case âm tính** cho một endpoint API gửi mã **SMS**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case tích cực (Positive):** Send a `POST` request với mã **SMS** hợp lệ đến `/send-sms` và verify **status** là `200 OK`. - **Test Case âm tính (Negative):** Send mã **SMS** đã được sử dụng hoặc không tồn tại."
    },
    {
      "question_id": "EQ2040-VN",
      "question": "Giải thích một lợi thế của việc **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Mocking API bên ngoài cho phép kiểm tra các kịch bản thất bại một cách an toàn và kiểm soát được, vì thực tế là hệ thống khác có thể không sẵn sàng hoặc không thể kiểm tra được."
    },
    {
      "question_id": "EQ2042-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi khi API trả về **JSON** bị định dạng sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "Chỉ cần gửi request với body chứa các khóa hoặc giá trị không hợp lệ (ví dụ, `{ \"id\": \"string\" }`) và kiểm tra API trả `400 Bad Request` hoặc `500 Internal Server Error` với mãn hình lỗi phù hợp."
    },
    {
      "question_id": "EQ2044-VN",
      "question": "Thiết kế một **test step** để xác nhận các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "1. **Action:** Send request with all required rate limiting headers (e.g., `X-RateLimit-Remaining`, `X-RateLimit-Limit`, `X-RateLimit-Reset`).\n2. **Expected:** Headers phải được gửi lại với status `200 OK` (bằng vènhỏ). \n3. **Verify:** Kiểm tra response headers để đảm bảo tất cả các header rate limiting đều được gửi và có giá trị."
    },
    {
      "question_id": "EQ2046-VN",
      "question": "Mô tả một lợi thế của việc tách dữ liệu **test** khỏi logic **test** trong **API testing**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Tách dữ liệu test ngăn tránh thay đổi cơ sở dữ liệu, giúp test cases độc lập và dễ dự đoán."
    },
    {
      "question_id": "EQ2048-VN",
      "question": "Viết một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "- **Test Case:** Tìm SDB không tồn tại. - **Action:** Gửi `GET /products` -> DB. - **Expected:** Không trả hồi vụn 404, DB được cập nhật. - **Post-condition:** Suy thoái, phản hồi DB chính xác."
    },
    {
      "question_id": "EQ2050-VN",
      "question": "Giải thích một cách để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Thay đổi mật khẩu -> thay đổi hash mật khẩu. Log hash -> an toàn, không tiết lộ mật khẩu."
    },
    {
      "question_id": "EQ2052-VN",
      "question": "Cung cấp một **test case âm tính** và một **boundary test case** cho một trường tiền tệ phải khớp với mã **ISO 4217**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case Âm Tính (Negative):** \"Mua hàng với số tiền âm (e.g., -10 USD)\".\n- **Boundary Test Case (Boundary Condition):** \"Mua hàng với số tiền biên (e.g., 10.99 USD)\" vì sẽ kiểm tra xem hệ thống xử lý chính xác số tiền biên giới hay không."
    },
    {
      "question_id": "EQ2054-VN",
      "question": "Viết một **test case** để xác thực hành vi API dưới tình trạng mất gói mạng.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "1) Triggers: Send request via API while network packet sniffing disabled. 2) Expected: API response `500 Internal Server Error` with error like 'Connection timed out' (if retry timeout occurs), else service unavailable (if disallow connection). 3) Logs confirm no unexpected database queries."
    },
    {
      "question_id": "EQ2056-VN",
      "question": "Mô tả một phương pháp để xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Truy cập DB sau test **API** -> kiểm tra liệu Row/Record bị xóa."
    },
    {
      "question_id": "EQ2058-VN",
      "question": "Viết một **test case** để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "Test case: Đăng hàng với tình trạng 'Shipped'. Precondition: Transaction được khởi tạo. Action: Thử lỗi nhập hàng không tồn tại. Expected: Transaction phải tự độngrollback đến trạng thái 'Processing'."
    },
    {
      "question_id": "EQ2060-VN",
      "question": "Giải thích một cách tiếp cận để xác thực các thông báo lỗi tuân theo một **JSON schema** nhất quán trên tất cả các **endpoint**.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "Tập trung vào việc validate JSON body với một schema validating specific error types. \nEnsure all API endpoints consume the same schema. \nExample: Endpoint A /create, Endpoint B /update both validate against ErrorSchema.json."
    },
    {
      "question_id": "EQ3002-VN",
      "question": "Viết một test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "Test case: Đăng nhập và truy cập API bảo vệ.\n- **Preconditions:** Một người dùng có sẵn.\n- **Test Steps:**\n  1. Đăng nhập và nhận token.\n  2. Sử dụng token làm mới -> token mới được trả về.\n  3. Sử dụng token mới -> truy cập API được bảo vệ.\n- **Expected Result:** API được truy cập là 200 OK."
    },
    {
      "question_id": "EQ3004-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "Tập trung vào các trường hợp login thất bại và hành động token. Đảm bảo test case có logic block ngăn cản refresh. Ví dụ, if wrong credentials -> no refresh token generated."
    },
    {
      "question_id": "EQ3006-VN",
      "question": "Giải thích cách bạn sẽ xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Xác thực: sử dụng các mã trường (201 Created, 204 No Content) và mã phản hồi (200 OK) trong API. Ánh xạ: chuyển dịch mã nghiệp vụ (ORDER_001) -> mã trạng thái HTTP (để tạo order) trong logic API."
    },
    {
      "question_id": "EQ3008-VN",
      "question": "Viết một test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "**Test Case: Transaction Flow**\n- **Preconditions:** APIs available, DB seeded with valid user, product, and payment methods.\n- **Steps:**\n  1. **Create Order:** `POST /orders` với thông tin hợp lệ (e.g., ID user, ID sản phẩm).\n  2. **Process Payment:** `POST /payments` với ID đơn hàng và phương thức thanh toán.\n  3. **Refund Order:** `POST /refunds` với ID đơn hàng và lý do (e.g., trả hoàn tiền).\n- **Expected:** DB phản hồi đơn hàng có trạng thái `processed`, DB payment phản hồi `id` exist, DB refund phản hồi `amount` được tính chính xác."
    },
    {
      "question_id": "EQ3010-VN",
      "question": "Giải thích một test case xác thực việc làm mới token hoạt động trên nhiều microservice.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case: 'Đăng nhập và sử dụng token'. Đăng nhập vào hệ thống, lấy token và nhắn nó vào header của các request. Kiểm tra xem các microservice được gọi và trả lời đúng (ví dụ, API User -> API Product)."
    },
    {
      "question_id": "EQ3012-VN",
      "question": "Viết một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "Dòng lệnh `curl -XPOST http://localhost:8000/create-user` với mã lỗi xác thực (e.g., `1007`) → `400 Bad Request`. Dòng lệnh khác → `200 OK`. Test đảm bảo trả lời HTTP tương ứng với mã lỗi."
    },
    {
      "question_id": "EQ3014-VN",
      "question": "Thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Action:** Send request for refresh token.\n2. **Expected Result:** Instead of `200 OK` and new access token, trả `403 Forbidden` hoặc `400 Bad Request` vì refresh token đã hết hạn."
    },
    {
      "question_id": "EQ3016-VN",
      "question": "Giải thích một bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra yêu cầu hành động đăng xuất, sau đó kiểm tra các lệnh liên quan: `logout`, `disconnect`, `abort session`. Nghiên cứu cần xác minh session được tự động reset hoặc phải được hủy thủ công."
    },
    {
      "question_id": "EQ3018-VN",
      "question": "Viết một test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "- **Đăng ký:** Send `POST /register` with valid data.\n- **Xác minh email:** Send `POST /verify-email` với địa chỉ email đã đăng ký.\n- **Đăng nhập:** Send `POST /login` với password hoặc token JWT."
    },
    {
      "question_id": "EQ3020-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Đầu tiên, tạo bài kiểm tra cơ bản (Điểm 3) yêu cầu chỉ nhập mã xác minh và mật khẩu mới. Tiếp theo, tạo bài kiểm tra trung bình (Điểm 5) yêu cầu nhập thông tin người dùng. Cuối cùng, tạo bài kiểm tra khó nhất (Điểm 7) yêu cầu nhập thông tin người dùng và xác nhận."
    },
    {
      "question_id": "EQ3022-VN",
      "question": "Viết một test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "**Test Case: Tạo Người Dùng**\n- **Preconditions:** API hoạt động.\n- **Steps:**\n  - Tạo người dùng mới (đây là hành động cơ bản).\n  - Cập nhật hồ sơ với thông tin cụ thể (ví dụ, địa chỉ, số điện thoại).\n  - Truy xuất hồ sơ bằng ID người dùng.\n- **Expected:** Các phản hồi phải là `200 OK` cho tạo mới, `200 OK` cho cập nhật, và dữ liệu phải được lưu trữ."
    },
    {
      "question_id": "EQ3024-VN",
      "question": "Giải thích một bài kiểm tra để xác thực refresh token không thể được sử dụng sau khi đăng xuất.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra là đăng nhập vào tài khoản với mã access. Tìm kiếm refresh token và dùng nó để lấy token mới. Thử đăng xuất và cố lấy tài khoản mới với token cũ. Nếu được chặn, token refresh bị block."
    },
    {
      "question_id": "EQ3026-VN",
      "question": "Viết một test case xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "- **Mô tả:** Triggers session expiration → expect `403 Exceeded Lifetime` rather than internal error. \n- **Điểm kiểm tra:** 1) Log in với thời gian hạn chế → 2) Xác minh phản hồi có status code 403. \n- **Hàm xác minh:** Assert response body chứa thông tin 'expires' hoặc 'lifetime'."
    },
    {
      "question_id": "EQ3028-VN",
      "question": "Giải thích một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Thật đơn giản. Nếu token không hợp lệ, thì kiểm tra xác minh sẽ thất bại vì nó chỉ chấp nhận token hợp lệ. Ví dụ, sử dụng token đã được sử dụng nhưng đã hết hạn."
    },
    {
      "question_id": "EQ3030-VN",
      "question": "Viết một test case cấp độ khó chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "**Test Case: Sợm Mạo**\n- **Preconditions:** Tài khoản có tiền sử vay, tín dụng sẵn.\n- **Steps:** Đăng nhập -> Nộp đơn vay -> Tín dụng -> Phê duyệt -> All Combinations.\n- **Expected:** only valid -> response 400 invalid -> DB matches."
    },
    {
      "question_id": "EQ3032-VN",
      "question": "Thiết kế một test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Preconditions:** Tạo tài khoản exist, mật khẩu thay đổi.\n2. **Steps:**\n   - **Chuỗi đăng ký:** Đăng ký mới với email và password unique.\n   - **Đặt lại mật khẩu:** Gửi mã và nhập lại.\n   - **Đăng nhập:** Log in với email và password mới.\n3. **Expected Results:** Đăng nhập thành công only khi đúng password."
    },
    {
      "question_id": "EQ3034-VN",
      "question": "Viết một test case chuỗi các endpoint tải lên file, quét virus và tải xuống.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "- **Preconditions:** File exist, user token.\n- - **Endpoint 1 (POST /files):** Chức năng tải lên file → `{\"file_name\": \"test.txt\", \"file_type\": \"text/plain\", \"file_size\": 102}`.\n- - **Endpoint 2 (GET /files/:id) → Virus Scan:** Chức năng quét virus → trả `200 OK` với báo cáo virus.\n- - **Endpoint 3 (GET /files/:id) → Download:** Chức năng tải xuống → trả tệp `test.txt`."
    },
    {
      "question_id": "EQ3036-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn việc sử dụng lại refresh token.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Đo kiểm xem refresh token được sử dụng một cách hợp lệ và xem có token mới được tạo sau thời gian hạn đầu không."
    },
    {
      "question_id": "EQ3038-VN",
      "question": "Viết một test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Giỏ Hàng**\n- **Preconditions:** User exist, sản phẩm có giá.\n- **Steps:** 1) Tìm kiếm sản phẩm. 2) Thêm vào giỏ hàng. 3) Thanh toán (bán hàng). 4) Xác nhận giỏ hàng được cập nhật.\n- **Expected:** DB có order record, sản phẩm số lượng giảm 1."
    },
    {
      "question_id": "EQ3040-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn tấn công chiếm đoạt session API.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Bài kiểm tra sẽ yêu cầu người dùng thực hiện các hành động như đăng nhập, mua hàng, và chuyển giao giao dịch. Sau đó, người dùng sẽ cố gắng truy cập tài khoản khác bằng session bị đánh cắp. **Điểm kiểm tra:** 1) Tốc độ phản hồi khi nhập session bất hợp pháp. 2) Kiểm tra xem session bị canjú (impersonate) được chấp nhận hay không. 3) Vérify xem DB được cập nhật khi session bị vô hiệu hóa."
    },
    {
      "question_id": "EQ3042-VN",
      "question": "Cung cấp chính xác một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "Test: Đăng ký (POST) tạo một tài liệu với ETag `\"revision=123\"` và mã được tạo. Tiếp đó, cập nhật tài liệu thay đổi (PUT) và lưu lại ETag mới. Đọc lại (GET) và kiểm tra phản ứng là `200 OK`."
    },
    {
      "question_id": "EQ3044-VN",
      "question": "Thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ: POST /exports -> thăm dò GET /jobs/{id} cho đến khi hoàn thành -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Đầu tiên, gửi request POST /exports và lưu ID export. Tiếp theo, gửi request GET /jobs/{id} liên tục cho đến khi trả code 200 OK (hoàn thành) hoặc 503 Service Unavailable (đồng bộ). Cuối cùng, kiểm tra request GET /exports/{id} được thực hiện sau thời gian."
    },
    {
      "question_id": "EQ3046-VN",
      "question": "Cung cấp một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code: /authorize -> /token -> gọi tài nguyên với scope bị thiếu.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "Đáp án: Trả lời `/authorize` với scope không tồn tại, `/token` không được trả lại, gọi tài nguyên -> 403 Forbidden."
    },
    {
      "question_id": "EQ3048-VN",
      "question": "Viết một bài kiểm tra chuỗi bao gồm việc tạo charge幂等 (idempotent charge creation) với Idempotency-Key trên các endpoint thử lại và hoàn tiền.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "Tập trung vào idempotency với các trường như `idempotency-key` trên headers. Các test yêu cầu tạo `charge` với key giống nhau (tương tự) và key khác nhau, sau đó thử lại với hành động tương tự. Hoàn tiền yêu cầu kích hoạt sau mỗi lần thử."
    },
    {
      "question_id": "EQ3050-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi cho quy trình xử lý file: tải lên -> POST /process -> thăm dò trạng thái -> tải xuống, bao gồm cả việc xử lý 202.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Chuỗi kiểm tra: 1) Tải file lên server. 2) Gửi yêu cầu POST /process với mã bài kiểm tra. 3) Xác động trạng thái (đăng nhập, xử lý, cập nhật). 4) Xử lý 202 nếu file được xử lý thành công nhưng không cần phản hồi. 5) Tải file xuống (tùy chọn) hoặc trả tựa. 6) Vệ sinh state DB."
    },
    {
      "question_id": "EQ3052-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "1. **API Gateway:** Send a logout request (e.g., `/logout`) to the session management endpoint. **Microservice:** Verify that a user's session data (e.g., user ID) is cleared from the database within a reasonable timeframe (e.g., 5-10 minutes). 2. **Database Verification:** Perform a SQL query on the microservice's database to confirm the user's session has been terminated (session ID removed, expired, or nullified)."
    },
    {
      "question_id": "EQ3054-VN",
      "question": "Viết một test case chuỗi cho việc thực hiện đơn hàng một phần: tạo đơn hàng -> dự trữ hàng tồn kho -> ship một phần -> hủy phần còn lại và hoàn tiền chênh lệch.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "- **Preconditions:** Đơn hàng (ID=xxx) và hàng tồn kho (tên sản phẩm exist).\n- **Steps:**\n  1. Tạo đơn hàng (`/orders`).\n  2. Dự trữ hàng cho đơn hàng.\n  3. Ship một phần đơn hàng.\n  4. Hủy phần còn lại và kiểm tra hoàn tiền chênh lệch.\n- **Expected:** DB phản ánh số lượng hàng còn lại."
    },
    {
      "question_id": "EQ3056-VN",
      "question": "Cung cấp chính xác một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA: POST /login -> POST /2fa/verify với mã sai -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập 2FA (POST /login)**: Send `POST /login` với mã OTP đúng và thông tin người dùng. 2. **Xác minh 2FA (POST /2fa/verify)**: Send mã OTP sai (ví dụ: `{\"otp\": \"123456\"}`) và mã OTP đúng. 3. **Tiền Refresh (POST /refresh)**: Send yêu cầu refresh token."
    },
    {
      "question_id": "EQ3058-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê (với các xác nhận tổng số đếm).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Đầu tiên, tạo các trường mẫu (e.g., ID=999, tên='Test Item'). Tiếp theo, chạy các thao tác theo quy tắc (tạo 10, xóa 5, liệt kê sau tạo và xóa). Cuối cùng, so sánh số liệu cơ bản (tổng số, ID) giữa các bước và kết luận phân trang là thành công."
    },
    {
      "question_id": "EQ3060-VN",
      "question": "Viết một bài kiểm tra chuỗi cho tính dính session (session stickiness): đăng nhập -> các cuộc gọi tiếp theo qua load balancer -> đăng xuất -> xác minh không có node nào chấp nhận token cũ.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "Đăng nhập -> truy cập API -> đăng xuất -> kiểm tra session bị hủy -> kết quả là `403 Forbidden` hoặc token expired."
    },
    {
      "question_id": "EQ4002-VN",
      "question": "Viết một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản: tạo → kích hoạt → tạm ngừng → kích hoạt lại → xóa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "1. **Đầu vào:** Tạo tài khoản mới (mã user exist).\n2. **Trạng thái:** Aktivated → kích hoạt.\n3. **Hành động:** Tạm ngừng tài khoản (status → inactive).\n4. **Trả lời:** Xóa tài khoản → không tồn tại.\n5. **Xử lý lỗi:** Tạo tài khoản đã tồn tại → 409 Conflict.\n6. **Tập hợp:** Tăng quyền (admin) → cập nhật quyền.\n7. **Đặt điều kiện:** Xóa tài khoản không tồn tại → 404 Not Found."
    },
    {
      "question_id": "EQ4004-VN",
      "question": "Thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Action 1 (Create Transaction):** Khởi động giao dịch chuyển tiền từ tài khoản A -> Tai Khoan B với số tiền 10. 2. **Action 2 (Perform Transfer):** Send amount 3 from Tai Khoan A -> Tai Khoang B. 3. **Action 3 (Fail Transfer):** Send amount -3 từ Tai Khoang A -> Tai Khoang B. 4. **Expected Result:** Giao dịch rollback tự động."
    },
    {
      "question_id": "EQ4006-VN",
      "question": "Viết một **test** xác thực chuỗi nhiều dịch vụ: đăng nhập → tạo đơn hàng → xử lý thanh toán → hủy đơn hàng sau khi ghi nhận.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Test: 1) Đăng nhập vào tài khoản. 2) Tạo đơn hàng. 3) Chọn phương thức thanh toán. 4) Xác nhận đơn hàng được tạo thành công. 5) Hủy đơn hàng. 6) Kiểm tra DB, record bị xóa."
    },
    {
      "question_id": "EQ4008-VN",
      "question": "Mô tả một **test state-machine** xác thực vòng đời mật khẩu: đặt → hết hạn → đặt lại → ngăn tái sử dụng.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "Mô tả: Đăng nhập → mãng mật khẩu → nhập mới → không tái sử dụng."
    },
    {
      "question_id": "EQ4010-VN",
      "question": "Viết một **test chained** phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "1. Đăng nhập vào hệ thống với tài khoản hợp lệ.\n2. Chọn `LoanApplication` và chọn branch `Default`.\n3. Triggers API đăng ký khoản vay. Verifies `201 Created` for success. \n4. Simulates lỗi khi đăng nhập với tài khoản có tín dụng kém (kẻ xấu).\n5. Verifies `409 Conflict` hoặc `500 Internal Server Error` là expected."
    },
    {
      "question_id": "EQ4012-VN",
      "question": "Viết một **test** xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra: cập nhật hồ sơ người dùng với các giá trị xung đột.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "**Test:** 1) Tiến hành cập nhật hồ sơ người dùng với giá trị 'tên' = 'John Doe'. 2) Simulate các yêu cầu ghi đồng thời. 3) Verificaton: sau giao dịch, đọc hồ sơ người dùng. **Expected:** Tính toàn vẹn dữ liệu (mã người dùng không thay đổi, trường 'tên' không bị thay đổi bất hợp pháp)."
    },
    {
      "question_id": "EQ4014-VN",
      "question": "Viết một **test chained** rất khó xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Test chained yêu cầu kiểm tra quy trình ký tài liệu chuỗi. Ví dụ, tải file có chữ ký → thực hiện ký → kiểm tra chữ ký → tìm chứng thực. Có thể giả mạo chữ ký, test chỉ xác định thực thể có quyền."
    },
    {
      "question_id": "EQ4017-VN",
      "question": "Viết một **test state-machine** xác thực vòng đời đăng ký: tạo → nâng cấp → hạ cấp → hủy.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Initial State:** Register → `state = 'pending'`.\n2. **Actions & Expected Results:**\n   - **Create:** `state = 'created' → expect DB record created`.\n   - **Upgrade:** `state = 'upgraded' → expect DB field 'level' updated to 'premium' → expect features enabled`.\n   - **Downgrade:** `state = 'downgraded' → expect DB field 'level' set to 'basic' → expect features disabled`.\n   - **Delete:** `state = 'deleted' → expect record removed from DB`."
    },
    {
      "question_id": "EQ4019-VN",
      "question": "Viết một **test chained** rất khó xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "A test chained with a partial failure in a distributed order saga is difficult to design and execute because it requires a complex, automated setup that simulates a specific failure point. This is hard to control and reproduce, as it depends on multiple distributed services failing or recovering in specific ways."
    },
    {
      "question_id": "EQ4021-VN",
      "question": "Viết một **test** rất khó xác minh việc đảo ngược giao dịch tài chính: ghi nợ → ghi có → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "Test tự động simulates giao dịch. Nếu thất bại, DB must có record của giao dịch bị lỗi. Rollback test khó vì cần giả data, simulate lỗi giao dịch, và đảm bảo DB reverted back."
    },
    {
      "question_id": "EQ4023-VN",
      "question": "Thiết kế một **test state-machine** cho kho hàng: thêm hàng → phân bổ → vận chuyển → trả lại → đối chiếu.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Add item → 2) Verify distribution → 3) Simulate shipment → 4) Confirm delivery. All steps must follow state machine logic."
    },
    {
      "question_id": "EQ4025-VN",
      "question": "Viết một **test chained** xác thực vòng đời **session mobile**: đăng nhập → làm mới **token** → đăng xuất → làm mới với **token** cũ → thất bại.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "1. **Đăng nhập**: Viết command `login` với người dùng có quyền.\n2. **Làm mới token**: Viết command `refresh_token` sử dụng token mới nhất.\n3. **Đăng xuất**: Viết command `logout`.\n4. **Làm mới token cũ**: Chained command với token cũ → thất bại (đáp ứng không được hỗ trợ).\n5. **Xác minh kết quả**: Kiểm tra trạng thái cơ sở lưu trữ."
    },
    {
      "question_id": "EQ4027-VN",
      "question": "Viết một **test chained** xác thực API gửi email: gửi → theo dõi mở → hủy đăng ký → đảm bảo không gửi thêm email nào nữa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "1. **Action 1:** Triggers email sending via `send_email` endpoint with valid email = `{\"to\": \"user@example.com\", \"subject\": \"Test\"}`.\n2. **Action 2:** Verifies API returns `200 OK` and DB confirms email sent only once per user.\n3. **Action 3:** Simulates user action → API response: if email sent → `200`, hủy đăng ký → API response → `204 No Content` (no response for successful deletion)."
    },
    {
      "question_id": "EQ4029-VN",
      "question": "Viết một **test chained** rất khó cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại: áp dụng phiếu giảm giá → thanh toán → phiếu giảm giá không hợp lệ → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chained must ensure all states (valid, invalid) are covered with rollback for invalid. Example: 1) Đặt hàng → 2) Áp dụng giảm giá → 3) Giảm giá bị block → 4) Rollback → DB đảm bảo giao dịch reverted."
    }
  ]
}