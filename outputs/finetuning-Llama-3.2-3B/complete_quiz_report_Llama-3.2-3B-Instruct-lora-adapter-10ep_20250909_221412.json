{
  "timestamp": "20250909_221412",
  "model": "Llama-3.2-3B-Instruct-lora-adapter-10ep",
  "summary": {
    "total_questions": 500,
    "mcq_questions": 258,
    "writing_questions": 242,
    "mcq_accuracy": 0.7286821705426356,
    "mcq_correct": 188,
    "mcq_incorrect": 70
  },
  "results": [
    {
      "question_id": "EQ5001",
      "question": "Which HTTP method is commonly used to retrieve data from an API?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. GET. The `GET` method is used to retrieve or read data from a specific resource on the server. It is considered a safe and idempotent request, meaning it should not change the state of the server and making the same request multiple times will not cause unintended side effects.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is the standard method for retrieving data."
    },
    {
      "question_id": "EQ5002",
      "question": "What does HTTP status code 404 represent?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "OK",
        "B": "Unauthorized",
        "C": "Not Found",
        "D": "Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Not Found – this status code is used for resources that can’t be found.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "404 indicates the requested resource could not be found."
    },
    {
      "question_id": "EQ5003",
      "question": "What is the purpose of the HTTP POST method?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "Retrieve data",
        "B": "Submit data to create resources",
        "C": "Update existing resources",
        "D": "Delete resources"
      },
      "gold_answer": "B",
      "model_raw_answer": "The purpose of the HTTP POST method is to submit data to create a new resource.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "POST is used to create new resources with data in the request body."
    },
    {
      "question_id": "EQ5004",
      "type": "Writing",
      "gold": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user exists with a valid password.\n- **Test Steps:** Send a `POST` request to the login endpoint with a valid username and password (e.g., `{\"username\": \"john\", \"password\": \"Pass123\"}`).\n- **Expected Result:** The API returns a `200 OK` status code with a login token in the response."
    },
    {
      "question_id": "EQ5005",
      "question": "Which of these HTTP status codes means 'Unauthorized'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 is the status code for 'Unauthorized'.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates missing or invalid credentials."
    },
    {
      "question_id": "EQ5006",
      "type": "Writing",
      "gold": "User must be logged in and have a valid token.",
      "model_answer": "A valid user account with existing profile data is required. This ensures tests can operate on a known state and verify correct profile updates or reads."
    },
    {
      "question_id": "EQ5007",
      "question": "Which HTTP method is considered idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "PUT",
        "D": "CONNECT"
      },
      "gold_answer": "C",
      "model_raw_answer": "Idempotent methods will not cause a change if called multiple times. Examples are `GET`, `PUT`, and `PATCH`. `POST` is not idempotent because it will always create a new resource.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "PUT is idempotent because multiple identical requests have the same effect."
    },
    {
      "question_id": "EQ5008",
      "type": "Writing",
      "gold": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Send a `POST` request with an invalid transaction ID. The expected response is a `400 Bad Request` with a clear error message."
    },
    {
      "question_id": "EQ5009",
      "question": "Which HTTP status code means 'OK'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 200",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK is the standard success code."
    },
    {
      "question_id": "EQ5010",
      "type": "Writing",
      "gold": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure and expected data for an API endpoint. It helps testers create valid request bodies, validate responses against a known format, and identify integration issues."
    },
    {
      "question_id": "EQ5011",
      "question": "Which HTTP method is used to delete a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. GET.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "DELETE removes the resource specified in the URL."
    },
    {
      "question_id": "EQ5012",
      "type": "Writing",
      "gold": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "Send a `POST` request with all required parameters. Expected: The response status code should be `201 Created`."
    },
    {
      "question_id": "EQ5013",
      "question": "Which HTTP header is typically used for authentication tokens?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "Accept",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Authorization.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Authorization header carries credentials or tokens."
    },
    {
      "question_id": "EQ5014",
      "type": "Writing",
      "gold": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependencies with simulated ones. This isolates the API under test and allows faster, more reliable, and more reproducible tests to be run. It prevents tests from failing due to external systems being unavailable."
    },
    {
      "question_id": "EQ5015",
      "question": "Which HTTP status code indicates 'Created'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "403"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 201. This status code is used to indicate that a resource was created on the server.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created confirms successful creation of a resource."
    },
    {
      "question_id": "EQ5016",
      "type": "Writing",
      "gold": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "**Test Case: Fetch Product List**\n- **Preconditions:** API is running, and a sample product (e.g., 'product_1') exists in the database.\n- **Test Steps:** Send a `GET` request to `/products`.\n- **Expected Result:** The API returns a successful `200 OK` status code with a valid JSON array of products."
    },
    {
      "question_id": "EQ5017",
      "question": "Which HTTP status indicates 'Internal Server Error'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "403",
        "D": "500"
      },
      "gold_answer": "D",
      "model_raw_answer": "Internal Server Errors (500 series) indicate the server encountered an unexpected condition. The correct status code is 500 Internal Server Error.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "500 indicates unexpected server-side failure."
    },
    {
      "question_id": "EQ5018",
      "type": "Writing",
      "gold": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "A precondition is a state that must be true before a test case is executed. It ensures the test environment is stable and consistent."
    },
    {
      "question_id": "EQ5019",
      "question": "Which HTTP status is appropriate for forbidden access with valid credentials?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "Answer: C. 403 Forbidden indicates that access to the requested resource is forbidden for the authenticated user.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden indicates insufficient permissions despite valid login."
    },
    {
      "question_id": "EQ5020",
      "type": "Writing",
      "gold": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Negative Test: Upload a.docx file. Expected: The file should not be processed, and no successful upload response is given."
    },
    {
      "question_id": "EQ5021",
      "question": "Which HTTP method is typically used for partial updates?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PATCH",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. PATCH.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PATCH is used to modify part of a resource."
    },
    {
      "question_id": "EQ5022",
      "type": "Writing",
      "gold": "To explain the objective and scope of a test scenario.",
      "model_answer": "A test case description explains what the test case is testing, its preconditions, and its expected results. It serves as a clear and concise summary of the test's objective."
    },
    {
      "question_id": "EQ5023",
      "question": "Which HTTP header indicates the format of request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Accept-Encoding"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. Content-Type. It indicates the format of the request body.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Type defines the media type of request body."
    },
    {
      "question_id": "EQ5024",
      "type": "Writing",
      "gold": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "1. Send request with timer configured.\n2. Assert response time < 1 second."
    },
    {
      "question_id": "EQ5025",
      "question": "Which HTTP status code indicates a conflict, such as duplicate resource creation?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 409 Conflict.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict is used when request conflicts with current state."
    },
    {
      "question_id": "EQ5026",
      "question": "Which HTTP status code means 'Bad Request'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 Bad Request indicates invalid syntax or parameters."
    },
    {
      "question_id": "EQ5027",
      "type": "Writing",
      "gold": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "Request the `/health` endpoint and verify that the response body contains a simple 'healthy' message like '{\"status\":\"healthy\"}'."
    },
    {
      "question_id": "EQ5028",
      "question": "Which HTTP method is used to fully update a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B, as PUT is the HTTP method used to fully update a resource.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT replaces an existing resource with new data."
    },
    {
      "question_id": "EQ5029",
      "type": "Writing",
      "gold": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management provides secure, repeatable, and relevant data for API testing. This is crucial for avoiding data leaks, reducing setup time, and improving test reliability. It ensures that tests can be run multiple times without affecting real data."
    },
    {
      "question_id": "EQ5030",
      "question": "Which HTTP status indicates 'Forbidden'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "401",
        "D": "403"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 403. This status code indicates that the client does not have access to the requested resource; however, it is associated with authentication (e.g., 401 Unauthorized) rather than lack of access. The correct status for 'Forbidden' is 403.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "403 Forbidden means user is authenticated but not authorized."
    },
    {
      "question_id": "EQ5031",
      "type": "Writing",
      "gold": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "Send a `GET` request with a raw text response body (e.g., 'User found'). The API should fail if it doesn't expect this format. Example: `expect_json = False => 400 Bad Request for malformed response`."
    },
    {
      "question_id": "EQ5032",
      "question": "Which HTTP status code represents 'Too Many Requests'?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Easy",
      "options": {
        "A": "408",
        "B": "429",
        "C": "503",
        "D": "504"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 429. This status code indicates that the user exceeded the rate limit for the request, which is a common anti-abuse measure.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "429 Too Many Requests is returned when rate limits are exceeded."
    },
    {
      "question_id": "EQ5033",
      "type": "Writing",
      "gold": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions are used to verify that the API behaves exactly as expected. They are included in the `assert` statement in the test script, e.g., `assert.json.equal(response.json(), expected_json)`. This ensures the API returns the correct status code, headers, and data format."
    },
    {
      "question_id": "EQ5034",
      "question": "Which HTTP status indicates a timeout from the server?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "400",
        "C": "200",
        "D": "504"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 504. This status code indicates that the server timed out waiting for a response from an upstream server.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "504 Gateway Timeout indicates the server did not respond in time."
    },
    {
      "question_id": "EQ5035",
      "type": "Writing",
      "gold": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "Create a user, send a DELETE request, and verify the user is now gone from the database."
    },
    {
      "question_id": "EQ5036",
      "question": "Which HTTP method is safe (does not change server state)?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is safe because it only retrieves data."
    },
    {
      "question_id": "EQ5037",
      "type": "Writing",
      "gold": "A new resource has been successfully created.",
      "model_answer": "That the request was successful and a new resource was created."
    },
    {
      "question_id": "EQ5038",
      "question": "Which HTTP status is returned when a client request is well-formed but unauthorized?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "401",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "Correct answer: C. 401.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized is used for invalid credentials."
    },
    {
      "question_id": "EQ5039",
      "type": "Writing",
      "gold": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test: Request /users/123 and verify the response body contains only valid data (e.g., user name, email)."
    },
    {
      "question_id": "EQ5040",
      "question": "Which HTTP status indicates success but no content is returned?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204 – No Content is a safe response indicating success but the client doesn’t need to process the full response body.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content is returned on successful deletion or empty responses."
    },
    {
      "question_id": "EQ5041",
      "type": "Writing",
      "gold": "It confirms that the request has succeeded.",
      "model_answer": "The purpose of a 200 OK response is to indicate that the request was successful and the resource was updated, but the full response is not needed. It's a common practice to only return the created resource in a `201 Created` response, while `200 OK` is used for `PUT` or `PATCH` operations that don't need to return the full state of the resource."
    },
    {
      "question_id": "EQ5042",
      "question": "Which header is used to specify accepted response formats?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Accept",
        "C": "Authorization",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Accept. The `Accept` header is used to specify the response formats that the client can understand and accept. For example, a client might send `Accept: application/json, application/xml` to tell the server it can handle both JSON and XML formats.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Accept header tells the server which formats are expected (e.g., application/json)."
    },
    {
      "question_id": "EQ5043",
      "type": "Writing",
      "gold": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "Send a request to a non-existent endpoint like `/v1/users` and assert that the server responds with a `405 Method Not Allowed` or `404 Not Found` status."
    },
    {
      "question_id": "EQ5044",
      "question": "Which HTTP status code is used when the client must authenticate to access a resource?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "403",
        "C": "401",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 401 – Unauthorized. The client must provide credentials to access the resource.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized requires authentication credentials."
    },
    {
      "question_id": "EQ5045",
      "type": "Writing",
      "gold": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion is a statement that checks if a certain condition is true. It is the 'asserts' part of 'assertion' in testing."
    },
    {
      "question_id": "EQ5046",
      "question": "Which HTTP status indicates the server cannot handle the request due to overload?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "503 Service Unavailable",
        "B": "200 OK",
        "C": "404 Not Found",
        "D": "201 Created"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. 503 Service Unavailable. This status code indicates that the server is temporarily unable to handle the request due to overload or high traffic.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "503 indicates temporary overload or maintenance."
    },
    {
      "question_id": "EQ5047",
      "type": "Writing",
      "gold": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "Test uploads a valid 5MB text file (`upload.txt`) with content 'Hello World!'. Expected: `201 Created` with file present in storage."
    },
    {
      "question_id": "EQ5048",
      "question": "Which HTTP method is safe and idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "GET",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "Both 'GET' and 'PUT' (not listed) are safe and idempotent. However, since 'PUT' is not an option, the safest and most common idempotent method listed is 'GET'.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "GET is both safe and idempotent."
    },
    {
      "question_id": "EQ5049",
      "type": "Writing",
      "gold": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "It indicates the server cannot process the request format."
    },
    {
      "question_id": "EQ5050",
      "question": "Which HTTP status code means 'Request Timeout'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "408",
        "C": "500",
        "D": "429"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 408. This status code is used for timeouts, indicating the server timed out waiting for a response from the client.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout indicates the client took too long to send the request."
    },
    {
      "question_id": "EQ5051",
      "question": "Which HTTP method is typically used to create a new resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. POST.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST is the standard method for creating resources."
    },
    {
      "question_id": "EQ5052",
      "type": "Writing",
      "gold": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "Send a `GET` request for a specific product ID, such as `product_id=123`, and assert that the response status code is `200 OK` and that the retrieved product data includes a valid `id`, `price`, and `description`."
    },
    {
      "question_id": "EQ5053",
      "question": "Which HTTP status code is returned when a resource is successfully deleted?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. 200",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "204 No Content confirms deletion succeeded."
    },
    {
      "question_id": "EQ5054",
      "type": "Writing",
      "gold": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The Authorization header is used to include a valid token or credential in API requests. This token is typically issued by a authentication server (like OAuth or JWT) and grants the client access to specific resources. In testing, you would replace a real token with a dummy or placeholder to simulate a user's access."
    },
    {
      "question_id": "EQ5055",
      "question": "Which HTTP status code is used when a client sends an invalid JSON payload?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. 400 Bad Request. This status code indicates that the server cannot process the request due to a client error, often because of a malformed parameter in the request body, such as an invalid JSON payload.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 indicates the request could not be understood due to invalid syntax."
    },
    {
      "question_id": "EQ5056",
      "type": "Writing",
      "gold": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Unauthorized Login**\n- **Preconditions:** No valid user token exists.\n- **Test Steps:** Send a regular login request (e.g., `POST /login`) without a username or password.\n- **Expected Result:** `401 Unauthorized` status code is returned with a corresponding error message."
    },
    {
      "question_id": "EQ5057",
      "question": "Which HTTP method is generally used to update a resource entirely?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B, as the `PUT` method is specifically designed to update a resource completely with all necessary fields.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT replaces the full resource with new data."
    },
    {
      "question_id": "EQ5058",
      "type": "Writing",
      "gold": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "A 500 Internal Server Error is a generic status code that indicates an unexpected condition was encountered. In API testing, it usually means there is a bug in the server code that cannot be resolved by a valid request. It's not a client error but a server error."
    },
    {
      "question_id": "EQ5059",
      "question": "Which HTTP status means 'Conflict'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "409"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 is the correct status code for 'Conflict'.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict occurs when resource creation/update conflicts with state."
    },
    {
      "question_id": "EQ5060",
      "type": "Writing",
      "gold": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "**Test Case: Retrieve Orders**\n- **Preconditions:** User authenticated, 5 orders exist (e.g., order_id=1→customer→order_id=2→...).\n- **Test Steps:** Send `GET /orders` to API.\n- **Expected Result:** `200 OK` with JSON array of 5 orders (e.g., `{...}, {...},...}`)."
    },
    {
      "question_id": "EQ5061",
      "question": "Which HTTP method is used for partial updates to resources?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. PATCH. PATCH is used for sending a partial set of changes to a resource.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH modifies only part of a resource."
    },
    {
      "question_id": "EQ5062",
      "type": "Writing",
      "gold": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "Response headers provide metadata about the response, such as the `Content-Type` or `Cache-Control`. They are crucial for API testing as they help verify the format of the data and configure caching behavior in the client."
    },
    {
      "question_id": "EQ5063",
      "question": "Which HTTP status code is returned when authentication is required but missing?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 401. This status code is used for authentication errors, meaning the client must authenticate itself before accessing the resource.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates missing or invalid credentials."
    },
    {
      "question_id": "EQ5064",
      "type": "Writing",
      "gold": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Create Resource A → 200 OK. Attempt to create identical Resource A → 409 Conflict (Duplicate Resource)."
    },
    {
      "question_id": "EQ5065",
      "question": "Which HTTP method is most often used for safe read-only operations?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. GET. It is used for safe read-only operations, as it retrieves data without modifying it.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is safe and read-only."
    },
    {
      "question_id": "EQ5066",
      "type": "Writing",
      "gold": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "202 Accepted is a status code that indicates an request was successful but the API doesn't need to create a resource. It's commonly used for `PUT` or `PATCH` requests that update existing data, or for `POST` requests that create a resource but the client already knows about it."
    },
    {
      "question_id": "EQ5067",
      "question": "Which HTTP status is returned when a resource has been permanently moved?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "302",
        "C": "301",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "Answer: C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "301 Moved Permanently indicates redirection."
    },
    {
      "question_id": "EQ5068",
      "type": "Writing",
      "gold": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "Test by calling an endpoint like `/products` and verifying that the response contains the expected `id` field."
    },
    {
      "question_id": "EQ5069",
      "question": "Which HTTP status indicates the request is valid but resource not found?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "404"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 404.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "404 Not Found means the resource does not exist."
    },
    {
      "question_id": "EQ5070",
      "type": "Writing",
      "gold": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body contains the data returned to the client after an API request is executed. It's a crucial part of API testing to ensure the correct data format and content is being returned."
    },
    {
      "question_id": "EQ5071",
      "question": "Which HTTP status indicates client request timeout?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "500",
        "B": "408",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout means the client did not finish sending in time."
    },
    {
      "question_id": "EQ5072",
      "type": "Writing",
      "gold": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "Test Case: Logout\n- Log in successfully.\n- Click logout → expect `href` to redirect to login page.\n- Verify session cleared (e.g., no admin token)."
    },
    {
      "question_id": "EQ5073",
      "question": "Which HTTP status indicates a successful request returning JSON data?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. 200 OK, as it indicates the request was successful.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK is the standard code for successful GETs."
    },
    {
      "question_id": "EQ5074",
      "type": "Writing",
      "gold": "That the server rejects unsupported request body formats.",
      "model_answer": "A 415 Unsupported Media Type error validates that the client can understand unsupported media types. It ensures the client knows how to handle different types of data formats."
    },
    {
      "question_id": "EQ5075",
      "question": "Which HTTP status code indicates server is temporarily down for maintenance?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable – indicates the server is temporarily unable to handle requests.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 is used when service is unavailable due to overload or maintenance."
    },
    {
      "question_id": "EQ5076",
      "question": "Which HTTP method is commonly used for updating only part of a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH is commonly used for updating only part of a resource.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH is designed for partial updates."
    },
    {
      "question_id": "EQ5077",
      "type": "Writing",
      "gold": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "Send a valid GET request to `/status` and assert the response status code is `200 OK`."
    },
    {
      "question_id": "EQ5078",
      "question": "Which HTTP status indicates a successful resource creation?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 201 Created. This status code indicates that a new resource has been successfully created on the server.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created confirms successful creation of resource."
    },
    {
      "question_id": "EQ5079",
      "type": "Writing",
      "gold": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content is a successful request response that indicates the server understood the client's request but does not need to return all the data. It is often used for `PUT` or `PATCH` requests where only part of the resource needs to be updated."
    },
    {
      "question_id": "EQ5080",
      "question": "Which HTTP status code is used when a request is valid but access is forbidden?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden means valid credentials but insufficient permissions."
    },
    {
      "question_id": "EQ5081",
      "type": "Writing",
      "gold": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "Send a request with a `Content-Type` header like `application=csv`. The server should reject the request with a `400 Bad Request` or `415 Unsupported Media Type` error."
    },
    {
      "question_id": "EQ5082",
      "question": "Which HTTP status code indicates success but the resource is empty?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "400 Bad Request",
        "D": "204 No Content"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 is returned when no body content is available."
    },
    {
      "question_id": "EQ5083",
      "type": "Writing",
      "gold": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header tells the server which data formats it supports and asks the server to return a response body in that format. It is commonly used to request JSON or XML data."
    },
    {
      "question_id": "EQ5084",
      "question": "Which HTTP status code is appropriate for invalid user credentials?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct HTTP status code for invalid user credentials is 401 Unauthorized, as it indicates that the client must authenticate itself and the provided credentials are incorrect.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates invalid login credentials."
    },
    {
      "question_id": "EQ5085",
      "type": "Writing",
      "gold": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Successful Logout**\n- **Preconditions:** User logged in with valid session.\n- **Test Step:** Send `POST` request to `/logout` and verify no-redirection response.\n- **Expected Result:** API returns `204 No Content` with no session data cleared."
    },
    {
      "question_id": "EQ5086",
      "question": "Which HTTP method is used to retrieve resource details?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. GET. This method is used to retrieve or read the details of a resource that already exists.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is used to retrieve data."
    },
    {
      "question_id": "EQ5087",
      "type": "Writing",
      "gold": "It means the client must provide valid authentication credentials.",
      "model_answer": "The 401 Unauthorized status code indicates that the API request must be authenticated. A typical cause is providing a valid API key in the request headers but a mismatched or expired key. It signifies a security check that has failed."
    },
    {
      "question_id": "EQ5088",
      "question": "Which HTTP status code indicates duplicate resource creation attempt?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 409 Conflict, because it indicates a conflict resolution mechanism, such as a duplicate entry.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict means duplicate or conflicting request."
    },
    {
      "question_id": "EQ5089",
      "type": "Writing",
      "gold": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test creates and retrieves a user's profile with valid data."
    },
    {
      "question_id": "EQ5090",
      "question": "Which HTTP status code indicates request was valid but the server failed to fulfill it?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "500",
        "D": "201"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is A. 200. This status code, known as ‘OK’, indicates the request was successful and the client’s request was received and understood by the server.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "500 Internal Server Error signals server-side failure."
    },
    {
      "question_id": "EQ5091",
      "type": "Writing",
      "gold": "It indicates temporary redirection to another URL.",
      "model_answer": "It indicates the request was found and accepted for processing."
    },
    {
      "question_id": "EQ5092",
      "question": "Which HTTP status is correct for a successfully updated resource using PUT?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 200 OK – indicates the request was successful and the resource was updated.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK indicates the resource was updated successfully."
    },
    {
      "question_id": "EQ5093",
      "type": "Writing",
      "gold": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Wrong Password Login**\n- **Preconditions:** User exists with correct email and positive status.\n- **Test Steps:** Send `POST` /login with user's email and 'wrongpassword'.\n- **Expected Result:** `401 Unauthorized` status code, no session created."
    },
    {
      "question_id": "EQ5094",
      "question": "Which HTTP method is safe and cacheable?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "GET",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. GET. It is both safe (it does not change state) and cacheable (the browser can store the response).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "GET is safe, idempotent, and cacheable."
    },
    {
      "question_id": "EQ5095",
      "type": "Writing",
      "gold": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "It means the server could not process the request."
    },
    {
      "question_id": "EQ5096",
      "question": "Which HTTP status is appropriate when service is temporarily overloaded?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "201",
        "B": "200",
        "C": "503",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "Temporary overload -> 503 Service Unavailable.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 Service Unavailable indicates overload or maintenance."
    },
    {
      "question_id": "EQ5097",
      "type": "Writing",
      "gold": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "Send a valid user payload with a unique username. Expected: `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5098",
      "question": "Which HTTP header specifies the size of the request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Length",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Cache-Control"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. Content-Length. This header is used to specify the size of the request body in bytes.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Length defines body size in bytes."
    },
    {
      "question_id": "EQ5099",
      "type": "Writing",
      "gold": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most direct and successful sequence of steps in a system or process. In testing, it's the sequence of inputs, actions, and decisions that always leads to a positive outcome, such as a successful login or payment processing."
    },
    {
      "question_id": "EQ5100",
      "question": "Which HTTP status code is used when a request method is not allowed on a resource?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "405 Method Not Allowed"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 405 Method Not Allowed. This status code is used when the request method is not allowed on the specified resource. For example, trying to access a `GET /users/123` resource that only accepts `POST` requests.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "405 is used when HTTP method is invalid for the resource."
    },
    {
      "question_id": "EQ2001",
      "question": "When designing API tests, which scenario best represents a boundary condition for a pagination parameter?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sending page=2 when total items=200",
        "B": "Sending page=10 when each page size=10 and total items=100",
        "C": "Sending page=11 when total items=100 with size=10",
        "D": "Sending page=1 when size=20 and total items=300"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. Sending page=11 when total items=100 with size=10. This is because when the request exceeds the maximum allowed page size, the API should return an error, not return incorrect data.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Page=11 would exceed the available range (max 10), testing a boundary overflow."
    },
    {
      "question_id": "EQ2002",
      "type": "Writing",
      "gold": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Send a request to the endpoint without including a valid OAuth2 Bearer token. The expected result is a `401 Unauthorized` status code indicating bad credentials."
    },
    {
      "question_id": "EQ2003",
      "question": "Which of the following is the most effective way to validate an API’s response time under simulated user load?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Manual sequential API calls with stopwatch measurement",
        "B": "Automated load test with concurrent virtual users",
        "C": "Single request execution and measuring response time",
        "D": "Unit testing with mocked responses"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Automated load test with concurrent virtual users. This is the most effective way to validate an API’s response time under simulated user load because it simulates real-world traffic and provides accurate performance metrics under load.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Load testing with concurrent virtual users mimics real-world conditions."
    },
    {
      "question_id": "EQ2004",
      "type": "Writing",
      "gold": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "**Happy Path:** Send a valid `POST` request with a known refund amount and customer ID, expecting a `200 OK` response with a refund confirmation. **Error Path:** Send a `POST` request with an invalid transaction ID, expecting a `404 Not Found` error."
    },
    {
      "question_id": "EQ2005",
      "question": "Which practice reduces the flakiness of automated API tests running in CI/CD pipelines?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcoding API keys in scripts",
        "B": "Using random sleep delays before assertions",
        "C": "Running tests only once per release",
        "D": "Using stable test data and environment setup hooks"
      },
      "gold_answer": "D",
      "model_raw_answer": "D is the correct answer because it directly addresses the flakiness issue by stabilizing the environment. The other options may cause issues but are not directly related to reducing flakiness: A introduces variability, B is unpredictable, and C may not catch all changes.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Stable test data and environment setup reduce randomness and flakiness."
    },
    {
      "question_id": "EQ2006",
      "type": "Writing",
      "gold": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "1. **Test Old Clients:** Send requests with outdated parameters or deprecated fields. 2. **Verify No Errors:** API should not return 400 or 500 errors. 3. **Check New Data Availability:** Ensure new fields (e.g., `updated_at`) or modified values (e.g., changed response code for deprecated endpoint) are returned correctly."
    },
    {
      "question_id": "EQ2007",
      "question": "Which of the following represents a correct negative test for input validation on a date-of-birth field?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sending dateOfBirth=‘2025-13-40’",
        "B": "Sending dateOfBirth=‘1990-05-20’",
        "C": "Leaving dateOfBirth empty when optional",
        "D": "Sending dateOfBirth=‘2000-01-01’"
      },
      "gold_answer": "A",
      "model_raw_answer": "Explanation: A negative test validates that the program rejects invalid inputs. \n- A: Sending dateOfBirth=‘2025-13-40’ → expected to return an error (e.g., invalid date), so this is correct.\n- B: Sending dateOfBirth=‘1990-05-20’ → this is a valid date, so it’s not a negative test for invalid input.\n- C: Leaving dateOfBirth empty when optional → this is not a test for a negative scenario because the system should either accept it (if empty is allowed) or explicitly indicate an error for an empty string.\n- D: Sending dateOfBirth=‘2000-01-01’ → this is a valid date, so it’s not a negative test for invalid input.\nTherefore, only A represents a correct negative test.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Invalid month/day makes it a correct negative input validation case."
    },
    {
      "question_id": "EQ2008",
      "type": "Writing",
      "gold": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "By creating a mock banking API that simulates transactions, the payment API can be tested with valid and invalid requests without actually contacting a real bank. This isolates the payment API from external dependencies and allows for faster, more reliable tests."
    },
    {
      "question_id": "EQ2009",
      "question": "Which monitoring approach helps detect sudden spikes in API error rates?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Code coverage reports",
        "B": "Manual log review every week",
        "C": "Real-time alerting on error rate metrics",
        "D": "Static code analysis"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Real-time alerting on error rate metrics. This approach provides immediate feedback when error rates suddenly spike, allowing swift investigation and response.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Real-time alerting ensures immediate detection of error rate spikes."
    },
    {
      "question_id": "EQ2010",
      "type": "Writing",
      "gold": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "Boundary Test: `POST /registration` with `age=65`. Invalid Test: `POST /registration` with `age=0`."
    },
    {
      "question_id": "EQ2011",
      "question": "Which of these is an example of contract validation in API testing?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking response latency",
        "B": "Validating response JSON matches OpenAPI schema",
        "C": "Measuring server CPU load",
        "D": "Asserting SQL queries from logs"
      },
      "gold_answer": "B",
      "model_raw_answer": "Validation checks that API responses conform to expected rules. Latency (A) and CPU load (C) are performance metrics, not validation. SQL queries (D) might be a validation test, but logs are not reliable. Only B correctly defines contract validation.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Contract validation ensures responses match defined schemas."
    },
    {
      "question_id": "EQ2012",
      "type": "Writing",
      "gold": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "By configuring a mock server or API mock to simulate a slow or disconnected connection. You would set the mock's timeout to a very high value (e.g., 300 seconds) or simulate a disconnection mid-request. This allows you to test how your API handles a timeout without requiring a real network failure."
    },
    {
      "question_id": "EQ2013",
      "question": "Which scenario best represents an intermediate load test?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "10,000 concurrent users for stress testing",
        "B": "Single-user functional check",
        "C": "Unit testing one function",
        "D": "100–200 concurrent users simulating average traffic"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 100–200 concurrent users simulating average traffic. This represents an intermediate load test because it goes beyond the lightest load (single-user functional check) but is not the highest load (10,000 concurrent users for stress testing) or the smallest unit (unit testing one function).",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Intermediate load tests simulate moderate, realistic user traffic."
    },
    {
      "question_id": "EQ2014",
      "type": "Writing",
      "gold": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "Precondition: The user's account must be logged in. \nFollow-up: The API call for a protected resource."
    },
    {
      "question_id": "EQ2015",
      "question": "Which approach helps detect unauthorized access attempts in an API?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Penetration test using invalid or missing tokens",
        "B": "Unit tests on helper functions",
        "C": "CI pipeline build success",
        "D": "Running API in debug mode"
      },
      "gold_answer": "A",
      "model_raw_answer": "Running penetration tests with invalid or missing tokens (A) directly at the API endpoint is the most direct approach to detect unauthorized access attempts. Unit tests on helper functions (B) verify internal logic but don't cover external access attempts. CI pipeline build success (C) checks code compilation, not security. Debug mode (D) exposes internal state, not external access attempts.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Penetration tests reveal weaknesses in authorization handling."
    },
    {
      "question_id": "EQ2016",
      "type": "Writing",
      "gold": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "Test sends 1k requests in 5 minutes and verify first 200 are `200 OK`, remaining are `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2017",
      "question": "Which strategy ensures reproducibility of integration API tests?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Running against random live production data",
        "B": "Using seeded test databases and reset scripts",
        "C": "Hardcoding timestamps in requests",
        "D": "Disabling cleanup steps after tests"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Using seeded test databases and reset scripts ensures that test execution is isolated and consistent, allowing repeatable results.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Seeded test data ensures consistent reproducibility."
    },
    {
      "question_id": "EQ2018",
      "type": "Writing",
      "gold": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "It allows testing with simplified or mocked service behaviors before real implementations are ready."
    },
    {
      "question_id": "EQ2019",
      "question": "Which of these is an appropriate recovery step if API monitoring detects consistent 500 errors?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Ignore them until next release",
        "B": "Add random retry logic to all clients",
        "C": "Alert ops team and trigger rollback of recent deployment",
        "D": "Turn off error logs"
      },
      "gold_answer": "C",
      "model_raw_answer": "Ignoring consistent errors (A) or adding retry logic (B) might hide issues, while turning off logs (D) makes debugging harder. Alerting ops team and triggering rollback (C) is the safest recovery step.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Rollback and alerts ensure quick mitigation."
    },
    {
      "question_id": "EQ2020",
      "type": "Writing",
      "gold": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "Positive Test: Valid username and password → `200 OK`. Boundary Test: Shortest allowed username character count → `200 OK` (valid length)."
    },
    {
      "question_id": "EQ2021",
      "question": "Which of the following scenarios is an example of a chained API test case?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Calling GET /status repeatedly",
        "B": "Creating a user, then using that user’s ID in GET /profile",
        "C": "Testing an endpoint with invalid headers",
        "D": "Measuring average latency of one endpoint"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Creating a user, then using that user’s ID in GET /profile. This is an example of a chained API test case because it involves calling two API endpoints in a specific order, where the second endpoint requires a specific piece of information (the user ID) that was obtained from the first endpoint.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Chained test cases depend on output of one API being input to another."
    },
    {
      "question_id": "EQ2022",
      "type": "Writing",
      "gold": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Send a request for a non-authorized media type (e.g., `/upload file` with no file). Verify the API's response status code is `415` (Unsupported Media Type) and the response body is `{\"error\": \"Invalid Media Type\"}` or a generic success message with the media type removed."
    },
    {
      "question_id": "EQ2023",
      "question": "Which practice helps detect contract violations early in a CI/CD pipeline?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Load testing in production only",
        "B": "Manual regression testing once a month",
        "C": "Schema validation tests integrated into pipeline",
        "D": "Using mocks for all external dependencies"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Schema validation tests integrated into pipeline.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Automated schema validation in CI/CD detects breaking changes quickly."
    },
    {
      "question_id": "EQ2024",
      "type": "Writing",
      "gold": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Inject a latency injection tool into the database connection pool. Monitor API response times and database connection metrics. Expected: API latency increases, DB connection latency metrics exposed in traces."
    },
    {
      "question_id": "EQ2025",
      "question": "Which of the following is an example of a negative authorization test?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Calling DELETE /users without admin privileges",
        "B": "Calling GET /users with valid token",
        "C": "Logging in with valid credentials",
        "D": "Refreshing a valid session token"
      },
      "gold_answer": "A",
      "model_raw_answer": "A negative authorization test would involve attempting an action that is not allowed for a particular user role. \n\n- A: Calling DELETE /users without admin privileges (this is a test for negative authorization as a regular user should not be able to delete another user's account).\n- B: Calling GET /users with valid token (this is a positive authorization test, as a valid token grants access to all resources).\n- C: Logging in with valid credentials (this is a positive authorization test, as logging in with valid credentials grants full access).\n- D: Refreshing a valid session token (this is a positive authorization test, as a valid session token is used to grant access to protected resources).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Attempting to delete users without privileges tests access restrictions."
    },
    {
      "question_id": "EQ2026",
      "type": "Writing",
      "gold": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Send the same request multiple times with a retry policy. Expected: all requests should return `200 OK` with no changes, and the system state should not change more than once."
    },
    {
      "question_id": "EQ2027",
      "question": "Which method ensures sensitive API keys are not exposed during automated testing?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcoding them in test scripts",
        "B": "Printing them in CI/CD logs",
        "C": "Storing them in public GitHub repos",
        "D": "Using encrypted environment variables"
      },
      "gold_answer": "D",
      "model_raw_answer": "Exposing API keys is a security risk. Hardcoding or printing them is dangerous. Storing in repos is a breach of security. Using encrypted environment variables is the correct approach.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Encrypted env variables keep secrets secure."
    },
    {
      "question_id": "EQ2028",
      "type": "Writing",
      "gold": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "Boundary: Upload a 5 MB file and confirm it's accepted. Invalid Test: Attempt to upload a file larger than 5 MB."
    },
    {
      "question_id": "EQ2029",
      "question": "Which monitoring metric would best indicate a memory leak in an API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Spike in average latency",
        "B": "Steadily increasing memory usage",
        "C": "Decreasing CPU utilization",
        "D": "Random increase in cache hit ratio"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Steadily increasing memory usage. Memory leaks are characterized by a gradual increase in memory consumption over time, often caused by poorly managed resources or circular references. Monitoring memory usage (e.g., via Java's VisualVM, Python's psutil, or Node.js's performance counters) and logging heap dumps periodically will help detect leaks. Other metrics like latency, CPU, or cache hit ratios are not directly indicative of memory leaks.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "A memory leak manifests as continuously rising memory usage."
    },
    {
      "question_id": "EQ2030",
      "type": "Writing",
      "gold": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "### **Test Case: Missing Email**\n- **Precondition:** API expects `email` in request body.\n- **Test Step:** Send request with empty email field (e.g., `{\"username\": \"john\"}`).\n- **Expected Result:** API returns `400 Bad Request` with a clear error message like 'Missing required field: email'."
    },
    {
      "question_id": "EQ2031",
      "question": "Which of the following best describes service virtualization?",
      "type": "MCQ",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Running APIs only in production",
        "B": "Using local database replicas",
        "C": "Simulating unavailable dependencies with virtual services",
        "D": "Replacing backend logic with new microservices"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Simulating unavailable dependencies with virtual services.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Service virtualization allows testing without real dependencies."
    },
    {
      "question_id": "EQ2032",
      "type": "Writing",
      "gold": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "Design a test with two steps: 1) Send a request and capture the first response (either 200 or 503). 2) If the initial attempt was 503, send subsequent retries until one succeeds or the maximum retries limit is reached."
    },
    {
      "question_id": "EQ2033",
      "question": "Which error scenario best represents a client-side failure?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "HTTP 400 Bad Request",
        "B": "HTTP 500 Internal Server Error",
        "C": "Database timeout",
        "D": "Out-of-memory on server"
      },
      "gold_answer": "A",
      "model_raw_answer": "A client-side failure occurs when the client (usually a web browser) cannot fulfill a request. This is typically caused by a condition at the client's end, such as a malformed request (HTTP 400 Bad Request) or a timeout waiting for a response. Scenarios like database timeouts (C) or out-of-memory errors (D) are server-side issues, and an internal server error (HTTP 500) is a generic server failure. Therefore, the correct answer is A.",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "400 Bad Request indicates client-side invalid request."
    },
    {
      "question_id": "EQ2034",
      "type": "Writing",
      "gold": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "Test sends requests with unique trace IDs. Verify logs are correctly correlated (e.g., same ID on multiple requests). Ensure missing trace ID results in null correlation."
    },
    {
      "question_id": "EQ2035",
      "question": "Which of these scenarios requires schema validation during testing?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking average API response time",
        "B": "Ensuring response JSON fields match OpenAPI definition",
        "C": "Measuring throughput under load",
        "D": "Analyzing SQL query logs"
      },
      "gold_answer": "B",
      "model_raw_answer": "Schema validation during testing is necessary when verifying that API responses (B) or database queries (D) adhere to the expected data structure as defined in the API specification or database schema. Scenario A is performance-related, C is load testing, and D is logging analysis.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Schema validation ensures structural correctness of responses."
    },
    {
      "question_id": "EQ2036",
      "type": "Writing",
      "gold": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "Test sends 5 requests per second from 3 clients. Verify first 5 requests are `200 OK`, subsequent requests are `429 Too Many Requests` with rate limit reset after 1 minute, and all clients are slowed down equally."
    },
    {
      "question_id": "EQ2037",
      "question": "Which of the following improves reproducibility of API tests in multiple environments?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Using hardcoded environment URLs",
        "B": "Randomizing all test data",
        "C": "Executing tests against production data",
        "D": "Parameterizing endpoints and using environment configs"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Parameterizing endpoints and using environment configs improves reproducibility by making tests independent of specific environments.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Parameterization ensures same test logic works across environments."
    },
    {
      "question_id": "EQ2038",
      "type": "Writing",
      "gold": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "Positive: A user registering with a valid phone number and expecting an SMS. Negative: A user with a locked account trying to resend a code that already exists."
    },
    {
      "question_id": "EQ2039",
      "question": "Which of these best describes performance baseline testing?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Measuring normal response times under expected load",
        "B": "Testing API with invalid inputs",
        "C": "Validating API against OpenAPI spec",
        "D": "Simulating 10x peak traffic"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Measuring normal response times under expected load.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Baseline testing captures normal expected performance."
    },
    {
      "question_id": "EQ2040",
      "type": "Writing",
      "gold": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "Mocking prevents actual users or services from being impacted during testing."
    },
    {
      "question_id": "EQ2041",
      "question": "Which of these is a correct test case for validating session expiration?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Login with valid credentials, expect 200 OK",
        "B": "Send request with valid token immediately after login",
        "C": "Send request with token after session timeout, expect 401 Unauthorized",
        "D": "Send request without token, expect 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct test case is C. Send request with token after session timeout, expect 401 Unauthorized. This simulates real-world behavior where a session expires.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Expired sessions must return 401 Unauthorized."
    },
    {
      "question_id": "EQ2042",
      "type": "Writing",
      "gold": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "Test sends request with malformed JSON payload. Expected: API returns `500 Internal Server Error` or `400 Bad Request` with clear error message, not a `200 OK`."
    },
    {
      "question_id": "EQ2043",
      "question": "Which strategy helps validate backward compatibility after adding new optional fields?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Ensure older clients still work without sending new fields",
        "B": "Force clients to update immediately",
        "C": "Remove old fields from responses",
        "D": "Require schema changes to be breaking"
      },
      "gold_answer": "A",
      "model_raw_answer": "A ensures backward compatibility by confirming older clients still function correctly without sending new fields.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Backward compatibility means old clients should still function without new fields."
    },
    {
      "question_id": "EQ2044",
      "type": "Writing",
      "gold": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "Send a request to an API's rate limit endpoint. Verify that the response contains the `X-RateLimit-Remaining` header and that its value is non-negative."
    },
    {
      "question_id": "EQ2045",
      "question": "Which is the most effective way to test resilience when an API’s downstream service fails?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "options": {
        "A": "Disable retries in client",
        "B": "Stop testing until service recovers",
        "C": "Run unit tests only",
        "D": "Inject failures using chaos testing or mocks"
      },
      "gold_answer": "D",
      "model_raw_answer": "The most effective way to test resilience when an API’s downstream service fails is to inject failures using chaos testing or mocks. This approach allows you to simulate real-world conditions (e.g., API timeout, service crash, dependency denial) without relying on external failures or disrupting real users. It provides immediate feedback on the API’s error handling and recovery strategies under stress. Options A, B, and C either don’t simulate failures or stop testing prematurely, which wouldn’t give you real resilience testing.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Chaos testing/mocks allow controlled simulation of dependency failures."
    },
    {
      "question_id": "EQ2046",
      "type": "Writing",
      "gold": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic allows for independent setup and teardown of the test environment, improving test repeatability."
    },
    {
      "question_id": "EQ2047",
      "question": "Which response status code is appropriate for a request blocked due to missing authorization header?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct response status code for a request blocked due to a missing authorization header is 401 Unauthorized, as it indicates that the request lacks the necessary credentials to proceed.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Missing authorization results in 401 Unauthorized."
    },
    {
      "question_id": "EQ2048",
      "type": "Writing",
      "gold": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "Test sends request with invalid cache-present header → expect 429 Too Many Requests or 500 Internal Server Error, but response time acceptable."
    },
    {
      "question_id": "EQ2049",
      "question": "Which of the following represents a proper boundary test for a password length field (min=8, max=20)?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Testing with 7, 8, 20, and 21 characters",
        "B": "Testing with 10 characters only",
        "C": "Testing with 15 characters only",
        "D": "Testing with empty password only"
      },
      "gold_answer": "A",
      "model_raw_answer": "A proper boundary test for a password length field (min=8, max=20) would involve sending three different types of requests to the password length endpoint:\n\n- **Valid Min Boundary (8 characters):** Request with exactly 8 characters (e.g., 'a'.{8}).\n- **Valid Max Boundary (20 characters):** Request with exactly 20 characters (e.g., 'a'.{20}).\n- **Invalid Boundary (Beyond Max):** Request with more than 20 characters (e.g., 'a'.{21}).\n\nThe other options do not cover all boundaries for a proper test:\n- **Option B (Testing with 10 characters only):** This is not a boundary test because it doesn't validate the minimum or maximum limits.\n- **Option C (Testing with 15 characters only):** This is also not a boundary test for the same reason as B.\n- **Option D (Testing with empty password only):** This is not relevant to the length test, as an empty string is still a valid input (even if it's not allowed by the schema, the API might still accept it).",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Boundary testing includes values at, below, and above limits."
    },
    {
      "question_id": "EQ2050",
      "type": "Writing",
      "gold": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "One validation method is to store a masked or encrypted version of the password in the log, then run a decryption test against a known password on the system. Another approach is to compare the logged password with a computed hash of the actual password and verify they match."
    },
    {
      "question_id": "EQ2051",
      "question": "Which monitoring method helps identify gradual latency increases over weeks?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Single request stopwatch timing",
        "B": "Manual debugging during incidents",
        "C": "Time-series trend analysis with dashboards",
        "D": "Code coverage metrics"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Time-series trend analysis with dashboards. Dashboards show latency trends over time, helping identify gradual increases.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Dashboards and time-series monitoring highlight latency trends."
    },
    {
      "question_id": "EQ2052",
      "type": "Writing",
      "gold": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "Negative test: 'USD' → expect `400` level error for invalid currency. Boundary test: 'EUR' → valid, but at edge, another valid code like 'GBP' should exist."
    },
    {
      "question_id": "EQ2053",
      "question": "Which strategy ensures contract tests remain useful when APIs evolve?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Never updating schema tests",
        "B": "Removing optional fields from tests",
        "C": "Running only manual regression tests",
        "D": "Versioning schema contracts and maintaining backward compatibility"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Versioning schema contracts and maintaining backward compatibility ensures that evolving APIs still pass old test cases, which is crucial for long-term contract testing stability.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Versioning and backward compatibility keep contract tests reliable."
    },
    {
      "question_id": "EQ2054",
      "type": "Writing",
      "gold": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "Test sends 1k packets, then removes half. API should still accept remaining packets without error. Expected: response time increases, but system remains stable."
    },
    {
      "question_id": "EQ2055",
      "question": "Which of these scenarios correctly validates API observability using distributed tracing?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking only HTTP status codes",
        "B": "Following a trace ID across multiple microservices",
        "C": "Checking memory usage in server logs",
        "D": "Using manual testing notes"
      },
      "gold_answer": "B",
      "model_raw_answer": "B is the correct option as it directly follows the definition of distributed tracing and validation of trace IDs.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tracing IDs track requests across services."
    },
    {
      "question_id": "EQ2056",
      "type": "Writing",
      "gold": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "Preconditions: Test Data Service (TDS) configured to generate test datasets with specific IDs. After test execution, query TDS to verify that all generated test dataset IDs (e.g., user, product, order) have been either cleaned up or reverted to a 'pending' state within a reasonable timeout."
    },
    {
      "question_id": "EQ2057",
      "question": "Which of the following indicates a denial-of-service vulnerability?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "API accepts unlimited requests without throttling",
        "B": "API returns 404 Not Found",
        "C": "API schema missing a description field",
        "D": "Unit test coverage is low"
      },
      "gold_answer": "A",
      "model_raw_answer": "A denial-of-service (DoS) vulnerability occurs when a system fails to respond appropriately to excessive or malicious requests. In this case, option A (\"API accepts unlimited requests without throttling\") is the correct answer because it directly describes a common DoS vulnerability. If an API does not limit the number of requests from a client, an attacker could potentially crash the server or consume all available resources. Options B, C, and D do not directly describe denial-of-service vulnerabilities.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Unrestricted requests can exhaust resources, causing DoS."
    },
    {
      "question_id": "EQ2058",
      "type": "Writing",
      "gold": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "Test involves executing a sequence of DB operations (e.g., `INSERT`, `UPDATE`, `DELETE`). Introduce a failure point (e.g., `DELETE` fails because record doesn't exist). Expected: Transaction rolls back entirely, DB state reverted to initial."
    },
    {
      "question_id": "EQ2059",
      "question": "Which HTTP status code should be validated when an API request is well-formed but forbidden due to role restrictions?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. 403 Forbidden, as it indicates that the client does not have access to the requested resource, even if the request itself is valid.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden indicates client is authenticated but not authorized."
    },
    {
      "question_id": "EQ2060",
      "type": "Writing",
      "gold": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "Automatically validate each endpoint's response against a shared JSON schema. This is achieved by 1) defining a single, centralized JSON schema that defines the required and optional fields for error conditions, 2) using a tool like JSON Schema Validator to automatically generate validation tests, and 3) integrating these validation tests into the CI/CD pipeline for each endpoint."
    },
    {
      "question_id": "EQ3001",
      "question": "Which of the following scenarios best represents a multi-hop test involving login and refresh token endpoints?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Send a request to GET /health",
        "B": "Obtain access token via POST /login, then use POST /refresh to extend session",
        "C": "Send request with expired token to protected endpoint",
        "D": "Check status 200 on GET /docs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Obtaining an access token via the login endpoint and then using a refresh token to extend the session is a multi-hop test.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Multi-hop testing means chaining login with subsequent refresh token usage."
    },
    {
      "question_id": "EQ3002",
      "type": "Writing",
      "gold": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "Test: Login & Token Refresh. Preconditions: User logged in → token available. Steps: 1) Login → `token_response` (e.g., 200 OK). 2) Send protected API request with initial token → `200 OK` (valid). 3) Wait for refresh timeout → refresh token generated. 4) Send protected API request with new refresh token → `200 OK` (valid after refresh). Expected: All requests successful with valid tokens."
    },
    {
      "question_id": "EQ3003",
      "question": "Which HTTP status code should a server return when a refresh token is expired?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "401 Unauthorized",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is A. 200 OK. This is because the server is responding to the client's request for a status code, and the token has simply expired. A '200 OK' indicates that the request was successful but may return data about the previous request (like an expired token).",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Expired refresh token means the client must log in again → 401 Unauthorized."
    },
    {
      "question_id": "EQ3004",
      "type": "Writing",
      "gold": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: A user with a valid refresh token exists in the system. 2. Action: Send a failed login attempt request (e.g., wrong password). 3. Expected: The API `401` or `403` response is correct, and a `200 OK` with a refresh token is not returned."
    },
    {
      "question_id": "EQ3005",
      "question": "Which of the following maps an application-specific error code to the correct HTTP status?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "APP_1001 (User not found) → 404 Not Found",
        "B": "APP_2002 (Invalid password) → 201 Created",
        "C": "APP_3003 (Success) → 500 Internal Server Error",
        "D": "APP_9999 (Database error) → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct answer because it maps an application-specific error code (APP_1001) to the correct HTTP status code (404 Not Found), which is a common practice in API design. The other options are incorrect because they map an error code to an inappropriate status code.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Mapping user-not-found to 404 is the correct HTTP translation."
    },
    {
      "question_id": "EQ3006",
      "type": "Writing",
      "gold": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Designate specific business codes (e.g., ORDER_001, SHIPMENT_002) and map them to expected HTTP status codes (e.g., `200 OK` for ORDER_001, `304 Not Modified` for SHIPMENT_002). Automate API test cases to both send requests and assert the correct status code is returned for valid operations."
    },
    {
      "question_id": "EQ3007",
      "question": "Which scenario demonstrates chained negative testing?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Testing single GET /status request",
        "B": "Valid login followed by accessing /profile",
        "C": "Checking server uptime with GET /health",
        "D": "Logging in with expired password → 401, then retrying refresh token → 401"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. Logging in with expired password → 401, then retrying refresh token → 401. This demonstrates chained negative testing because it tests a sequence of failures: a valid login attempt followed by an expired password, which results in a 401 Unauthorized response, and then attempting to retry with a refresh token also leading to a 401.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Chained negative tests validate failures across endpoints."
    },
    {
      "question_id": "EQ3008",
      "type": "Writing",
      "gold": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "Test case: 'Order Refund'. Preconditions: Order exists, payment processed, API triggered. Steps: 1) Order creation → order ID. 2) Payment gateway call. 3) Refund API called with order ID → DB update. Verify DB state, payment ledger updated."
    },
    {
      "question_id": "EQ3009",
      "question": "Which HTTP status code is correct for mapping a custom error ORDER_DUPLICATE to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "404 Not Found",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct HTTP status code for a custom error like `ORDER_DUPLICATE` is 409 Conflict. This is because the request could not be completed (the order already exists with a duplicate ID) and the client should not attempt to process it.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Duplicate order is a conflict → 409."
    },
    {
      "question_id": "EQ3010",
      "type": "Writing",
      "gold": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "Test case: Refresh Token Refresh. Precondition: User authenticated with short-lived token → expect `200 OK` and new token across services."
    },
    {
      "question_id": "EQ3011",
      "question": "Which scenario correctly validates multi-hop error handling in an e-commerce workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Create order → invalid payment details → 402 Payment Required",
        "B": "Check inventory → product exists → 200 OK",
        "C": "Call healthcheck endpoint → 200 OK",
        "D": "Request product catalog → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A correctly validates multi-hop error handling because it involves a sequence of API calls where some fail gracefully (e.g., 402) while others succeed immediately (e.g., 200 OK). Only option A covers this, as it shows an invalid payment scenario failing with a specific code (402) but still succeeding with another API call. Options B, C, and D are incorrect because they either succeed immediately (B, D) or fail without handling the error properly (C).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Payment failure after order creation is a multi-hop negative test."
    },
    {
      "question_id": "EQ3012",
      "type": "Writing",
      "gold": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "Define error codes and assert they map to correct 400 status codes."
    },
    {
      "question_id": "EQ3013",
      "question": "Which of these represents a hard-level chained login test?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Only testing GET /login-docs",
        "B": "Logging in once and stopping",
        "C": "Login → refresh token → logout → confirm refresh fails",
        "D": "Checking GET /health endpoint"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Combines multiple endpoints into a workflow validation."
    },
    {
      "question_id": "EQ3014",
      "type": "Writing",
      "gold": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "Test sends expired refresh token to token endpoint. Expected: `400 Bad Request` or `403 Forbidden` instead of valid access token."
    },
    {
      "question_id": "EQ3015",
      "question": "Which mapping is correct for business error PAYMENT_DECLINED?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. 200 OK - indicates successful request; B. 201 Created - indicates successful request and new resource created; C. 404 Not Found - indicates resource not found; D. 402 Payment Required - indicates payment required but not declined.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Payment declined → 402 Payment Required."
    },
    {
      "question_id": "EQ3016",
      "type": "Writing",
      "gold": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Test: 1) Login → 2) Perform action → 3) Logout → 4) Verify session expired and subsequent requests failed."
    },
    {
      "question_id": "EQ3017",
      "question": "Which scenario maps to the correct HTTP code for an internal application error?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "APP_TIMEOUT → 200 OK",
        "B": "APP_TIMEOUT → 504 Gateway Timeout",
        "C": "APP_TIMEOUT → 201 Created",
        "D": "APP_TIMEOUT → 400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "Internal application errors, such as timeouts or internal logic errors, should not be exposed directly to clients. However, they are not generic errors like 400 Bad Request. A timeout error, like 504 Gateway Timeout, is more appropriate because it indicates the server was unable to handle the request within a reasonable time. 200 OK is used for successful requests, 201 Created is used for successful resource creation, and 400 Bad Request is used for malformed client requests. Therefore, the correct answer is B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Timeouts should map to 504 Gateway Timeout."
    },
    {
      "question_id": "EQ3018",
      "type": "Writing",
      "gold": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "Test: 1) Precondition: User exists in DB. 2) Action: Signup → email sent → verification link. 3) Action: Login with correct credentials. Expected: Login succeeds."
    },
    {
      "question_id": "EQ3019",
      "question": "Which test validates chained role-based access?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login as user → access /admin → expect 403 Forbidden",
        "B": "Login as admin → access /admin → expect 200 OK",
        "C": "Login as user → view profile → 200 OK",
        "D": "GET /health → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct answer because it shows a valid chain with a user accessing admin content and getting a 403 Forbidden, which is the expected behavior for role-based access.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Role mismatch leading to 403 is a multi-hop role validation."
    },
    {
      "question_id": "EQ3020",
      "type": "Writing",
      "gold": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "1. **Precondition:** A user (Test User) exists with a valid email and password. \n2. **Action:** Trigger a password reset via a unique, automated email. \n3. **Verification:** Confirm the reset link is generated correctly, and the user can successfully complete the reset process."
    },
    {
      "question_id": "EQ3021",
      "question": "Which scenario validates a chained login, refresh, and logout sequence?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → use token once",
        "B": "Refresh token immediately after login",
        "C": "Logout only",
        "D": "Login → refresh token → logout → confirm refresh fails"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Login → refresh token → logout → confirm refresh fails. This sequence tests the chain: login grants a token, refresh uses the token, and logout invalidates it. Confirming refresh fails after logout ensures the system enforces logout token revocation.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "This full sequence tests the entire authentication lifecycle."
    },
    {
      "question_id": "EQ3022",
      "type": "Writing",
      "gold": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "Test: 1) Create user → 2) Update profile → 3) Retrieve profile (with DB query)."
    },
    {
      "question_id": "EQ3023",
      "question": "Which mapping correctly translates a business error STOCK_OUT to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "201 Created",
        "D": "403 Forbidden"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct mapping for a business error like STOCK_OUT would be a 403 Forbidden status code, as it indicates that the client (user) does not have access to the product they are trying to purchase.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Stock-out means a conflict with order fulfillment, mapping to 409."
    },
    {
      "question_id": "EQ3024",
      "type": "Writing",
      "gold": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "1. **Action:** Send a `POST` request to the token endpoint using a valid refresh token.\n2. **Expected Result:** The server should respond with a `403 Forbidden` status code, not an access token.\n3. **Rationale:** A refresh token is bound to a user's session. After logout, the session is invalid, and using the refresh token would be an attempt to access another user's session."
    },
    {
      "question_id": "EQ3025",
      "question": "Which scenario validates chained negative testing for a shopping cart workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Add valid item to cart → 200 OK",
        "B": "Checkout with valid payment → 200 OK",
        "C": "Add item → remove item → checkout → expect 400 Bad Request",
        "D": "View cart after login → 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "Correct answer is C. Scenario validates that the system correctly handles a sequence of invalid states (item removed, checkout attempted without valid payment, invalid state for view cart) and prevents an incorrect 200 OK response.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Empty cart checkout is a chained negative scenario."
    },
    {
      "question_id": "EQ3026",
      "type": "Writing",
      "gold": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "Test case: 'Expired Session'.\n- Precondition: User session expires after 5 minutes.\n- Action: Call authentication endpoint with expired session claim (e.g., 'auth_expired' → 'AUTH_EXPIRED').\n- Expected: API returns `403 Forbidden` or `401 Unauthorized` with `AUTH_EXPIRED` as the error code, not `400 Bad Request`."
    },
    {
      "question_id": "EQ3027",
      "question": "Which scenario best validates chained order cancellation?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Hard",
      "options": {
        "A": "Create order → cancel order → GET /orders/{id} shows status=cancelled",
        "B": "Cancel non-existent order → 404",
        "C": "Create order only",
        "D": "Check /status endpoint"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. This scenario validates the chain of events: 1) An order is created, 2) it is successfully cancelled, and 3) the order's status is correctly reflected in the /orders/{id} endpoint. This ensures that the cancellation process works as intended when an order is created and then cancelled.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Covers lifecycle of order creation → cancellation → verification."
    },
    {
      "question_id": "EQ3028",
      "type": "Writing",
      "gold": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Email user with expired token → expect `401 Unauthorized` response. 2) Send invalid token → expect `400 Bad Request` with validation error. 3) Chain to final test: send token with wrong user → expect `403 Forbidden` with 500 Internal Server Error (if backend can't handle invalid token)."
    },
    {
      "question_id": "EQ3029",
      "question": "Which mapping correctly translates FILE_TOO_LARGE to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "404 Not Found",
        "D": "413 Payload Too Large"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 413 Payload Too Large.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "File too large should map to 413."
    },
    {
      "question_id": "EQ3030",
      "type": "Writing",
      "gold": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "**Test Case: Loan Application**\n- **Preconditions:** User authenticated, credit profile available.\n- **Test Steps:**\n  1. `POST /loans` with valid income, credit score, and loan amount → `201 Created`.\n  2. Same request but low credit → `403 Forbidden`.\n  3. Missing required field (e.g., employment history) → `400 Bad Request`.\n- **Expected Result:** Only valid applications approved.\n\n**Test Case: Credit Check**\n- **Preconditions:** API mock service for credit profile retrieval.\n- **Test Steps:**\n  1. `GET /users/{id}/credit` → `200 OK` with mock profile.\n  2. Same request but ID=999 (non-existent) → `404 Not Found`.\n  3. Request timing-out → `503 Service Unavailable`.\n- **Expected Result:** API must handle errors gracefully."
    },
    {
      "question_id": "EQ3031",
      "question": "Which chained sequence validates refresh tokens across multiple sessions?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → logout only",
        "B": "Login → refresh token → logout → login again → confirm old refresh invalid",
        "C": "Refresh token without login",
        "D": "Check GET /status"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Login → refresh token → logout → login again → confirm old refresh invalid. A valid refresh token is issued per user session. After logout, the token becomes invalid and cannot be reused.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Ensures session handling across multiple logins."
    },
    {
      "question_id": "EQ3032",
      "type": "Writing",
      "gold": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "Preconditions: User email exists. Steps: 1) Sign up → confirm via email. 2) Password reset → new password sent. 3) Login with new credentials → expected login success."
    },
    {
      "question_id": "EQ3033",
      "question": "Which mapping is correct for mapping business error INVALID_COUPON?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request – indicates an invalid input.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Invalid coupon should map to 400 Bad Request."
    },
    {
      "question_id": "EQ3034",
      "type": "Writing",
      "gold": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "Preconditions: File 'virus_file.exe' and 'clean_file.txt' available. Test Case: 1) File Upload → `POST /upload` with file. 2) Virus Scan → `POST /scan` with uploaded file. 3) Download → `POST /download` with positive ID → `200 OK` with file. Negative: Invalid File → `400 Bad Request`."
    },
    {
      "question_id": "EQ3035",
      "question": "Which scenario validates correct multi-hop error mapping in payment workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Payment API returns DECLINED → mapped to HTTP 402",
        "B": "Payment API returns APPROVED → mapped to HTTP 404",
        "C": "Payment API returns DECLINED → mapped to HTTP 201",
        "D": "Payment API returns ERROR → mapped to HTTP 200"
      },
      "gold_answer": "A",
      "model_raw_answer": "Valid scenario: Payment API returns DECLINED → mapped to HTTP 402. This is because a declined payment is a negative outcome, commonly represented by an HTTP status code indicating a bad request or unprocessible entity, such as 402.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Payment declined correctly maps to 402 Payment Required."
    },
    {
      "question_id": "EQ3036",
      "type": "Writing",
      "gold": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "1. Send first request with token → token granted.\n2. Wait for refresh token expiration → send request with new token → expect 401 Unauthorized.\n3. Ensure system state not changed (DB still valid)."
    },
    {
      "question_id": "EQ3037",
      "question": "Which mapping is correct for mapping RATE_LIMIT_EXCEEDED to HTTP?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct mapping for RATE_LIMIT_EXCEEDED to HTTP is 429 Too Many Requests.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rate limits exceeded should map to 429."
    },
    {
      "question_id": "EQ3038",
      "type": "Writing",
      "gold": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "Test case: 'Shopping Cart Journey'. \n1. Search for 'Laptop' → `GET /products`.\n2. Add to Cart → `POST /cart`.\n3. Checkout → `POST /checkout`."
    },
    {
      "question_id": "EQ3039",
      "question": "Which scenario validates chained negative testing in ticket booking workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Book valid ticket → 200 OK",
        "B": "Book ticket → cancel ticket → attempt refund → expect 400 Bad Request",
        "C": "View available seats → 200 OK",
        "D": "Check GET /status → 200 OK"
      },
      "gold_answer": "B",
      "model_raw_answer": "Negative chained testing (B) validates that intermediate failures (booking, then cancel, then attempt refund) are handled correctly, preventing unexpected success. Positive flows (A, C, D) are valid but not the focus of negative chained testing.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Chained negative: refunding after cancel is invalid."
    },
    {
      "question_id": "EQ3040",
      "type": "Writing",
      "gold": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "1. Log in user → 2. Access protected resource → 3. Verify response and authentication headers are different for logged-in and guest users."
    },
    {
      "question_id": "EQ3041",
      "question": "Which chained flow correctly validates token rotation with refresh token reuse detection?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → call API once → logout",
        "B": "Login → refresh token → attempt reuse of old refresh → expect 401 Unauthorized",
        "C": "Login only",
        "D": "Refresh without login"
      },
      "gold_answer": "B",
      "model_raw_answer": "Token rotation invalidates old tokens. Attempting reuse of an expired token → 401 Unauthorized. Chained flow must validate logout and refresh token binding.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Token reuse must be rejected after rotation to prevent replay attacks."
    },
    {
      "question_id": "EQ3042",
      "type": "Writing",
      "gold": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "1. **Precondition:** A resource (e.g., a product) exists with an ETag `\"V1R1\"`. 2. **Action:** Perform an `UPDATE` request changing the resource, but include the original ETag `\"V1R1\"`. 3. **Verification:** Send an `GET` request with the updated ETag (`\"V2R1\"`) in the `If-Match: \"V2R1\"`` header. The test succeeds only if the server rejects the request with a `412 Precondition Failed` and not the `200 OK` response."
    },
    {
      "question_id": "EQ3043",
      "question": "Which HTTP status should be returned when an If-Match precondition fails due to stale ETag during PUT /resource/{id}?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "412 Precondition Failed",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "Precondition Failed indicates the request cannot be made under the given conditions, but 412 is for bad inputs, 400 is general bad request, 200 is successful response for a valid request. The correct status code is 412 because the precondition failed but it's not an invalid input like a bad request.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Stale ETag should map to 412 Precondition Failed."
    },
    {
      "question_id": "EQ3044",
      "type": "Writing",
      "gold": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "1. Send POST /exports with a job that should take time to complete (e.g., exporting a large file). 2. Poll the /jobs/{id} endpoint for the export job. 3. Verify the final export status by retrieving the exported file at /exports/{id}."
    },
    {
      "question_id": "EQ3045",
      "question": "Which mapping from business code to HTTP is most appropriate for RESOURCE_VERSION_CONFLICT during update?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct mapping for RESOURCE_VERSION_CONFLICT during update is 409 Conflict.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Version conflict maps correctly to 409 Conflict."
    },
    {
      "question_id": "EQ3046",
      "type": "Writing",
      "gold": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Send `/authorize` with user consent. Then, call `/token` with no `scope` parameter. Expected: `403 Forbidden` or `400 Bad Request`."
    },
    {
      "question_id": "EQ3047",
      "question": "Which status code best represents a refresh token presented to the wrong client_id in a multi-tenant system?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 400 Bad Request. This status code is suitable for a refresh token presented to the wrong client_id, as it indicates an invalid request.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "OAuth2 specifies invalid_grant (400) for wrong client/refresh usage."
    },
    {
      "question_id": "EQ3048",
      "type": "Writing",
      "gold": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. Given a user with an Idempotency-Key, send two identical `POST /orders` requests with retry logic. The second request should not create a new order but rather update the existing one with the same Key. Verify the DB state and return from the service match the first request's outcome."
    },
    {
      "question_id": "EQ3049",
      "question": "Which status mapping is correct for business code INSUFFICIENT_FUNDS from payment gateway?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "A status map of 200 OK is correct for business code INSUFFICIENT_FUNDS from a payment gateway, as it indicates the transaction was received but could not be processed successfully.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Insufficient funds → 402 Payment Required."
    },
    {
      "question_id": "EQ3050",
      "type": "Writing",
      "gold": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "1. Chain tests: 1) Upload file → 2) `POST /process` → 3) Poll status → 4) Download → 5) Verify 202 OK for partial processing."
    },
    {
      "question_id": "EQ3051",
      "question": "Which scenario correctly validates backoff + retry policy across gateway 429 -> 200 transitions?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "options": {
        "A": "API returns 429 Too Many Requests → client retries with backoff → 200 OK",
        "B": "API returns 401 Unauthorized → retry succeeds",
        "C": "API returns 404 Not Found → retry succeeds",
        "D": "API returns 500 → retry without backoff"
      },
      "gold_answer": "A",
      "model_raw_answer": "A correctly describes the transition from 429 (Too Many Requests) → 200 (OK) after retry with backoff. B and C imply immediate success, which is not valid retry logic. D is incorrect because a retry without backoff might not be considered valid under retry logic.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Retry with exponential backoff is required for 429 handling."
    },
    {
      "question_id": "EQ3052",
      "type": "Writing",
      "gold": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "1. Log in with SSO → session granted → revoke session → expected API gateway and microservice access denied."
    },
    {
      "question_id": "EQ3053",
      "question": "Which HTTP code should map to BUSINESS_LIMIT_EXCEEDED when per-user quota blocks a valid, authenticated request?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct HTTP code for BUSINESS_LIMIT_EXCEEDED is 429 Too Many Requests. This is because it is a status code for exceeding rate limits, which is a business-level limit. The other options do not fit the scenario: 200 OK is successful, 400 Bad Request is for malformed requests, and 403 Forbidden is for unauthorized requests.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Quota exhaustion maps to 429 Too Many Requests."
    },
    {
      "question_id": "EQ3054",
      "type": "Writing",
      "gold": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "1. Given an order, reserve inventory, and partially ship it. 2. When the partial shipment is completed, mark the order as'shipped' but not fully. 3. Then, cancel the remaining amount and verify that the refund reflects only the partial shipment delta."
    },
    {
      "question_id": "EQ3055",
      "question": "Which mapping is most accurate for error code SIGNATURE_INVALID on webhook delivery verification?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct mapping for an error code like SIGNATURE_INVALID on webhook delivery verification is a 400-level error, specifically 400 Bad Request. This is because the request (the webhook delivery) was malformed (the signature was invalid). \n\nThe closest option provided is 400, but since that's not directly available, the next best choice for a 'bad request' error is 404 Not Found, as it indicates the resource (a valid delivery) was not found (because it didn't exist). However, the most accurate and common mapping for a 'bad request' like this would indeed be 400 Bad Request itself, but that's not an option. So, the closest accurate answer from the given choices is 404 Not Found.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Invalid webhook signature should return 401 Unauthorized."
    },
    {
      "question_id": "EQ3056",
      "type": "Writing",
      "gold": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "Send a 2FA verification request with a wrong authentication code. The system should respond with a `401 Unauthorized` status code and an appropriate error message."
    },
    {
      "question_id": "EQ3057",
      "question": "Which HTTP code best represents a soft-deleted resource requested by GET /resource/{id} after DELETE (with recoverable state)?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "204 No Content"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is D. 204 No Content. A soft-deleted resource is considered 'gone' but still exists. The server will respond with 204 No Content, indicating the request was successful but the resource has been deleted and is now available for recovery. Other options do not accurately represent a successful request for a soft-deleted resource.",
      "model_normalized_answer": "D",
      "correct": false,
      "explanation": "Soft-deleted resource should be treated as not found."
    },
    {
      "question_id": "EQ3058",
      "type": "Writing",
      "gold": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "Create 5 items, page through results, delete last, and confirm previous pages still exist."
    },
    {
      "question_id": "EQ3059",
      "question": "Which mapping is correct when dependency outage triggers circuit breaker OPEN, causing gateway to reject requests immediately?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "400 Bad Request"
      },
      "gold_answer": "C",
      "model_raw_answer": "Correct answer is C. 503 Service Unavailable.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Circuit breaker OPEN maps to 503 Service Unavailable."
    },
    {
      "question_id": "EQ3060",
      "type": "Writing",
      "gold": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "1. Chain: 1) Login as user A. 2) Access API via load balancer -> expect single node response. 3) Logout. 4) Verify no node accepts old token (e.g., user A's session cookie)."
    },
    {
      "question_id": "EQ4001",
      "question": "Which chained flow correctly validates an order lifecycle with create → capture → refund, ensuring idempotency across retries?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Create order → retry refund twice → refund fails",
        "B": "Capture payment without creating order",
        "C": "Create order → capture payment → retry capture with same idempotency key → single charge → refund succeeds",
        "D": "Refund before order creation"
      },
      "gold_answer": "C",
      "model_raw_answer": "C is the correct chained flow. It validates the order lifecycle with idempotency across retries. If a capture or refund operation is retried with the same idempotency key (e.g., payment token), it should not result in a failed charge. Instead, it should succeed, as seen in scenario E.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Idempotency must ensure duplicate captures do not create multiple charges."
    },
    {
      "question_id": "EQ4002",
      "type": "Writing",
      "gold": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "Define states: Create (active), Active, Suspended, Reactivated, Delete. Transition and validate status after each step."
    },
    {
      "question_id": "EQ4003",
      "question": "Which mapping is correct for handling a duplicate transaction detected during a refund request?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct mapping for handling a duplicate transaction detected during a refund request is 409 Conflict. This is because the transaction has already occurred, and the request cannot be processed as expected. The other options do not accurately represent this scenario.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Duplicate transaction must map to 409 Conflict."
    },
    {
      "question_id": "EQ4004",
      "type": "Writing",
      "gold": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "Plan three steps: 1. Successful transfer. 2. Failed transfer (e.g., insufficient funds). 3. Third step (e.g., confirm transfer). The chained test will execute steps 1 and 3 in sequence. The second step should be deliberately failed (e.g., by introducing a mock service that rejects the transaction). The test validates that the entire transaction is rolled back only when the second step fails."
    },
    {
      "question_id": "EQ4005",
      "question": "Which chained scenario validates proper error propagation in a distributed saga transaction?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Start saga → all steps succeed",
        "B": "Start saga → ignore error in step 2",
        "C": "Start saga → rollback ignored",
        "D": "Start saga → step 3 fails → compensating rollback of steps 1 & 2 executed"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. This scenario validates that when a step fails, the entire saga (all dependent steps) is properly rolled back, and compensating actions are executed correctly to maintain consistency.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Saga pattern ensures compensating actions on failure."
    },
    {
      "question_id": "EQ4006",
      "type": "Writing",
      "gold": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "1. **Action:** Log in as a valid user, create an order, and capture payment.\n2. **Verification:** After capture, assert the order is'shipped' or 'delivered' and not 'cancelled'."
    },
    {
      "question_id": "EQ4007",
      "question": "Which error handling scenario best validates sanity checks in payment APIs?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Submitting refund > captured amount → 400 Bad Request",
        "B": "Submitting refund = captured amount → 200 OK",
        "C": "Submitting refund < captured amount → 200 OK",
        "D": "Refund without capture → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A correctly validates sanity checks in payment APIs. Submitting a refund for an amount greater than the system’s limit results in a 400 Bad Request, as the API enforces business logic (maximum transaction amount).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Refunds larger than capture must fail with 400."
    },
    {
      "question_id": "EQ4008",
      "type": "Writing",
      "gold": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "Test: 1) Log in with valid password → set. 2) Wait for expiration → 'password expired' error. 3) Reset password → new token generated. 4) Attempt reuse of old token → fail. Verify all steps prevent insecure reuse."
    },
    {
      "question_id": "EQ4009",
      "question": "Which mapping best validates format error handling for malformed JSON payloads?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. 400 Bad Request. A `400 Bad Request` status code is used for malformed request data, such as an invalid JSON payload in an API request. It indicates that the server cannot process the request as it was presented.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Malformed JSON must result in 400 Bad Request."
    },
    {
      "question_id": "EQ4010",
      "type": "Writing",
      "gold": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "Test: 'Apply for Loan' → Verify approval, then chain to negative paths: \n1. Credit Check → Reject → System State: 'Application Rejected'.\n2. Alternative Credit Score → Approve → System State: 'Application Approved'.\n3. Insufficient Employment History → System State: 'Application Rejected'."
    },
    {
      "question_id": "EQ4011",
      "question": "Which chained flow validates consistent state during distributed booking workflow?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Reserve hotel only",
        "B": "Reserve hotel → book flight → flight fails → hotel reservation auto-cancelled",
        "C": "Book flight only",
        "D": "Book hotel and keep reservation even if payment fails"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct option is B. This is because it represents the only chained flow where a single step (booking a flight) causes the entire distributed workflow to fail, resulting in a valid action (auto-cancelling the hotel reservation) that maintains consistency.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Hotel auto-cancellation ensures consistent state across systems."
    },
    {
      "question_id": "EQ4012",
      "type": "Writing",
      "gold": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "Test sends two simultaneous API requests to update user profiles. Expected: only one succeeds, DB remains consistent with majority vote."
    },
    {
      "question_id": "EQ4013",
      "question": "Which HTTP code is correct for validating sanity check on withdraw > account balance?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "400 Bad Request"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct HTTP status code for validating sanity check on withdraw > account balance is 403 Forbidden. This is because the request is denied due to insufficient funds or an invalid transaction, which is a form of access restriction.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Over-withdrawal must be rejected as 400 Bad Request."
    },
    {
      "question_id": "EQ4014",
      "type": "Writing",
      "gold": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "Precondition: Document uploaded with original signature. Action: Modify signature text → re-sign → send for verification → expected `InvalidSignature'` if tampered."
    },
    {
      "question_id": "EQ4015",
      "question": "Which scenario validates state rollback when an API partially updates user info and DB transaction fails?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Update fails mid-way → no partial changes persist",
        "B": "Update fails mid-way → partial changes remain",
        "C": "Update fails mid-way → system crashes",
        "D": "Update succeeds despite DB rollback"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is B. Update fails mid-way → partial changes remain. This is because a partial update occurs when only part of the data is changed, and in a failure scenario, this partial change should still be present in the database but not committed.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Proper rollback prevents partial/inconsistent data."
    },
    {
      "question_id": "EQ4016",
      "question": "Which chained scenario best validates the idempotency of a payment capture endpoint?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "POST /capture twice with different Idempotency-Key values → two charges",
        "B": "POST /capture twice with the same Idempotency-Key → single charge recorded",
        "C": "POST /refund without capture → success",
        "D": "GET /capture-status once"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. POST /capture twice with the same Idempotency-Key → single charge recorded. This scenario validates idempotency because making the same payment request (with the same data, including the Idempotency-Key) more than once should result in only one charge being recorded in the system.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Idempotency ensures duplicate requests with same key do not create multiple charges."
    },
    {
      "question_id": "EQ4017",
      "type": "Writing",
      "gold": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "Test: 1) Create subscription → 2) Upgrade → 3) Downgrade → 4) Cancel → all states validated with expected results."
    },
    {
      "question_id": "EQ4018",
      "question": "Which mapping correctly handles application error LIMIT_EXCEEDED for per-account API quota?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct mapping is D. 429 Too Many Requests, as it is the standard HTTP exception for exceeding rate limits. The other options (200 OK, 400 Bad Request, 403 Forbidden) do not accurately represent an error for exceeding a quota limit.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rate/limit exceeded maps to 429 Too Many Requests."
    },
    {
      "question_id": "EQ4019",
      "type": "Writing",
      "gold": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "Send three orders in parallel. Ensure two succeed but one (e.g., payment service) fails. Verify the failed order's state is rolled back to 'pending', and its corresponding compensating service is triggered to reverse any changes."
    },
    {
      "question_id": "EQ4020",
      "question": "Which chained flow validates OAuth2 token misuse detection across services?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "options": {
        "A": "Login once",
        "B": "Refresh token immediately",
        "C": "Login → get token → attempt to use token in another client → 403 Forbidden",
        "D": "Logout only"
      },
      "gold_answer": "C",
      "model_raw_answer": "C is the correct answer because it describes a valid test for OAuth2 token misuse detection: logging in, getting an access token, and then attempting to use that token with a different client (which would likely result in a 403 Forbidden error).",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Cross-client token misuse should be forbidden."
    },
    {
      "question_id": "EQ4021",
      "type": "Writing",
      "gold": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "Precondition: two accounts (A, B) with initial balances known. Action: Debit A → credit B → system rollback. Verify A's balance unchanged, B's → inconsistent state."
    },
    {
      "question_id": "EQ4022",
      "question": "Which scenario best validates format error handling for XML vs JSON input mismatch?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "Send XML body with Content-Type: application/json → 415 Unsupported Media Type",
        "B": "Send JSON body with application/json → 200 OK",
        "C": "Send XML body with application/xml → 200 OK",
        "D": "Send YAML → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A correctly validates that format error handling for XML vs JSON input mismatch. The correct action when the client sends an XML payload with a `Content-Type` header claiming to be `application/json` (like in option A) is a known error handling strategy.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Mismatch in body vs header must result in 415."
    },
    {
      "question_id": "EQ4023",
      "type": "Writing",
      "gold": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Define states (stock, allocated, shipped, returned, reconciled) and transitions (e.g., stock → allocated, returned → reconciled). Run test steps (e.g., add 10 units, allocate, ship, return 5 units, reconcile). Verify state changes and inventory updates match DB."
    },
    {
      "question_id": "EQ4024",
      "question": "Which HTTP status is correct when a schema validation error occurs for a nested field?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "A 400 Bad Request is appropriate because the client request contains a malformed payload (invalid schema for a nested field). This status indicates the server cannot process the request as it is.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Schema validation errors must return 400."
    },
    {
      "question_id": "EQ4025",
      "type": "Writing",
      "gold": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "1. Send login request → expect `200 OK` and valid token.\n2. Send token refresh request → expect new token in body.\n3. Send logout request → expect `200 OK` and null response.\n4. Send refresh with old token → expect `401 Unauthorized` response."
    },
    {
      "question_id": "EQ4026",
      "question": "Which chained scenario validates proper rollback after multi-step booking (flight + hotel) when payment fails?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Book flight → 200 OK",
        "B": "Book hotel → 200 OK",
        "C": "Book flight + hotel → payment succeeds",
        "D": "Book flight + hotel → payment fails → rollback both bookings"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct option is D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rollback ensures no inconsistent bookings remain."
    },
    {
      "question_id": "EQ4027",
      "type": "Writing",
      "gold": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. Send email → 2a. Verify email sent in API response. 2b. Check email is opened in DB → trackable. 2c. Perform unsubscribe action. 3. Verify no further emails (follow-up) are sent to user after unsubscribe."
    },
    {
      "question_id": "EQ4028",
      "question": "Which mapping is correct for application code TOKEN_REPLAY_DETECTED?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct mapping for a token replay detected is a `401 Unauthorized` status code, as it indicates that the authentication token has been replayed and is invalid.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Token replay must be treated as 401 Unauthorized."
    },
    {
      "question_id": "EQ4029",
      "type": "Writing",
      "gold": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "1. Chain: 1) Log in as customer. 2) Add valid coupon (e.g., '10% off') to cart. 3) Navigate to checkout. 4) Click 'Apply Coupon'. 5) Mock API returns 400 Bad Request on invalid coupon. 6) Expected: Order removed from cart, cart updated to $0, purchase failed flag set."
    },
    {
      "question_id": "EQ4030",
      "question": "Which chained workflow validates asynchronous payment settlement with reconciliation?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Create order only",
        "B": "Create order → capture payment → async settlement → reconcile → final status=settled",
        "C": "Refund without settlement",
        "D": "Check API health"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. This workflow validates the full asynchronous payment process, including capture, immediate settlement, and eventual reconciliation for a final'settled' status.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Asynchronous settlement must reconcile correctly."
    },
    {
      "question_id": "EQ5001-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để truy xuất dữ liệu từ một API?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "Truy xuất dữ liệu thường được thực hiện bằng `GET`, vì nó chỉ trả về một bộ lưu trữ (tên hoặc ID) và không thay đổi dữ liệu gốc. `POST` được dùng để tạo mới, `PUT` để cập nhật toàn bộ, và `DELETE` để xóa.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là phương thức chuẩn để truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5002-VN",
      "question": "Mã trạng thái HTTP 404 đại diện cho điều gì?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "OK",
        "B": "Unauthorized",
        "C": "Not Found",
        "D": "Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Not Found. Trạng thái 404 chỉ ra tài nguyên được tìm thấy không có trên server.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "404 cho biết tài nguyên được yêu cầu không thể tìm thấy."
    },
    {
      "question_id": "EQ5003-VN",
      "question": "Mục đích của phương thức HTTP POST là gì?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "Truy xuất dữ liệu",
        "B": "Gửi dữ liệu để tạo tài nguyên",
        "C": "Cập nhật tài nguyên hiện có",
        "D": "Xóa tài nguyên"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Gửi dữ liệu để tạo tài nguyên.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST được sử dụng để tạo tài nguyên mới với dữ liệu trong request body."
    },
    {
      "question_id": "EQ5004-VN",
      "type": "Writing",
      "gold": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "Tiến hành: Trả lời 200 OK khi đăng nhập thành công."
    },
    {
      "question_id": "EQ5005-VN",
      "question": "Mã trạng thái HTTP nào trong số này có nghĩa là 'Unauthorized'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 là mã trạng thái HTTP có nghĩa là 'Unauthorized'.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
    },
    {
      "question_id": "EQ5006-VN",
      "type": "Writing",
      "gold": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "A valid user token (API key or Bearer Token) attached to the request. This ensures the request is executed as a legitimate user with a profile. Without this, the endpoint will only be 'visible' to authenticated users in the system."
    },
    {
      "question_id": "EQ5007-VN",
      "question": "Phương thức HTTP nào được coi là idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "PUT",
        "D": "CONNECT"
      },
      "gold_answer": "C",
      "model_raw_answer": "POST, PATCH, PUT, và CONNECT đều không idempotent. POST gửi dữ liệu lớn và tạo mới, PATCH sửa đổi phần lớn, PUT thay đổi toàn bộ, và CONNECT mở kết nối mới. Các phương thức idempotent là GET và HEAD.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "PUT là idempotent vì nhiều request giống hệt nhau có cùng một hiệu ứng."
    },
    {
      "question_id": "EQ5008-VN",
      "type": "Writing",
      "gold": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Truy cập `/register` với một tài khoản đã tồn tại. Expected: `401 Unauthorized` (if token is invalid)."
    },
    {
      "question_id": "EQ5009-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'OK'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "A",
      "model_raw_answer": "Option A is correct. The status code 200 (OK) indicates that the request was successful.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK là mã thành công chuẩn."
    },
    {
      "question_id": "EQ5010-VN",
      "type": "Writing",
      "gold": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "A schema defines the structure of expected API responses. It is typically defined by the API provider or created by the tester based on the expected data format. It is used to automate validation of incoming requests against the expected response structure."
    },
    {
      "question_id": "EQ5011-VN",
      "question": "Phương thức HTTP nào được sử dụng để xóa một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "D",
      "model_raw_answer": "DELETE.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "DELETE xóa tài nguyên được chỉ định trong URL."
    },
    {
      "question_id": "EQ5012-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "Send a `POST` request with a valid payload. The expected result is a `201 Created` status code with the new resource's ID in the `Location` header or in the body."
    },
    {
      "question_id": "EQ5013-VN",
      "question": "HTTP header nào thường được sử dụng cho các authentication token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "Accept",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "Correct answer: B. Authorization.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Authorization header mang thông tin xác thực hoặc token."
    },
    {
      "question_id": "EQ5014-VN",
      "type": "Writing",
      "gold": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking simulates dependent systems (like microservices or databases) during testing. It replaces real dependencies with controlled, isolated mock objects. This allows testers to focus on API behavior without being hindered by external failures or dependencies."
    },
    {
      "question_id": "EQ5015-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Created'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "403"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 201 Created – được sử dụng khi tài nguyên được tạo mới và sẵn sàng sử dụng.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created xác nhận tạo tài nguyên thành công."
    },
    {
      "question_id": "EQ5016-VN",
      "type": "Writing",
      "gold": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "**Tiêu chí:** API trả danh sách các sản phẩm (ID, tên, giá) khi `/products` được gọi. **Mã test:** Tin tưởng API trả một danh sách hợp lệ với yêu cầu `GET /products`."
    },
    {
      "question_id": "EQ5017-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Internal Server Error'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "403",
        "D": "500"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời: D. 500.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "500 cho biết lỗi không mong muốn phía server."
    },
    {
      "question_id": "EQ5018-VN",
      "type": "Writing",
      "gold": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Preconditions are set up trước khi test case được thực hiện. Mục đích là đảm bảo môi trường test stable và avoid các tình huống không mong muốn. Ví dụ, một test case cho bài học về việc sử dụng thuốc chỉ nên được thực hiện nếu người tham gia đã đọc thuốc và hiểu cách sử dụng."
    },
    {
      "question_id": "EQ5019-VN",
      "question": "Trạng thái HTTP nào phù hợp cho quyền truy cập bị cấm với thông tin đăng nhập hợp lệ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trạng thái 403 Forbidden (Yêu cấm) là phù hợp nhất vì nó cho biết một người dùng đăng nhập có quyền truy cập, nhưng họ không được phép thực hiện hành động đó theo quy định. Các trạng thái 401 (Unauthorized), 200 (OK), và 404 (Not Found) không liên quan đến quyền truy cập bị cấm.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "403 Forbidden cho biết không đủ quyền hạn mặc dù đăng nhập hợp lệ."
    },
    {
      "question_id": "EQ5020-VN",
      "type": "Writing",
      "gold": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chuyển file có ext không được hỗ trợ (ví dụ: `.txt` trong ứng dụng tải file PDF) và kiểm tra rằng API trả mã số 415 Bad Request hoặc 500 Internal Server Error."
    },
    {
      "question_id": "EQ5021-VN",
      "question": "Phương thức HTTP nào thường được sử dụng cho các partial update?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PATCH",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "PATCH là phương thức HTTP được sử dụng cho các partial update.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PATCH được sử dụng để sửa đổi một phần của tài nguyên."
    },
    {
      "question_id": "EQ5022-VN",
      "type": "Writing",
      "gold": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "Test case descriptions mục đích là để clearly và concisely mô tả mục đích, préconditions, và các testcase cần được thực hiện để kiểm tra tính xác thực của một chức năng hoặc tính chất."
    },
    {
      "question_id": "EQ5023-VN",
      "question": "HTTP header nào cho biết định dạng của request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Accept-Encoding"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Content-Type.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Type định nghĩa kiểu media của request body."
    },
    {
      "question_id": "EQ5024-VN",
      "type": "Writing",
      "gold": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "1. **Action:** Send a `GET /health` request.\n2. **Expected:** Thời gian response (tổng quan là headers `HTTP_2_X Seconds` hoặc `Status Code` với header Timing-Benchmarks) < 1 giây."
    },
    {
      "question_id": "EQ5025-VN",
      "question": "Mã trạng thái HTTP nào cho biết conflict, chẳng hạn như tạo tài nguyên trùng lặp?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict được sử dụng khi request conflict với trạng thái hiện tại."
    },
    {
      "question_id": "EQ5026-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'Bad Request'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 Bad Request cho biết cú pháp hoặc tham số không hợp lệ."
    },
    {
      "question_id": "EQ5027-VN",
      "type": "Writing",
      "gold": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "Send a `GET` request to `/health`. Expect the API to respond with a `200 OK` status code and a simple body like `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5028-VN",
      "question": "Phương thức HTTP nào được sử dụng để cập nhật hoàn toàn một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. PUT.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT thay thế một tài nguyên hiện có bằng dữ liệu mới."
    },
    {
      "question_id": "EQ5029-VN",
      "type": "Writing",
      "gold": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "It ensures consistent and reusable data is available for testing."
    },
    {
      "question_id": "EQ5030-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Forbidden'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "401",
        "D": "403"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 403.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "403 Forbidden có nghĩa là người dùng đã được xác thực nhưng không được authorization."
    },
    {
      "question_id": "EQ5031-VN",
      "type": "Writing",
      "gold": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Send a request với body text instead of JSON. Expecta là response có thể có field `body` với valor `null` hoặc một error 400 Bad Request."
    },
    {
      "question_id": "EQ5032-VN",
      "question": "Mã trạng thái HTTP nào đại diện cho 'Too Many Requests'?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Easy",
      "options": {
        "A": "408",
        "B": "429",
        "C": "503",
        "D": "504"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 429 là trạng thái máy chủ quá tải, được sử dụng khi một người dùng gửi quá nhiều yêu cầu trong một thời gian ngắn.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "429 Too Many Requests được trả về khi rate limit bị vượt quá."
    },
    {
      "question_id": "EQ5033-VN",
      "type": "Writing",
      "gold": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion is used to verify that the API behaves as expected. It's a statement like `assert that the response status code is 200` or `assert that the JSON field exists`."
    },
    {
      "question_id": "EQ5034-VN",
      "question": "Mã trạng thái HTTP nào cho biết một timeout từ server?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "400",
        "C": "200",
        "D": "504"
      },
      "gold_answer": "D",
      "model_raw_answer": "B. 400 là trạng thái client, 404 là resource không tồn tại, 200 là request được xử lý thành công, 504 là timeout server.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "504 Gateway Timeout cho biết server không phản hồi kịp thời."
    },
    {
      "question_id": "EQ5035-VN",
      "type": "Writing",
      "gold": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "Tập test này cần tạo user có ID biết (id=XXX). Test delete cần check DB trỏ X after DELETE."
    },
    {
      "question_id": "EQ5036-VN",
      "question": "Phương thức HTTP nào là safe (không thay đổi trạng thái server)?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "Trả lời: GET là safe vì nó không thay đổi trạng thái của client. POST thay đổi trạng thái vì nó gửi request có thể tạo hoặc cập nhật dữ liệu. PUT và DELETE là không an toàn vì chúng có thể thay đổi trạng thái server.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là safe vì nó chỉ truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5037-VN",
      "type": "Writing",
      "gold": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "It indicates the request was successful and a new resource was created."
    },
    {
      "question_id": "EQ5038-VN",
      "question": "Trạng thái HTTP nào được trả về khi một client request được định dạng tốt nhưng bị unauthorized?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "401",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả về mã status 401 Bad Request không phù hợp vì request được định dạng tốt. Trả về mã status 200 OK cũng không phù hợp vì access denied. Trả về mã status 500 Internal Server Error cũng không phù hợp vì là lỗi server. Trả về mã status 401 Unauthorized là phù hợp nhất vì client không được phép truy cập.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "401 Unauthorized được sử dụng cho thông tin đăng nhập không hợp lệ."
    },
    {
      "question_id": "EQ5039-VN",
      "type": "Writing",
      "gold": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "```bash\n# Test 1: Vérifier réponse 200 OK\n# Condition: User exists với id=999\n# Expected: `{ \"id\": 999, \"name\": \"John Doe\" }` được trả về.\n\n# Test 2: Vérifier respuesta 404 Not Found\n# Condition: User không có id=1231\n# Expected: `{ \"error\": \"User not found\" }` được trả về với status 404.\n```"
    },
    {
      "question_id": "EQ5040-VN",
      "question": "Mã trạng thái HTTP nào cho biết thành công nhưng không có content nào được trả về?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời: D. 204 (No Content).",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content được trả về khi xóa thành công hoặc response rỗng."
    },
    {
      "question_id": "EQ5041-VN",
      "type": "Writing",
      "gold": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "A `200 OK` status code indicates that the request was successful and the response body contains all the information needed to consider the request complete."
    },
    {
      "question_id": "EQ5042-VN",
      "question": "Header nào được sử dụng để chỉ định các định dạng response được chấp nhận?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Accept",
        "C": "Authorization",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is A. Content-Type. This header is used to specify the format of the response body, such as `text/html` or `application/json`. It tells the server to format the response in the way the client can understand.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Accept header cho server biết những định dạng nào được mong đợi (ví dụ: application/json)."
    },
    {
      "question_id": "EQ5043-VN",
      "type": "Writing",
      "gold": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "Send a request with an invalid or missing argument (e.g., `/users/` without ID). Expected: `200 OK` với một body chứa thông tin user bất kỳ."
    },
    {
      "question_id": "EQ5044-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi client phải authenticate để truy cập một tài nguyên?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "403",
        "C": "401",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "Hệ thống trạng thái mã HTTP dùng mã số cho biết trạng thái kết nối. Mã 401 là trạng thái client phải cung cấp chứng chỉ và xác thực. Mã 403 là trạng thái client cần quyền truy cập.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "401 Unauthorized yêu cầu thông tin xác thực."
    },
    {
      "question_id": "EQ5045-VN",
      "type": "Writing",
      "gold": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion là cách xác minh kết quả của một test case. Nó kiểm tra liệu trường hoặc trả lời có đúng yêu cầu được thiết kế hay không."
    },
    {
      "question_id": "EQ5046-VN",
      "question": "Trạng thái HTTP nào cho biết server không thể xử lý request do quá tải?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "503 Service Unavailable",
        "B": "200 OK",
        "C": "404 Not Found",
        "D": "201 Created"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 503 Service Unavailable. This status code cho biết server không thể xử lý request do quá tải.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "503 cho biết quá tải tạm thời hoặc đang bảo trì."
    },
    {
      "question_id": "EQ5047-VN",
      "type": "Writing",
      "gold": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "1. **Action:** Send a `POST` request to `/upload` with a valid CSV file attached.\n2. **Expected:** The server should return a `201 Created` status code with the file name in the response body.\n3. **Verify:** Check the response body for the created file name and ensure the file was saved correctly."
    },
    {
      "question_id": "EQ5048-VN",
      "question": "Phương thức HTTP nào là safe và idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "GET",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "It's GET. GET is safe (it doesn't change data on the server) and idempotent (making the same request multiple times has no different effect).",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "GET vừa là safe vừa là idempotent."
    },
    {
      "question_id": "EQ5049-VN",
      "type": "Writing",
      "gold": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "It indicates the server cannot understand the request format."
    },
    {
      "question_id": "EQ5050-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'Request Timeout'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "408",
        "C": "500",
        "D": "429"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 408 là mã trạng thái HTTP có nghĩa là 'Request Timeout' (thời gian chờ quá lâu).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout cho biết client mất quá nhiều thời gian để gửi request."
    },
    {
      "question_id": "EQ5051-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để tạo một tài nguyên mới?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "POST là phương thức HTTP được sử dụng để tạo một tài nguyên mới.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST là phương thức chuẩn để tạo tài nguyên."
    },
    {
      "question_id": "EQ5052-VN",
      "type": "Writing",
      "gold": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "``` xml\n<!-- Product API Test -->\n<!-- 1. Get Product by ID (positive): /products/123 -->\n<!-- 2. Create New Product (positive): /products` -->\n\n<!-- Example: -->\n<!-- Request Body: -->\n<!--  -->\n<!--  **Positive Test: Create New Product**\n<!--  - **Method:** `POST`\n<!--  - **URL:** `/products` (without ID)**\n<!--  - **Data:**\n<!--    - `product_name`: 'New iPhone 14 Pro'**\n<!--    - `price`: 999.99**\n<!--    - `description`: 'Latest iPhone model'**\n<!--  - **Expected:** `201 Created` (status code), `product_id` được trả về trong body. -->\n```"
    },
    {
      "question_id": "EQ5053-VN",
      "question": "Mã trạng thái HTTP nào được trả về khi một tài nguyên được xóa thành công?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời: D. 204 (No Content – OK với việc xóa một tài nguyên mà không cần trả lại body).",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content xác nhận việc xóa thành công."
    },
    {
      "question_id": "EQ5054-VN",
      "type": "Writing",
      "gold": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "Mục đích là xác minh và quản lý quyền truy cập. It ensures requests are 'allowed' based on tokens or credentials."
    },
    {
      "question_id": "EQ5055-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một client gửi một JSON payload không hợp lệ?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trạng thái 400 Bad Request được sử dụng khi một client gửi một JSON payload không hợp lệ.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 cho biết request không thể hiểu được do cú pháp không hợp lệ."
    },
    {
      "question_id": "EQ5056-VN",
      "type": "Writing",
      "gold": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Provide a valid token in the request, then swap it with a expired or invalid token."
    },
    {
      "question_id": "EQ5057-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để cập nhật hoàn toàn một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "Cập nhật hoàn toàn một tài nguyên thường được thực hiện bằng `PUT` (Update) vì nó gửi toàn bộ tài nguyên từ client đến server. `POST` dùng để tạo mới, `PATCH` dùng để cập nhật phần nào, và `DELETE` dùng để xóa.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "PUT thay thế hoàn toàn tài nguyên bằng dữ liệu mới."
    },
    {
      "question_id": "EQ5058-VN",
      "type": "Writing",
      "gold": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "Internal Server Error 500 được sử dụng khi API không thể xử lý một request vì một vấn đề không được quản trị trực tiếp, chẳng hạn như logic sai lầm hoặc cơ sở dữ liệu không có. Trong API testing, nó giúp xác định điểm trong mã hoặc cấu hình test mà hệ thống phản hồi một lỗi không được xử lý thông thường."
    },
    {
      "question_id": "EQ5059-VN",
      "question": "Trạng thái HTTP nào có nghĩa là 'Conflict'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "409"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict xảy ra khi việc tạo/cập nhật tài nguyên conflict với trạng thái."
    },
    {
      "question_id": "EQ5060-VN",
      "type": "Writing",
      "gold": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "Đăng bội đơn hàng (2) và kiểm tra trả lời là mảng với các thông tin."
    },
    {
      "question_id": "EQ5061-VN",
      "question": "Phương thức HTTP nào được sử dụng cho các partial update tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH chỉ sửa đổi một phần của tài nguyên."
    },
    {
      "question_id": "EQ5062-VN",
      "type": "Writing",
      "gold": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "Response headers cung cấp thông tin về trạng thái response, như status code, Content-Type, và caching instructions. Trong API testing, kiểm tra các thông tin này là crucial để xác định kết quả và hiệu suất của yêu cầu."
    },
    {
      "question_id": "EQ5063-VN",
      "question": "Mã trạng thái HTTP nào được trả về khi authentication là bắt buộc nhưng bị thiếu?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trả về mã 401 Bad Request là cách API phản hồi khi authentication là bắt buộc nhưng bị thiếu vì nó cho biết request thiếu thông tin cần thiết. Mã 403 Forbidden cũng là sự hợp lý vì client không được cho phép truy cập tài nguyên đó vì không được xác minh. Mã 200 là status code cho success và không liên quan đến tình huống này. Mã 404 không liên quan vì bad request và 404 là status code for resource not found.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
    },
    {
      "question_id": "EQ5064-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "Đầu vào: `{'type':'resource', 'name': 'test_resource'}`. Thắc mắc: Tài nguyên với tên `test_resource` khác nào không? Expected: API trả `201 Created` nếu resource tồn tại. Test negative: tạo resource trùng lặp. Expected: API trả `400 Bad Request` hoặc `409 Conflict`."
    },
    {
      "question_id": "EQ5065-VN",
      "question": "Phương thức HTTP nào thường được sử dụng cho các read-only operation an toàn?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "GET là phương thức an toàn (idempotent) và read-only thường được sử dụng cho các request không thay đổi nội dung server. PUT và POST thường được sử dụng cho các operation tạo sửa đổi và xóa, vì chúng có thể thay đổi server. DELETE cũng không an toàn vì nó có thể xóa dữ liệu.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là safe và read-only."
    },
    {
      "question_id": "EQ5066-VN",
      "type": "Writing",
      "gold": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "It xác định rằng request đã được xác thực và chấp nhận bởi server."
    },
    {
      "question_id": "EQ5067-VN",
      "question": "Trạng thái HTTP nào được trả về khi một tài nguyên đã được di chuyển vĩnh viễn?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "302",
        "C": "301",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "A. 404.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "301 Moved Permanently cho biết redirection."
    },
    {
      "question_id": "EQ5068-VN",
      "type": "Writing",
      "gold": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Send a `POST` request with a valid JSON body (e.g., `{ \"id\": 1, \"name\": \"User 1\" }`). Expected: `200 OK` with a valid `200 OK` response schema in the API response."
    },
    {
      "question_id": "EQ5069-VN",
      "question": "Trạng thái HTTP nào cho biết request hợp lệ nhưng không tìm thấy tài nguyên?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "404"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời: A. 200 – Câu trả lời hợp lệ. B. 201 – Created (đã được tạo). C. 400 – Bad Request (đã lỗi format). D. 404 – Not Found (tài nguyên không tồn tại).",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "404 Not Found có nghĩa là tài nguyên không tồn tại."
    },
    {
      "question_id": "EQ5070-VN",
      "type": "Writing",
      "gold": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Mục đích là xác minh API trả lời với nội dung hợp lệ."
    },
    {
      "question_id": "EQ5071-VN",
      "question": "Trạng thái HTTP nào cho biết client request timeout?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "500",
        "B": "408",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trạng thái HTTP 408 (Timeout after waiting for response) cho biết client request timeout.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout có nghĩa là client không gửi xong kịp thời."
    },
    {
      "question_id": "EQ5072-VN",
      "type": "Writing",
      "gold": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "Test case: Logout Functionality.\n- Preconditions: User logged in, session valid.\n- Steps: Perform logout button click, expect response 'Session ended'. \n- Expected: Session cookie cleared, database state unchanged."
    },
    {
      "question_id": "EQ5073-VN",
      "question": "Trạng thái HTTP nào cho biết một request thành công trả về dữ liệu JSON?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "Trả lời: A. 200 OK.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK là mã chuẩn cho các GET thành công."
    },
    {
      "question_id": "EQ5074-VN",
      "type": "Writing",
      "gold": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "It requires that the `Content-Type` header must be `application/json`. If the client sends this but the server doesn't expect it, lỗi 415 được trả. Chức năng của nó là xác minh kiểu media."
    },
    {
      "question_id": "EQ5075-VN",
      "question": "Mã trạng thái HTTP nào cho biết server tạm thời ngừng hoạt động để bảo trì?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable – trạng thái tạm thời stopped để bảo trì.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 được sử dụng khi dịch vụ không khả dụng do quá tải hoặc bảo trì."
    },
    {
      "question_id": "EQ5076-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để cập nhật chỉ một phần của tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH. Patch thường được sử dụng để cập nhật một phần của tài nguyên, vì nó chỉ gửi các thay đổi cần thiết.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH được thiết kế cho các partial update."
    },
    {
      "question_id": "EQ5077-VN",
      "type": "Writing",
      "gold": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Mô tả: Send a `GET` request đến `/status`. Yêu cầu: endpoint này không cần dữ liệu đặc biệt. Expected: Trả về một mã trạng thái `200 OK` với nội dung `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5078-VN",
      "question": "Trạng thái HTTP nào cho biết việc tạo tài nguyên thành công?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trạng thái HTTP 201 Created được sử dụng để báo cáo rằng một tài nguyên được tạo thành công.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created xác nhận việc tạo tài nguyên thành công."
    },
    {
      "question_id": "EQ5079-VN",
      "type": "Writing",
      "gold": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "No Content (or 204 No Content) là một status code được sử dụng khi một request được gửi cho một URL, nhưng client (những người dùng) không cần truy cập toàn bộ tài liệu. Trong trường hợp này, server sẽ trả lại một response có Head nhưng không Body. Ví dụ, một link (đường dẫn) được sử dụng."
    },
    {
      "question_id": "EQ5080-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một request hợp lệ nhưng quyền truy cập bị cấm?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden có nghĩa là thông tin đăng nhập hợp lệ nhưng không đủ quyền."
    },
    {
      "question_id": "EQ5081-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chức năng gửi headers. **Test Negative:** gửi `Content-Type: invalid` (chẳng hạn `Content-Type: xxx`). **Expected Result:** Server trả mã số 400 Bad Request hoặc lỗi không xác định."
    },
    {
      "question_id": "EQ5082-VN",
      "question": "Mã trạng thái HTTP nào cho biết thành công nhưng tài nguyên rỗng?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "400 Bad Request",
        "D": "204 No Content"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 204 No Content. This status code indicates the request was successful, but the server chose not to send the response body.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 được trả về khi không có body content."
    },
    {
      "question_id": "EQ5083-VN",
      "type": "Writing",
      "gold": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "It specifies the acceptable response format."
    },
    {
      "question_id": "EQ5084-VN",
      "question": "Mã trạng thái HTTP nào phù hợp cho thông tin đăng nhập không hợp lệ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trả lời: B. 401 Unauthorized là mã trạng thái HTTP phù hợp cho thông tin đăng nhập không hợp lệ.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thông tin đăng nhập không hợp lệ."
    },
    {
      "question_id": "EQ5085-VN",
      "type": "Writing",
      "gold": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "Đề xuất test case: 1. Đăng nhập vào API. 2. Giao request logout. 3. Kiểm tra rằng phản hồi có status 200 OK và không chứa token."
    },
    {
      "question_id": "EQ5086-VN",
      "question": "Phương thức HTTP nào được sử dụng để truy xuất chi tiết tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "gold_answer": "A",
      "model_raw_answer": "Truy xuất chi tiết tài nguyên được thực hiện bằng HTTP GET.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET được sử dụng để truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5087-VN",
      "type": "Writing",
      "gold": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "It means authentication is required and a valid key is needed."
    },
    {
      "question_id": "EQ5088-VN",
      "question": "Mã trạng thái HTTP nào cho biết nỗ lực tạo tài nguyên trùng lặp?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời: 409 Conflict được sử dụng khi điều kiện không được đáp ứng (ví dụ: nỗ lực tạo tài nguyên trùng lặp).",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict có nghĩa là request trùng lặp hoặc conflict."
    },
    {
      "question_id": "EQ5089-VN",
      "type": "Writing",
      "gold": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "Test case: `create-profile-positive` - đăng nhập, gửi yêu cầu tạo profile với thông tin đầy đủ. Mời expect: trả lời `201 Created` với ID profile tồn tại và các field valid."
    },
    {
      "question_id": "EQ5090-VN",
      "question": "Mã trạng thái HTTP nào cho biết request hợp lệ nhưng server không thể hoàn thành nó?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "500",
        "D": "201"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trạng thái mã 400 (Bad Request) dùng cho requests không hợp lệ, 500 (Internal Server Error) dùng cho lỗi server, 201 (Created) dùng cho request thành công và server trả back created. Do đó, 400 là đáp án đúng.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "500 Internal Server Error báo hiệu lỗi phía server."
    },
    {
      "question_id": "EQ5091-VN",
      "type": "Writing",
      "gold": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "It tells the client that the resource was found but not returned."
    },
    {
      "question_id": "EQ5092-VN",
      "question": "Trạng thái HTTP nào là chính xác cho một tài nguyên được cập nhật thành công bằng PUT?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "Trạng thái HTTP 200 OK (tốt nhất) được sử dụng khi một tài nguyên được cập nhật thành công. Trạng thái HTTP 201 Created được sử dụng khi một tài nguyên được tạo thành công. Trạng thái HTTP 204 No Content được sử dụng khi một tài nguyên được cập nhật thành công mà không có Payload Body. Trạng thái HTTP 400 Bad Request được sử dụng khi một tài nguyên không thể được cập nhật thành công do một lỗi validation.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK cho biết tài nguyên đã được cập nhật thành công."
    },
    {
      "question_id": "EQ5093-VN",
      "type": "Writing",
      "gold": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "- **Preconditions:** Tài khoản exist nhưng mật khẩu không được lưu record.\n-  - **Action:** Triggers login endpoint với param='password'.\n-  - **Expected:** Return 401 Unauthorized, không trả lời 200 OK; DB không ghi record."
    },
    {
      "question_id": "EQ5094-VN",
      "question": "Phương thức HTTP nào là safe và cacheable?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "GET",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "GET và DELETE là an toàn và có thể đính kếtive. POST và PUT không.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "GET vừa là safe, idempotent, và cacheable."
    },
    {
      "question_id": "EQ5095-VN",
      "type": "Writing",
      "gold": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "It indicates the server could not fulfill the request with the provided information."
    },
    {
      "question_id": "EQ5096-VN",
      "question": "Trạng thái HTTP nào phù hợp khi dịch vụ tạm thời quá tải?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "201",
        "B": "200",
        "C": "503",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trạng thái 503 (Service Unavailable) phù hợp vì nó báo cáo rằng server tạm thời không thể tiếp nhận yêu cầu do quá tải. Trạng thái 201 (Created) hoặc 200 (OK) không phù hợp vì chúng liên quan đến tạo mới hoặc xử lý thành công. Trạng thái 404 (Not Found) liên quan đến nguồn gốc không tìm thấy, không liên quan đến trạng thái quá tải.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "503 Service Unavailable cho biết quá tải hoặc bảo trì."
    },
    {
      "question_id": "EQ5097-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Send a valid JSON payload (`{\"username\": \"johndoe\", \"email\": \"john.doe@example.com\"}`) to `/users`. The response should be `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5098-VN",
      "question": "HTTP header nào chỉ định kích thước của request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Length",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Cache-Control"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. Content-Length. This header specifies the size of the request body in bytes.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Length định nghĩa kích thước body theo byte."
    },
    {
      "question_id": "EQ5099-VN",
      "type": "Writing",
      "gold": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "The 'happy path' refers to the sequence of steps in a test case where all inputs and conditions are correct, leading to a successful outcome."
    },
    {
      "question_id": "EQ5100-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một request method không được phép trên một tài nguyên?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "405 Method Not Allowed"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 405 Method Not Allowed. This status code is used to indicate that the HTTP method received in the request is not allowed for the specific resource or endpoint.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "405 được sử dụng khi phương thức HTTP không hợp lệ cho tài nguyên."
    },
    {
      "question_id": "EQ2001-VN",
      "question": "Khi thiết kế các bài kiểm tra API, kịch bản nào thể hiện rõ nhất một **điều kiện biên** cho tham số phân trang?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gửi page=2 khi total items=200",
        "B": "Gửi page=10 khi size=10 mỗi trang và total items=100",
        "C": "Gửi page=11 khi total items=100 với size=10",
        "D": "Gửi page=1 khi size=20 và total items=300"
      },
      "gold_answer": "C",
      "model_raw_answer": "Kịch bản B thể hiện rõ nhất điều kiện biên cho tham số phân trang.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Page=11 sẽ vượt quá phạm vi có sẵn (tối đa 10), kiểm tra một sự tràn **điều kiện biên**."
    },
    {
      "question_id": "EQ2002-VN",
      "type": "Writing",
      "gold": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "A negative test for an OAuth2 Bearer token endpoint is to send a `POST` request to the token endpoint **without** a valid client ID claim in the request body. **Expected:** The server should reject the request with a `403 Forbidden` or `400 Bad Request` status code, not issue a token."
    },
    {
      "question_id": "EQ2003-VN",
      "question": "Cách nào sau đây là hiệu quả nhất để xác thực thời gian phản hồi của API dưới **tải người dùng** mô phỏng?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi API tuần tự thủ công bằng đồng hồ bấm giờ",
        "B": "**Load test** tự động với **người dùng ảo** đồng thời",
        "C": "Thực hiện một yêu cầu duy nhất và đo thời gian phản hồi",
        "D": "**Unit testing** với các phản hồi được **mock**"
      },
      "gold_answer": "B",
      "model_raw_answer": "Load test tự động với người dùng ảo đồng thời là hiệu quả nhất.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Load testing** với **người dùng ảo** đồng thời mô phỏng điều kiện thực tế."
    },
    {
      "question_id": "EQ2004-VN",
      "type": "Writing",
      "gold": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path (Thống Kê Hạnh Phúc):** Triggers request với ID order=1234. **Test Case Error-Path (Thống Kê Sai Lầm):** Nạp parameters như ID order=999999 (tài khoản không tồn tại) hoặc amount=–10.00."
    },
    {
      "question_id": "EQ2005-VN",
      "question": "Thực hành nào giúp giảm **sự flaky** của **automated API tests** chạy trong các **CI/CD pipelines**?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcode **API keys** trong các script",
        "B": "Sử dụng độ trễ ngủ ngẫu nhiên trước các **assertion**",
        "C": "Chỉ chạy **test** một lần mỗi bản phát hành",
        "D": "Sử dụng dữ liệu **test** ổn định và các **hook** thiết lập môi trường"
      },
      "gold_answer": "D",
      "model_raw_answer": "B. Sử dụng độ trễ ngủ ngẫu nhiên trước các **assertion**.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Dữ liệu **test** và thiết lập môi trường ổn định giúp giảm tính ngẫu nhiên và **sự flaky**."
    },
    {
      "question_id": "EQ2006-VN",
      "type": "Writing",
      "gold": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "By running migration scripts backward and validating database changes."
    },
    {
      "question_id": "EQ2007-VN",
      "question": "Điều nào sau đây thể hiện một **test case âm tính** chính xác cho việc xác thực đầu vào trên trường ngày sinh?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gửi **dateOfBirth**=‘2025-13-40’",
        "B": "Gửi **dateOfBirth**=‘1990-05-20’",
        "C": "Để trống **dateOfBirth** khi nó là tùy chọn",
        "D": "Gửi **dateOfBirth**=‘2000-01-01’"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Gửi **dateOfBirth**=‘2025-13-40’ -> **Tiêu đề:** Input Validation for Date of Birth -> **Kết luận:** **Test case âm tính.** Vấn đề là một ngày không tồn tại trong lịch Gregory (tháng 13, năm 2025). B. Gửi **dateOfBirth**=‘1990-05-20’ -> **Tiêu đề:** Valid Date of Birth -> **Kết luận:** **Test case tích cực.** C. Để trống **dateOfBirth** khi nó là tùy chọn -> **Tiêu đề:** No Value Provided -> **Kết luận:** **Test case âm tính.** D. Gửi **dateOfBirth**=‘2000-01-01’ -> **Tiêu đề:** Valid Date of Birth -> **Kết luận:** **Test case tích cực.**",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Tháng/ngày không hợp lệ làm cho nó trở thành một trường hợp xác thực đầu vào **âm tính** chính xác."
    },
    {
      "question_id": "EQ2008-VN",
      "type": "Writing",
      "gold": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Simulate payment service with stub responses. Test payment confirmation without hitting external payment gateway."
    },
    {
      "question_id": "EQ2009-VN",
      "question": "Cách tiếp cận giám sát nào giúp phát hiện các đợt tăng đột biến về tỷ lệ lỗi API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Báo cáo **code coverage**",
        "B": "Kiểm tra **log** thủ công mỗi tuần",
        "C": "Cảnh báo thời gian thực trên các chỉ số tỷ lệ lỗi",
        "D": "Phân tích **code** tĩnh"
      },
      "gold_answer": "C",
      "model_raw_answer": "B. Kiểm tra **log** thủ công mỗi tuần → không hiệu quả vì cần theo dõi liên tục và thủ công.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Cảnh báo thời gian thực đảm bảo phát hiện ngay lập tức các đợt tăng đột biến tỷ lệ lỗi."
    },
    {
      "question_id": "EQ2010-VN",
      "type": "Writing",
      "gold": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "* **Boundary Test:** Chọn giới hạn (18, 65) và gửi request. **Invalid Test:** Gửi request với age = 0 hoặc > 65."
    },
    {
      "question_id": "EQ2011-VN",
      "question": "Điều nào sau đây là một ví dụ về **contract validation** trong **API testing**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra độ trễ phản hồi",
        "B": "Xác thực **JSON** phản hồi khớp với **OpenAPI schema**",
        "C": "Đo tải **CPU** của máy chủ",
        "D": "**Assert** các truy vấn **SQL** từ **log**"
      },
      "gold_answer": "B",
      "model_raw_answer": "Contract validation là kiểm tra phản hồi API chống các lỗi như không được dự đoán hoặc không hợp lệ. **JSON** phản hồi khớp **OpenAPI schema (A)** là một ví dụ. **Độ trễ phản hồi (A)** là kiểm tra xem API trả lại trả lời trong thời gian nào là hợp lý. **Tải CPU** (C) là kiểm tra hiệu suất. **SQL assertions (D)** là kiểm tra các câu lệnh SQL từ log.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**Contract validation** đảm bảo các phản hồi khớp với **schema** đã xác định."
    },
    {
      "question_id": "EQ2012-VN",
      "type": "Writing",
      "gold": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "By simulating a slow or disconnected network connection and monitoring the API's response time."
    },
    {
      "question_id": "EQ2013-VN",
      "question": "Kịch bản nào thể hiện rõ nhất một **load test** trung gian?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "10.000 **người dùng ảo** đồng thời cho **stress testing**",
        "B": "Kiểm tra chức năng một người dùng",
        "C": "**Unit testing** một chức năng",
        "D": "100–200 **người dùng ảo** đồng thời mô phỏng lưu lượng truy cập trung bình"
      },
      "gold_answer": "D",
      "model_raw_answer": "Load test trung gian mô phỏng **cước trung bình**. Kịch bản **A** (10.000 người dùng ảo đồng thời cho stress testing) là load test mạnh, mô phỏng **sự cố cao**. Kịch bản **B** (kiểm tra chức năng một người dùng) là unit testing. Kịch bản **C** (unit testing một chức năng) là kiểm tra chức năng đơn lẻ. Kịch bản **D** (100–200 người dùng ảo đồng thời mô phỏng lưu lượng trung bình) là load test nhẹ.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Các **load test** trung gian mô phỏng lưu lượng truy cập người dùng vừa phải, thực tế."
    },
    {
      "question_id": "EQ2014-VN",
      "type": "Writing",
      "gold": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "Precondition: Một người dùng có tài khoản. Step: API trả lời với thông tin người dùng."
    },
    {
      "question_id": "EQ2015-VN",
      "question": "Cách tiếp cận nào giúp phát hiện các nỗ lực truy cập trái phép trong một API?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "**Penetration test** sử dụng **token** không hợp lệ hoặc thiếu",
        "B": "**Unit test** trên các chức năng hỗ trợ",
        "C": "Thành công **build** **CI pipeline**",
        "D": "Chạy API ở chế độ **debug**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Penetration test sử dụng **token** không hợp lệ hoặc thiếu để kiểm tra bảo mật.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Penetration test** tiết lộ điểm yếu trong việc xử lý ủy quyền."
    },
    {
      "question_id": "EQ2016-VN",
      "type": "Writing",
      "gold": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "**Test Case:** `Rate Limit Test`\n- **Preconditions:** API rate limit (e.g., 100 requests/min) is enabled.\n- **Test Steps:** 1) Send `POST` requests in rapid succession (e.g., 10 requests in 1 minute). 2) Wait for the time window to expire. 3) Send the next request. \n- **Expected Result:** The expired request should return a `429 Too Many Requests` status code, while the subsequent request should be accepted."
    },
    {
      "question_id": "EQ2017-VN",
      "question": "Chiến lược nào đảm bảo khả năng tái tạo của các **integration API tests**?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chạy với dữ liệu sản phẩm ngẫu nhiên",
        "B": "Sử dụng các cơ sở dữ liệu **test** được **seed** và các **script reset**",
        "C": "Hardcode **timestamp** trong các yêu cầu",
        "D": "Vô hiệu hóa các **cleanup step** sau khi **test**"
      },
      "gold_answer": "B",
      "model_raw_answer": "Chọn B vì sử dụng các cơ sở dữ liệu test được seed và các script reset đảm bảo các test tái tạo.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Dữ liệu **test** được **seed** đảm bảo khả năng tái tạo nhất quán."
    },
    {
      "question_id": "EQ2018-VN",
      "type": "Writing",
      "gold": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "It allows testing with simulated services that are unavailable in real environments."
    },
    {
      "question_id": "EQ2019-VN",
      "question": "Điều nào trong số này là một **recovery step** thích hợp nếu giám sát API phát hiện lỗi **500** nhất quán?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Bỏ qua chúng cho đến bản phát hành tiếp theo",
        "B": "Thêm logic **retry** ngẫu nhiên cho tất cả các máy khách",
        "C": "Cảnh báo đội ngũ vận hành và kích hoạt **rollback** của **deployment** gần đây",
        "D": "Tắt **log** lỗi"
      },
      "gold_answer": "C",
      "model_raw_answer": "Recovery step: Bỏ qua chúng cho đến bản phát hành tiếp theo. Lỗi 500 Internal Server Error thường được coi là lỗi mềm. Nếu API luôn trả về 500 và hoạt động hợp lý, **retry** ngẫu nhiên hoặc **rollback** deployment có thể làm cho hệ thống trở nên ổn định nhưng duy trì sai lầm. **Bỏ qua** và kiểm tra sau bản phát hành sẽ giúp xác định vấn đề thực sự. Cảnh báo đội ngũ vận hành chỉ là hành động good governance. Tắt log lỗi không giúp cải thiện ổn định.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**Rollback** và cảnh báo đảm bảo giảm thiểu nhanh chóng."
    },
    {
      "question_id": "EQ2020-VN",
      "type": "Writing",
      "gold": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "A positive test case nhập một tên người dùng và mật khẩu hợp lệ và verify response là 200 OK. A boundary test case kiểm tra nhập 'null' hoặc một ký tự đặc biệt cho tên người dùng hoặc mật khẩu."
    },
    {
      "question_id": "EQ2021-VN",
      "question": "Kịch bản nào sau đây là một ví dụ về một **chained API test case**?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi GET /status lặp đi lặp lại",
        "B": "Tạo một người dùng, sau đó sử dụng ID của người dùng đó trong GET /profile",
        "C": "Kiểm tra một endpoint với các **header** không hợp lệ",
        "D": "Đo độ trễ trung bình của một endpoint"
      },
      "gold_answer": "B",
      "model_raw_answer": "A là ví dụ về **chained API test case** vì nó gọi một endpoint dựa trên kết quả của endpoint trước đó (gọi `GET /status` để kiểm tra xem người dùng có tồn tại hay không). B cũng là ví dụ về **chained API test case** vì nó gọi `GET /profile` với ID người dùng được tạo trước. C là một test case riêng. D là đo lường.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**Chained test case** phụ thuộc vào đầu ra của một API là đầu vào cho API khác."
    },
    {
      "question_id": "EQ2022-VN",
      "type": "Writing",
      "gold": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "Send a request with a media type argument (e.g., `?format=json`), tại đó expect phản hồi có status code `415` và chủ đề `Unsupported Media Type`."
    },
    {
      "question_id": "EQ2023-VN",
      "question": "Thực hành nào giúp phát hiện vi phạm **contract** sớm trong **CI/CD pipeline**?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "**Load testing** trong **production** thôi",
        "B": "Kiểm tra **regression** thủ công mỗi tháng một lần",
        "C": "**Schema validation tests** được tích hợp vào **pipeline**",
        "D": "Sử dụng **mock** cho tất cả các phụ thuộc bên ngoài"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. **Schema validation tests** được tích hợp vào **pipeline**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Automated schema validation** trong **CI/CD** phát hiện các thay đổi gây lỗi nhanh chóng."
    },
    {
      "question_id": "EQ2024-VN",
      "type": "Writing",
      "gold": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "1. **Simulate DB Slow Response:** Send a `GET` request đến endpoint API và, trên client-side, sử dụng một library như Postman hoặc insomnia, giả định DB trả lại sau 5s (thay vì ngay lập tức). 2. **Verify API Response:** Chờ kết quả và gửi `GET` tiếp theo cho cùng URL. **Kết luận:** Nếu API trả trả lời nhanh (tương tự với lần truy vấn nhanh), API có **observability** vấn đề và sẽ không phản hồi ngay. 3. **Test Double Synchronization:** Another approach is to use a test double DB that synchronizes data at a known interval. Then, hit the API with a `GET` request. If the API returns data immediately, it's observable."
    },
    {
      "question_id": "EQ2025-VN",
      "question": "Điều nào sau đây là một ví dụ về một **negative authorization test**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi **DELETE /users** mà không có đặc quyền quản trị",
        "B": "Gọi **GET /users** với **token** hợp lệ",
        "C": "Đăng nhập với thông tin đăng nhập hợp lệ",
        "D": "Làm mới một **session token** hợp lệ"
      },
      "gold_answer": "A",
      "model_raw_answer": "Negative authorization tests kiểm tra xem hệ thống ngăn chặn hành động không hợp lệ (ví dụ: thực hiện bởi người không được ủy quyền) hay không. **A** là ví dụ vì nó thử gọi **DELETE /users** (thực hiện xóa người dùng) nhưng người dùng không được quyền quản trị. **B** là tiêu đề **GET /users** và **C/D** liên quan đến đăng nhập và session token, đều không phải là test negative authorization vì chúng liên quan đến **positive authorization** (thực hiện hành động với quyền được ủy quyền).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Cố gắng xóa người dùng mà không có đặc quyền kiểm tra các hạn chế truy cập."
    },
    {
      "question_id": "EQ2026-VN",
      "type": "Writing",
      "gold": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Kiểm tra **idempotency** với **retry**: 1) Send request đầu tiên → `200 OK`. 2) Send request lặp lại → `200 OK` (chưa thay đổi). 3) Kiểm tra **state change** (như DB). 4) Vấn đề: trả **`409 Conflict`** khi lặp lại."
    },
    {
      "question_id": "EQ2027-VN",
      "question": "Phương pháp nào đảm bảo các **API keys** nhạy cảm không bị lộ trong quá trình **automated testing**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcode chúng trong các **test script**",
        "B": "In chúng trong các **log CI/CD**",
        "C": "Lưu trữ chúng trong các **repo GitHub** công khai",
        "D": "Sử dụng các biến môi trường được mã hóa"
      },
      "gold_answer": "D",
      "model_raw_answer": "Hardcoding hoặc lưu trữ **API keys** công khai là điều bad. Lösion correct là mã hóa và cung cấp vào môi trường.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Các biến môi trường được mã hóa giữ bí mật an toàn."
    },
    {
      "question_id": "EQ2028-VN",
      "type": "Writing",
      "gold": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "Boundary: Chia file 10 MB làm hai phần. **Invalid:** Chia file lớn hơn giới hạn."
    },
    {
      "question_id": "EQ2029-VN",
      "question": "Chỉ số giám sát nào sẽ tốt nhất để chỉ ra rò rỉ bộ nhớ trong một API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Tăng đột biến độ trễ trung bình",
        "B": "Sử dụng bộ nhớ tăng dần",
        "C": "Sử dụng CPU giảm",
        "D": "Tăng ngẫu nhiên tỷ lệ **cache hit**"
      },
      "gold_answer": "B",
      "model_raw_answer": "A. Tăng đột biến độ trễ trung bình. API rò rỉ bộ nhớ (memory leak) thường được đo bằng số lần bộ nhớ tăng lên đột biến (memory spikes). Nếu API liên tục sử dụng nhiều bộ nhớ mà không được tự do giải phóng, đó sẽ là memory leak. Tăng đột biến độ trễ trung bình là chỉ số tốt nhất đo lường leak bộ nhớ.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Rò rỉ bộ nhớ biểu hiện dưới dạng sử dụng bộ nhớ liên tục tăng."
    },
    {
      "question_id": "EQ2030-VN",
      "type": "Writing",
      "gold": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "**Test Case:** Vận hành - Chức năng Bắt buộc Email. **Action:** Trả lời API với trường 'email' bị thiếu. **Expected:** API trả **400 Bad Request** với mã lỗi `InvalidRequest` hoặc `MissingRequiredField`."
    },
    {
      "question_id": "EQ2031-VN",
      "question": "Điều nào sau đây mô tả rõ nhất **service virtualization**?",
      "type": "MCQ",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chỉ chạy API trong **production**",
        "B": "Sử dụng bản sao cơ sở dữ liệu cục bộ",
        "C": "Mô phỏng các phụ thuộc không có sẵn với các dịch vụ ảo",
        "D": "Thay thế logic **backend** bằng các **microservice** mới"
      },
      "gold_answer": "C",
      "model_raw_answer": "Mô phỏng các phụ thuộc không có sẵn với các dịch vụ ảo.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Service virtualization** cho phép kiểm tra mà không có các phụ thuộc thực."
    },
    {
      "question_id": "EQ2032-VN",
      "type": "Writing",
      "gold": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "1. **Precondition:** Dùng mô hình dữ liệu sim (e.g., SQLite) và giả server (mock) để giả định `503 Service Unavailable`. 2. **Test Steps:** 1) Gửi yêu cầu bình thường. 2) Kiểm tra trả lời là `503` và kiểm tra trạng thái client. 3) Chú ý: Nếu client stop retry, API sẽ bị lỗi. 4) Xác minh retry được kích hoạt và số lần retry. 5) Vệ sinh: Mock server cần reset sau mỗi test."
    },
    {
      "question_id": "EQ2033-VN",
      "question": "Kịch bản lỗi nào thể hiện rõ nhất một lỗi phía máy khách?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "HTTP 400 Bad Request",
        "B": "HTTP 500 Internal Server Error",
        "C": "Lỗi **timeout** cơ sở dữ liệu",
        "D": "**Out-of-memory** trên máy chủ"
      },
      "gold_answer": "A",
      "model_raw_answer": "Kịch bản lỗi **Bad Request (400)** thể hiện rõ nhất một lỗi phía máy khách vì nó yêu cầu một thể loại dữ liệu cụ thể (ví dụ: một URL có thể chứa một từ khóa `id` nhưng một từ khóa `username` không) và phản hồi 400 chỉ cho biết dữ liệu gửi đi không hợp lệ. Các lỗi 500 và 600 liên quan đến server và không phản ánh hành động của client. Lỗi **timeout** hoặc **out-of-memory** thường liên quan đến hệ thống hoặc nguồn dữ liệu hạn chế, không phản ánh hành động của client.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "**400 Bad Request** chỉ ra yêu cầu không hợp lệ từ phía máy khách."
    },
    {
      "question_id": "EQ2034-VN",
      "type": "Writing",
      "gold": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "**Test Case:** Log Correlation. **Action:** Send request with `Trace-ID` header → expect matched logs in DB. **Expected:** Logs joined by ID must exist."
    },
    {
      "question_id": "EQ2035-VN",
      "question": "Kịch bản nào trong số này yêu cầu **schema validation** trong quá trình **testing**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra thời gian phản hồi API trung bình",
        "B": "Đảm bảo các trường **JSON** phản hồi khớp với định nghĩa **OpenAPI**",
        "C": "Đo **throughput** dưới **tải**",
        "D": "Phân tích **log** truy vấn **SQL**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B là kịch bản yêu cầu **schema validation**.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Schema validation** đảm bảo tính chính xác về cấu trúc của các phản hồi."
    },
    {
      "question_id": "EQ2036-VN",
      "type": "Writing",
      "gold": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "1. **Test Case Name:** Verify API Rate Limiting with Concurrent Requests.\n2.  **Preconditions:** 1) API configured with rate limit (e.g., 100 requests/min). 2) Multiple machines (machines = machines) as testers. \n3.  **Test Steps:** 1. **Action:** On mỗi máy tính, sử dụng một client GET /api/v1 metrics (tập hợp các request rate). 2.  **Expected Result:** 1) Tất cả các máy tính đều trả về `200 OK` và metadata (ví dụ: `rate: 68/100`). 2) Không một máy tính nào trả về lỗi 429 Too Many Requests. 3) Tổng số request từ tất cả các máy tính phải `<threshold>`. 4) Đáp thời gian trung bình (average latency) của các request từ các máy tính khác nhau nên không được giới hạn."
    },
    {
      "question_id": "EQ2037-VN",
      "question": "Điều nào sau đây cải thiện khả năng tái tạo của các **API tests** trong nhiều môi trường?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sử dụng các **URL** môi trường được **hardcode**",
        "B": "Ngẫu nhiên hóa tất cả dữ liệu **test**",
        "C": "Thực hiện **test** trên dữ liệu **production**",
        "D": "Tham số hóa các **endpoint** và sử dụng cấu hình môi trường"
      },
      "gold_answer": "D",
      "model_raw_answer": "Sử dụng **URL** môi trường được **hardcode** (A) là sai vì nó không linh hoạt. Ngẫu nhiên hóa tất cả dữ liệu **test** (B) giúp tránh các sai sót. Thực hiện **test** trên dữ liệu **production** (C) nguy hiểm vì có thể ảnh hưởng đến hệ thống thực tế. Tham số hóa các **endpoint** và sử dụng cấu hình môi trường (D) linh hoạt và dễ kiểm tra.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**Parameterization** đảm bảo cùng một logic **test** hoạt động trên các môi trường."
    },
    {
      "question_id": "EQ2038-VN",
      "type": "Writing",
      "gold": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case tích cực (Positive):** Send a `POST` request với mã **SMS** hợp lệ đến `/send-sms` và verify **status** là `200 OK`. - **Test Case âm tính (Negative):** Send mã **SMS** đã được sử dụng hoặc không tồn tại."
    },
    {
      "question_id": "EQ2039-VN",
      "question": "Điều nào trong số này mô tả rõ nhất **performance baseline testing**?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đo thời gian phản hồi bình thường dưới **tải** dự kiến",
        "B": "Kiểm tra API với các đầu vào không hợp lệ",
        "C": "Xác thực API so với **OpenAPI spec**",
        "D": "Mô phỏng lưu lượng truy cập **peak** gấp 10 lần"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Đo thời gian phản hồi bình thường dưới **tải** dự kiến.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Baseline testing** nắm bắt hiệu suất bình thường dự kiến."
    },
    {
      "question_id": "EQ2040-VN",
      "type": "Writing",
      "gold": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Mocking API bên ngoài cho phép kiểm tra các kịch bản thất bại một cách an toàn và kiểm soát được, vì thực tế là hệ thống khác có thể không sẵn sàng hoặc không thể kiểm tra được."
    },
    {
      "question_id": "EQ2041-VN",
      "question": "Điều nào trong số này là một **test case** chính xác để xác thực hết hạn **session**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đăng nhập với thông tin đăng nhập hợp lệ, mong đợi **200 OK**",
        "B": "Gửi yêu cầu với **token** hợp lệ ngay sau khi đăng nhập",
        "C": "Gửi yêu cầu với **token** sau khi hết **timeout session**, mong đợi **401 Unauthorized**",
        "D": "Gửi yêu cầu không có **token**, mong đợi **200 OK**"
      },
      "gold_answer": "C",
      "model_raw_answer": "Chọn **C. Gửi yêu cầu với token sau khi hết timeout session, mong đợi 401 Unauthorized**. Đây là test case chính xác để kiểm tra tình trạng **session expired**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Session** đã hết hạn phải trả về **401 Unauthorized**."
    },
    {
      "question_id": "EQ2042-VN",
      "type": "Writing",
      "gold": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "Chỉ cần gửi request với body chứa các khóa hoặc giá trị không hợp lệ (ví dụ, `{ \"id\": \"string\" }`) và kiểm tra API trả `400 Bad Request` hoặc `500 Internal Server Error` với mãn hình lỗi phù hợp."
    },
    {
      "question_id": "EQ2043-VN",
      "question": "Chiến lược nào giúp xác thực **tương thích ngược** sau khi thêm các trường tùy chọn mới?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đảm bảo các máy khách cũ vẫn hoạt động mà không cần gửi các trường mới",
        "B": "Buộc các máy khách cập nhật ngay lập tức",
        "C": "Xóa các trường cũ khỏi phản hồi",
        "D": "Yêu cầu các thay đổi **schema** phải gây lỗi"
      },
      "gold_answer": "A",
      "model_raw_answer": "Đảm bảo các máy khách cũ vẫn hoạt động mà không cần gửi các trường mới.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Tương thích ngược** có nghĩa là các máy khách cũ vẫn phải hoạt động mà không cần các trường mới."
    },
    {
      "question_id": "EQ2044-VN",
      "type": "Writing",
      "gold": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "1. **Action:** Send request with all required rate limiting headers (e.g., `X-RateLimit-Remaining`, `X-RateLimit-Limit`, `X-RateLimit-Reset`).\n2. **Expected:** Headers phải được gửi lại với status `200 OK` (bằng vènhỏ). \n3. **Verify:** Kiểm tra response headers để đảm bảo tất cả các header rate limiting đều được gửi và có giá trị."
    },
    {
      "question_id": "EQ2045-VN",
      "question": "Cách hiệu quả nhất để kiểm tra khả năng phục hồi khi một dịch vụ **downstream** của API bị lỗi là gì?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "options": {
        "A": "Vô hiệu hóa **retry** ở máy khách",
        "B": "Ngừng **testing** cho đến khi dịch vụ phục hồi",
        "C": "Chỉ chạy **unit tests**",
        "D": "Chèn lỗi bằng cách sử dụng **chaos testing** hoặc **mock**"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời: B. Ngừng **testing** cho đến khi dịch vụ phục hồi. Cách này đảm bảo kiểm tra khả năng phục hồi tốt nhất. Các phương pháp khác chỉ kiểm tra khả năng phục hồi trong trường hợp cụ thể.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "**Chaos testing/mocks** cho phép mô phỏng có kiểm soát các lỗi phụ thuộc."
    },
    {
      "question_id": "EQ2046-VN",
      "type": "Writing",
      "gold": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Tách dữ liệu test ngăn tránh thay đổi cơ sở dữ liệu, giúp test cases độc lập và dễ dự đoán."
    },
    {
      "question_id": "EQ2047-VN",
      "question": "**Response status code** nào thích hợp cho một yêu cầu bị chặn do thiếu **authorization header**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct status code for a request being blocked because of a missing **authorization header** is **401 Unauthorized**. This is because the client failed to provide the required authentication information, which is a common requirement for accessing protected resources. \n\n- **200 OK** is used when the request is successful and a response is expected (e.g., a resource was found or created).\n- **403 Forbidden** indicates the client does not have access to the requested resource but was authenticated (which is not the case here).\n- **409 Conflict** is used for resource inconsistencies or invalid updates, which is not relevant to authentication failures.\n- **401 Unauthorized** is the exact status code for failing to provide an **authorization header**, indicating the client needs to authenticate itself.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Thiếu ủy quyền dẫn đến **401 Unauthorized**."
    },
    {
      "question_id": "EQ2048-VN",
      "type": "Writing",
      "gold": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "- **Test Case:** Tìm SDB không tồn tại. - **Action:** Gửi `GET /products` -> DB. - **Expected:** Không trả hồi vụn 404, DB được cập nhật. - **Post-condition:** Suy thoái, phản hồi DB chính xác."
    },
    {
      "question_id": "EQ2049-VN",
      "question": "Điều nào sau đây thể hiện một **boundary test** thích hợp cho trường độ dài mật khẩu (**min**=8, **max**=20)?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra với 7, 8, 20, và 21 ký tự",
        "B": "Chỉ kiểm tra với 10 ký tự",
        "C": "Chỉ kiểm tra với 15 ký tự",
        "D": "Chỉ kiểm tra với mật khẩu trống"
      },
      "gold_answer": "A",
      "model_raw_answer": "A test boundary checks limits of constraints. So, testing 7, 8, 20, and 21 ensures **min** and **max** limits are known.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Boundary testing** bao gồm các giá trị ở, dưới và trên giới hạn."
    },
    {
      "question_id": "EQ2050-VN",
      "type": "Writing",
      "gold": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Thay đổi mật khẩu -> thay đổi hash mật khẩu. Log hash -> an toàn, không tiết lộ mật khẩu."
    },
    {
      "question_id": "EQ2051-VN",
      "question": "Phương pháp giám sát nào giúp xác định sự gia tăng độ trễ dần dần qua các tuần?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đo thời gian bằng đồng hồ bấm giờ cho một yêu cầu duy nhất",
        "B": "Gỡ lỗi thủ công trong các sự cố",
        "C": "Phân tích xu hướng chuỗi thời gian bằng **dashboard**",
        "D": "Các chỉ số **code coverage**"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Phân tích xu hướng chuỗi thời gian bằng **dashboard**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Dashboard** và giám sát chuỗi thời gian làm nổi bật các xu hướng độ trễ."
    },
    {
      "question_id": "EQ2052-VN",
      "type": "Writing",
      "gold": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case Âm Tính (Negative):** \"Mua hàng với số tiền âm (e.g., -10 USD)\".\n- **Boundary Test Case (Boundary Condition):** \"Mua hàng với số tiền biên (e.g., 10.99 USD)\" vì sẽ kiểm tra xem hệ thống xử lý chính xác số tiền biên giới hay không."
    },
    {
      "question_id": "EQ2053-VN",
      "question": "Chiến lược nào đảm bảo các **contract test** vẫn hữu ích khi API phát triển?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Không bao giờ cập nhật **schema tests**",
        "B": "Xóa các trường tùy chọn khỏi **test**",
        "C": "Chỉ chạy các **regression test** thủ công",
        "D": "Phiên bản hóa các **schema contract** và duy trì **tương thích ngược**"
      },
      "gold_answer": "D",
      "model_raw_answer": "Phiên bản hóa **schema contract** và duy trì **tương thích ngược** đảm bảo rằng các **contract test** vẫn hữu ích khi API phát triển.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "**Versioning** và **tương thích ngược** giữ cho các **contract test** đáng tin cậy."
    },
    {
      "question_id": "EQ2054-VN",
      "type": "Writing",
      "gold": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "1) Triggers: Send request via API while network packet sniffing disabled. 2) Expected: API response `500 Internal Server Error` with error like 'Connection timed out' (if retry timeout occurs), else service unavailable (if disallow connection). 3) Logs confirm no unexpected database queries."
    },
    {
      "question_id": "EQ2055-VN",
      "question": "Kịch bản nào trong số này xác thực chính xác **observability** API bằng cách sử dụng **distributed tracing**?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chỉ kiểm tra các **HTTP status codes**",
        "B": "Theo dõi một **trace ID** trên nhiều **microservice**",
        "C": "Kiểm tra việc sử dụng bộ nhớ trong các **log** máy chủ",
        "D": "Sử dụng các ghi chú **test** thủ công"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Theo dõi một **trace ID** trên nhiều **microservice**.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Trace ID** theo dõi các yêu cầu trên các dịch vụ."
    },
    {
      "question_id": "EQ2056-VN",
      "type": "Writing",
      "gold": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Truy cập DB sau test **API** -> kiểm tra liệu Row/Record bị xóa."
    },
    {
      "question_id": "EQ2057-VN",
      "question": "Điều nào sau đây chỉ ra một lỗ hổng **denial-of-service**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "API chấp nhận yêu cầu không giới hạn mà không cần **throttling**",
        "B": "API trả về **404 Not Found**",
        "C": "**API schema** thiếu trường mô tả",
        "D": "**Unit test coverage** thấp"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct answer because it describes a **denial-of-service (DoS) vulnerability**. Accepting unlimited requests without throttling (limiting rate) is a well-known DoS weakness. The other options do not describe security vulnerabilities like DoS.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Các yêu cầu không bị hạn chế có thể làm cạn kiệt tài nguyên, gây ra **DoS**."
    },
    {
      "question_id": "EQ2058-VN",
      "type": "Writing",
      "gold": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "Test case: Đăng hàng với tình trạng 'Shipped'. Precondition: Transaction được khởi tạo. Action: Thử lỗi nhập hàng không tồn tại. Expected: Transaction phải tự độngrollback đến trạng thái 'Processing'."
    },
    {
      "question_id": "EQ2059-VN",
      "question": "**HTTP status code** nào nên được xác thực khi một yêu cầu API được định dạng tốt nhưng bị cấm do hạn chế vai trò?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả lời đúng là **403 Forbidden** vì nó xác định trạng thái 'bị cấm' mà người dùng có thể kiểm tra. 200 OK là chung, 401 Unauthorized là lỗi khách hàng, 500 Internal Server Error là lỗi server.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**403 Forbidden** chỉ ra máy khách đã được xác thực nhưng không được ủy quyền."
    },
    {
      "question_id": "EQ2060-VN",
      "type": "Writing",
      "gold": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "Tập trung vào việc validate JSON body với một schema validating specific error types. \nEnsure all API endpoints consume the same schema. \nExample: Endpoint A /create, Endpoint B /update both validate against ErrorSchema.json."
    },
    {
      "question_id": "EQ3001-VN",
      "question": "Kịch bản nào sau đây thể hiện rõ nhất một bài kiểm tra multi-hop (đa bước) liên quan đến các endpoint đăng nhập và làm mới token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Gửi yêu cầu tới GET /health",
        "B": "Nhận access token qua POST /login, sau đó sử dụng POST /refresh để gia hạn session",
        "C": "Gửi yêu cầu với token đã hết hạn tới một endpoint được bảo vệ",
        "D": "Kiểm tra trạng thái 200 trên GET /docs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Nhận access token qua POST /login, sau đó sử dụng POST /refresh để gia hạn session.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Kiểm tra multi-hop có nghĩa là nối chuỗi đăng nhập với việc sử dụng refresh token sau đó."
    },
    {
      "question_id": "EQ3002-VN",
      "type": "Writing",
      "gold": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "Test case: Đăng nhập và truy cập API bảo vệ.\n- **Preconditions:** Một người dùng có sẵn.\n- **Test Steps:**\n  1. Đăng nhập và nhận token.\n  2. Sử dụng token làm mới -> token mới được trả về.\n  3. Sử dụng token mới -> truy cập API được bảo vệ.\n- **Expected Result:** API được truy cập là 200 OK."
    },
    {
      "question_id": "EQ3003-VN",
      "question": "Một server nên trả về mã trạng thái HTTP nào khi một refresh token đã hết hạn?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "401 Unauthorized",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "Mã trạng thái 400 Bad Request hoặc 409 Conflict cũng phù hợp vì họ cho biết lỗi không rõ ràng. Nhưng 403 Forbidden là một lựa chọn hợp lý vì token bị khóa và người dùng không được phép sử dụng nó.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Refresh token đã hết hạn có nghĩa là client phải đăng nhập lại → 401 Unauthorized."
    },
    {
      "question_id": "EQ3004-VN",
      "type": "Writing",
      "gold": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "Tập trung vào các trường hợp login thất bại và hành động token. Đảm bảo test case có logic block ngăn cản refresh. Ví dụ, if wrong credentials -> no refresh token generated."
    },
    {
      "question_id": "EQ3005-VN",
      "question": "Cái nào sau đây ánh xạ một mã lỗi cụ thể của ứng dụng tới mã trạng thái HTTP chính xác?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "APP_1001 (User not found) → 404 Not Found",
        "B": "APP_2002 (Invalid password) → 201 Created",
        "C": "APP_3003 (Success) → 500 Internal Server Error",
        "D": "APP_9999 (Database error) → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. APP_1001 (User not found) → 404 Not Found.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Ánh xạ lỗi người dùng không tìm thấy tới 404 là một bản dịch HTTP chính xác."
    },
    {
      "question_id": "EQ3006-VN",
      "type": "Writing",
      "gold": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Xác thực: sử dụng các mã trường (201 Created, 204 No Content) và mã phản hồi (200 OK) trong API. Ánh xạ: chuyển dịch mã nghiệp vụ (ORDER_001) -> mã trạng thái HTTP (để tạo order) trong logic API."
    },
    {
      "question_id": "EQ3007-VN",
      "question": "Kịch bản nào thể hiện việc kiểm tra tiêu cực chuỗi (chained negative testing)?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Kiểm tra yêu cầu GET /status đơn lẻ",
        "B": "Đăng nhập hợp lệ sau đó truy cập /profile",
        "C": "Kiểm tra thời gian hoạt động của server với GET /health",
        "D": "Đăng nhập với mật khẩu hết hạn → 401, sau đó thử lại refresh token → 401"
      },
      "gold_answer": "D",
      "model_raw_answer": "Truy cập URL `/health` sẽ trả `200 OK`. Kiểm tra chuỗi với hành động không có lỗi.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Các bài kiểm tra tiêu cực chuỗi xác thực các thất bại trên nhiều endpoint."
    },
    {
      "question_id": "EQ3008-VN",
      "type": "Writing",
      "gold": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "**Test Case: Transaction Flow**\n- **Preconditions:** APIs available, DB seeded with valid user, product, and payment methods.\n- **Steps:**\n  1. **Create Order:** `POST /orders` với thông tin hợp lệ (e.g., ID user, ID sản phẩm).\n  2. **Process Payment:** `POST /payments` với ID đơn hàng và phương thức thanh toán.\n  3. **Refund Order:** `POST /refunds` với ID đơn hàng và lý do (e.g., trả hoàn tiền).\n- **Expected:** DB phản hồi đơn hàng có trạng thái `processed`, DB payment phản hồi `id` exist, DB refund phản hồi `amount` được tính chính xác."
    },
    {
      "question_id": "EQ3009-VN",
      "question": "Mã trạng thái HTTP nào là chính xác để ánh xạ một lỗi tùy chỉnh ORDER_DUPLICATE tới HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "404 Not Found",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trạng thái 409 Conflict là chính xác nhất vì nó mô tả tình trạng đặt hàng trùng lặp.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Đơn hàng trùng lặp là một xung đột → 409."
    },
    {
      "question_id": "EQ3010-VN",
      "type": "Writing",
      "gold": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case: 'Đăng nhập và sử dụng token'. Đăng nhập vào hệ thống, lấy token và nhắn nó vào header của các request. Kiểm tra xem các microservice được gọi và trả lời đúng (ví dụ, API User -> API Product)."
    },
    {
      "question_id": "EQ3011-VN",
      "question": "Kịch bản nào xác thực việc xử lý lỗi đa bước (multi-hop) chính xác trong một quy trình thương mại điện tử?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Tạo đơn hàng → chi tiết thanh toán không hợp lệ → 402 Payment Required",
        "B": "Kiểm tra kho hàng → sản phẩm tồn tại → 200 OK",
        "C": "Gọi endpoint healthcheck → 200 OK",
        "D": "Yêu cầu danh mục sản phẩm → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "Tính xác thực lỗi đa bước (multi-hop) là kiểm tra xem quy trình có xử lý hợp lý cho các tình huống lỗi ở nhiều bước (đơn hàng không hợp lệ, kho hàng không tồn tại sản phẩm, service healthcheck fail) hay không. \n- **A (Tạo đơn hàng → chi tiết thanh toán không hợp lệ → 402 Payment Required):** Đây là kịch bản chính xác để test xử lý lỗi đa bước. Khi tạo một đơn hàng nhưng liên kết chi tiết thanh toán với số tài khoản không tồn tại (ví dụ, 'payment_method_id' = 'invalid_account'), hệ thống sẽ trả lời `402 Payment Required` (Liên kết tài khoản bị hạn chế) và không tạo đơn hàng successfully. Kịch này kiểm tra xử lý chính xác khi một bước đầu tiên thất bại trong quá trình đặt hàng đa bước.\n- **B (Kiểm tra kho hàng → sản phẩm tồn tại → 200 OK):** Đây là kịch bản không xác thực lỗi đa bước. Khi kiểm tra trạng thái của sản phẩm (vì đã tồn tại) thì hệ thống trả về `200 OK` (Thành công) và không phản ánh rằng kiểm tra đã thành công vì không cần hành động.\n- **C (Gọi endpoint healthcheck → 200 OK):** Đây là kịch bản không xác thực lỗi đa bước. Giao dịch gọi một endpoint healthcheck và nhận `200 OK` là một phản hồi bình thường, không phản ánh lỗi. Trong thực tế, healthcheck thường được sử dụng để xác minh dịch vụ hoạt động, nhưng trả về `200 OK` cho mọi tình huống, bao gồm cả lỗi, và không phản ánh thất bại là một hành động không hợp lệ.\n- **D (Yêu cầu danh mục sản phẩm → 200 OK):** Đây là kịch bản không xác thực lỗi đa bước. Yêu cầu danh mục sản phẩm và nhận `200 OK` là một phản hồi bình thường, không phản ánh lỗi. Trong thực tế, nếu danh mục sản phẩm không tồn tại, API thường trả về một mã lỗi (ví dụ, `404 Not Found`) hoặc một thể loại phản hồi đặc biệt cho tình huống thất bại, nhưng `200 OK` chỉ cho thành công.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thanh toán thất bại sau khi tạo đơn hàng là một bài kiểm tra tiêu cực multi-hop."
    },
    {
      "question_id": "EQ3012-VN",
      "type": "Writing",
      "gold": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "Dòng lệnh `curl -XPOST http://localhost:8000/create-user` với mã lỗi xác thực (e.g., `1007`) → `400 Bad Request`. Dòng lệnh khác → `200 OK`. Test đảm bảo trả lời HTTP tương ứng với mã lỗi."
    },
    {
      "question_id": "EQ3013-VN",
      "question": "Cái nào trong số này thể hiện một bài kiểm tra đăng nhập chuỗi cấp độ khó?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Chỉ kiểm tra GET /login-docs",
        "B": "Chỉ đăng nhập một lần và dừng lại",
        "C": "Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại",
        "D": "Kiểm tra endpoint GET /health"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Kết hợp nhiều endpoint vào một quy trình xác thực."
    },
    {
      "question_id": "EQ3014-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Action:** Send request for refresh token.\n2. **Expected Result:** Instead of `200 OK` and new access token, trả `403 Forbidden` hoặc `400 Bad Request` vì refresh token đã hết hạn."
    },
    {
      "question_id": "EQ3015-VN",
      "question": "Ánh xạ nào là chính xác cho lỗi nghiệp vụ PAYMENT_DECLINED?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 402 Payment Required.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Thanh toán bị từ chối → 402 Payment Required."
    },
    {
      "question_id": "EQ3016-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra yêu cầu hành động đăng xuất, sau đó kiểm tra các lệnh liên quan: `logout`, `disconnect`, `abort session`. Nghiên cứu cần xác minh session được tự động reset hoặc phải được hủy thủ công."
    },
    {
      "question_id": "EQ3017-VN",
      "question": "Kịch bản nào ánh xạ tới mã HTTP chính xác cho một lỗi ứng dụng nội bộ?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "APP_TIMEOUT → 200 OK",
        "B": "APP_TIMEOUT → 504 Gateway Timeout",
        "C": "APP_TIMEOUT → 201 Created",
        "D": "APP_TIMEOUT → 400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "Only A matches the scenario.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Các lỗi timeout nên ánh xạ tới 504 Gateway Timeout."
    },
    {
      "question_id": "EQ3018-VN",
      "type": "Writing",
      "gold": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "- **Đăng ký:** Send `POST /register` with valid data.\n- **Xác minh email:** Send `POST /verify-email` với địa chỉ email đã đăng ký.\n- **Đăng nhập:** Send `POST /login` với password hoặc token JWT."
    },
    {
      "question_id": "EQ3019-VN",
      "question": "Bài kiểm tra nào xác thực quyền truy cập dựa trên vai trò chuỗi?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập với vai trò user → truy cập /admin → mong đợi 403 Forbidden",
        "B": "Đăng nhập với vai trò admin → truy cập /admin → mong đợi 200 OK",
        "C": "Đăng nhập với vai trò user → xem hồ sơ → 200 OK",
        "D": "GET /health → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Đăng nhập với vai trò user → truy cập /admin → mong đợi 403 Forbidden. B. Đăng nhập với vai trò admin → truy cập /admin → mong đợi 200 OK. C. Đăng nhập với vai trò user → xem hồ sơ → 200 OK. D. GET /health → 200 OK.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Vai trò không khớp dẫn đến 403 là một xác thực vai trò multi-hop."
    },
    {
      "question_id": "EQ3020-VN",
      "type": "Writing",
      "gold": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Đầu tiên, tạo bài kiểm tra cơ bản (Điểm 3) yêu cầu chỉ nhập mã xác minh và mật khẩu mới. Tiếp theo, tạo bài kiểm tra trung bình (Điểm 5) yêu cầu nhập thông tin người dùng. Cuối cùng, tạo bài kiểm tra khó nhất (Điểm 7) yêu cầu nhập thông tin người dùng và xác nhận."
    },
    {
      "question_id": "EQ3021-VN",
      "question": "Kịch bản nào xác thực một chuỗi đăng nhập, làm mới và đăng xuất?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập → sử dụng token một lần",
        "B": "Làm mới token ngay sau khi đăng nhập",
        "C": "Chỉ đăng xuất",
        "D": "Đăng nhập → làm mới token → đăng xuất → xác nhận làm mới thất bại"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. Đăng nhập → sử dụng token một lần.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Chuỗi đầy đủ này kiểm tra toàn bộ vòng đời xác thực."
    },
    {
      "question_id": "EQ3022-VN",
      "type": "Writing",
      "gold": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "**Test Case: Tạo Người Dùng**\n- **Preconditions:** API hoạt động.\n- **Steps:**\n  - Tạo người dùng mới (đây là hành động cơ bản).\n  - Cập nhật hồ sơ với thông tin cụ thể (ví dụ, địa chỉ, số điện thoại).\n  - Truy xuất hồ sơ bằng ID người dùng.\n- **Expected:** Các phản hồi phải là `200 OK` cho tạo mới, `200 OK` cho cập nhật, và dữ liệu phải được lưu trữ."
    },
    {
      "question_id": "EQ3023-VN",
      "question": "Ánh xạ nào dịch chính xác một lỗi nghiệp vụ STOCK_OUT sang HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "201 Created",
        "D": "403 Forbidden"
      },
      "gold_answer": "B",
      "model_raw_answer": "Dịch chính xác lỗi stock out sang HTTP là 403 Forbidden, vì nó chỉmời người dùng không được quyền truy cập vào hàng tồn tại.",
      "model_normalized_answer": "D",
      "correct": false,
      "explanation": "Hết hàng có nghĩa là một xung đột với việc thực hiện đơn hàng, ánh xạ tới 409."
    },
    {
      "question_id": "EQ3024-VN",
      "type": "Writing",
      "gold": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra là đăng nhập vào tài khoản với mã access. Tìm kiếm refresh token và dùng nó để lấy token mới. Thử đăng xuất và cố lấy tài khoản mới với token cũ. Nếu được chặn, token refresh bị block."
    },
    {
      "question_id": "EQ3025-VN",
      "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi cho một quy trình giỏ hàng?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Thêm mặt hàng hợp lệ vào giỏ hàng → 200 OK",
        "B": "Thanh toán với thanh toán hợp lệ → 200 OK",
        "C": "Thêm mặt hàng → xóa mặt hàng → thanh toán → mong đợi 400 Bad Request",
        "D": "Xem giỏ hàng sau khi đăng nhập → 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C because it ensures the wrong state (a cart without items) results in a bad request, not a successful status code like OK.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Thanh toán giỏ hàng trống là một kịch bản tiêu cực chuỗi."
    },
    {
      "question_id": "EQ3026-VN",
      "type": "Writing",
      "gold": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "- **Mô tả:** Triggers session expiration → expect `403 Exceeded Lifetime` rather than internal error. \n- **Điểm kiểm tra:** 1) Log in với thời gian hạn chế → 2) Xác minh phản hồi có status code 403. \n- **Hàm xác minh:** Assert response body chứa thông tin 'expires' hoặc 'lifetime'."
    },
    {
      "question_id": "EQ3027-VN",
      "question": "Kịch bản nào thể hiện rõ nhất việc xác thực việc hủy đơn hàng chuỗi?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Hard",
      "options": {
        "A": "Tạo đơn hàng → hủy đơn hàng → GET /orders/{id} hiển thị status=cancelled",
        "B": "Hủy đơn hàng không tồn tại → 404",
        "C": "Chỉ tạo đơn hàng",
        "D": "Kiểm tra endpoint /status"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Tạo đơn hàng → hủy đơn hàng → GET /orders/{id} hiển thị status=cancelled.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Bao gồm vòng đời của việc tạo đơn hàng → hủy bỏ → xác minh."
    },
    {
      "question_id": "EQ3028-VN",
      "type": "Writing",
      "gold": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Thật đơn giản. Nếu token không hợp lệ, thì kiểm tra xác minh sẽ thất bại vì nó chỉ chấp nhận token hợp lệ. Ví dụ, sử dụng token đã được sử dụng nhưng đã hết hạn."
    },
    {
      "question_id": "EQ3029-VN",
      "question": "Ánh xạ nào dịch chính xác FILE_TOO_LARGE sang HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "404 Not Found",
        "D": "413 Payload Too Large"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 413 Payload Too Large. This status code indicates that the server could not process the request because the payload (in this case, the file too large) exceeded the maximum allowed size.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "File quá lớn nên ánh xạ tới 413."
    },
    {
      "question_id": "EQ3030-VN",
      "type": "Writing",
      "gold": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "**Test Case: Sợm Mạo**\n- **Preconditions:** Tài khoản có tiền sử vay, tín dụng sẵn.\n- **Steps:** Đăng nhập -> Nộp đơn vay -> Tín dụng -> Phê duyệt -> All Combinations.\n- **Expected:** only valid -> response 400 invalid -> DB matches."
    },
    {
      "question_id": "EQ3031-VN",
      "question": "Chuỗi nào xác thực các refresh token trên nhiều session?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Chỉ đăng nhập → đăng xuất",
        "B": "Đăng nhập → làm mới token → đăng xuất → đăng nhập lại → xác nhận refresh token cũ không hợp lệ",
        "C": "Làm mới token mà không đăng nhập",
        "D": "Kiểm tra GET /status"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đăng nhập → làm mới token → đăng xuất → đăng nhập lại → xác nhận refresh token cũ không hợp lệ.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Đảm bảo xử lý session trên nhiều lần đăng nhập."
    },
    {
      "question_id": "EQ3032-VN",
      "type": "Writing",
      "gold": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Preconditions:** Tạo tài khoản exist, mật khẩu thay đổi.\n2. **Steps:**\n   - **Chuỗi đăng ký:** Đăng ký mới với email và password unique.\n   - **Đặt lại mật khẩu:** Gửi mã và nhập lại.\n   - **Đăng nhập:** Log in với email và password mới.\n3. **Expected Results:** Đăng nhập thành công only khi đúng password."
    },
    {
      "question_id": "EQ3033-VN",
      "question": "Ánh xạ nào là chính xác để ánh xạ lỗi nghiệp vụ INVALID_COUPON?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "Ánh xạ 403 Forbidden là chính xác nhất vì nó chỉnhanh thông báo lỗi khi yêu cầu không được thực hiện.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Coupon không hợp lệ nên ánh xạ tới 400 Bad Request."
    },
    {
      "question_id": "EQ3034-VN",
      "type": "Writing",
      "gold": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "- **Preconditions:** File exist, user token.\n- - **Endpoint 1 (POST /files):** Chức năng tải lên file → `{\"file_name\": \"test.txt\", \"file_type\": \"text/plain\", \"file_size\": 102}`.\n- - **Endpoint 2 (GET /files/:id) → Virus Scan:** Chức năng quét virus → trả `200 OK` với báo cáo virus.\n- - **Endpoint 3 (GET /files/:id) → Download:** Chức năng tải xuống → trả tệp `test.txt`."
    },
    {
      "question_id": "EQ3035-VN",
      "question": "Kịch bản nào xác thực ánh xạ lỗi đa bước (multi-hop) chính xác trong quy trình thanh toán?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 402",
        "B": "API thanh toán trả về APPROVED → được ánh xạ tới HTTP 404",
        "C": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 201",
        "D": "API thanh toán trả về ERROR → được ánh xạ tới HTTP 200"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. API thanh toán trả về DECLINED → được ánh xạ tới HTTP 402.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thanh toán bị từ chối ánh xạ chính xác tới 402 Payment Required."
    },
    {
      "question_id": "EQ3036-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Đo kiểm xem refresh token được sử dụng một cách hợp lệ và xem có token mới được tạo sau thời gian hạn đầu không."
    },
    {
      "question_id": "EQ3037-VN",
      "question": "Ánh xạ nào là chính xác để ánh xạ RATE_LIMIT_EXCEEDED sang HTTP?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "Correct answer is D. 429 Too Many Requests.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Vượt quá giới hạn tốc độ nên ánh xạ tới 429."
    },
    {
      "question_id": "EQ3038-VN",
      "type": "Writing",
      "gold": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Giỏ Hàng**\n- **Preconditions:** User exist, sản phẩm có giá.\n- **Steps:** 1) Tìm kiếm sản phẩm. 2) Thêm vào giỏ hàng. 3) Thanh toán (bán hàng). 4) Xác nhận giỏ hàng được cập nhật.\n- **Expected:** DB có order record, sản phẩm số lượng giảm 1."
    },
    {
      "question_id": "EQ3039-VN",
      "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi trong quy trình đặt vé?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Đặt vé hợp lệ → 200 OK",
        "B": "Đặt vé → hủy vé → thử hoàn tiền → mong đợi 400 Bad Request",
        "C": "Xem các ghế có sẵn → 200 OK",
        "D": "Kiểm tra GET /status → 200 OK"
      },
      "gold_answer": "B",
      "model_raw_answer": "B is the correct option as it tests for a negative response (400 Bad Request) which is expected when trying to complete an invalid action (attempting to complete a cancelled ticket).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tiêu cực chuỗi: hoàn tiền sau khi hủy là không hợp lệ."
    },
    {
      "question_id": "EQ3040-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Bài kiểm tra sẽ yêu cầu người dùng thực hiện các hành động như đăng nhập, mua hàng, và chuyển giao giao dịch. Sau đó, người dùng sẽ cố gắng truy cập tài khoản khác bằng session bị đánh cắp. **Điểm kiểm tra:** 1) Tốc độ phản hồi khi nhập session bất hợp pháp. 2) Kiểm tra xem session bị canjú (impersonate) được chấp nhận hay không. 3) Vérify xem DB được cập nhật khi session bị vô hiệu hóa."
    },
    {
      "question_id": "EQ3041-VN",
      "question": "Chuỗi nào xác thực chính xác việc xoay vòng token với phát hiện việc sử dụng lại refresh token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập → gọi API một lần → đăng xuất",
        "B": "Đăng nhập → làm mới token → thử sử dụng lại refresh token cũ → mong đợi 401 Unauthorized",
        "C": "Chỉ đăng nhập",
        "D": "Làm mới mà không đăng nhập"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đăng nhập → làm mới token → thử sử dụng lại refresh token cũ → mong đợi 401 Unauthorized.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Việc sử dụng lại token phải bị từ chối sau khi xoay vòng để ngăn chặn các cuộc tấn công replay."
    },
    {
      "question_id": "EQ3042-VN",
      "type": "Writing",
      "gold": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "Test: Đăng ký (POST) tạo một tài liệu với ETag `\"revision=123\"` và mã được tạo. Tiếp đó, cập nhật tài liệu thay đổi (PUT) và lưu lại ETag mới. Đọc lại (GET) và kiểm tra phản ứng là `200 OK`."
    },
    {
      "question_id": "EQ3043-VN",
      "question": "Mã trạng thái HTTP nào nên được trả về khi một điều kiện tiên quyết If-Match thất bại do ETag cũ trong quá trình PUT /resource/{id}?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "412 Precondition Failed",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả về 412 Precondition Failed vì điều kiện If-Match (ETag) là một điều kiện tiên quyết và thất bại khi không đúng.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "ETag cũ nên ánh xạ tới 412 Precondition Failed."
    },
    {
      "question_id": "EQ3044-VN",
      "type": "Writing",
      "gold": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Đầu tiên, gửi request POST /exports và lưu ID export. Tiếp theo, gửi request GET /jobs/{id} liên tục cho đến khi trả code 200 OK (hoàn thành) hoặc 503 Service Unavailable (đồng bộ). Cuối cùng, kiểm tra request GET /exports/{id} được thực hiện sau thời gian."
    },
    {
      "question_id": "EQ3045-VN",
      "question": "Ánh xạ nào từ mã nghiệp vụ tới HTTP là phù hợp nhất cho RESOURCE_VERSION_CONFLICT trong quá trình cập nhật?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 409 Conflict. This is because a 409 Conflict status code is specifically used to indicate that the request could not be completed due to a conflict, which in this case is a version conflict when trying to update a resource.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Xung đột phiên bản ánh xạ chính xác tới 409 Conflict."
    },
    {
      "question_id": "EQ3046-VN",
      "type": "Writing",
      "gold": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "Đáp án: Trả lời `/authorize` với scope không tồn tại, `/token` không được trả lại, gọi tài nguyên -> 403 Forbidden."
    },
    {
      "question_id": "EQ3047-VN",
      "question": "Mã trạng thái nào thể hiện rõ nhất một refresh token được trình bày cho một client_id sai trong một hệ thống đa người thuê (multi-tenant)?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B, as a bad request status code (400 Bad Request) is commonly used to indicate an invalid parameter, such as a client ID that does not exist in the system.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "OAuth2 chỉ định invalid_grant (400) cho việc sử dụng client/refresh sai."
    },
    {
      "question_id": "EQ3048-VN",
      "type": "Writing",
      "gold": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "Tập trung vào idempotency với các trường như `idempotency-key` trên headers. Các test yêu cầu tạo `charge` với key giống nhau (tương tự) và key khác nhau, sau đó thử lại với hành động tương tự. Hoàn tiền yêu cầu kích hoạt sau mỗi lần thử."
    },
    {
      "question_id": "EQ3049-VN",
      "question": "Ánh xạ trạng thái nào là chính xác cho mã nghiệp vụ INSUFFICIENT_FUNDS từ cổng thanh toán?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 402 Payment Required. This is because the INSUFFICIENT_FUNDS status code is used to indicate that the user's account has insufficient funds for a particular transaction. An 'Ánh xạ' (status code) of 402 Payment Required is the standard code for this condition.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Không đủ tiền → 402 Payment Required."
    },
    {
      "question_id": "EQ3050-VN",
      "type": "Writing",
      "gold": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Chuỗi kiểm tra: 1) Tải file lên server. 2) Gửi yêu cầu POST /process với mã bài kiểm tra. 3) Xác động trạng thái (đăng nhập, xử lý, cập nhật). 4) Xử lý 202 nếu file được xử lý thành công nhưng không cần phản hồi. 5) Tải file xuống (tùy chọn) hoặc trả tựa. 6) Vệ sinh state DB."
    },
    {
      "question_id": "EQ3051-VN",
      "question": "Kịch bản nào xác thực chính xác chính sách backoff + thử lại trên các chuyển đổi 429 -> 200 của gateway?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "options": {
        "A": "API trả về 429 Too Many Requests → client thử lại với backoff → 200 OK",
        "B": "API trả về 401 Unauthorized → thử lại thành công",
        "C": "API trả về 404 Not Found → thử lại thành công",
        "D": "API trả về 500 → thử lại mà không có backoff"
      },
      "gold_answer": "A",
      "model_raw_answer": "Kịch bản xác thực chính sách backoff + thử lại: 1) Triggers 429 Too Many Requests, 2) Client gửi request sau thời gian backoff → 200 OK, 3) Không thử lại với policy backoff.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Thử lại với backoff lũy thừa là cần thiết để xử lý 429."
    },
    {
      "question_id": "EQ3052-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "1. **API Gateway:** Send a logout request (e.g., `/logout`) to the session management endpoint. **Microservice:** Verify that a user's session data (e.g., user ID) is cleared from the database within a reasonable timeframe (e.g., 5-10 minutes). 2. **Database Verification:** Perform a SQL query on the microservice's database to confirm the user's session has been terminated (session ID removed, expired, or nullified)."
    },
    {
      "question_id": "EQ3053-VN",
      "question": "Mã HTTP nào nên ánh xạ tới BUSINESS_LIMIT_EXCEEDED khi hạn ngạch (quota) trên mỗi người dùng chặn một yêu cầu hợp lệ, đã xác thực?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời đúng là D. 429 Too Many Requests, vì mã này dùng để trả lời yêu cầu quá hạn. Các mã còn lại không phù hợp với tình huống này.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Hạn ngạch cạn kiệt ánh xạ tới 429 Too Many Requests."
    },
    {
      "question_id": "EQ3054-VN",
      "type": "Writing",
      "gold": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "- **Preconditions:** Đơn hàng (ID=xxx) và hàng tồn kho (tên sản phẩm exist).\n- **Steps:**\n  1. Tạo đơn hàng (`/orders`).\n  2. Dự trữ hàng cho đơn hàng.\n  3. Ship một phần đơn hàng.\n  4. Hủy phần còn lại và kiểm tra hoàn tiền chênh lệch.\n- **Expected:** DB phản ánh số lượng hàng còn lại."
    },
    {
      "question_id": "EQ3055-VN",
      "question": "Ánh xạ nào là chính xác nhất cho mã lỗi SIGNATURE_INVALID trên xác minh giao hàng webhook?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is B. 404 Not Found. This is because the error SIGNATURE_INVALID typically indicates that a valid signature was not provided, meaning the request was made without the necessary authentication. A 404 Not Found status code is appropriate because the client (likely a webhook listener) cannot find the order (or shipment) it was trying to verify.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Chữ ký webhook không hợp lệ nên trả về 401 Unauthorized."
    },
    {
      "question_id": "EQ3056-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập 2FA (POST /login)**: Send `POST /login` với mã OTP đúng và thông tin người dùng. 2. **Xác minh 2FA (POST /2fa/verify)**: Send mã OTP sai (ví dụ: `{\"otp\": \"123456\"}`) và mã OTP đúng. 3. **Tiền Refresh (POST /refresh)**: Send yêu cầu refresh token."
    },
    {
      "question_id": "EQ3057-VN",
      "question": "Mã HTTP nào thể hiện rõ nhất một tài nguyên đã bị xóa mềm (soft-deleted) được yêu cầu bởi GET /resource/{id} sau DELETE (với trạng thái có thể khôi phục)?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "204 No Content"
      },
      "gold_answer": "B",
      "model_raw_answer": "In thực tế, mã 200 OK sẽ gửi dữ liệu có thể khôi phục được. Tác vụ soft-deleted là thay đổi trạng thái, nhưng mã 200 OK sẽ gửi data như bình thường. Nếu người dùng xóa nó nhưng vẫn còn tồn tại thì sẽ trả 200 OK. Vai trò là để khách hàng không biết.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Tài nguyên đã bị xóa mềm nên được coi là không tìm thấy."
    },
    {
      "question_id": "EQ3058-VN",
      "type": "Writing",
      "gold": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Đầu tiên, tạo các trường mẫu (e.g., ID=999, tên='Test Item'). Tiếp theo, chạy các thao tác theo quy tắc (tạo 10, xóa 5, liệt kê sau tạo và xóa). Cuối cùng, so sánh số liệu cơ bản (tổng số, ID) giữa các bước và kết luận phân trang là thành công."
    },
    {
      "question_id": "EQ3059-VN",
      "question": "Ánh xạ nào là chính xác khi sự cố phụ thuộc kích hoạt mạch ngắt (circuit breaker) MỞ, khiến gateway từ chối yêu cầu ngay lập tức?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "400 Bad Request"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable – vì gateway từ chối vì nó không sẵn sàng. 200 OK và 201 Created là tạo thành công, 400 Bad Request là format không đúng. 503 Service Unavailable cũng là lỗi cơ bản nhưng cụ thể hơn.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Mạch ngắt MỞ ánh xạ tới 503 Service Unavailable."
    },
    {
      "question_id": "EQ3060-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "Đăng nhập -> truy cập API -> đăng xuất -> kiểm tra session bị hủy -> kết quả là `403 Forbidden` hoặc token expired."
    },
    {
      "question_id": "EQ4001-VN",
      "question": "Luồng **chained** nào xác thực chính xác vòng đời đơn hàng với tạo → ghi nhận → hoàn tiền, đảm bảo **idempotency** trên các lần **retry**?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Tạo đơn hàng → **retry** hoàn tiền hai lần → hoàn tiền thất bại",
        "B": "Ghi nhận thanh toán mà không tạo đơn hàng",
        "C": "Tạo đơn hàng → ghi nhận thanh toán → **retry** ghi nhận với cùng **idempotency key** → một lần ghi nhận duy nhất → hoàn tiền thành công",
        "D": "Hoàn tiền trước khi tạo đơn hàng"
      },
      "gold_answer": "C",
      "model_raw_answer": "Chọn đáp án C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Idempotency** phải đảm bảo các lần ghi nhận trùng lặp không tạo ra nhiều lần ghi nhận."
    },
    {
      "question_id": "EQ4002-VN",
      "type": "Writing",
      "gold": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "1. **Đầu vào:** Tạo tài khoản mới (mã user exist).\n2. **Trạng thái:** Aktivated → kích hoạt.\n3. **Hành động:** Tạm ngừng tài khoản (status → inactive).\n4. **Trả lời:** Xóa tài khoản → không tồn tại.\n5. **Xử lý lỗi:** Tạo tài khoản đã tồn tại → 409 Conflict.\n6. **Tập hợp:** Tăng quyền (admin) → cập nhật quyền.\n7. **Đặt điều kiện:** Xóa tài khoản không tồn tại → 404 Not Found."
    },
    {
      "question_id": "EQ4003-VN",
      "question": "Ánh xạ nào là đúng để xử lý một giao dịch trùng lặp được phát hiện trong quá trình yêu cầu hoàn tiền?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "Answer: B. 409 Conflict là mã trạng thái được dùng cho tình huống này vì nó cho biết yêu cầu đã bị reject do một điều kiện vĩ mô (chẳng hạn, tiền mặt chưa được xử lý).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Giao dịch trùng lặp phải ánh xạ tới **409 Conflict**."
    },
    {
      "question_id": "EQ4004-VN",
      "type": "Writing",
      "gold": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Action 1 (Create Transaction):** Khởi động giao dịch chuyển tiền từ tài khoản A -> Tai Khoan B với số tiền 10. 2. **Action 2 (Perform Transfer):** Send amount 3 from Tai Khoan A -> Tai Khoang B. 3. **Action 3 (Fail Transfer):** Send amount -3 từ Tai Khoang A -> Tai Khoang B. 4. **Expected Result:** Giao dịch rollback tự động."
    },
    {
      "question_id": "EQ4005-VN",
      "question": "Kịch bản **chained** nào xác thực đúng việc truyền lỗi trong một giao dịch **distributed saga**?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Bắt đầu saga → tất cả các bước thành công",
        "B": "Bắt đầu saga → bỏ qua lỗi ở bước 2",
        "C": "Bắt đầu saga → **rollback** bị bỏ qua",
        "D": "Bắt đầu saga → bước 3 thất bại → **rollback** bù trừ của các bước 1 & 2 được thực thi"
      },
      "gold_answer": "D",
      "model_raw_answer": "Chọn **D. Bắt đầu saga → bước 3 thất bại → **rollback** bù trừ của các bước 1 & 2 được thực thi.**\nThis is the correct chained scenario because it accurately represents how to simulate a distributed saga with error propagation: starting the saga, where the third step (e.g., a database write) fails, but instead of ignoring the error, the system rolls back all previous successful steps, maintaining consistency across distributed systems.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Mô hình **saga** đảm bảo các hành động bù trừ khi thất bại."
    },
    {
      "question_id": "EQ4006-VN",
      "type": "Writing",
      "gold": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Test: 1) Đăng nhập vào tài khoản. 2) Tạo đơn hàng. 3) Chọn phương thức thanh toán. 4) Xác nhận đơn hàng được tạo thành công. 5) Hủy đơn hàng. 6) Kiểm tra DB, record bị xóa."
    },
    {
      "question_id": "EQ4007-VN",
      "question": "Kịch bản xử lý lỗi nào tốt nhất để xác thực các kiểm tra hợp lý trong **payment APIs**?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Gửi hoàn tiền > số tiền đã ghi nhận → **400 Bad Request**",
        "B": "Gửi hoàn tiền = số tiền đã ghi nhận → **200 OK**",
        "C": "Gửi hoàn tiền < số tiền đã ghi nhận → **200 OK**",
        "D": "Hoàn tiền mà không ghi nhận → **200 OK**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Tốt nhất là gửi hoàn tiền > số tiền đã ghi nhận → **400 Bad Request**. Hơn nữa, kiểm tra hợp lý sẽ xác minh số lượng và tính xác thực của khoản thanh toán. Các lựa chọn còn lại sẽ không xác minh chính xác lỗi xử lý và sẽ không đảm bảo tính nhất quán của kiểm tra.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Số tiền hoàn tiền lớn hơn số tiền đã ghi nhận phải thất bại với **400**."
    },
    {
      "question_id": "EQ4008-VN",
      "type": "Writing",
      "gold": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "Mô tả: Đăng nhập → mãng mật khẩu → nhập mới → không tái sử dụng."
    },
    {
      "question_id": "EQ4009-VN",
      "question": "Ánh xạ nào tốt nhất để xác thực xử lý lỗi định dạng cho các tải trọng **JSON** bị định dạng sai?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request. Lỗi này được gửi khi dữ liệu không hợp lệ, phù hợp với trường hợp lỗi định dạng.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**JSON** bị định dạng sai phải dẫn đến **400 Bad Request**."
    },
    {
      "question_id": "EQ4010-VN",
      "type": "Writing",
      "gold": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "1. Đăng nhập vào hệ thống với tài khoản hợp lệ.\n2. Chọn `LoanApplication` và chọn branch `Default`.\n3. Triggers API đăng ký khoản vay. Verifies `201 Created` for success. \n4. Simulates lỗi khi đăng nhập với tài khoản có tín dụng kém (kẻ xấu).\n5. Verifies `409 Conflict` hoặc `500 Internal Server Error` là expected."
    },
    {
      "question_id": "EQ4011-VN",
      "question": "Luồng **chained** nào xác thực trạng thái nhất quán trong quy trình đặt phòng phân tán?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Chỉ đặt khách sạn",
        "B": "Đặt khách sạn → đặt chuyến bay → chuyến bay thất bại → đặt phòng khách sạn tự động bị hủy",
        "C": "Chỉ đặt chuyến bay",
        "D": "Đặt khách sạn và giữ đặt phòng ngay cả khi thanh toán thất bại"
      },
      "gold_answer": "B",
      "model_raw_answer": "Chained means linked together. So, the correct answer is B because it describes a chain of actions (book hotel -> book flight -> flight fails -> auto-cancel hotel booking).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Việc tự động hủy khách sạn đảm bảo trạng thái nhất quán trên các hệ thống."
    },
    {
      "question_id": "EQ4012-VN",
      "type": "Writing",
      "gold": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "**Test:** 1) Tiến hành cập nhật hồ sơ người dùng với giá trị 'tên' = 'John Doe'. 2) Simulate các yêu cầu ghi đồng thời. 3) Verificaton: sau giao dịch, đọc hồ sơ người dùng. **Expected:** Tính toàn vẹn dữ liệu (mã người dùng không thay đổi, trường 'tên' không bị thay đổi bất hợp pháp)."
    },
    {
      "question_id": "EQ4013-VN",
      "question": "**HTTP code** nào là đúng để xác thực kiểm tra hợp lý khi rút tiền > số dư tài khoản?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "400 Bad Request"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời hợp lý là 201 Created, vì đồng nghĩa giao dịch thành công.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Rút tiền quá số dư phải bị từ chối với **400 Bad Request**."
    },
    {
      "question_id": "EQ4014-VN",
      "type": "Writing",
      "gold": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Test chained yêu cầu kiểm tra quy trình ký tài liệu chuỗi. Ví dụ, tải file có chữ ký → thực hiện ký → kiểm tra chữ ký → tìm chứng thực. Có thể giả mạo chữ ký, test chỉ xác định thực thể có quyền."
    },
    {
      "question_id": "EQ4015-VN",
      "question": "Kịch bản nào xác thực **rollback** trạng thái khi một API cập nhật thông tin người dùng một phần và giao dịch **DB** thất bại?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Cập nhật thất bại giữa chừng → không có thay đổi một phần nào tồn tại",
        "B": "Cập nhật thất bại giữa chừng → thay đổi một phần vẫn còn",
        "C": "Cập nhật thất bại giữa chừng → hệ thống bị lỗi",
        "D": "Cập nhật thành công mặc dù **DB rollback**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Only A describes a valid rollback scenario.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Rollback** thích hợp ngăn ngừa dữ liệu một phần/không nhất quán."
    },
    {
      "question_id": "EQ4016-VN",
      "question": "Kịch bản **chained** nào tốt nhất để xác thực **idempotency** của một **endpoint** ghi nhận thanh toán?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "POST /capture hai lần với các giá trị **Idempotency-Key** khác nhau → hai lần ghi nhận",
        "B": "POST /capture hai lần với cùng một **Idempotency-Key** → một lần ghi nhận duy nhất được ghi lại",
        "C": "POST /refund mà không ghi nhận → thành công",
        "D": "GET /capture-status một lần"
      },
      "gold_answer": "B",
      "model_raw_answer": "Tốt nhất là **POST /capture** với cùng **Idempotency-Key** → một lần ghi nhận duy nhất được ghi lại.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "**Idempotency** đảm bảo các yêu cầu trùng lặp với cùng một khóa không tạo ra nhiều lần ghi nhận."
    },
    {
      "question_id": "EQ4017-VN",
      "type": "Writing",
      "gold": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Initial State:** Register → `state = 'pending'`.\n2. **Actions & Expected Results:**\n   - **Create:** `state = 'created' → expect DB record created`.\n   - **Upgrade:** `state = 'upgraded' → expect DB field 'level' updated to 'premium' → expect features enabled`.\n   - **Downgrade:** `state = 'downgraded' → expect DB field 'level' set to 'basic' → expect features disabled`.\n   - **Delete:** `state = 'deleted' → expect record removed from DB`."
    },
    {
      "question_id": "EQ4018-VN",
      "question": "Ánh xạ nào là đúng để xử lý mã lỗi ứng dụng **LIMIT_EXCEEDED** cho hạn ngạch API mỗi tài khoản?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "Đáp án D là đúng vì **LIMIT_EXCEEDED** là lỗi 429 Too Many Requests, được sử dụng khi một khách hàng vượt quá số yêu cầu hạn ngạch API trong một khoảng thời gian nhất định.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Vượt quá giới hạn/hạn ngạch ánh xạ tới **429 Too Many Requests**."
    },
    {
      "question_id": "EQ4019-VN",
      "type": "Writing",
      "gold": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "A test chained with a partial failure in a distributed order saga is difficult to design and execute because it requires a complex, automated setup that simulates a specific failure point. This is hard to control and reproduce, as it depends on multiple distributed services failing or recovering in specific ways."
    },
    {
      "question_id": "EQ4020-VN",
      "question": "Luồng **chained** nào xác thực việc phát hiện lạm dụng **OAuth2 token** trên các dịch vụ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "options": {
        "A": "Đăng nhập một lần",
        "B": "Làm mới **token** ngay lập tức",
        "C": "Đăng nhập → lấy **token** → cố gắng sử dụng **token** trong một máy khách khác → **403 Forbidden**",
        "D": "Chỉ đăng xuất"
      },
      "gold_answer": "C",
      "model_raw_answer": "Chained refresh requires a multi-step validation flow to ensure token misuse protection. It involves a sequence of client credentials, refresh tokens, and access tokens that are validated on each subsequent request. The correct response is that only one step in this process (C) will correctly return a **403 Forbidden** error if misuse is detected, because subsequent requests use refresh tokens and chained tokens that have been previously issued.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Việc lạm dụng **token** chéo máy khách phải bị cấm."
    },
    {
      "question_id": "EQ4021-VN",
      "type": "Writing",
      "gold": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "Test tự động simulates giao dịch. Nếu thất bại, DB must có record của giao dịch bị lỗi. Rollback test khó vì cần giả data, simulate lỗi giao dịch, và đảm bảo DB reverted back."
    },
    {
      "question_id": "EQ4022-VN",
      "question": "Kịch bản nào tốt nhất để xác thực xử lý lỗi định dạng cho sự không khớp đầu vào **XML vs JSON**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "Gửi thân **XML** với **Content-Type: application/json** → **415 Unsupported Media Type**",
        "B": "Gửi thân **JSON** với **application/json** → **200 OK**",
        "C": "Gửi thân **XML** với **application/xml** → **200 OK**",
        "D": "Gửi **YAML** → **200 OK**"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Gửi thân **XML** với **Content-Type: application/json** → **415 Unsupported Media Type**.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Sự không khớp trong thân so với **header** phải dẫn đến **415**."
    },
    {
      "question_id": "EQ4023-VN",
      "type": "Writing",
      "gold": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Add item → 2) Verify distribution → 3) Simulate shipment → 4) Confirm delivery. All steps must follow state machine logic."
    },
    {
      "question_id": "EQ4024-VN",
      "question": "**HTTP status** nào là đúng khi xảy ra lỗi xác thực **schema** cho một trường lồng nhau?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "A. 201 Created -> Triggers khi tài liệu được tạo nhưng không đúng schema. B. 500 Internal Server Error -> Triggers khi một tình huống bất ngờ xảy ra. C. 400 Bad Request -> Triggers khi request không đúng format. D. 404 Not Found -> Triggers khi tài nguyên không tìm thấy.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Lỗi xác thực **schema** phải trả về **400**."
    },
    {
      "question_id": "EQ4025-VN",
      "type": "Writing",
      "gold": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "1. **Đăng nhập**: Viết command `login` với người dùng có quyền.\n2. **Làm mới token**: Viết command `refresh_token` sử dụng token mới nhất.\n3. **Đăng xuất**: Viết command `logout`.\n4. **Làm mới token cũ**: Chained command với token cũ → thất bại (đáp ứng không được hỗ trợ).\n5. **Xác minh kết quả**: Kiểm tra trạng thái cơ sở lưu trữ."
    },
    {
      "question_id": "EQ4026-VN",
      "question": "Kịch bản **chained** nào xác thực **rollback** thích hợp sau khi đặt phòng nhiều bước (chuyến bay + khách sạn) khi thanh toán thất bại?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Đặt chuyến bay → **200 OK**",
        "B": "Đặt khách sạn → **200 OK**",
        "C": "Đặt chuyến bay + khách sạn → thanh toán thành công",
        "D": "Đặt chuyến bay + khách sạn → thanh toán thất bại → **rollback** cả hai đặt phòng"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Đặt chuyến bay + khách sạn → thanh toán thất bại → **rollback** cả hai đặt phòng.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Rollback** đảm bảo không còn đặt phòng không nhất quán."
    },
    {
      "question_id": "EQ4027-VN",
      "type": "Writing",
      "gold": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "1. **Action 1:** Triggers email sending via `send_email` endpoint with valid email = `{\"to\": \"user@example.com\", \"subject\": \"Test\"}`.\n2. **Action 2:** Verifies API returns `200 OK` and DB confirms email sent only once per user.\n3. **Action 3:** Simulates user action → API response: if email sent → `200`, hủy đăng ký → API response → `204 No Content` (no response for successful deletion)."
    },
    {
      "question_id": "EQ4028-VN",
      "question": "Ánh xạ nào là đúng cho mã ứng dụng **TOKEN_REPLAY_DETECTED**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "Hàm **TOKEN_REPLAY_DETECTED** trả **401 Unauthorized** nếu mã ứng dụng bị tấn công replay.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Tái sử dụng **token** phải được xử lý như **401 Unauthorized**."
    },
    {
      "question_id": "EQ4029-VN",
      "type": "Writing",
      "gold": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chained must ensure all states (valid, invalid) are covered with rollback for invalid. Example: 1) Đặt hàng → 2) Áp dụng giảm giá → 3) Giảm giá bị block → 4) Rollback → DB đảm bảo giao dịch reverted."
    },
    {
      "question_id": "EQ4030-VN",
      "question": "Luồng **chained** nào xác thực việc thanh toán không đồng bộ với đối chiếu?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Chỉ tạo đơn hàng",
        "B": "Tạo đơn hàng → ghi nhận thanh toán → đối chiếu không đồng bộ → trạng thái cuối cùng=đã đối chiếu",
        "C": "Hoàn tiền mà không đối chiếu",
        "D": "Kiểm tra tình trạng API"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Tạo đơn hàng → ghi nhận thanh toán → đối chiếu không đồng bộ → trạng thái cuối cùng=đã đối chiếu.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Thanh toán không đồng bộ phải đối chiếu chính xác."
    }
  ],
  "writing_for_review": [
    {
      "question_id": "EQ5004",
      "question": "Write one simple positive test case for a login API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user exists with a valid password.\n- **Test Steps:** Send a `POST` request to the login endpoint with a valid username and password (e.g., `{\"username\": \"john\", \"password\": \"Pass123\"}`).\n- **Expected Result:** The API returns a `200 OK` status code with a login token in the response."
    },
    {
      "question_id": "EQ5006",
      "question": "What is a common precondition for testing a user profile endpoint?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "User must be logged in and have a valid token.",
      "model_answer": "A valid user account with existing profile data is required. This ensures tests can operate on a known state and verify correct profile updates or reads."
    },
    {
      "question_id": "EQ5008",
      "question": "Write a simple negative test for a register API.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Send a `POST` request with an invalid transaction ID. The expected response is a `400 Bad Request` with a clear error message."
    },
    {
      "question_id": "EQ5010",
      "question": "What is the role of a schema in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure and expected data for an API endpoint. It helps testers create valid request bodies, validate responses against a known format, and identify integration issues."
    },
    {
      "question_id": "EQ5012",
      "question": "Write a simple test step for validating a 201 Created response.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "Send a `POST` request with all required parameters. Expected: The response status code should be `201 Created`."
    },
    {
      "question_id": "EQ5014",
      "question": "What is the purpose of mocking in API testing?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependencies with simulated ones. This isolates the API under test and allows faster, more reliable, and more reproducible tests to be run. It prevents tests from failing due to external systems being unavailable."
    },
    {
      "question_id": "EQ5016",
      "question": "Write one easy test case for an API that fetches product list.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "**Test Case: Fetch Product List**\n- **Preconditions:** API is running, and a sample product (e.g., 'product_1') exists in the database.\n- **Test Steps:** Send a `GET` request to `/products`.\n- **Expected Result:** The API returns a successful `200 OK` status code with a valid JSON array of products."
    },
    {
      "question_id": "EQ5018",
      "question": "What is the purpose of a precondition in a test case?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "A precondition is a state that must be true before a test case is executed. It ensures the test environment is stable and consistent."
    },
    {
      "question_id": "EQ5020",
      "question": "Write one negative test for file upload with an unsupported format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Negative Test: Upload a.docx file. Expected: The file should not be processed, and no successful upload response is given."
    },
    {
      "question_id": "EQ5022",
      "question": "What is the purpose of a test case description?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "To explain the objective and scope of a test scenario.",
      "model_answer": "A test case description explains what the test case is testing, its preconditions, and its expected results. It serves as a clear and concise summary of the test's objective."
    },
    {
      "question_id": "EQ5024",
      "question": "Write a test step to validate response time under 1 second.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "1. Send request with timer configured.\n2. Assert response time < 1 second."
    },
    {
      "question_id": "EQ5027",
      "question": "Write one simple positive test for GET /health endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "Request the `/health` endpoint and verify that the response body contains a simple 'healthy' message like '{\"status\":\"healthy\"}'."
    },
    {
      "question_id": "EQ5029",
      "question": "What is the purpose of using test data management in API testing?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management provides secure, repeatable, and relevant data for API testing. This is crucial for avoiding data leaks, reducing setup time, and improving test reliability. It ensures that tests can be run multiple times without affecting real data."
    },
    {
      "question_id": "EQ5031",
      "question": "Write one easy negative test case for an API expecting JSON format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "Send a `GET` request with a raw text response body (e.g., 'User found'). The API should fail if it doesn't expect this format. Example: `expect_json = False => 400 Bad Request for malformed response`."
    },
    {
      "question_id": "EQ5033",
      "question": "What is the role of assertions in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions are used to verify that the API behaves exactly as expected. They are included in the `assert` statement in the test script, e.g., `assert.json.equal(response.json(), expected_json)`. This ensures the API returns the correct status code, headers, and data format."
    },
    {
      "question_id": "EQ5035",
      "question": "Write a test case to check DELETE /users/{id} works correctly.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "Create a user, send a DELETE request, and verify the user is now gone from the database."
    },
    {
      "question_id": "EQ5037",
      "question": "What does HTTP status 201 Created indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "A new resource has been successfully created.",
      "model_answer": "That the request was successful and a new resource was created."
    },
    {
      "question_id": "EQ5039",
      "question": "Write one simple test for GET /users/{id} returning correct response.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test: Request /users/123 and verify the response body contains only valid data (e.g., user name, email)."
    },
    {
      "question_id": "EQ5041",
      "question": "What is the purpose of a 200 OK response?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It confirms that the request has succeeded.",
      "model_answer": "The purpose of a 200 OK response is to indicate that the request was successful and the resource was updated, but the full response is not needed. It's a common practice to only return the created resource in a `201 Created` response, while `200 OK` is used for `PUT` or `PATCH` operations that don't need to return the full state of the resource."
    },
    {
      "question_id": "EQ5043",
      "question": "Write one negative test to validate response for an invalid endpoint.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "Send a request to a non-existent endpoint like `/v1/users` and assert that the server responds with a `405 Method Not Allowed` or `404 Not Found` status."
    },
    {
      "question_id": "EQ5045",
      "question": "What does a test case assertion do?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion is a statement that checks if a certain condition is true. It is the 'asserts' part of 'assertion' in testing."
    },
    {
      "question_id": "EQ5047",
      "question": "Write one positive test for file upload endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "Test uploads a valid 5MB text file (`upload.txt`) with content 'Hello World!'. Expected: `201 Created` with file present in storage."
    },
    {
      "question_id": "EQ5049",
      "question": "What is the role of 415 Unsupported Media Type?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "It indicates the server cannot process the request format."
    },
    {
      "question_id": "EQ5052",
      "question": "Write a simple positive test for checking product details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "Send a `GET` request for a specific product ID, such as `product_id=123`, and assert that the response status code is `200 OK` and that the retrieved product data includes a valid `id`, `price`, and `description`."
    },
    {
      "question_id": "EQ5054",
      "question": "What is the purpose of using Authorization headers in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The Authorization header is used to include a valid token or credential in API requests. This token is typically issued by a authentication server (like OAuth or JWT) and grants the client access to specific resources. In testing, you would replace a real token with a dummy or placeholder to simulate a user's access."
    },
    {
      "question_id": "EQ5056",
      "question": "Write a negative test case for an API requiring authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Unauthorized Login**\n- **Preconditions:** No valid user token exists.\n- **Test Steps:** Send a regular login request (e.g., `POST /login`) without a username or password.\n- **Expected Result:** `401 Unauthorized` status code is returned with a corresponding error message."
    },
    {
      "question_id": "EQ5058",
      "question": "What is the role of 500 Internal Server Error in API testing?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "A 500 Internal Server Error is a generic status code that indicates an unexpected condition was encountered. In API testing, it usually means there is a bug in the server code that cannot be resolved by a valid request. It's not a client error but a server error."
    },
    {
      "question_id": "EQ5060",
      "question": "Write one positive test case for an API returning list of orders.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "**Test Case: Retrieve Orders**\n- **Preconditions:** User authenticated, 5 orders exist (e.g., order_id=1→customer→order_id=2→...).\n- **Test Steps:** Send `GET /orders` to API.\n- **Expected Result:** `200 OK` with JSON array of 5 orders (e.g., `{...}, {...},...}`)."
    },
    {
      "question_id": "EQ5062",
      "question": "What is the function of response headers in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "Response headers provide metadata about the response, such as the `Content-Type` or `Cache-Control`. They are crucial for API testing as they help verify the format of the data and configure caching behavior in the client."
    },
    {
      "question_id": "EQ5064",
      "question": "Write one negative test for creating a duplicate resource.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Create Resource A → 200 OK. Attempt to create identical Resource A → 409 Conflict (Duplicate Resource)."
    },
    {
      "question_id": "EQ5066",
      "question": "What is the role of 202 Accepted in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "202 Accepted is a status code that indicates an request was successful but the API doesn't need to create a resource. It's commonly used for `PUT` or `PATCH` requests that update existing data, or for `POST` requests that create a resource but the client already knows about it."
    },
    {
      "question_id": "EQ5068",
      "question": "Write one easy positive test for checking API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "Test by calling an endpoint like `/products` and verifying that the response contains the expected `id` field."
    },
    {
      "question_id": "EQ5070",
      "question": "What is the purpose of response body in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body contains the data returned to the client after an API request is executed. It's a crucial part of API testing to ensure the correct data format and content is being returned."
    },
    {
      "question_id": "EQ5072",
      "question": "Write one test case for verifying logout functionality.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "Test Case: Logout\n- Log in successfully.\n- Click logout → expect `href` to redirect to login page.\n- Verify session cleared (e.g., no admin token)."
    },
    {
      "question_id": "EQ5074",
      "question": "What does a 415 Unsupported Media Type error validate?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "That the server rejects unsupported request body formats.",
      "model_answer": "A 415 Unsupported Media Type error validates that the client can understand unsupported media types. It ensures the client knows how to handle different types of data formats."
    },
    {
      "question_id": "EQ5077",
      "question": "Write one simple positive test for GET /status endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "Send a valid GET request to `/status` and assert the response status code is `200 OK`."
    },
    {
      "question_id": "EQ5079",
      "question": "What does a 204 No Content response mean?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content is a successful request response that indicates the server understood the client's request but does not need to return all the data. It is often used for `PUT` or `PATCH` requests where only part of the resource needs to be updated."
    },
    {
      "question_id": "EQ5081",
      "question": "Write a negative test case for sending an invalid Content-Type header.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "Send a request with a `Content-Type` header like `application=csv`. The server should reject the request with a `400 Bad Request` or `415 Unsupported Media Type` error."
    },
    {
      "question_id": "EQ5083",
      "question": "What is the purpose of the Accept header in API requests?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header tells the server which data formats it supports and asks the server to return a response body in that format. It is commonly used to request JSON or XML data."
    },
    {
      "question_id": "EQ5085",
      "question": "Write a simple test case for a successful logout API call.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Successful Logout**\n- **Preconditions:** User logged in with valid session.\n- **Test Step:** Send `POST` request to `/logout` and verify no-redirection response.\n- **Expected Result:** API returns `204 No Content` with no session data cleared."
    },
    {
      "question_id": "EQ5087",
      "question": "What is the meaning of 401 Unauthorized in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "It means the client must provide valid authentication credentials.",
      "model_answer": "The 401 Unauthorized status code indicates that the API request must be authenticated. A typical cause is providing a valid API key in the request headers but a mismatched or expired key. It signifies a security check that has failed."
    },
    {
      "question_id": "EQ5089",
      "question": "Write one easy positive test case for checking profile details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test creates and retrieves a user's profile with valid data."
    },
    {
      "question_id": "EQ5091",
      "question": "What is the purpose of 302 Found in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates temporary redirection to another URL.",
      "model_answer": "It indicates the request was found and accepted for processing."
    },
    {
      "question_id": "EQ5093",
      "question": "Write a test case for negative login attempt with wrong password.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Wrong Password Login**\n- **Preconditions:** User exists with correct email and positive status.\n- **Test Steps:** Send `POST` /login with user's email and 'wrongpassword'.\n- **Expected Result:** `401 Unauthorized` status code, no session created."
    },
    {
      "question_id": "EQ5095",
      "question": "What does 422 Unprocessable Entity indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "It means the server could not process the request."
    },
    {
      "question_id": "EQ5097",
      "question": "Write a positive test for POST /users endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "Send a valid user payload with a unique username. Expected: `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5099",
      "question": "What does the term 'happy path' mean in testing?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most direct and successful sequence of steps in a system or process. In testing, it's the sequence of inputs, actions, and decisions that always leads to a positive outcome, such as a successful login or payment processing."
    },
    {
      "question_id": "EQ2002",
      "question": "Explain how you would design a negative test case for an API endpoint that requires OAuth2 Bearer tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Send a request to the endpoint without including a valid OAuth2 Bearer token. The expected result is a `401 Unauthorized` status code indicating bad credentials."
    },
    {
      "question_id": "EQ2004",
      "question": "Provide one happy-path and one error-path test case for a payment refund API endpoint.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "**Happy Path:** Send a valid `POST` request with a known refund amount and customer ID, expecting a `200 OK` response with a refund confirmation. **Error Path:** Send a `POST` request with an invalid transaction ID, expecting a `404 Not Found` error."
    },
    {
      "question_id": "EQ2006",
      "question": "How would you validate schema changes in a backward-compatible API upgrade?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "1. **Test Old Clients:** Send requests with outdated parameters or deprecated fields. 2. **Verify No Errors:** API should not return 400 or 500 errors. 3. **Check New Data Availability:** Ensure new fields (e.g., `updated_at`) or modified values (e.g., changed response code for deprecated endpoint) are returned correctly."
    },
    {
      "question_id": "EQ2008",
      "question": "Explain how mocking can be used to test a payment API without calling the real bank service.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "By creating a mock banking API that simulates transactions, the payment API can be tested with valid and invalid requests without actually contacting a real bank. This isolates the payment API from external dependencies and allows for faster, more reliable tests."
    },
    {
      "question_id": "EQ2010",
      "question": "Design one boundary test and one invalid test for an API field `age` (range 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "Boundary Test: `POST /registration` with `age=65`. Invalid Test: `POST /registration` with `age=0`."
    },
    {
      "question_id": "EQ2012",
      "question": "Explain how you would simulate a network timeout error in API testing.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "By configuring a mock server or API mock to simulate a slow or disconnected connection. You would set the mock's timeout to a very high value (e.g., 300 seconds) or simulate a disconnection mid-request. This allows you to test how your API handles a timeout without requiring a real network failure."
    },
    {
      "question_id": "EQ2014",
      "question": "Give one example of an API precondition and one step that follows it.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "Precondition: The user's account must be logged in. \nFollow-up: The API call for a protected resource."
    },
    {
      "question_id": "EQ2016",
      "question": "Write one test case to validate that API rate limiting is enforced correctly.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "Test sends 1k requests in 5 minutes and verify first 200 are `200 OK`, remaining are `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2018",
      "question": "Explain one advantage of using service virtualization in API testing.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "It allows testing with simplified or mocked service behaviors before real implementations are ready."
    },
    {
      "question_id": "EQ2020",
      "question": "Describe how to design one positive and one boundary test case for a login API requiring username and password.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "Positive Test: Valid username and password → `200 OK`. Boundary Test: Shortest allowed username character count → `200 OK` (valid length)."
    },
    {
      "question_id": "EQ2022",
      "question": "Write one test step to validate that an API correctly returns 415 Unsupported Media Type.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Send a request for a non-authorized media type (e.g., `/upload file` with no file). Verify the API's response status code is `415` (Unsupported Media Type) and the response body is `{\"error\": \"Invalid Media Type\"}` or a generic success message with the media type removed."
    },
    {
      "question_id": "EQ2024",
      "question": "Describe one way to test observability when an API experiences a slow database query.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Inject a latency injection tool into the database connection pool. Monitor API response times and database connection metrics. Expected: API latency increases, DB connection latency metrics exposed in traces."
    },
    {
      "question_id": "EQ2026",
      "question": "Explain how you would test API idempotency for a retry scenario.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Send the same request multiple times with a retry policy. Expected: all requests should return `200 OK` with no changes, and the system state should not change more than once."
    },
    {
      "question_id": "EQ2028",
      "question": "Give one boundary and one invalid test for a file upload API accepting max 5 MB files.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "Boundary: Upload a 5 MB file and confirm it's accepted. Invalid Test: Attempt to upload a file larger than 5 MB."
    },
    {
      "question_id": "EQ2030",
      "question": "Write a test case to validate proper error handling when an API is called with a missing required field `email`.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "### **Test Case: Missing Email**\n- **Precondition:** API expects `email` in request body.\n- **Test Step:** Send request with empty email field (e.g., `{\"username\": \"john\"}`).\n- **Expected Result:** API returns `400 Bad Request` with a clear error message like 'Missing required field: email'."
    },
    {
      "question_id": "EQ2032",
      "question": "How would you design a test to validate retry logic when an API occasionally returns 503?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "Design a test with two steps: 1) Send a request and capture the first response (either 200 or 503). 2) If the initial attempt was 503, send subsequent retries until one succeeds or the maximum retries limit is reached."
    },
    {
      "question_id": "EQ2034",
      "question": "Write a test case that validates log correlation using a trace ID header.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "Test sends requests with unique trace IDs. Verify logs are correctly correlated (e.g., same ID on multiple requests). Ensure missing trace ID results in null correlation."
    },
    {
      "question_id": "EQ2036",
      "question": "Design one intermediate-level test case for validating API rate limiting when multiple clients are involved.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "Test sends 5 requests per second from 3 clients. Verify first 5 requests are `200 OK`, subsequent requests are `429 Too Many Requests` with rate limit reset after 1 minute, and all clients are slowed down equally."
    },
    {
      "question_id": "EQ2038",
      "question": "Describe one positive and one negative test case for an API endpoint that sends SMS codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "Positive: A user registering with a valid phone number and expecting an SMS. Negative: A user with a locked account trying to resend a code that already exists."
    },
    {
      "question_id": "EQ2040",
      "question": "Explain one advantage of mocking external APIs when testing failure scenarios.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "Mocking prevents actual users or services from being impacted during testing."
    },
    {
      "question_id": "EQ2042",
      "question": "Write one test case to validate error handling when API returns malformed JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "Test sends request with malformed JSON payload. Expected: API returns `500 Internal Server Error` or `400 Bad Request` with clear error message, not a `200 OK`."
    },
    {
      "question_id": "EQ2044",
      "question": "Design one test step to confirm rate limiting headers (e.g., X-RateLimit-Remaining) are present.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "Send a request to an API's rate limit endpoint. Verify that the response contains the `X-RateLimit-Remaining` header and that its value is non-negative."
    },
    {
      "question_id": "EQ2046",
      "question": "Describe one advantage of separating test data from test logic in API testing.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic allows for independent setup and teardown of the test environment, improving test repeatability."
    },
    {
      "question_id": "EQ2048",
      "question": "Write a test case for validating graceful degradation when API cache is unavailable.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "Test sends request with invalid cache-present header → expect 429 Too Many Requests or 500 Internal Server Error, but response time acceptable."
    },
    {
      "question_id": "EQ2050",
      "question": "Explain one way to validate logging for sensitive fields such as passwords.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "One validation method is to store a masked or encrypted version of the password in the log, then run a decryption test against a known password on the system. Another approach is to compare the logged password with a computed hash of the actual password and verify they match."
    },
    {
      "question_id": "EQ2052",
      "question": "Provide one negative and one boundary test case for a currency field that must match ISO 4217 codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "Negative test: 'USD' → expect `400` level error for invalid currency. Boundary test: 'EUR' → valid, but at edge, another valid code like 'GBP' should exist."
    },
    {
      "question_id": "EQ2054",
      "question": "Write one test case to validate API behavior under network packet loss.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "Test sends 1k packets, then removes half. API should still accept remaining packets without error. Expected: response time increases, but system remains stable."
    },
    {
      "question_id": "EQ2056",
      "question": "Describe one method to verify test data cleanup after API test execution.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "Preconditions: Test Data Service (TDS) configured to generate test datasets with specific IDs. After test execution, query TDS to verify that all generated test dataset IDs (e.g., user, product, order) have been either cleaned up or reverted to a 'pending' state within a reasonable timeout."
    },
    {
      "question_id": "EQ2058",
      "question": "Write a test case to verify proper rollback when a multi-step transaction partially fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "Test involves executing a sequence of DB operations (e.g., `INSERT`, `UPDATE`, `DELETE`). Introduce a failure point (e.g., `DELETE` fails because record doesn't exist). Expected: Transaction rolls back entirely, DB state reverted to initial."
    },
    {
      "question_id": "EQ2060",
      "question": "Explain one approach to validating error messages follow a consistent JSON schema across all endpoints.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "Automatically validate each endpoint's response against a shared JSON schema. This is achieved by 1) defining a single, centralized JSON schema that defines the required and optional fields for error conditions, 2) using a tool like JSON Schema Validator to automatically generate validation tests, and 3) integrating these validation tests into the CI/CD pipeline for each endpoint."
    },
    {
      "question_id": "EQ3002",
      "question": "Write a test case that validates login, token refresh, and accessing a protected API using the refreshed token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "Test: Login & Token Refresh. Preconditions: User logged in → token available. Steps: 1) Login → `token_response` (e.g., 200 OK). 2) Send protected API request with initial token → `200 OK` (valid). 3) Wait for refresh timeout → refresh token generated. 4) Send protected API request with new refresh token → `200 OK` (valid after refresh). Expected: All requests successful with valid tokens."
    },
    {
      "question_id": "EQ3004",
      "question": "Design a chained test validating that a failed login attempt still prevents refresh token generation.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: A user with a valid refresh token exists in the system. 2. Action: Send a failed login attempt request (e.g., wrong password). 3. Expected: The API `401` or `403` response is correct, and a `200 OK` with a refresh token is not returned."
    },
    {
      "question_id": "EQ3006",
      "question": "Explain how you would validate correct mapping of business codes (e.g., ORDER_001) to HTTP status codes in API responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Designate specific business codes (e.g., ORDER_001, SHIPMENT_002) and map them to expected HTTP status codes (e.g., `200 OK` for ORDER_001, `304 Not Modified` for SHIPMENT_002). Automate API test cases to both send requests and assert the correct status code is returned for valid operations."
    },
    {
      "question_id": "EQ3008",
      "question": "Write one hard-level test case chaining order creation, payment, and refund APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "Test case: 'Order Refund'. Preconditions: Order exists, payment processed, API triggered. Steps: 1) Order creation → order ID. 2) Payment gateway call. 3) Refund API called with order ID → DB update. Verify DB state, payment ledger updated."
    },
    {
      "question_id": "EQ3010",
      "question": "Explain one test case that validates token refresh works across multiple microservices.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "Test case: Refresh Token Refresh. Precondition: User authenticated with short-lived token → expect `200 OK` and new token across services."
    },
    {
      "question_id": "EQ3012",
      "question": "Write a test that validates mapping of validation error codes to HTTP 400 responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "Define error codes and assert they map to correct 400 status codes."
    },
    {
      "question_id": "EQ3014",
      "question": "Design a test case validating expired refresh tokens cannot issue new access tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "Test sends expired refresh token to token endpoint. Expected: `400 Bad Request` or `403 Forbidden` instead of valid access token."
    },
    {
      "question_id": "EQ3016",
      "question": "Explain one multi-hop chained test that validates session invalidation after logout.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Test: 1) Login → 2) Perform action → 3) Logout → 4) Verify session expired and subsequent requests failed."
    },
    {
      "question_id": "EQ3018",
      "question": "Write a test case chaining signup, email verification, and login endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "Test: 1) Precondition: User exists in DB. 2) Action: Signup → email sent → verification link. 3) Action: Login with correct credentials. Expected: Login succeeds."
    },
    {
      "question_id": "EQ3020",
      "question": "Design one hard-level chained test validating a password reset flow.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "1. **Precondition:** A user (Test User) exists with a valid email and password. \n2. **Action:** Trigger a password reset via a unique, automated email. \n3. **Verification:** Confirm the reset link is generated correctly, and the user can successfully complete the reset process."
    },
    {
      "question_id": "EQ3022",
      "question": "Write a chained test case for validating user creation, profile update, and profile retrieval.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "Test: 1) Create user → 2) Update profile → 3) Retrieve profile (with DB query)."
    },
    {
      "question_id": "EQ3024",
      "question": "Explain one test to validate refresh token cannot be used after logout.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "1. **Action:** Send a `POST` request to the token endpoint using a valid refresh token.\n2. **Expected Result:** The server should respond with a `403 Forbidden` status code, not an access token.\n3. **Rationale:** A refresh token is bound to a user's session. After logout, the session is invalid, and using the refresh token would be an attempt to access another user's session."
    },
    {
      "question_id": "EQ3026",
      "question": "Write a test case validating correct mapping of internal error code AUTH_EXPIRED to HTTP status.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "Test case: 'Expired Session'.\n- Precondition: User session expires after 5 minutes.\n- Action: Call authentication endpoint with expired session claim (e.g., 'auth_expired' → 'AUTH_EXPIRED').\n- Expected: API returns `403 Forbidden` or `401 Unauthorized` with `AUTH_EXPIRED` as the error code, not `400 Bad Request`."
    },
    {
      "question_id": "EQ3028",
      "question": "Explain a chained test validating email verification failure if token is invalid.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Email user with expired token → expect `401 Unauthorized` response. 2) Send invalid token → expect `400 Bad Request` with validation error. 3) Chain to final test: send token with wrong user → expect `403 Forbidden` with 500 Internal Server Error (if backend can't handle invalid token)."
    },
    {
      "question_id": "EQ3030",
      "question": "Write a hard-level test case chaining loan application, credit check, and approval endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "**Test Case: Loan Application**\n- **Preconditions:** User authenticated, credit profile available.\n- **Test Steps:**\n  1. `POST /loans` with valid income, credit score, and loan amount → `201 Created`.\n  2. Same request but low credit → `403 Forbidden`.\n  3. Missing required field (e.g., employment history) → `400 Bad Request`.\n- **Expected Result:** Only valid applications approved.\n\n**Test Case: Credit Check**\n- **Preconditions:** API mock service for credit profile retrieval.\n- **Test Steps:**\n  1. `GET /users/{id}/credit` → `200 OK` with mock profile.\n  2. Same request but ID=999 (non-existent) → `404 Not Found`.\n  3. Request timing-out → `503 Service Unavailable`.\n- **Expected Result:** API must handle errors gracefully."
    },
    {
      "question_id": "EQ3032",
      "question": "Design a test case chaining signup, password reset, and login with new credentials.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "Preconditions: User email exists. Steps: 1) Sign up → confirm via email. 2) Password reset → new password sent. 3) Login with new credentials → expected login success."
    },
    {
      "question_id": "EQ3034",
      "question": "Write a test case chaining file upload, virus scan, and download endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "Preconditions: File 'virus_file.exe' and 'clean_file.txt' available. Test Case: 1) File Upload → `POST /upload` with file. 2) Virus Scan → `POST /scan` with uploaded file. 3) Download → `POST /download` with positive ID → `200 OK` with file. Negative: Invalid File → `400 Bad Request`."
    },
    {
      "question_id": "EQ3036",
      "question": "Explain one chained test for validating refresh token reuse prevention.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "1. Send first request with token → token granted.\n2. Wait for refresh token expiration → send request with new token → expect 401 Unauthorized.\n3. Ensure system state not changed (DB still valid)."
    },
    {
      "question_id": "EQ3038",
      "question": "Write a test case chaining search, add-to-cart, and checkout APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "Test case: 'Shopping Cart Journey'. \n1. Search for 'Laptop' → `GET /products`.\n2. Add to Cart → `POST /cart`.\n3. Checkout → `POST /checkout`."
    },
    {
      "question_id": "EQ3040",
      "question": "Explain one chained test for validating API session hijacking prevention.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "1. Log in user → 2. Access protected resource → 3. Verify response and authentication headers are different for logged-in and guest users."
    },
    {
      "question_id": "EQ3042",
      "question": "Provide exactly one chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "1. **Precondition:** A resource (e.g., a product) exists with an ETag `\"V1R1\"`. 2. **Action:** Perform an `UPDATE` request changing the resource, but include the original ETag `\"V1R1\"`. 3. **Verification:** Send an `GET` request with the updated ETag (`\"V2R1\"`) in the `If-Match: \"V2R1\"`` header. The test succeeds only if the server rejects the request with a `412 Precondition Failed` and not the `200 OK` response."
    },
    {
      "question_id": "EQ3044",
      "question": "Design a multi-hop test verifying async export job: POST /exports -> poll GET /jobs/{id} until complete -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "1. Send POST /exports with a job that should take time to complete (e.g., exporting a large file). 2. Poll the /jobs/{id} endpoint for the export job. 3. Verify the final export status by retrieving the exported file at /exports/{id}."
    },
    {
      "question_id": "EQ3046",
      "question": "Give one chained negative test for OAuth2 Authorization Code: /authorize -> /token -> resource call with missing scope.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Send `/authorize` with user consent. Then, call `/token` with no `scope` parameter. Expected: `403 Forbidden` or `400 Bad Request`."
    },
    {
      "question_id": "EQ3048",
      "question": "Write one chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. Given a user with an Idempotency-Key, send two identical `POST /orders` requests with retry logic. The second request should not create a new order but rather update the existing one with the same Key. Verify the DB state and return from the service match the first request's outcome."
    },
    {
      "question_id": "EQ3050",
      "question": "Provide one chained test for file processing pipeline: upload -> POST /process -> poll status -> download, including 202 handling.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "1. Chain tests: 1) Upload file → 2) `POST /process` → 3) Poll status → 4) Download → 5) Verify 202 OK for partial processing."
    },
    {
      "question_id": "EQ3052",
      "question": "Give one chained test to validate SSO session revocation propagates to API gateway and microservice access.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "1. Log in with SSO → session granted → revoke session → expected API gateway and microservice access denied."
    },
    {
      "question_id": "EQ3054",
      "question": "Write one chained test for partial order fulfillment: create order -> reserve inventory -> partial ship -> cancel remaining and refund delta.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "1. Given an order, reserve inventory, and partially ship it. 2. When the partial shipment is completed, mark the order as'shipped' but not fully. 3. Then, cancel the remaining amount and verify that the refund reflects only the partial shipment delta."
    },
    {
      "question_id": "EQ3056",
      "question": "Provide exactly one chained negative test for 2FA login: POST /login -> POST /2fa/verify with wrong code -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "Send a 2FA verification request with a wrong authentication code. The system should respond with a `401 Unauthorized` status code and an appropriate error message."
    },
    {
      "question_id": "EQ3058",
      "question": "Design a chained test verifying pagination consistency across create -> list -> delete -> list (with total count assertions).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "Create 5 items, page through results, delete last, and confirm previous pages still exist."
    },
    {
      "question_id": "EQ3060",
      "question": "Write one chained test for session stickiness: login -> subsequent calls via load balancer -> logout -> verify no node accepts old token.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "1. Chain: 1) Login as user A. 2) Access API via load balancer -> expect single node response. 3) Logout. 4) Verify no node accepts old token (e.g., user A's session cookie)."
    },
    {
      "question_id": "EQ4002",
      "question": "Write a state-machine style test validating account lifecycle: create → activate → suspend → reactivate → delete.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "Define states: Create (active), Active, Suspended, Reactivated, Delete. Transition and validate status after each step."
    },
    {
      "question_id": "EQ4004",
      "question": "Design a chained test that validates transaction rollback when step 2 of a 3-step money transfer fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "Plan three steps: 1. Successful transfer. 2. Failed transfer (e.g., insufficient funds). 3. Third step (e.g., confirm transfer). The chained test will execute steps 1 and 3 in sequence. The second step should be deliberately failed (e.g., by introducing a mock service that rejects the transaction). The test validates that the entire transaction is rolled back only when the second step fails."
    },
    {
      "question_id": "EQ4006",
      "question": "Write one test validating a multi-service chain: login → create order → process payment → cancel order after capture.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "1. **Action:** Log in as a valid user, create an order, and capture payment.\n2. **Verification:** After capture, assert the order is'shipped' or 'delivered' and not 'cancelled'."
    },
    {
      "question_id": "EQ4008",
      "question": "Describe one state-machine test validating password lifecycle: set → expire → reset → reuse prevention.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "Test: 1) Log in with valid password → set. 2) Wait for expiration → 'password expired' error. 3) Reset password → new token generated. 4) Attempt reuse of old token → fail. Verify all steps prevent insecure reuse."
    },
    {
      "question_id": "EQ4010",
      "question": "Write one complex chained test covering a loan application flow with branch failure in credit check.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "Test: 'Apply for Loan' → Verify approval, then chain to negative paths: \n1. Credit Check → Reject → System State: 'Application Rejected'.\n2. Alternative Credit Score → Approve → System State: 'Application Approved'.\n3. Insufficient Employment History → System State: 'Application Rejected'."
    },
    {
      "question_id": "EQ4012",
      "question": "Write a test validating data integrity when concurrent writes occur: update user profile with conflicting values.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "Test sends two simultaneous API requests to update user profiles. Expected: only one succeeds, DB remains consistent with majority vote."
    },
    {
      "question_id": "EQ4014",
      "question": "Write one very hard test validating chained document signing: upload → sign → verify → tamper detection.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "Precondition: Document uploaded with original signature. Action: Modify signature text → re-sign → send for verification → expected `InvalidSignature'` if tampered."
    },
    {
      "question_id": "EQ4017",
      "question": "Write one state-machine test validating subscription lifecycle: create → upgrade → downgrade → cancel.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "Test: 1) Create subscription → 2) Upgrade → 3) Downgrade → 4) Cancel → all states validated with expected results."
    },
    {
      "question_id": "EQ4019",
      "question": "Write a very hard chained test validating recovery after partial failure in a distributed order saga.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "Send three orders in parallel. Ensure two succeed but one (e.g., payment service) fails. Verify the failed order's state is rolled back to 'pending', and its corresponding compensating service is triggered to reverse any changes."
    },
    {
      "question_id": "EQ4021",
      "question": "Write one very hard test verifying financial transaction reversals: debit → credit → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "Precondition: two accounts (A, B) with initial balances known. Action: Debit A → credit B → system rollback. Verify A's balance unchanged, B's → inconsistent state."
    },
    {
      "question_id": "EQ4023",
      "question": "Design a state-machine test for warehouse inventory: add stock → allocate → ship → return → reconcile.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Define states (stock, allocated, shipped, returned, reconciled) and transitions (e.g., stock → allocated, returned → reconciled). Run test steps (e.g., add 10 units, allocate, ship, return 5 units, reconcile). Verify state changes and inventory updates match DB."
    },
    {
      "question_id": "EQ4025",
      "question": "Write one chained test validating mobile session lifecycle: login → token refresh → logout → refresh with old token → fail.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "1. Send login request → expect `200 OK` and valid token.\n2. Send token refresh request → expect new token in body.\n3. Send logout request → expect `200 OK` and null response.\n4. Send refresh with old token → expect `401 Unauthorized` response."
    },
    {
      "question_id": "EQ4027",
      "question": "Write one chained test validating email delivery API: send → open-tracking → unsubscribe → ensure no further emails sent.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. Send email → 2a. Verify email sent in API response. 2b. Check email is opened in DB → trackable. 2c. Perform unsubscribe action. 3. Verify no further emails (follow-up) are sent to user after unsubscribe."
    },
    {
      "question_id": "EQ4029",
      "question": "Write one very hard chained test for purchase flow with coupon application and failure branch: apply coupon → checkout → coupon invalid → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "1. Chain: 1) Log in as customer. 2) Add valid coupon (e.g., '10% off') to cart. 3) Navigate to checkout. 4) Click 'Apply Coupon'. 5) Mock API returns 400 Bad Request on invalid coupon. 6) Expected: Order removed from cart, cart updated to $0, purchase failed flag set."
    },
    {
      "question_id": "EQ5004-VN",
      "question": "Viết một test case positive đơn giản cho một API đăng nhập.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "Tiến hành: Trả lời 200 OK khi đăng nhập thành công."
    },
    {
      "question_id": "EQ5006-VN",
      "question": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "A valid user token (API key or Bearer Token) attached to the request. This ensures the request is executed as a legitimate user with a profile. Without this, the endpoint will only be 'visible' to authenticated users in the system."
    },
    {
      "question_id": "EQ5008-VN",
      "question": "Viết một test negative đơn giản cho một API đăng ký.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Truy cập `/register` với một tài khoản đã tồn tại. Expected: `401 Unauthorized` (if token is invalid)."
    },
    {
      "question_id": "EQ5010-VN",
      "question": "Vai trò của một schema trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "A schema defines the structure of expected API responses. It is typically defined by the API provider or created by the tester based on the expected data format. It is used to automate validation of incoming requests against the expected response structure."
    },
    {
      "question_id": "EQ5012-VN",
      "question": "Viết một test step đơn giản để validate một response 201 Created.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "Send a `POST` request with a valid payload. The expected result is a `201 Created` status code with the new resource's ID in the `Location` header or in the body."
    },
    {
      "question_id": "EQ5014-VN",
      "question": "Mục đích của mocking trong API testing là gì?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking simulates dependent systems (like microservices or databases) during testing. It replaces real dependencies with controlled, isolated mock objects. This allows testers to focus on API behavior without being hindered by external failures or dependencies."
    },
    {
      "question_id": "EQ5016-VN",
      "question": "Viết một test case dễ dàng cho một API lấy danh sách sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "**Tiêu chí:** API trả danh sách các sản phẩm (ID, tên, giá) khi `/products` được gọi. **Mã test:** Tin tưởng API trả một danh sách hợp lệ với yêu cầu `GET /products`."
    },
    {
      "question_id": "EQ5018-VN",
      "question": "Mục đích của một precondition trong một test case là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Preconditions are set up trước khi test case được thực hiện. Mục đích là đảm bảo môi trường test stable và avoid các tình huống không mong muốn. Ví dụ, một test case cho bài học về việc sử dụng thuốc chỉ nên được thực hiện nếu người tham gia đã đọc thuốc và hiểu cách sử dụng."
    },
    {
      "question_id": "EQ5020-VN",
      "question": "Viết một test negative cho việc upload file với định dạng không được hỗ trợ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chuyển file có ext không được hỗ trợ (ví dụ: `.txt` trong ứng dụng tải file PDF) và kiểm tra rằng API trả mã số 415 Bad Request hoặc 500 Internal Server Error."
    },
    {
      "question_id": "EQ5022-VN",
      "question": "Mục đích của một test case description là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "Test case descriptions mục đích là để clearly và concisely mô tả mục đích, préconditions, và các testcase cần được thực hiện để kiểm tra tính xác thực của một chức năng hoặc tính chất."
    },
    {
      "question_id": "EQ5024-VN",
      "question": "Viết một test step để validate thời gian response dưới 1 giây.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "1. **Action:** Send a `GET /health` request.\n2. **Expected:** Thời gian response (tổng quan là headers `HTTP_2_X Seconds` hoặc `Status Code` với header Timing-Benchmarks) < 1 giây."
    },
    {
      "question_id": "EQ5027-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /health.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "Send a `GET` request to `/health`. Expect the API to respond with a `200 OK` status code and a simple body like `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5029-VN",
      "question": "Mục đích của việc sử dụng test data management trong API testing là gì?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "It ensures consistent and reusable data is available for testing."
    },
    {
      "question_id": "EQ5031-VN",
      "question": "Viết một test negative dễ dàng cho một API mong đợi định dạng JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Send a request với body text instead of JSON. Expecta là response có thể có field `body` với valor `null` hoặc một error 400 Bad Request."
    },
    {
      "question_id": "EQ5033-VN",
      "question": "Vai trò của assertion trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion is used to verify that the API behaves as expected. It's a statement like `assert that the response status code is 200` or `assert that the JSON field exists`."
    },
    {
      "question_id": "EQ5035-VN",
      "question": "Viết một test case để kiểm tra DELETE /users/{id} hoạt động đúng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "Tập test này cần tạo user có ID biết (id=XXX). Test delete cần check DB trỏ X after DELETE."
    },
    {
      "question_id": "EQ5037-VN",
      "question": "Mã trạng thái HTTP 201 Created cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "It indicates the request was successful and a new resource was created."
    },
    {
      "question_id": "EQ5039-VN",
      "question": "Viết một test đơn giản cho GET /users/{id} trả về response chính xác.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "```bash\n# Test 1: Vérifier réponse 200 OK\n# Condition: User exists với id=999\n# Expected: `{ \"id\": 999, \"name\": \"John Doe\" }` được trả về.\n\n# Test 2: Vérifier respuesta 404 Not Found\n# Condition: User không có id=1231\n# Expected: `{ \"error\": \"User not found\" }` được trả về với status 404.\n```"
    },
    {
      "question_id": "EQ5041-VN",
      "question": "Mục đích của một response 200 OK là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "A `200 OK` status code indicates that the request was successful and the response body contains all the information needed to consider the request complete."
    },
    {
      "question_id": "EQ5043-VN",
      "question": "Viết một test negative để validate response cho một endpoint không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "Send a request with an invalid or missing argument (e.g., `/users/` without ID). Expected: `200 OK` với một body chứa thông tin user bất kỳ."
    },
    {
      "question_id": "EQ5045-VN",
      "question": "Một test case assertion làm gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion là cách xác minh kết quả của một test case. Nó kiểm tra liệu trường hoặc trả lời có đúng yêu cầu được thiết kế hay không."
    },
    {
      "question_id": "EQ5047-VN",
      "question": "Viết một test positive cho endpoint upload file.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "1. **Action:** Send a `POST` request to `/upload` with a valid CSV file attached.\n2. **Expected:** The server should return a `201 Created` status code with the file name in the response body.\n3. **Verify:** Check the response body for the created file name and ensure the file was saved correctly."
    },
    {
      "question_id": "EQ5049-VN",
      "question": "Vai trò của 415 Unsupported Media Type là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "It indicates the server cannot understand the request format."
    },
    {
      "question_id": "EQ5052-VN",
      "question": "Viết một test positive đơn giản để kiểm tra API chi tiết sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "``` xml\n<!-- Product API Test -->\n<!-- 1. Get Product by ID (positive): /products/123 -->\n<!-- 2. Create New Product (positive): /products` -->\n\n<!-- Example: -->\n<!-- Request Body: -->\n<!--  -->\n<!--  **Positive Test: Create New Product**\n<!--  - **Method:** `POST`\n<!--  - **URL:** `/products` (without ID)**\n<!--  - **Data:**\n<!--    - `product_name`: 'New iPhone 14 Pro'**\n<!--    - `price`: 999.99**\n<!--    - `description`: 'Latest iPhone model'**\n<!--  - **Expected:** `201 Created` (status code), `product_id` được trả về trong body. -->\n```"
    },
    {
      "question_id": "EQ5054-VN",
      "question": "Mục đích của việc sử dụng Authorization headers trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "Mục đích là xác minh và quản lý quyền truy cập. It ensures requests are 'allowed' based on tokens or credentials."
    },
    {
      "question_id": "EQ5056-VN",
      "question": "Viết một test negative case cho một API yêu cầu authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Provide a valid token in the request, then swap it with a expired or invalid token."
    },
    {
      "question_id": "EQ5058-VN",
      "question": "Vai trò của 500 Internal Server Error trong API testing là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "Internal Server Error 500 được sử dụng khi API không thể xử lý một request vì một vấn đề không được quản trị trực tiếp, chẳng hạn như logic sai lầm hoặc cơ sở dữ liệu không có. Trong API testing, nó giúp xác định điểm trong mã hoặc cấu hình test mà hệ thống phản hồi một lỗi không được xử lý thông thường."
    },
    {
      "question_id": "EQ5060-VN",
      "question": "Viết một test case positive cho một API trả về danh sách đơn hàng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "Đăng bội đơn hàng (2) và kiểm tra trả lời là mảng với các thông tin."
    },
    {
      "question_id": "EQ5062-VN",
      "question": "Chức năng của response header trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "Response headers cung cấp thông tin về trạng thái response, như status code, Content-Type, và caching instructions. Trong API testing, kiểm tra các thông tin này là crucial để xác định kết quả và hiệu suất của yêu cầu."
    },
    {
      "question_id": "EQ5064-VN",
      "question": "Viết một test negative cho việc tạo một tài nguyên trùng lặp.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "Đầu vào: `{'type':'resource', 'name': 'test_resource'}`. Thắc mắc: Tài nguyên với tên `test_resource` khác nào không? Expected: API trả `201 Created` nếu resource tồn tại. Test negative: tạo resource trùng lặp. Expected: API trả `400 Bad Request` hoặc `409 Conflict`."
    },
    {
      "question_id": "EQ5066-VN",
      "question": "Vai trò của 202 Accepted trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "It xác định rằng request đã được xác thực và chấp nhận bởi server."
    },
    {
      "question_id": "EQ5068-VN",
      "question": "Viết một test positive dễ dàng để kiểm tra API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Send a `POST` request with a valid JSON body (e.g., `{ \"id\": 1, \"name\": \"User 1\" }`). Expected: `200 OK` with a valid `200 OK` response schema in the API response."
    },
    {
      "question_id": "EQ5070-VN",
      "question": "Mục đích của response body trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Mục đích là xác minh API trả lời với nội dung hợp lệ."
    },
    {
      "question_id": "EQ5072-VN",
      "question": "Viết một test case để verify chức năng logout.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "Test case: Logout Functionality.\n- Preconditions: User logged in, session valid.\n- Steps: Perform logout button click, expect response 'Session ended'. \n- Expected: Session cookie cleared, database state unchanged."
    },
    {
      "question_id": "EQ5074-VN",
      "question": "Lỗi 415 Unsupported Media Type validate điều gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "It requires that the `Content-Type` header must be `application/json`. If the client sends this but the server doesn't expect it, lỗi 415 được trả. Chức năng của nó là xác minh kiểu media."
    },
    {
      "question_id": "EQ5077-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /status.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Mô tả: Send a `GET` request đến `/status`. Yêu cầu: endpoint này không cần dữ liệu đặc biệt. Expected: Trả về một mã trạng thái `200 OK` với nội dung `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5079-VN",
      "question": "Một response 204 No Content có nghĩa là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "No Content (or 204 No Content) là một status code được sử dụng khi một request được gửi cho một URL, nhưng client (những người dùng) không cần truy cập toàn bộ tài liệu. Trong trường hợp này, server sẽ trả lại một response có Head nhưng không Body. Ví dụ, một link (đường dẫn) được sử dụng."
    },
    {
      "question_id": "EQ5081-VN",
      "question": "Viết một test negative case cho việc gửi một Content-Type header không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chức năng gửi headers. **Test Negative:** gửi `Content-Type: invalid` (chẳng hạn `Content-Type: xxx`). **Expected Result:** Server trả mã số 400 Bad Request hoặc lỗi không xác định."
    },
    {
      "question_id": "EQ5083-VN",
      "question": "Mục đích của Accept header trong các API request là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "It specifies the acceptable response format."
    },
    {
      "question_id": "EQ5085-VN",
      "question": "Viết một test case đơn giản cho một API logout thành công.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "Đề xuất test case: 1. Đăng nhập vào API. 2. Giao request logout. 3. Kiểm tra rằng phản hồi có status 200 OK và không chứa token."
    },
    {
      "question_id": "EQ5087-VN",
      "question": "Ý nghĩa của 401 Unauthorized trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "It means authentication is required and a valid key is needed."
    },
    {
      "question_id": "EQ5089-VN",
      "question": "Viết một test case positive dễ dàng để kiểm tra API chi tiết profile.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "Test case: `create-profile-positive` - đăng nhập, gửi yêu cầu tạo profile với thông tin đầy đủ. Mời expect: trả lời `201 Created` với ID profile tồn tại và các field valid."
    },
    {
      "question_id": "EQ5091-VN",
      "question": "Mục đích của 302 Found trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "It tells the client that the resource was found but not returned."
    },
    {
      "question_id": "EQ5093-VN",
      "question": "Viết một test case cho nỗ lực đăng nhập negative với mật khẩu sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "- **Preconditions:** Tài khoản exist nhưng mật khẩu không được lưu record.\n-  - **Action:** Triggers login endpoint với param='password'.\n-  - **Expected:** Return 401 Unauthorized, không trả lời 200 OK; DB không ghi record."
    },
    {
      "question_id": "EQ5095-VN",
      "question": "422 Unprocessable Entity cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "It indicates the server could not fulfill the request with the provided information."
    },
    {
      "question_id": "EQ5097-VN",
      "question": "Viết một test positive cho endpoint POST /users.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Send a valid JSON payload (`{\"username\": \"johndoe\", \"email\": \"john.doe@example.com\"}`) to `/users`. The response should be `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5099-VN",
      "question": "Thuật ngữ 'happy path' trong testing có nghĩa là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "The 'happy path' refers to the sequence of steps in a test case where all inputs and conditions are correct, leading to a successful outcome."
    },
    {
      "question_id": "EQ2002-VN",
      "question": "Hãy giải thích cách bạn thiết kế một **test case âm tính** cho một endpoint API yêu cầu **OAuth2 Bearer token**.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "A negative test for an OAuth2 Bearer token endpoint is to send a `POST` request to the token endpoint **without** a valid client ID claim in the request body. **Expected:** The server should reject the request with a `403 Forbidden` or `400 Bad Request` status code, not issue a token."
    },
    {
      "question_id": "EQ2004-VN",
      "question": "Cung cấp một **test case happy-path** và một **test case error-path** cho một endpoint API hoàn tiền thanh toán.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path (Thống Kê Hạnh Phúc):** Triggers request với ID order=1234. **Test Case Error-Path (Thống Kê Sai Lầm):** Nạp parameters như ID order=999999 (tài khoản không tồn tại) hoặc amount=–10.00."
    },
    {
      "question_id": "EQ2006-VN",
      "question": "Bạn sẽ xác thực các thay đổi **schema** trong một nâng cấp API **tương thích ngược** như thế nào?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "By running migration scripts backward and validating database changes."
    },
    {
      "question_id": "EQ2008-VN",
      "question": "Giải thích cách **mocking** có thể được sử dụng để kiểm tra một API thanh toán mà không gọi dịch vụ ngân hàng thực.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Simulate payment service with stub responses. Test payment confirmation without hitting external payment gateway."
    },
    {
      "question_id": "EQ2010-VN",
      "question": "Thiết kế một **boundary test** và một **invalid test** cho trường API `age` (phạm vi 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "* **Boundary Test:** Chọn giới hạn (18, 65) và gửi request. **Invalid Test:** Gửi request với age = 0 hoặc > 65."
    },
    {
      "question_id": "EQ2012-VN",
      "question": "Giải thích cách bạn mô phỏng lỗi **network timeout** trong **API testing**.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "By simulating a slow or disconnected network connection and monitoring the API's response time."
    },
    {
      "question_id": "EQ2014-VN",
      "question": "Đưa ra một ví dụ về một **precondition** API và một **step** theo sau nó.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "Precondition: Một người dùng có tài khoản. Step: API trả lời với thông tin người dùng."
    },
    {
      "question_id": "EQ2016-VN",
      "question": "Viết một **test case** để xác thực rằng **API rate limiting** được thực thi đúng.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "**Test Case:** `Rate Limit Test`\n- **Preconditions:** API rate limit (e.g., 100 requests/min) is enabled.\n- **Test Steps:** 1) Send `POST` requests in rapid succession (e.g., 10 requests in 1 minute). 2) Wait for the time window to expire. 3) Send the next request. \n- **Expected Result:** The expired request should return a `429 Too Many Requests` status code, while the subsequent request should be accepted."
    },
    {
      "question_id": "EQ2018-VN",
      "question": "Giải thích một lợi thế của việc sử dụng **service virtualization** trong **API testing**.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "It allows testing with simulated services that are unavailable in real environments."
    },
    {
      "question_id": "EQ2020-VN",
      "question": "Mô tả cách thiết kế một **test case tích cực** và một **boundary test case** cho một API đăng nhập yêu cầu tên người dùng và mật khẩu.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "A positive test case nhập một tên người dùng và mật khẩu hợp lệ và verify response là 200 OK. A boundary test case kiểm tra nhập 'null' hoặc một ký tự đặc biệt cho tên người dùng hoặc mật khẩu."
    },
    {
      "question_id": "EQ2022-VN",
      "question": "Viết một **test step** để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "Send a request with a media type argument (e.g., `?format=json`), tại đó expect phản hồi có status code `415` và chủ đề `Unsupported Media Type`."
    },
    {
      "question_id": "EQ2024-VN",
      "question": "Mô tả một cách để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "1. **Simulate DB Slow Response:** Send a `GET` request đến endpoint API và, trên client-side, sử dụng một library như Postman hoặc insomnia, giả định DB trả lại sau 5s (thay vì ngay lập tức). 2. **Verify API Response:** Chờ kết quả và gửi `GET` tiếp theo cho cùng URL. **Kết luận:** Nếu API trả trả lời nhanh (tương tự với lần truy vấn nhanh), API có **observability** vấn đề và sẽ không phản hồi ngay. 3. **Test Double Synchronization:** Another approach is to use a test double DB that synchronizes data at a known interval. Then, hit the API with a `GET` request. If the API returns data immediately, it's observable."
    },
    {
      "question_id": "EQ2026-VN",
      "question": "Giải thích cách bạn sẽ kiểm tra **API idempotency** cho một kịch bản **retry**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Kiểm tra **idempotency** với **retry**: 1) Send request đầu tiên → `200 OK`. 2) Send request lặp lại → `200 OK` (chưa thay đổi). 3) Kiểm tra **state change** (như DB). 4) Vấn đề: trả **`409 Conflict`** khi lặp lại."
    },
    {
      "question_id": "EQ2028-VN",
      "question": "Đưa ra một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "Boundary: Chia file 10 MB làm hai phần. **Invalid:** Chia file lớn hơn giới hạn."
    },
    {
      "question_id": "EQ2030-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "**Test Case:** Vận hành - Chức năng Bắt buộc Email. **Action:** Trả lời API với trường 'email' bị thiếu. **Expected:** API trả **400 Bad Request** với mã lỗi `InvalidRequest` hoặc `MissingRequiredField`."
    },
    {
      "question_id": "EQ2032-VN",
      "question": "Bạn sẽ thiết kế một **test** để xác thực logic **retry** như thế nào khi một API thỉnh thoảng trả về **503**?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "1. **Precondition:** Dùng mô hình dữ liệu sim (e.g., SQLite) và giả server (mock) để giả định `503 Service Unavailable`. 2. **Test Steps:** 1) Gửi yêu cầu bình thường. 2) Kiểm tra trả lời là `503` và kiểm tra trạng thái client. 3) Chú ý: Nếu client stop retry, API sẽ bị lỗi. 4) Xác minh retry được kích hoạt và số lần retry. 5) Vệ sinh: Mock server cần reset sau mỗi test."
    },
    {
      "question_id": "EQ2034-VN",
      "question": "Viết một **test case** xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "**Test Case:** Log Correlation. **Action:** Send request with `Trace-ID` header → expect matched logs in DB. **Expected:** Logs joined by ID must exist."
    },
    {
      "question_id": "EQ2036-VN",
      "question": "Thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting** khi có nhiều máy khách tham gia.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "1. **Test Case Name:** Verify API Rate Limiting with Concurrent Requests.\n2.  **Preconditions:** 1) API configured with rate limit (e.g., 100 requests/min). 2) Multiple machines (machines = machines) as testers. \n3.  **Test Steps:** 1. **Action:** On mỗi máy tính, sử dụng một client GET /api/v1 metrics (tập hợp các request rate). 2.  **Expected Result:** 1) Tất cả các máy tính đều trả về `200 OK` và metadata (ví dụ: `rate: 68/100`). 2) Không một máy tính nào trả về lỗi 429 Too Many Requests. 3) Tổng số request từ tất cả các máy tính phải `<threshold>`. 4) Đáp thời gian trung bình (average latency) của các request từ các máy tính khác nhau nên không được giới hạn."
    },
    {
      "question_id": "EQ2038-VN",
      "question": "Mô tả một **test case tích cực** và một **test case âm tính** cho một endpoint API gửi mã **SMS**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case tích cực (Positive):** Send a `POST` request với mã **SMS** hợp lệ đến `/send-sms` và verify **status** là `200 OK`. - **Test Case âm tính (Negative):** Send mã **SMS** đã được sử dụng hoặc không tồn tại."
    },
    {
      "question_id": "EQ2040-VN",
      "question": "Giải thích một lợi thế của việc **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Mocking API bên ngoài cho phép kiểm tra các kịch bản thất bại một cách an toàn và kiểm soát được, vì thực tế là hệ thống khác có thể không sẵn sàng hoặc không thể kiểm tra được."
    },
    {
      "question_id": "EQ2042-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi khi API trả về **JSON** bị định dạng sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "Chỉ cần gửi request với body chứa các khóa hoặc giá trị không hợp lệ (ví dụ, `{ \"id\": \"string\" }`) và kiểm tra API trả `400 Bad Request` hoặc `500 Internal Server Error` với mãn hình lỗi phù hợp."
    },
    {
      "question_id": "EQ2044-VN",
      "question": "Thiết kế một **test step** để xác nhận các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "1. **Action:** Send request with all required rate limiting headers (e.g., `X-RateLimit-Remaining`, `X-RateLimit-Limit`, `X-RateLimit-Reset`).\n2. **Expected:** Headers phải được gửi lại với status `200 OK` (bằng vènhỏ). \n3. **Verify:** Kiểm tra response headers để đảm bảo tất cả các header rate limiting đều được gửi và có giá trị."
    },
    {
      "question_id": "EQ2046-VN",
      "question": "Mô tả một lợi thế của việc tách dữ liệu **test** khỏi logic **test** trong **API testing**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Tách dữ liệu test ngăn tránh thay đổi cơ sở dữ liệu, giúp test cases độc lập và dễ dự đoán."
    },
    {
      "question_id": "EQ2048-VN",
      "question": "Viết một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "- **Test Case:** Tìm SDB không tồn tại. - **Action:** Gửi `GET /products` -> DB. - **Expected:** Không trả hồi vụn 404, DB được cập nhật. - **Post-condition:** Suy thoái, phản hồi DB chính xác."
    },
    {
      "question_id": "EQ2050-VN",
      "question": "Giải thích một cách để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Thay đổi mật khẩu -> thay đổi hash mật khẩu. Log hash -> an toàn, không tiết lộ mật khẩu."
    },
    {
      "question_id": "EQ2052-VN",
      "question": "Cung cấp một **test case âm tính** và một **boundary test case** cho một trường tiền tệ phải khớp với mã **ISO 4217**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case Âm Tính (Negative):** \"Mua hàng với số tiền âm (e.g., -10 USD)\".\n- **Boundary Test Case (Boundary Condition):** \"Mua hàng với số tiền biên (e.g., 10.99 USD)\" vì sẽ kiểm tra xem hệ thống xử lý chính xác số tiền biên giới hay không."
    },
    {
      "question_id": "EQ2054-VN",
      "question": "Viết một **test case** để xác thực hành vi API dưới tình trạng mất gói mạng.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "1) Triggers: Send request via API while network packet sniffing disabled. 2) Expected: API response `500 Internal Server Error` with error like 'Connection timed out' (if retry timeout occurs), else service unavailable (if disallow connection). 3) Logs confirm no unexpected database queries."
    },
    {
      "question_id": "EQ2056-VN",
      "question": "Mô tả một phương pháp để xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Truy cập DB sau test **API** -> kiểm tra liệu Row/Record bị xóa."
    },
    {
      "question_id": "EQ2058-VN",
      "question": "Viết một **test case** để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "Test case: Đăng hàng với tình trạng 'Shipped'. Precondition: Transaction được khởi tạo. Action: Thử lỗi nhập hàng không tồn tại. Expected: Transaction phải tự độngrollback đến trạng thái 'Processing'."
    },
    {
      "question_id": "EQ2060-VN",
      "question": "Giải thích một cách tiếp cận để xác thực các thông báo lỗi tuân theo một **JSON schema** nhất quán trên tất cả các **endpoint**.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "Tập trung vào việc validate JSON body với một schema validating specific error types. \nEnsure all API endpoints consume the same schema. \nExample: Endpoint A /create, Endpoint B /update both validate against ErrorSchema.json."
    },
    {
      "question_id": "EQ3002-VN",
      "question": "Viết một test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "Test case: Đăng nhập và truy cập API bảo vệ.\n- **Preconditions:** Một người dùng có sẵn.\n- **Test Steps:**\n  1. Đăng nhập và nhận token.\n  2. Sử dụng token làm mới -> token mới được trả về.\n  3. Sử dụng token mới -> truy cập API được bảo vệ.\n- **Expected Result:** API được truy cập là 200 OK."
    },
    {
      "question_id": "EQ3004-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "Tập trung vào các trường hợp login thất bại và hành động token. Đảm bảo test case có logic block ngăn cản refresh. Ví dụ, if wrong credentials -> no refresh token generated."
    },
    {
      "question_id": "EQ3006-VN",
      "question": "Giải thích cách bạn sẽ xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Xác thực: sử dụng các mã trường (201 Created, 204 No Content) và mã phản hồi (200 OK) trong API. Ánh xạ: chuyển dịch mã nghiệp vụ (ORDER_001) -> mã trạng thái HTTP (để tạo order) trong logic API."
    },
    {
      "question_id": "EQ3008-VN",
      "question": "Viết một test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "**Test Case: Transaction Flow**\n- **Preconditions:** APIs available, DB seeded with valid user, product, and payment methods.\n- **Steps:**\n  1. **Create Order:** `POST /orders` với thông tin hợp lệ (e.g., ID user, ID sản phẩm).\n  2. **Process Payment:** `POST /payments` với ID đơn hàng và phương thức thanh toán.\n  3. **Refund Order:** `POST /refunds` với ID đơn hàng và lý do (e.g., trả hoàn tiền).\n- **Expected:** DB phản hồi đơn hàng có trạng thái `processed`, DB payment phản hồi `id` exist, DB refund phản hồi `amount` được tính chính xác."
    },
    {
      "question_id": "EQ3010-VN",
      "question": "Giải thích một test case xác thực việc làm mới token hoạt động trên nhiều microservice.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case: 'Đăng nhập và sử dụng token'. Đăng nhập vào hệ thống, lấy token và nhắn nó vào header của các request. Kiểm tra xem các microservice được gọi và trả lời đúng (ví dụ, API User -> API Product)."
    },
    {
      "question_id": "EQ3012-VN",
      "question": "Viết một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "Dòng lệnh `curl -XPOST http://localhost:8000/create-user` với mã lỗi xác thực (e.g., `1007`) → `400 Bad Request`. Dòng lệnh khác → `200 OK`. Test đảm bảo trả lời HTTP tương ứng với mã lỗi."
    },
    {
      "question_id": "EQ3014-VN",
      "question": "Thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Action:** Send request for refresh token.\n2. **Expected Result:** Instead of `200 OK` and new access token, trả `403 Forbidden` hoặc `400 Bad Request` vì refresh token đã hết hạn."
    },
    {
      "question_id": "EQ3016-VN",
      "question": "Giải thích một bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra yêu cầu hành động đăng xuất, sau đó kiểm tra các lệnh liên quan: `logout`, `disconnect`, `abort session`. Nghiên cứu cần xác minh session được tự động reset hoặc phải được hủy thủ công."
    },
    {
      "question_id": "EQ3018-VN",
      "question": "Viết một test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "- **Đăng ký:** Send `POST /register` with valid data.\n- **Xác minh email:** Send `POST /verify-email` với địa chỉ email đã đăng ký.\n- **Đăng nhập:** Send `POST /login` với password hoặc token JWT."
    },
    {
      "question_id": "EQ3020-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Đầu tiên, tạo bài kiểm tra cơ bản (Điểm 3) yêu cầu chỉ nhập mã xác minh và mật khẩu mới. Tiếp theo, tạo bài kiểm tra trung bình (Điểm 5) yêu cầu nhập thông tin người dùng. Cuối cùng, tạo bài kiểm tra khó nhất (Điểm 7) yêu cầu nhập thông tin người dùng và xác nhận."
    },
    {
      "question_id": "EQ3022-VN",
      "question": "Viết một test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "**Test Case: Tạo Người Dùng**\n- **Preconditions:** API hoạt động.\n- **Steps:**\n  - Tạo người dùng mới (đây là hành động cơ bản).\n  - Cập nhật hồ sơ với thông tin cụ thể (ví dụ, địa chỉ, số điện thoại).\n  - Truy xuất hồ sơ bằng ID người dùng.\n- **Expected:** Các phản hồi phải là `200 OK` cho tạo mới, `200 OK` cho cập nhật, và dữ liệu phải được lưu trữ."
    },
    {
      "question_id": "EQ3024-VN",
      "question": "Giải thích một bài kiểm tra để xác thực refresh token không thể được sử dụng sau khi đăng xuất.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra là đăng nhập vào tài khoản với mã access. Tìm kiếm refresh token và dùng nó để lấy token mới. Thử đăng xuất và cố lấy tài khoản mới với token cũ. Nếu được chặn, token refresh bị block."
    },
    {
      "question_id": "EQ3026-VN",
      "question": "Viết một test case xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "- **Mô tả:** Triggers session expiration → expect `403 Exceeded Lifetime` rather than internal error. \n- **Điểm kiểm tra:** 1) Log in với thời gian hạn chế → 2) Xác minh phản hồi có status code 403. \n- **Hàm xác minh:** Assert response body chứa thông tin 'expires' hoặc 'lifetime'."
    },
    {
      "question_id": "EQ3028-VN",
      "question": "Giải thích một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Thật đơn giản. Nếu token không hợp lệ, thì kiểm tra xác minh sẽ thất bại vì nó chỉ chấp nhận token hợp lệ. Ví dụ, sử dụng token đã được sử dụng nhưng đã hết hạn."
    },
    {
      "question_id": "EQ3030-VN",
      "question": "Viết một test case cấp độ khó chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "**Test Case: Sợm Mạo**\n- **Preconditions:** Tài khoản có tiền sử vay, tín dụng sẵn.\n- **Steps:** Đăng nhập -> Nộp đơn vay -> Tín dụng -> Phê duyệt -> All Combinations.\n- **Expected:** only valid -> response 400 invalid -> DB matches."
    },
    {
      "question_id": "EQ3032-VN",
      "question": "Thiết kế một test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Preconditions:** Tạo tài khoản exist, mật khẩu thay đổi.\n2. **Steps:**\n   - **Chuỗi đăng ký:** Đăng ký mới với email và password unique.\n   - **Đặt lại mật khẩu:** Gửi mã và nhập lại.\n   - **Đăng nhập:** Log in với email và password mới.\n3. **Expected Results:** Đăng nhập thành công only khi đúng password."
    },
    {
      "question_id": "EQ3034-VN",
      "question": "Viết một test case chuỗi các endpoint tải lên file, quét virus và tải xuống.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "- **Preconditions:** File exist, user token.\n- - **Endpoint 1 (POST /files):** Chức năng tải lên file → `{\"file_name\": \"test.txt\", \"file_type\": \"text/plain\", \"file_size\": 102}`.\n- - **Endpoint 2 (GET /files/:id) → Virus Scan:** Chức năng quét virus → trả `200 OK` với báo cáo virus.\n- - **Endpoint 3 (GET /files/:id) → Download:** Chức năng tải xuống → trả tệp `test.txt`."
    },
    {
      "question_id": "EQ3036-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn việc sử dụng lại refresh token.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Đo kiểm xem refresh token được sử dụng một cách hợp lệ và xem có token mới được tạo sau thời gian hạn đầu không."
    },
    {
      "question_id": "EQ3038-VN",
      "question": "Viết một test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Giỏ Hàng**\n- **Preconditions:** User exist, sản phẩm có giá.\n- **Steps:** 1) Tìm kiếm sản phẩm. 2) Thêm vào giỏ hàng. 3) Thanh toán (bán hàng). 4) Xác nhận giỏ hàng được cập nhật.\n- **Expected:** DB có order record, sản phẩm số lượng giảm 1."
    },
    {
      "question_id": "EQ3040-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn tấn công chiếm đoạt session API.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Bài kiểm tra sẽ yêu cầu người dùng thực hiện các hành động như đăng nhập, mua hàng, và chuyển giao giao dịch. Sau đó, người dùng sẽ cố gắng truy cập tài khoản khác bằng session bị đánh cắp. **Điểm kiểm tra:** 1) Tốc độ phản hồi khi nhập session bất hợp pháp. 2) Kiểm tra xem session bị canjú (impersonate) được chấp nhận hay không. 3) Vérify xem DB được cập nhật khi session bị vô hiệu hóa."
    },
    {
      "question_id": "EQ3042-VN",
      "question": "Cung cấp chính xác một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "Test: Đăng ký (POST) tạo một tài liệu với ETag `\"revision=123\"` và mã được tạo. Tiếp đó, cập nhật tài liệu thay đổi (PUT) và lưu lại ETag mới. Đọc lại (GET) và kiểm tra phản ứng là `200 OK`."
    },
    {
      "question_id": "EQ3044-VN",
      "question": "Thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ: POST /exports -> thăm dò GET /jobs/{id} cho đến khi hoàn thành -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Đầu tiên, gửi request POST /exports và lưu ID export. Tiếp theo, gửi request GET /jobs/{id} liên tục cho đến khi trả code 200 OK (hoàn thành) hoặc 503 Service Unavailable (đồng bộ). Cuối cùng, kiểm tra request GET /exports/{id} được thực hiện sau thời gian."
    },
    {
      "question_id": "EQ3046-VN",
      "question": "Cung cấp một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code: /authorize -> /token -> gọi tài nguyên với scope bị thiếu.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "Đáp án: Trả lời `/authorize` với scope không tồn tại, `/token` không được trả lại, gọi tài nguyên -> 403 Forbidden."
    },
    {
      "question_id": "EQ3048-VN",
      "question": "Viết một bài kiểm tra chuỗi bao gồm việc tạo charge幂等 (idempotent charge creation) với Idempotency-Key trên các endpoint thử lại và hoàn tiền.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "Tập trung vào idempotency với các trường như `idempotency-key` trên headers. Các test yêu cầu tạo `charge` với key giống nhau (tương tự) và key khác nhau, sau đó thử lại với hành động tương tự. Hoàn tiền yêu cầu kích hoạt sau mỗi lần thử."
    },
    {
      "question_id": "EQ3050-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi cho quy trình xử lý file: tải lên -> POST /process -> thăm dò trạng thái -> tải xuống, bao gồm cả việc xử lý 202.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Chuỗi kiểm tra: 1) Tải file lên server. 2) Gửi yêu cầu POST /process với mã bài kiểm tra. 3) Xác động trạng thái (đăng nhập, xử lý, cập nhật). 4) Xử lý 202 nếu file được xử lý thành công nhưng không cần phản hồi. 5) Tải file xuống (tùy chọn) hoặc trả tựa. 6) Vệ sinh state DB."
    },
    {
      "question_id": "EQ3052-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "1. **API Gateway:** Send a logout request (e.g., `/logout`) to the session management endpoint. **Microservice:** Verify that a user's session data (e.g., user ID) is cleared from the database within a reasonable timeframe (e.g., 5-10 minutes). 2. **Database Verification:** Perform a SQL query on the microservice's database to confirm the user's session has been terminated (session ID removed, expired, or nullified)."
    },
    {
      "question_id": "EQ3054-VN",
      "question": "Viết một test case chuỗi cho việc thực hiện đơn hàng một phần: tạo đơn hàng -> dự trữ hàng tồn kho -> ship một phần -> hủy phần còn lại và hoàn tiền chênh lệch.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "- **Preconditions:** Đơn hàng (ID=xxx) và hàng tồn kho (tên sản phẩm exist).\n- **Steps:**\n  1. Tạo đơn hàng (`/orders`).\n  2. Dự trữ hàng cho đơn hàng.\n  3. Ship một phần đơn hàng.\n  4. Hủy phần còn lại và kiểm tra hoàn tiền chênh lệch.\n- **Expected:** DB phản ánh số lượng hàng còn lại."
    },
    {
      "question_id": "EQ3056-VN",
      "question": "Cung cấp chính xác một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA: POST /login -> POST /2fa/verify với mã sai -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập 2FA (POST /login)**: Send `POST /login` với mã OTP đúng và thông tin người dùng. 2. **Xác minh 2FA (POST /2fa/verify)**: Send mã OTP sai (ví dụ: `{\"otp\": \"123456\"}`) và mã OTP đúng. 3. **Tiền Refresh (POST /refresh)**: Send yêu cầu refresh token."
    },
    {
      "question_id": "EQ3058-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê (với các xác nhận tổng số đếm).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Đầu tiên, tạo các trường mẫu (e.g., ID=999, tên='Test Item'). Tiếp theo, chạy các thao tác theo quy tắc (tạo 10, xóa 5, liệt kê sau tạo và xóa). Cuối cùng, so sánh số liệu cơ bản (tổng số, ID) giữa các bước và kết luận phân trang là thành công."
    },
    {
      "question_id": "EQ3060-VN",
      "question": "Viết một bài kiểm tra chuỗi cho tính dính session (session stickiness): đăng nhập -> các cuộc gọi tiếp theo qua load balancer -> đăng xuất -> xác minh không có node nào chấp nhận token cũ.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "Đăng nhập -> truy cập API -> đăng xuất -> kiểm tra session bị hủy -> kết quả là `403 Forbidden` hoặc token expired."
    },
    {
      "question_id": "EQ4002-VN",
      "question": "Viết một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản: tạo → kích hoạt → tạm ngừng → kích hoạt lại → xóa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "1. **Đầu vào:** Tạo tài khoản mới (mã user exist).\n2. **Trạng thái:** Aktivated → kích hoạt.\n3. **Hành động:** Tạm ngừng tài khoản (status → inactive).\n4. **Trả lời:** Xóa tài khoản → không tồn tại.\n5. **Xử lý lỗi:** Tạo tài khoản đã tồn tại → 409 Conflict.\n6. **Tập hợp:** Tăng quyền (admin) → cập nhật quyền.\n7. **Đặt điều kiện:** Xóa tài khoản không tồn tại → 404 Not Found."
    },
    {
      "question_id": "EQ4004-VN",
      "question": "Thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Action 1 (Create Transaction):** Khởi động giao dịch chuyển tiền từ tài khoản A -> Tai Khoan B với số tiền 10. 2. **Action 2 (Perform Transfer):** Send amount 3 from Tai Khoan A -> Tai Khoang B. 3. **Action 3 (Fail Transfer):** Send amount -3 từ Tai Khoang A -> Tai Khoang B. 4. **Expected Result:** Giao dịch rollback tự động."
    },
    {
      "question_id": "EQ4006-VN",
      "question": "Viết một **test** xác thực chuỗi nhiều dịch vụ: đăng nhập → tạo đơn hàng → xử lý thanh toán → hủy đơn hàng sau khi ghi nhận.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Test: 1) Đăng nhập vào tài khoản. 2) Tạo đơn hàng. 3) Chọn phương thức thanh toán. 4) Xác nhận đơn hàng được tạo thành công. 5) Hủy đơn hàng. 6) Kiểm tra DB, record bị xóa."
    },
    {
      "question_id": "EQ4008-VN",
      "question": "Mô tả một **test state-machine** xác thực vòng đời mật khẩu: đặt → hết hạn → đặt lại → ngăn tái sử dụng.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "Mô tả: Đăng nhập → mãng mật khẩu → nhập mới → không tái sử dụng."
    },
    {
      "question_id": "EQ4010-VN",
      "question": "Viết một **test chained** phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "1. Đăng nhập vào hệ thống với tài khoản hợp lệ.\n2. Chọn `LoanApplication` và chọn branch `Default`.\n3. Triggers API đăng ký khoản vay. Verifies `201 Created` for success. \n4. Simulates lỗi khi đăng nhập với tài khoản có tín dụng kém (kẻ xấu).\n5. Verifies `409 Conflict` hoặc `500 Internal Server Error` là expected."
    },
    {
      "question_id": "EQ4012-VN",
      "question": "Viết một **test** xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra: cập nhật hồ sơ người dùng với các giá trị xung đột.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "**Test:** 1) Tiến hành cập nhật hồ sơ người dùng với giá trị 'tên' = 'John Doe'. 2) Simulate các yêu cầu ghi đồng thời. 3) Verificaton: sau giao dịch, đọc hồ sơ người dùng. **Expected:** Tính toàn vẹn dữ liệu (mã người dùng không thay đổi, trường 'tên' không bị thay đổi bất hợp pháp)."
    },
    {
      "question_id": "EQ4014-VN",
      "question": "Viết một **test chained** rất khó xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Test chained yêu cầu kiểm tra quy trình ký tài liệu chuỗi. Ví dụ, tải file có chữ ký → thực hiện ký → kiểm tra chữ ký → tìm chứng thực. Có thể giả mạo chữ ký, test chỉ xác định thực thể có quyền."
    },
    {
      "question_id": "EQ4017-VN",
      "question": "Viết một **test state-machine** xác thực vòng đời đăng ký: tạo → nâng cấp → hạ cấp → hủy.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Initial State:** Register → `state = 'pending'`.\n2. **Actions & Expected Results:**\n   - **Create:** `state = 'created' → expect DB record created`.\n   - **Upgrade:** `state = 'upgraded' → expect DB field 'level' updated to 'premium' → expect features enabled`.\n   - **Downgrade:** `state = 'downgraded' → expect DB field 'level' set to 'basic' → expect features disabled`.\n   - **Delete:** `state = 'deleted' → expect record removed from DB`."
    },
    {
      "question_id": "EQ4019-VN",
      "question": "Viết một **test chained** rất khó xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "A test chained with a partial failure in a distributed order saga is difficult to design and execute because it requires a complex, automated setup that simulates a specific failure point. This is hard to control and reproduce, as it depends on multiple distributed services failing or recovering in specific ways."
    },
    {
      "question_id": "EQ4021-VN",
      "question": "Viết một **test** rất khó xác minh việc đảo ngược giao dịch tài chính: ghi nợ → ghi có → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "Test tự động simulates giao dịch. Nếu thất bại, DB must có record của giao dịch bị lỗi. Rollback test khó vì cần giả data, simulate lỗi giao dịch, và đảm bảo DB reverted back."
    },
    {
      "question_id": "EQ4023-VN",
      "question": "Thiết kế một **test state-machine** cho kho hàng: thêm hàng → phân bổ → vận chuyển → trả lại → đối chiếu.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Add item → 2) Verify distribution → 3) Simulate shipment → 4) Confirm delivery. All steps must follow state machine logic."
    },
    {
      "question_id": "EQ4025-VN",
      "question": "Viết một **test chained** xác thực vòng đời **session mobile**: đăng nhập → làm mới **token** → đăng xuất → làm mới với **token** cũ → thất bại.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "1. **Đăng nhập**: Viết command `login` với người dùng có quyền.\n2. **Làm mới token**: Viết command `refresh_token` sử dụng token mới nhất.\n3. **Đăng xuất**: Viết command `logout`.\n4. **Làm mới token cũ**: Chained command với token cũ → thất bại (đáp ứng không được hỗ trợ).\n5. **Xác minh kết quả**: Kiểm tra trạng thái cơ sở lưu trữ."
    },
    {
      "question_id": "EQ4027-VN",
      "question": "Viết một **test chained** xác thực API gửi email: gửi → theo dõi mở → hủy đăng ký → đảm bảo không gửi thêm email nào nữa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "1. **Action 1:** Triggers email sending via `send_email` endpoint with valid email = `{\"to\": \"user@example.com\", \"subject\": \"Test\"}`.\n2. **Action 2:** Verifies API returns `200 OK` and DB confirms email sent only once per user.\n3. **Action 3:** Simulates user action → API response: if email sent → `200`, hủy đăng ký → API response → `204 No Content` (no response for successful deletion)."
    },
    {
      "question_id": "EQ4029-VN",
      "question": "Viết một **test chained** rất khó cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại: áp dụng phiếu giảm giá → thanh toán → phiếu giảm giá không hợp lệ → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chained must ensure all states (valid, invalid) are covered with rollback for invalid. Example: 1) Đặt hàng → 2) Áp dụng giảm giá → 3) Giảm giá bị block → 4) Rollback → DB đảm bảo giao dịch reverted."
    }
  ]
}