{
  "timestamp": "20250912_064622",
  "model": "Meta-Llama-3.1-8B-Instruct",
  "summary": {
    "total_questions": 500,
    "mcq_questions": 258,
    "writing_questions": 242,
    "mcq_accuracy": 0.9457364341085271,
    "mcq_correct": 244,
    "mcq_incorrect": 14
  },
  "results": [
    {
      "question_id": "EQ5001",
      "question": "Which HTTP method is commonly used to retrieve data from an API?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is the standard method for retrieving data."
    },
    {
      "question_id": "EQ5002",
      "question": "What does HTTP status code 404 represent?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "OK",
        "B": "Unauthorized",
        "C": "Not Found",
        "D": "Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "404 indicates the requested resource could not be found."
    },
    {
      "question_id": "EQ5003",
      "question": "What is the purpose of the HTTP POST method?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "Retrieve data",
        "B": "Submit data to create resources",
        "C": "Update existing resources",
        "D": "Delete resources"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST is used to create new resources with data in the request body."
    },
    {
      "question_id": "EQ5004",
      "type": "Writing",
      "gold": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "Here is a simple positive test case for a login API:\n\n**Test Case:** Successful Login with Valid Credentials\n\n**Description:** Verify that the login API returns a successful response with a valid username and password combination.\n\n**Preconditions:** The user has a valid account with a registered username and password.\n\n**Steps:**\n\n1. Send a POST request to the login API with the valid username and password.\n2. Verify that the response status code is 200 (OK).\n3. Verify that the response contains the user's details, such as their username and role.\n\n**Expected Result:** The user is successfully logged in, and the response contains the expected user details."
    },
    {
      "question_id": "EQ5005",
      "question": "Which of these HTTP status codes means 'Unauthorized'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates missing or invalid credentials."
    },
    {
      "question_id": "EQ5006",
      "type": "Writing",
      "gold": "User must be logged in and have a valid token.",
      "model_answer": "A common precondition for testing a user profile endpoint is that the user account must exist in the system, with a valid username and password (or API key) for authentication. Additionally, the user's profile information should be populated with relevant data, such as name, email, and other attributes. This ensures that the endpoint can be successfully queried and returns the expected data."
    },
    {
      "question_id": "EQ5007",
      "question": "Which HTTP method is considered idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "PUT",
        "D": "CONNECT"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PUT is idempotent because multiple identical requests have the same effect."
    },
    {
      "question_id": "EQ5008",
      "type": "Writing",
      "gold": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Here's a simple negative test for a register API:\n\n```python\nimport requests\n\ndef test_register_negative():\n    # Test case 1: Register with empty username and password\n    response = requests.post('http://localhost/register', json={'username': '', 'password': 'password'})\n    assert response.status_code == 400\n    \n    # Test case 2: Register with invalid username (too long)\n    response = requests.post('http://localhost/register', json={'username': 'a'*256, 'password': 'password'})\n    assert response.status_code == 400\n    \n    # Test case 3: Register with invalid password (too short)\n    response = requests.post('http://localhost/register', json={'username': 'username', 'password': 'pw'})\n    assert response.status_code == 400\n    \n    # Test case 4: Register with existing username\n    response = requests.post('http://localhost/register', json={'username': 'existing_username', 'password': 'password'})\n    assert response.status_code == 400\n```\n\nThis test suite covers four different negative test cases for the register API:\n\n*   Register with empty username and password\n*   Register with invalid username (too long)\n*   Register with invalid password (too short)\n*   Register with existing username"
    },
    {
      "question_id": "EQ5009",
      "question": "Which HTTP status code means 'OK'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK is the standard success code."
    },
    {
      "question_id": "EQ5010",
      "type": "Writing",
      "gold": "To define the expected structure of request and response data.",
      "model_answer": "In API testing, a schema serves as a blueprint or a contract that defines the structure and format of the data expected from the API, including the types of fields, their relationships, and constraints. This schema helps testers and developers understand the API's data model and ensures that the API returns data in the expected format, making it easier to write and execute API tests."
    },
    {
      "question_id": "EQ5011",
      "question": "Which HTTP method is used to delete a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "DELETE removes the resource specified in the URL."
    },
    {
      "question_id": "EQ5012",
      "type": "Writing",
      "gold": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "To validate a 201 Created response, you can use the following test step:\n\n1. Verify that the HTTP status code is 201.\n2. Check that the response body contains the expected data, such as a unique identifier for the created resource.\n3. Ensure that the response headers include a Location header with the URL of the newly created resource.\n\nExample in Python using the unittest framework:\n```python\ndef test_create_resource(self):\n    response = self.client.post('/resources', data={'name': 'Example Resource'})\n    self.assertEqual(response.status_code, 201)\n    self.assertIn('id', response.json())\n    self.assertIn('Location', response.headers)\n```"
    },
    {
      "question_id": "EQ5013",
      "question": "Which HTTP header is typically used for authentication tokens?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "Accept",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Authorization header carries credentials or tokens."
    },
    {
      "question_id": "EQ5014",
      "type": "Writing",
      "gold": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "The purpose of mocking in API testing is to isolate dependencies and simulate the behavior of external services, such as APIs, databases, or file systems, without actually making requests to them. This allows developers to test the functionality of their code in a controlled environment, reducing the complexity and time required for testing. By mocking, developers can focus on testing the logic of their code rather than the external dependencies."
    },
    {
      "question_id": "EQ5015",
      "question": "Which HTTP status code indicates 'Created'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "403"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created confirms successful creation of a resource."
    },
    {
      "question_id": "EQ5016",
      "type": "Writing",
      "gold": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "Here's an example test case for an API that fetches a product list:\n\n**Test Case:** \"Fetch Product List\"\n\n**Description:** Send a GET request to the `/products` endpoint to retrieve a list of products and verify that the response is successful (200 OK) with at least one product in the response body.\n\n**Expected Result:**\n\n- Status Code: 200 OK\n- Response Body: A list of products with at least one product."
    },
    {
      "question_id": "EQ5017",
      "question": "Which HTTP status indicates 'Internal Server Error'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "403",
        "D": "500"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "500 indicates unexpected server-side failure."
    },
    {
      "question_id": "EQ5018",
      "type": "Writing",
      "gold": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "The purpose of a precondition in a test case is to ensure that the test environment is in a known state before the test is executed, by setting up any necessary conditions or dependencies. This helps to prevent test failures due to external factors and ensures that the test results are reliable and accurate. Preconditions can include setup or initialization of variables, database records, or other system states."
    },
    {
      "question_id": "EQ5019",
      "question": "Which HTTP status is appropriate for forbidden access with valid credentials?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden indicates insufficient permissions despite valid login."
    },
    {
      "question_id": "EQ5020",
      "type": "Writing",
      "gold": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Here is a negative test for file upload with an unsupported format:\n\n**Test Case:** Unsupported File Format Upload\n\n**Description:** When uploading a file with an unsupported format, the application should not allow the file to be uploaded and should display an error message.\n\n**Test Steps:**\n\n1. Open the file upload interface.\n2. Select a file with an unsupported format (e.g..txt).\n3. Click the upload button.\n4. Verify that an error message is displayed indicating that the file format is not supported.\n\n**Expected Result:** The file is not uploaded and an error message is displayed."
    },
    {
      "question_id": "EQ5021",
      "question": "Which HTTP method is typically used for partial updates?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PATCH",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PATCH is used to modify part of a resource."
    },
    {
      "question_id": "EQ5022",
      "type": "Writing",
      "gold": "To explain the objective and scope of a test scenario.",
      "model_answer": "The purpose of a test case description is to provide a clear and concise explanation of the test case, including its objectives, inputs, expected results, and any assumptions made. This description serves as a reference for the test team, stakeholders, and developers, ensuring everyone is on the same page regarding the test case's purpose and expected outcomes. It also facilitates communication and collaboration among team members."
    },
    {
      "question_id": "EQ5023",
      "question": "Which HTTP header indicates the format of request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Accept-Encoding"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Type defines the media type of request body."
    },
    {
      "question_id": "EQ5024",
      "type": "Writing",
      "gold": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "**Test Step: Validate Response Time**\n\n1. Send a GET request to the application's homepage.\n2. Measure the time taken for the response using a timer or a tool like Selenium's `time.sleep()` function.\n3. Verify that the response time is less than 1 second (e.g., assert response_time <= 1000)."
    },
    {
      "question_id": "EQ5025",
      "question": "Which HTTP status code indicates a conflict, such as duplicate resource creation?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict is used when request conflicts with current state."
    },
    {
      "question_id": "EQ5026",
      "question": "Which HTTP status code means 'Bad Request'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 Bad Request indicates invalid syntax or parameters."
    },
    {
      "question_id": "EQ5027",
      "type": "Writing",
      "gold": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "To write a simple positive test for the GET /health endpoint, you can use the following example in Python with the unittest framework:\n\n```python\nimport unittest\nimport requests\n\nclass TestHealthEndpoint(unittest.TestCase):\n\n    def test_health_endpoint(self):\n        response = requests.get('http://localhost:5000/health')\n        self.assertEqual(response.status_code, 200)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test sends a GET request to the /health endpoint and checks if the response status code is 200, indicating a successful response."
    },
    {
      "question_id": "EQ5028",
      "question": "Which HTTP method is used to fully update a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT replaces an existing resource with new data."
    },
    {
      "question_id": "EQ5029",
      "type": "Writing",
      "gold": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "The purpose of using test data management in API testing is to ensure that sensitive and personal data is not exposed during testing, while still allowing for realistic and relevant test scenarios to be created. It helps to manage and generate test data, such as user credentials, payment information, and other sensitive details, in a secure and controlled manner. This approach helps to maintain data privacy and compliance with regulations."
    },
    {
      "question_id": "EQ5030",
      "question": "Which HTTP status indicates 'Forbidden'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "401",
        "D": "403"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "403 Forbidden means user is authenticated but not authorized."
    },
    {
      "question_id": "EQ5031",
      "type": "Writing",
      "gold": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "One easy negative test case for an API expecting JSON format is to send a request with a non-JSON body, such as a plain text string. For example, sending a GET request to the API with the query parameter \"name=John\" instead of a JSON payload. This should result in a server error or an invalid request response."
    },
    {
      "question_id": "EQ5032",
      "question": "Which HTTP status code represents 'Too Many Requests'?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Easy",
      "options": {
        "A": "408",
        "B": "429",
        "C": "503",
        "D": "504"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "429 Too Many Requests is returned when rate limits are exceeded."
    },
    {
      "question_id": "EQ5033",
      "type": "Writing",
      "gold": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions play a crucial role in API testing by verifying the expected outcome of a test, ensuring that the actual response matches the expected response. They help identify whether the API is functioning correctly, or if there are errors or bugs that need to be addressed. By using assertions, developers can write robust tests that catch issues early in the development cycle."
    },
    {
      "question_id": "EQ5034",
      "question": "Which HTTP status indicates a timeout from the server?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "400",
        "C": "200",
        "D": "504"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "504 Gateway Timeout indicates the server did not respond in time."
    },
    {
      "question_id": "EQ5035",
      "type": "Writing",
      "gold": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "Here's a test case in Python using the Pytest framework to check the DELETE /users/{id} endpoint:\n\n```python\nimport pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\n\ndef test_delete_user(client, user):\n    # Arrange\n    user_id = user['id']\n    response = client.delete(f'/users/{user_id}')\n\n    # Assert\n    assert response.status_code == status.HTTP_204_NO_CONTENT\n    assert get_user(client, user_id) is None\n\ndef get_user(client, user_id):\n    response = client.get(f'/users/{user_id}')\n    return response.json()\n```\n\nIn this test case, we first delete a user and then verify that the user is indeed deleted by checking if a GET request to the same user ID returns a 404 status code."
    },
    {
      "question_id": "EQ5036",
      "question": "Which HTTP method is safe (does not change server state)?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is safe because it only retrieves data."
    },
    {
      "question_id": "EQ5037",
      "type": "Writing",
      "gold": "A new resource has been successfully created.",
      "model_answer": "HTTP status 201 Created indicates that a new resource has been successfully created on the server. The request was successful, and the new resource can be found at the URI provided in the Location header of the response. This status code is often used in response to a POST request."
    },
    {
      "question_id": "EQ5038",
      "question": "Which HTTP status is returned when a client request is well-formed but unauthorized?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "401",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized is used for invalid credentials."
    },
    {
      "question_id": "EQ5039",
      "type": "Writing",
      "gold": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "To test the GET /users/{id} endpoint, you can use the following example in a testing framework like Pytest or Unittest:\n\n```python\ndef test_get_user_by_id(client):\n    response = client.get('/users/1')\n    assert response.status_code == 200\n    assert response.json()['id'] == 1\n```\n\nThis test sends a GET request to the endpoint with the user ID 1, checks if the response status code is 200 (OK), and verifies that the response JSON contains the expected user ID."
    },
    {
      "question_id": "EQ5040",
      "question": "Which HTTP status indicates success but no content is returned?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content is returned on successful deletion or empty responses."
    },
    {
      "question_id": "EQ5041",
      "type": "Writing",
      "gold": "It confirms that the request has succeeded.",
      "model_answer": "A 200 OK response is a standard HTTP status code that indicates a successful request. It signifies that the server has received and processed the request, and the response is being returned with a successful status. This code is used to confirm that the request was successful and the data was retrieved or processed correctly."
    },
    {
      "question_id": "EQ5042",
      "question": "Which header is used to specify accepted response formats?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Accept",
        "C": "Authorization",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Accept header tells the server which formats are expected (e.g., application/json)."
    },
    {
      "question_id": "EQ5043",
      "type": "Writing",
      "gold": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "To validate the response for an invalid endpoint, you can use the following negative test:\n\n```python\ndef test_invalid_endpoint():\n    response = requests.get('http://example.com/invalid')\n    assert response.status_code == 404\n    assert response.json()['error'] == 'Not Found'\n```\n\nIn this test, we send a GET request to an invalid endpoint and verify that the response status code is 404 (Not Found) and the JSON response contains an 'error' key with the value 'Not Found'."
    },
    {
      "question_id": "EQ5044",
      "question": "Which HTTP status code is used when the client must authenticate to access a resource?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "403",
        "C": "401",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized requires authentication credentials."
    },
    {
      "question_id": "EQ5045",
      "type": "Writing",
      "gold": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion is a statement in a test case that checks if the actual output or result of a program matches the expected output or result. If the assertion fails, the test case is considered failed, and an error message is typically displayed to indicate the discrepancy. Assertions help ensure that the program behaves as expected and facilitate the debugging process."
    },
    {
      "question_id": "EQ5046",
      "question": "Which HTTP status indicates the server cannot handle the request due to overload?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "503 Service Unavailable",
        "B": "200 OK",
        "C": "404 Not Found",
        "D": "201 Created"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "503 indicates temporary overload or maintenance."
    },
    {
      "question_id": "EQ5047",
      "type": "Writing",
      "gold": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "**Test: Successful File Upload**\n\nGiven a valid file and endpoint URL,\nWhen I send a POST request to the endpoint with the file,\nThen the response status code is 201 and the file is successfully uploaded."
    },
    {
      "question_id": "EQ5048",
      "question": "Which HTTP method is safe and idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "GET",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "GET is both safe and idempotent."
    },
    {
      "question_id": "EQ5049",
      "type": "Writing",
      "gold": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "The 415 Unsupported Media Type error is a HTTP status code indicating that the server cannot process the requested media type. This error typically occurs when the server does not support the format of the data being sent in the request, such as an unsupported file type or an incorrect content type. The client should retry the request with a supported media type or adjust the request accordingly."
    },
    {
      "question_id": "EQ5050",
      "question": "Which HTTP status code means 'Request Timeout'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "408",
        "C": "500",
        "D": "429"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout indicates the client took too long to send the request."
    },
    {
      "question_id": "EQ5051",
      "question": "Which HTTP method is typically used to create a new resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST is the standard method for creating resources."
    },
    {
      "question_id": "EQ5052",
      "type": "Writing",
      "gold": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "Here's a simple positive test for checking product details API:\n\n```python\nimport requests\nimport json\n\ndef test_product_details_api():\n    # Send a GET request to the product details API\n    response = requests.get('https://example.com/product/123')\n    \n    # Check if the response status code is 200 (OK)\n    assert response.status_code == 200\n    \n    # Parse the response content as JSON\n    product_details = json.loads(response.content)\n    \n    # Check if the product details contain the expected information\n    assert product_details['name'] == 'Example Product'\n    assert product_details['price'] == 9.99\n    assert product_details['description'] == 'This is an example product.'\n\ntest_product_details_api()\n```\n\nThis test sends a GET request to the product details API, checks if the response status code is 200, and then verifies that the product details contain the expected information."
    },
    {
      "question_id": "EQ5053",
      "question": "Which HTTP status code is returned when a resource is successfully deleted?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content confirms deletion succeeded."
    },
    {
      "question_id": "EQ5054",
      "type": "Writing",
      "gold": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The purpose of using Authorization headers in API testing is to simulate the authentication process, allowing testers to mimic the behavior of a legitimate user and verify the API's security and access control mechanisms. This helps ensure that the API is properly restricting access to authorized users and data. By incorporating Authorization headers, testers can thoroughly test the API's authentication workflow."
    },
    {
      "question_id": "EQ5055",
      "question": "Which HTTP status code is used when a client sends an invalid JSON payload?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 indicates the request could not be understood due to invalid syntax."
    },
    {
      "question_id": "EQ5056",
      "type": "Writing",
      "gold": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "To write a negative test case for an API requiring authentication, we can test what happens when a request is made without providing valid credentials. This can be done by sending a GET or POST request to the API endpoint without including an Authorization header or with invalid credentials, and verifying that the response is a 401 Unauthorized error."
    },
    {
      "question_id": "EQ5057",
      "question": "Which HTTP method is generally used to update a resource entirely?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT replaces the full resource with new data."
    },
    {
      "question_id": "EQ5058",
      "type": "Writing",
      "gold": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "In API testing, a 500 Internal Server Error is an HTTP status code indicating a server-side error occurred, such as a syntax error in the code, a database connection issue, or an unexpected exception. This error helps identify server-side problems that need to be addressed, and it's a crucial part of API testing to ensure the system's robustness and reliability. By testing for 500 errors, developers can catch and fix issues before they affect users."
    },
    {
      "question_id": "EQ5059",
      "question": "Which HTTP status means 'Conflict'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "409"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict occurs when resource creation/update conflicts with state."
    },
    {
      "question_id": "EQ5060",
      "type": "Writing",
      "gold": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "Here's a positive test case for an API returning a list of orders:\n\n**Test Case:** Retrieve a list of orders successfully\n\n**Description:** Send a GET request to the API endpoint \"/orders\" and verify that the response status code is 200 (OK) and the response body contains a list of at least 5 orders with valid order IDs, customer names, and order dates."
    },
    {
      "question_id": "EQ5061",
      "question": "Which HTTP method is used for partial updates to resources?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH modifies only part of a resource."
    },
    {
      "question_id": "EQ5062",
      "type": "Writing",
      "gold": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "In API testing, response headers serve as metadata that provide additional information about the response, such as caching instructions, content encoding, and security details. They help developers understand how to process the response, including whether it should be cached, how it should be decoded, and whether it requires authentication. By verifying the response headers, testers can ensure that the API is correctly configured and behaving as expected."
    },
    {
      "question_id": "EQ5063",
      "question": "Which HTTP status code is returned when authentication is required but missing?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates missing or invalid credentials."
    },
    {
      "question_id": "EQ5064",
      "type": "Writing",
      "gold": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Here's a negative test for creating a duplicate resource:\n\n**Test Case:** Duplicate Resource Creation\n\n**Precondition:** The resource already exists in the database.\n\n**Test Steps:**\n\n1. Send a POST request to create a new resource with the same attributes as the existing resource.\n2. Verify that the server returns a 400 Bad Request response, indicating that the resource already exists.\n\n**Expected Result:** The server returns a 400 Bad Request response with a message indicating that the resource already exists."
    },
    {
      "question_id": "EQ5065",
      "question": "Which HTTP method is most often used for safe read-only operations?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is safe and read-only."
    },
    {
      "question_id": "EQ5066",
      "type": "Writing",
      "gold": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "In APIs, the \"202 Accepted\" status code is used to indicate that a request has been accepted for processing, but the processing has not been completed yet. This status code is typically used in asynchronous APIs, where the server acknowledges the request and will send a follow-up response once the processing is complete. It provides a way to confirm that the request was received and is being processed, without waiting for the final response."
    },
    {
      "question_id": "EQ5067",
      "question": "Which HTTP status is returned when a resource has been permanently moved?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "302",
        "C": "301",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "301 Moved Permanently indicates redirection."
    },
    {
      "question_id": "EQ5068",
      "type": "Writing",
      "gold": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "One easy positive test for checking API response schema is to verify that the response contains the expected fields when a valid request is made. This can be achieved by asserting that the response JSON has a specific key-value pair, such as `assert response.json['name'] == 'John'`."
    },
    {
      "question_id": "EQ5069",
      "question": "Which HTTP status indicates the request is valid but resource not found?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "404"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "404 Not Found means the resource does not exist."
    },
    {
      "question_id": "EQ5070",
      "type": "Writing",
      "gold": "To provide the actual data returned from an endpoint.",
      "model_answer": "The purpose of the response body in API testing is to verify that the API returns the expected data in the correct format, such as JSON or XML. It allows testers to check the accuracy and completeness of the data, including the presence of required fields and the absence of unnecessary ones. This helps ensure that the API behaves as expected and returns the necessary information to the client."
    },
    {
      "question_id": "EQ5071",
      "question": "Which HTTP status indicates client request timeout?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "500",
        "B": "408",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout means the client did not finish sending in time."
    },
    {
      "question_id": "EQ5072",
      "type": "Writing",
      "gold": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Logout Verification**\n\n1. **Test Case Name:** Verify Successful Logout\n2. **Preconditions:** User is logged in with valid credentials.\n3. **Steps:**\n   - Navigate to the logout page.\n   - Click the logout button.\n   - Verify that the user is redirected to the login page and the session is terminated.\n4. **Expected Result:** The user is successfully logged out, and the session is cleared.\n\n**Test Data:**\n\n- Valid username and password for login.\n\n**Test Environment:** Web browser (e.g., Chrome, Firefox) with the application under test."
    },
    {
      "question_id": "EQ5073",
      "question": "Which HTTP status indicates a successful request returning JSON data?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK is the standard code for successful GETs."
    },
    {
      "question_id": "EQ5074",
      "type": "Writing",
      "gold": "That the server rejects unsupported request body formats.",
      "model_answer": "A 415 Unsupported Media Type error validates the type of media or data being sent in the request, specifically that the client is attempting to send a request with a media type that the server does not support. This error typically occurs when a client sends a request with a specific content type, such as JSON or XML, that the server cannot process. The server is essentially saying that it cannot handle the media type being sent."
    },
    {
      "question_id": "EQ5075",
      "question": "Which HTTP status code indicates server is temporarily down for maintenance?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 is used when service is unavailable due to overload or maintenance."
    },
    {
      "question_id": "EQ5076",
      "question": "Which HTTP method is commonly used for updating only part of a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH is designed for partial updates."
    },
    {
      "question_id": "EQ5077",
      "type": "Writing",
      "gold": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "Here's a simple positive test for the GET /status endpoint:\n\n```python\nimport requests\n\ndef test_status_endpoint():\n    response = requests.get('http://localhost:5000/status')\n    assert response.status_code == 200\n    assert response.json() == {'status': 'ok'}\n\ntest_status_endpoint()\n```\n\nThis test sends a GET request to the /status endpoint and checks that the response status code is 200 and the response body is as expected."
    },
    {
      "question_id": "EQ5078",
      "question": "Which HTTP status indicates a successful resource creation?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 201 Created",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created confirms successful creation of resource."
    },
    {
      "question_id": "EQ5079",
      "type": "Writing",
      "gold": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content response is an HTTP status code that indicates the server successfully processed the request, but there is no additional content to return. This response is often used for actions like deleting a resource or updating a resource without returning any new data. The client can assume the request was successful, but no new data is provided."
    },
    {
      "question_id": "EQ5080",
      "question": "Which HTTP status code is used when a request is valid but access is forbidden?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden means valid credentials but insufficient permissions."
    },
    {
      "question_id": "EQ5081",
      "type": "Writing",
      "gold": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "**Negative Test Case: Invalid Content-Type Header**\n\n**Test Case Name:** InvalidContentTypeHeaderTest\n\n**Description:** Verify that sending an invalid Content-Type header in a request results in a 415 Unsupported Media Type error response.\n\n**Test Steps:**\n\n1. Send a POST request with a valid payload to the server.\n2. Set the Content-Type header to an invalid value, such as \"application/invalid\".\n3. Verify that the server returns a 415 Unsupported Media Type error response."
    },
    {
      "question_id": "EQ5082",
      "question": "Which HTTP status code indicates success but the resource is empty?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "400 Bad Request",
        "D": "204 No Content"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 is returned when no body content is available."
    },
    {
      "question_id": "EQ5083",
      "type": "Writing",
      "gold": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header in API requests is used to specify the data format or media type that the client is able to understand. This allows the server to respond with a format that the client can handle, such as JSON or XML. By including the Accept header, the client can indicate its preferred response format and the server can tailor its response accordingly."
    },
    {
      "question_id": "EQ5084",
      "question": "Which HTTP status code is appropriate for invalid user credentials?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates invalid login credentials."
    },
    {
      "question_id": "EQ5085",
      "type": "Writing",
      "gold": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "To write a simple test case for a successful logout API call, you can use the following steps:\n\n1. Send a POST request to the logout API endpoint with the required headers (e.g., authorization token).\n2. Verify that the response status code is 200 (OK) or another expected status code.\n3. Assert that the response body contains the expected message, such as \"Logged out successfully.\"\n\n```python\nimport requests\n\ndef test_successful_logout():\n    # Send a POST request to the logout API endpoint\n    response = requests.post('https://example.com/logout', headers={'Authorization': 'Bearer token'})\n\n    # Verify the response status code\n    assert response.status_code == 200\n\n    # Verify the response body\n    assert response.json()['message'] == 'Logged out successfully.'\n```"
    },
    {
      "question_id": "EQ5086",
      "question": "Which HTTP method is used to retrieve resource details?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is used to retrieve data."
    },
    {
      "question_id": "EQ5087",
      "type": "Writing",
      "gold": "It means the client must provide valid authentication credentials.",
      "model_answer": "In API testing, a \"401 Unauthorized\" response indicates that the client (usually a web application or a testing tool) is not authenticated or authorized to access the requested resource. This error typically occurs when the client has not provided a valid authentication token, such as a session ID or an API key, or when the authentication credentials are invalid. The server is refusing to provide the requested data due to a lack of proper authorization."
    },
    {
      "question_id": "EQ5088",
      "question": "Which HTTP status code indicates duplicate resource creation attempt?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict means duplicate or conflicting request."
    },
    {
      "question_id": "EQ5089",
      "type": "Writing",
      "gold": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "**Test Case:** Verify Profile Details API\n\n**Description:** As a logged-in user, when I call the profile details API, I expect to receive a successful response with the user's profile information.\n\n**Test Steps:**\n\n1. Call the profile details API with a valid user ID.\n2. Verify the API returns a successful response (200 OK).\n3. Check the response contains the expected profile information (e.g., name, email, etc.)."
    },
    {
      "question_id": "EQ5090",
      "question": "Which HTTP status code indicates request was valid but the server failed to fulfill it?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "500",
        "D": "201"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "500 Internal Server Error signals server-side failure."
    },
    {
      "question_id": "EQ5091",
      "type": "Writing",
      "gold": "It indicates temporary redirection to another URL.",
      "model_answer": "In APIs (Application Programming Interfaces), the \"302 Found\" status code is used to indicate a temporary redirect of the requested resource. This means that the server is redirecting the client to a different URL, often for security, maintenance, or to update the resource location. The client should automatically follow the redirect to the new URL."
    },
    {
      "question_id": "EQ5092",
      "question": "Which HTTP status is correct for a successfully updated resource using PUT?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK indicates the resource was updated successfully."
    },
    {
      "question_id": "EQ5093",
      "type": "Writing",
      "gold": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "**Negative Login Test Case**\n\n**Test Case Name:** Invalid Password Login Attempt\n\n**Description:** This test case verifies that the application correctly handles a negative login attempt with a wrong password.\n\n**Test Steps:**\n\n1. Navigate to the login page.\n2. Enter a valid username.\n3. Enter an incorrect password.\n4. Submit the login form.\n5. Verify that an error message is displayed indicating an invalid password.\n\n**Expected Result:** The application should display an error message and prevent access to the user's account."
    },
    {
      "question_id": "EQ5094",
      "question": "Which HTTP method is safe and cacheable?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "GET",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "GET is safe, idempotent, and cacheable."
    },
    {
      "question_id": "EQ5095",
      "type": "Writing",
      "gold": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "A 422 Unprocessable Entity (also known as HTTP 422 Unprocessable Entity) is an HTTP status code indicating that the server understands the syntax of the request body but was unable to process it due to semantic errors. This error typically occurs when the server can't process the request data due to validation issues, such as missing or invalid data."
    },
    {
      "question_id": "EQ5096",
      "question": "Which HTTP status is appropriate when service is temporarily overloaded?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "201",
        "B": "200",
        "C": "503",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 Service Unavailable indicates overload or maintenance."
    },
    {
      "question_id": "EQ5097",
      "type": "Writing",
      "gold": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "Here's a positive test for the POST /users endpoint:\n\n```python\nimport requests\n\ndef test_create_user():\n    # Send a POST request to create a new user\n    response = requests.post('http://localhost:8000/users', json={\n        'name': 'John Doe',\n        'email': 'john@example.com',\n        'password': 'password123'\n    })\n\n    # Assert that the response status code is 201 (Created)\n    assert response.status_code == 201\n\n    # Assert that the response JSON contains the newly created user\n    user = response.json()\n    assert user['name'] == 'John Doe'\n    assert user['email'] == 'john@example.com'\n```\n\nThis test sends a POST request to the /users endpoint with a JSON payload containing the user's details. It then asserts that the response status code is 201 (Created) and that the response JSON contains the newly created user with the expected details."
    },
    {
      "question_id": "EQ5098",
      "question": "Which HTTP header specifies the size of the request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Length",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Cache-Control"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Length defines body size in bytes."
    },
    {
      "question_id": "EQ5099",
      "type": "Writing",
      "gold": "It refers to the expected successful execution scenario.",
      "model_answer": "In testing, the term 'happy path' refers to a scenario where all inputs or conditions are valid, and the system or application behaves as expected without any errors or issues. This path is often considered the most straightforward or typical use case, where everything goes right, and the system functions correctly. The happy path is typically used as a baseline for testing, to ensure that the system works as intended."
    },
    {
      "question_id": "EQ5100",
      "question": "Which HTTP status code is used when a request method is not allowed on a resource?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "405 Method Not Allowed"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "405 is used when HTTP method is invalid for the resource."
    },
    {
      "question_id": "EQ2001",
      "question": "When designing API tests, which scenario best represents a boundary condition for a pagination parameter?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sending page=2 when total items=200",
        "B": "Sending page=10 when each page size=10 and total items=100",
        "C": "Sending page=11 when total items=100 with size=10",
        "D": "Sending page=1 when size=20 and total items=300"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Sending page=11 when total items=100 with size=10",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Page=11 would exceed the available range (max 10), testing a boundary overflow."
    },
    {
      "question_id": "EQ2002",
      "type": "Writing",
      "gold": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "To design a negative test case for an API endpoint that requires OAuth2 Bearer tokens, you would intentionally omit or provide an invalid token, and then verify that the API returns an expected error response, such as a 401 Unauthorized status code. You would also test scenarios where the token is missing, expired, or invalid."
    },
    {
      "question_id": "EQ2003",
      "question": "Which of the following is the most effective way to validate an API’s response time under simulated user load?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Manual sequential API calls with stopwatch measurement",
        "B": "Automated load test with concurrent virtual users",
        "C": "Single request execution and measuring response time",
        "D": "Unit testing with mocked responses"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Load testing with concurrent virtual users mimics real-world conditions."
    },
    {
      "question_id": "EQ2004",
      "type": "Writing",
      "gold": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "Here are the test cases for a payment refund API endpoint:\n\n**Happy-path test case:**\nTest case: Successful refund\n- Input: Valid payment ID and refund amount\n- Expected outcome: Refund successful, payment status updated to \"refunded\", and response code 200\n\n**Error-path test case:**\nTest case: Invalid payment ID\n- Input: Invalid payment ID and refund amount\n- Expected outcome: Error message returned, payment status remains unchanged, and response code 404"
    },
    {
      "question_id": "EQ2005",
      "question": "Which practice reduces the flakiness of automated API tests running in CI/CD pipelines?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcoding API keys in scripts",
        "B": "Using random sleep delays before assertions",
        "C": "Running tests only once per release",
        "D": "Using stable test data and environment setup hooks"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Stable test data and environment setup reduce randomness and flakiness."
    },
    {
      "question_id": "EQ2006",
      "type": "Writing",
      "gold": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "To validate schema changes in a backward-compatible API upgrade, you can use techniques such as: \n\n1. **Dry-run testing**: Test the updated schema with existing data to ensure compatibility without affecting production data.\n2. **Mocking and stubbing**: Use mock data and stubs to simulate real-world scenarios and verify the updated schema's behavior.\n3. **Automated testing**: Write comprehensive unit tests and integration tests to cover various scenarios and validate the schema's changes.\n\nThese methods help ensure that the updated schema maintains backward compatibility and functions as expected."
    },
    {
      "question_id": "EQ2007",
      "question": "Which of the following represents a correct negative test for input validation on a date-of-birth field?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sending dateOfBirth=‘2025-13-40’",
        "B": "Sending dateOfBirth=‘1990-05-20’",
        "C": "Leaving dateOfBirth empty when optional",
        "D": "Sending dateOfBirth=‘2000-01-01’"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Invalid month/day makes it a correct negative input validation case."
    },
    {
      "question_id": "EQ2008",
      "type": "Writing",
      "gold": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "Mocking is used to isolate the payment API from the real bank service by creating a fake implementation that simulates the bank's responses, allowing the payment API to be tested independently. This is achieved by using a mocking library to create mock objects that mimic the behavior of the bank service, such as returning a successful transaction or throwing an error. By mocking the bank service, the payment API can be thoroughly tested without incurring any costs or risk."
    },
    {
      "question_id": "EQ2009",
      "question": "Which monitoring approach helps detect sudden spikes in API error rates?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Code coverage reports",
        "B": "Manual log review every week",
        "C": "Real-time alerting on error rate metrics",
        "D": "Static code analysis"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Real-time alerting ensures immediate detection of error rate spikes."
    },
    {
      "question_id": "EQ2010",
      "type": "Writing",
      "gold": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "**Boundary Test:** \nTest name: \"Age Boundary Test\"\nInput: `age=18` and `age=65`\nExpected result: Both inputs should be valid and return a successful response.\n\n**Invalid Test:** \nTest name: \"Age Invalid Test\"\nInput: `age=-1` and `age=70`\nExpected result: Both inputs should be invalid and return an error response indicating that the age is out of range."
    },
    {
      "question_id": "EQ2011",
      "question": "Which of these is an example of contract validation in API testing?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking response latency",
        "B": "Validating response JSON matches OpenAPI schema",
        "C": "Measuring server CPU load",
        "D": "Asserting SQL queries from logs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Validating response JSON matches OpenAPI schema",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Contract validation ensures responses match defined schemas."
    },
    {
      "question_id": "EQ2012",
      "type": "Writing",
      "gold": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "To simulate a network timeout error in API testing, you can use tools like Fiddler or Postman to set a custom timeout value for the API request, allowing it to fail after a specified duration. Alternatively, you can use a tool like Apache JMeter to simulate a network delay or timeout, mimicking real-world network conditions. This helps identify and troubleshoot issues related to timeouts in your API."
    },
    {
      "question_id": "EQ2013",
      "question": "Which scenario best represents an intermediate load test?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "10,000 concurrent users for stress testing",
        "B": "Single-user functional check",
        "C": "Unit testing one function",
        "D": "100–200 concurrent users simulating average traffic"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Intermediate load tests simulate moderate, realistic user traffic."
    },
    {
      "question_id": "EQ2014",
      "type": "Writing",
      "gold": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "API precondition: \"The user must have a valid login session.\" \n\nOne step that follows this precondition is: \"The server checks the user's session cookie to verify the login status before processing the request.\""
    },
    {
      "question_id": "EQ2015",
      "question": "Which approach helps detect unauthorized access attempts in an API?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Penetration test using invalid or missing tokens",
        "B": "Unit tests on helper functions",
        "C": "CI pipeline build success",
        "D": "Running API in debug mode"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Penetration tests reveal weaknesses in authorization handling."
    },
    {
      "question_id": "EQ2016",
      "type": "Writing",
      "gold": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "```python\nimport requests\nimport time\n\ndef test_api_rate_limiting():\n    # Make initial request to get the rate limit\n    response = requests.get('https://api.example.com/rate_limit')\n    initial_rate_limit = int(response.json()['rate_limit'])\n\n    # Make multiple requests within the rate limit window\n    for _ in range(initial_rate_limit):\n        requests.get('https://api.example.com/resource')\n\n    # Wait for the rate limit window to expire\n    time.sleep(initial_rate_limit * 0.9)\n\n    # Attempt to make a request after the rate limit has been exceeded\n    try:\n        requests.get('https://api.example.com/resource')\n        assert False, 'Expected API rate limiting to block this request'\n    except requests.exceptions.RequestException as e:\n        assert 'Rate Limit Exceeded' in str(e), 'Expected Rate Limit Exceeded error'\n\ntest_api_rate_limiting()\n```\n\nThis test case makes multiple requests within the rate limit window and then attempts to make another request after the rate limit has been exceeded, verifying that the API rate limiting is enforced correctly."
    },
    {
      "question_id": "EQ2017",
      "question": "Which strategy ensures reproducibility of integration API tests?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Running against random live production data",
        "B": "Using seeded test databases and reset scripts",
        "C": "Hardcoding timestamps in requests",
        "D": "Disabling cleanup steps after tests"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Seeded test data ensures consistent reproducibility."
    },
    {
      "question_id": "EQ2018",
      "type": "Writing",
      "gold": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "One advantage of using service virtualization in API testing is that it allows developers to test APIs in isolation, without relying on the actual backend services. This enables faster testing and reduces the risk of downstream dependencies, making it easier to identify and fix issues early in the development cycle."
    },
    {
      "question_id": "EQ2019",
      "question": "Which of these is an appropriate recovery step if API monitoring detects consistent 500 errors?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Ignore them until next release",
        "B": "Add random retry logic to all clients",
        "C": "Alert ops team and trigger rollback of recent deployment",
        "D": "Turn off error logs"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Rollback and alerts ensure quick mitigation."
    },
    {
      "question_id": "EQ2020",
      "type": "Writing",
      "gold": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "To design a positive test case, provide a valid username and password, such as \"admin\" and \"password123\". For a boundary test case, test the API with a username and password at their maximum allowed lengths, such as \"a\" repeated 20 times and \"password123\" repeated 20 times."
    },
    {
      "question_id": "EQ2021",
      "question": "Which of the following scenarios is an example of a chained API test case?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Calling GET /status repeatedly",
        "B": "Creating a user, then using that user’s ID in GET /profile",
        "C": "Testing an endpoint with invalid headers",
        "D": "Measuring average latency of one endpoint"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Creating a user, then using that user’s ID in GET /profile",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Chained test cases depend on output of one API being input to another."
    },
    {
      "question_id": "EQ2022",
      "type": "Writing",
      "gold": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Test step: \"Send a request with an invalid media type (e.g., 'application/json' with a binary file attachment) to the API endpoint and verify that the response status code is 415 and the response body contains an error message indicating 'Unsupported Media Type'.\""
    },
    {
      "question_id": "EQ2023",
      "question": "Which practice helps detect contract violations early in a CI/CD pipeline?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Load testing in production only",
        "B": "Manual regression testing once a month",
        "C": "Schema validation tests integrated into pipeline",
        "D": "Using mocks for all external dependencies"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Automated schema validation in CI/CD detects breaking changes quickly."
    },
    {
      "question_id": "EQ2024",
      "type": "Writing",
      "gold": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "To test observability when an API experiences a slow database query, you can use a tool like New Relic or Prometheus to instrument the API and database, and then simulate a high load on the API to trigger the slow query. This will allow you to observe the impact of the slow query on the API's performance, including latency, throughput, and error rates. By analyzing the metrics and logs, you can identify the root cause of the slow query and implement optimizations to improve the database's performance."
    },
    {
      "question_id": "EQ2025",
      "question": "Which of the following is an example of a negative authorization test?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Calling DELETE /users without admin privileges",
        "B": "Calling GET /users with valid token",
        "C": "Logging in with valid credentials",
        "D": "Refreshing a valid session token"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Attempting to delete users without privileges tests access restrictions."
    },
    {
      "question_id": "EQ2026",
      "type": "Writing",
      "gold": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "To test API idempotency for a retry scenario, you would send the same request multiple times with the same parameters, verifying that the server either returns the same response or indicates that the request has already been processed, without causing any unintended side effects. This can be achieved using tools like curl or Postman to simulate the retry scenario."
    },
    {
      "question_id": "EQ2027",
      "question": "Which method ensures sensitive API keys are not exposed during automated testing?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcoding them in test scripts",
        "B": "Printing them in CI/CD logs",
        "C": "Storing them in public GitHub repos",
        "D": "Using encrypted environment variables"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Encrypted env variables keep secrets secure."
    },
    {
      "question_id": "EQ2028",
      "type": "Writing",
      "gold": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "Boundary Test: \n- File size: 6 MB, which exceeds the maximum allowed size of 5 MB.\n\nInvalid Test:\n- File type:.docx, which is not a supported file type for the API."
    },
    {
      "question_id": "EQ2029",
      "question": "Which monitoring metric would best indicate a memory leak in an API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Spike in average latency",
        "B": "Steadily increasing memory usage",
        "C": "Decreasing CPU utilization",
        "D": "Random increase in cache hit ratio"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "A memory leak manifests as continuously rising memory usage."
    },
    {
      "question_id": "EQ2030",
      "type": "Writing",
      "gold": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "**Test Case: Missing Required Field 'email' Error Handling**\n\n```python\nimport unittest\nfrom your_module import api_client\n\nclass TestApiErrorHandling(unittest.TestCase):\n\n    def test_missing_email_field(self):\n        # Arrange\n        data = {'name': 'John Doe', 'password': 'password123'}\n        \n        # Act\n        response = api_client.create_user(data)\n        \n        # Assert\n        self.assertEqual(response.status_code, 400)\n        self.assertIn('email', response.json()['errors'])\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this test case, we're verifying that the API returns a 400 error status code and includes 'email' in the error messages when the required 'email' field is missing from the request data."
    },
    {
      "question_id": "EQ2031",
      "question": "Which of the following best describes service virtualization?",
      "type": "MCQ",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Running APIs only in production",
        "B": "Using local database replicas",
        "C": "Simulating unavailable dependencies with virtual services",
        "D": "Replacing backend logic with new microservices"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Service virtualization allows testing without real dependencies."
    },
    {
      "question_id": "EQ2032",
      "type": "Writing",
      "gold": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "To validate retry logic when an API occasionally returns 503, you can design a test with the following steps: \n\n1. Set up a mock API that returns 503 at a certain percentage of requests (e.g., 20%).\n2. Implement the retry logic in your application, specifying the number of retries and the delay between retries.\n3. Test the application's behavior when interacting with the mock API, verifying that it successfully completes the task after the specified number of retries."
    },
    {
      "question_id": "EQ2033",
      "question": "Which error scenario best represents a client-side failure?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "HTTP 400 Bad Request",
        "B": "HTTP 500 Internal Server Error",
        "C": "Database timeout",
        "D": "Out-of-memory on server"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "400 Bad Request indicates client-side invalid request."
    },
    {
      "question_id": "EQ2034",
      "type": "Writing",
      "gold": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "Here's an example of a test case that validates log correlation using a trace ID header:\n\n```python\nimport requests\nfrom unittest import TestCase\n\nclass LogCorrelationTestCase(TestCase):\n    def test_log_correlation(self):\n        # Send a request with a trace ID header\n        headers = {'trace-id': '1234567890'}\n        response = requests.get('https://example.com', headers=headers)\n\n        # Verify that the response contains the original trace ID\n        self.assertEqual(response.headers['trace-id'], '1234567890')\n\n        # Verify that the log correlation is successful\n        self.assertIn('trace-id: 1234567890', response.text)\n```\n\nThis test case sends a GET request with a `trace-id` header, verifies that the response contains the original `trace-id` header, and checks that the log correlation is successful by verifying that the `trace-id` is present in the response text."
    },
    {
      "question_id": "EQ2035",
      "question": "Which of these scenarios requires schema validation during testing?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking average API response time",
        "B": "Ensuring response JSON fields match OpenAPI definition",
        "C": "Measuring throughput under load",
        "D": "Analyzing SQL query logs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Schema validation ensures structural correctness of responses."
    },
    {
      "question_id": "EQ2036",
      "type": "Writing",
      "gold": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "**Test Case: \"API Rate Limiting with Multiple Clients\"**\n\n**Description:** Validate that the API correctly enforces rate limiting when multiple clients are making requests simultaneously.\n\n**Test Steps:**\n\n1. Set up two clients, Client A and Client B, to make concurrent requests to the API at a rate that exceeds the rate limit.\n2. Verify that Client A's requests are successfully processed within the allowed rate limit.\n3. Verify that Client B's requests are blocked or throttled due to exceeding the rate limit.\n\n**Expected Result:** Client B's requests are successfully blocked or throttled, while Client A's requests are processed within the allowed rate limit."
    },
    {
      "question_id": "EQ2037",
      "question": "Which of the following improves reproducibility of API tests in multiple environments?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Using hardcoded environment URLs",
        "B": "Randomizing all test data",
        "C": "Executing tests against production data",
        "D": "Parameterizing endpoints and using environment configs"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Parameterization ensures same test logic works across environments."
    },
    {
      "question_id": "EQ2038",
      "type": "Writing",
      "gold": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "Positive test case: The API endpoint receives a valid request with a phone number and a valid SMS code, and it successfully sends the code to the phone number and returns a success response. \n\nNegative test case: The API endpoint receives a request with an invalid phone number, and it returns an error response with a message indicating that the phone number is invalid."
    },
    {
      "question_id": "EQ2039",
      "question": "Which of these best describes performance baseline testing?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Measuring normal response times under expected load",
        "B": "Testing API with invalid inputs",
        "C": "Validating API against OpenAPI spec",
        "D": "Simulating 10x peak traffic"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Baseline testing captures normal expected performance."
    },
    {
      "question_id": "EQ2040",
      "type": "Writing",
      "gold": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "One advantage of mocking external APIs when testing failure scenarios is that it allows you to control the response and simulate different failure conditions, such as network errors, timeouts, or invalid responses, without relying on external dependencies that may be unavailable or unstable. This enables you to write more comprehensive and robust tests that cover a wide range of failure scenarios, improving the overall quality and reliability of your code."
    },
    {
      "question_id": "EQ2041",
      "question": "Which of these is a correct test case for validating session expiration?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Login with valid credentials, expect 200 OK",
        "B": "Send request with valid token immediately after login",
        "C": "Send request with token after session timeout, expect 401 Unauthorized",
        "D": "Send request without token, expect 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Expired sessions must return 401 Unauthorized."
    },
    {
      "question_id": "EQ2042",
      "type": "Writing",
      "gold": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "Here's an example test case in Python using the unittest framework to validate error handling when an API returns malformed JSON:\n\n```python\nimport unittest\nimport json\nfrom your_api_module import get_data  # replace with your actual API module\n\nclass TestAPIErrorHandling(unittest.TestCase):\n    def test_malformed_json(self):\n        # Simulate a malformed JSON response from the API\n        response = {'key': 'value'}  # invalid JSON format\n        with self.assertRaises(json.JSONDecodeError):\n            get_data(response)  # expected to raise an error\n```"
    },
    {
      "question_id": "EQ2043",
      "question": "Which strategy helps validate backward compatibility after adding new optional fields?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Ensure older clients still work without sending new fields",
        "B": "Force clients to update immediately",
        "C": "Remove old fields from responses",
        "D": "Require schema changes to be breaking"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Backward compatibility means old clients should still function without new fields."
    },
    {
      "question_id": "EQ2044",
      "type": "Writing",
      "gold": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "Test Step: Verify Rate Limiting Headers\n\n* Send a request to the rate-limited resource and verify that the response contains the rate limiting headers, such as X-RateLimit-Remaining, X-RateLimit-Limit, and X-RateLimit-Reset."
    },
    {
      "question_id": "EQ2045",
      "question": "Which is the most effective way to test resilience when an API’s downstream service fails?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "options": {
        "A": "Disable retries in client",
        "B": "Stop testing until service recovers",
        "C": "Run unit tests only",
        "D": "Inject failures using chaos testing or mocks"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Chaos testing/mocks allow controlled simulation of dependency failures."
    },
    {
      "question_id": "EQ2046",
      "type": "Writing",
      "gold": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "One advantage of separating test data from test logic in API testing is that it makes the tests more reusable and maintainable. By keeping test data separate, you can easily modify or update test data without affecting the test logic, making it easier to adapt to changing requirements or data formats. This separation also facilitates collaboration among team members."
    },
    {
      "question_id": "EQ2047",
      "question": "Which response status code is appropriate for a request blocked due to missing authorization header?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Missing authorization results in 401 Unauthorized."
    },
    {
      "question_id": "EQ2048",
      "type": "Writing",
      "gold": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "Here's a test case for validating graceful degradation when API cache is unavailable:\n\n```python\nimport requests\nimport unittest\n\nclass TestGraciousDegradation(unittest.TestCase):\n    def test_api_cache_unavailable(self):\n        # Simulate API cache unavailability by setting a mock cache status code\n        mock_cache_status_code = 500\n        \n        # Send a request to the API with the mock cache status code\n        response = requests.get('https://api.example.com', status_code=mock_cache_status_code)\n        \n        # Assert that the application gracefully degrades and returns a meaningful error message\n        self.assertIn('API cache unavailable', response.text)\n```\n\nThis test case checks if the application correctly handles the scenario where the API cache is unavailable by sending a request to the API with a mock cache status code and asserting that the response contains a meaningful error message."
    },
    {
      "question_id": "EQ2049",
      "question": "Which of the following represents a proper boundary test for a password length field (min=8, max=20)?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Testing with 7, 8, 20, and 21 characters",
        "B": "Testing with 10 characters only",
        "C": "Testing with 15 characters only",
        "D": "Testing with empty password only"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Testing with 7, 8, 20, and 21 characters.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Boundary testing includes values at, below, and above limits."
    },
    {
      "question_id": "EQ2050",
      "type": "Writing",
      "gold": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "One way to validate logging for sensitive fields such as passwords is to use a masked logging approach, where the actual password is replaced with a placeholder or asterisks (*) before being logged. This ensures that the password is not stored or transmitted in plain text, reducing the risk of a data breach. The placeholder can be reconstructed to display the actual password to authorized personnel."
    },
    {
      "question_id": "EQ2051",
      "question": "Which monitoring method helps identify gradual latency increases over weeks?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Single request stopwatch timing",
        "B": "Manual debugging during incidents",
        "C": "Time-series trend analysis with dashboards",
        "D": "Code coverage metrics"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Dashboards and time-series monitoring highlight latency trends."
    },
    {
      "question_id": "EQ2052",
      "type": "Writing",
      "gold": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "Negative test case: A non-ISO 4217 code, such as \"USD123\", should be rejected or highlighted as invalid.\n\nBoundary test case: An ISO 4217 code with a single character, such as \"A\" (for Australian dollar, but not an official ISO 4217 code), should also be rejected or highlighted as invalid."
    },
    {
      "question_id": "EQ2053",
      "question": "Which strategy ensures contract tests remain useful when APIs evolve?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Never updating schema tests",
        "B": "Removing optional fields from tests",
        "C": "Running only manual regression tests",
        "D": "Versioning schema contracts and maintaining backward compatibility"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Versioning and backward compatibility keep contract tests reliable."
    },
    {
      "question_id": "EQ2054",
      "type": "Writing",
      "gold": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "To validate API behavior under network packet loss, we can create a test case using a tool like `locust` or `k6`. Here's an example test case in `locust`:\n\n```python\nimport locust\nfrom locust import HttpUser, task\n\nclass NetworkLossUser(HttpUser):\n    @task(1)\n    def request_with_packet_loss(self):\n        # Simulate a network packet loss by setting a timeout\n        with self.client.get(\"/api/endpoint\", timeout=1) as response:\n            if response.status_code == 200:\n                self.assertGreater(response.elapsed.total_seconds(), 1)\n            else:\n                self.fail(f\"Expected 200, got {response.status_code}\")\n```\n\nThis test case sends a GET request to the `/api/endpoint` and checks if the response takes longer than 1 second to arrive, simulating a network packet loss. If the response is received within the expected time, the test fails."
    },
    {
      "question_id": "EQ2055",
      "question": "Which of these scenarios correctly validates API observability using distributed tracing?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking only HTTP status codes",
        "B": "Following a trace ID across multiple microservices",
        "C": "Checking memory usage in server logs",
        "D": "Using manual testing notes"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tracing IDs track requests across services."
    },
    {
      "question_id": "EQ2056",
      "type": "Writing",
      "gold": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "One method to verify test data cleanup after API test execution is to use an automated script or API that checks the database or data storage for any remaining test data. This can be achieved by querying the database for test data identifiers and verifying that they have been deleted or marked as inactive. If the test data is not found, it indicates successful cleanup."
    },
    {
      "question_id": "EQ2057",
      "question": "Which of the following indicates a denial-of-service vulnerability?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "API accepts unlimited requests without throttling",
        "B": "API returns 404 Not Found",
        "C": "API schema missing a description field",
        "D": "Unit test coverage is low"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Unrestricted requests can exhaust resources, causing DoS."
    },
    {
      "question_id": "EQ2058",
      "type": "Writing",
      "gold": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "To verify proper rollback when a multi-step transaction partially fails, you can write a test case as follows:\n\n```python\nimport unittest\nfrom your_module import DatabaseConnection\n\nclass TestTransactionRollback(unittest.TestCase):\n    def test_partial_failure(self):\n        # Create a database connection\n        conn = DatabaseConnection()\n\n        # Start a transaction\n        conn.start_transaction()\n\n        # Perform a series of operations\n        conn.execute(\"INSERT INTO table1 VALUES (1, 'value1')\")\n        conn.execute(\"INSERT INTO table2 VALUES (2, 'value2')\")\n        conn.execute(\"INSERT INTO table3 VALUES (3, 'value3')\")  # This operation will fail\n\n        # Attempt to commit the transaction\n        with self.assertRaises(Exception):\n            conn.commit()\n\n        # Verify that the failed operation was rolled back\n        self.assertFalse(conn.execute(\"SELECT * FROM table3\").fetchone())\n\n        # Verify that the successful operations were rolled back\n        self.assertFalse(conn.execute(\"SELECT * FROM table1\").fetchone())\n        self.assertFalse(conn.execute(\"SELECT * FROM table2\").fetchone())\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test case simulates a multi-step transaction that partially fails due to an error in the third operation. It then verifies that the failed operation was rolled back, and that the successful operations were also rolled back."
    },
    {
      "question_id": "EQ2059",
      "question": "Which HTTP status code should be validated when an API request is well-formed but forbidden due to role restrictions?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden indicates client is authenticated but not authorized."
    },
    {
      "question_id": "EQ2060",
      "type": "Writing",
      "gold": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "One approach to validating error messages follow a consistent JSON schema across all endpoints is to use a centralized error message repository, where all error messages are defined and validated against a standard JSON schema. This repository can be used to generate error responses across all endpoints, ensuring consistency in error message format and content."
    },
    {
      "question_id": "EQ3001",
      "question": "Which of the following scenarios best represents a multi-hop test involving login and refresh token endpoints?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Send a request to GET /health",
        "B": "Obtain access token via POST /login, then use POST /refresh to extend session",
        "C": "Send request with expired token to protected endpoint",
        "D": "Check status 200 on GET /docs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Multi-hop testing means chaining login with subsequent refresh token usage."
    },
    {
      "question_id": "EQ3002",
      "type": "Writing",
      "gold": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "Here's a sample test case in Python using the `unittest` framework:\n\n```python\nimport unittest\nimport requests\n\nclass TestLoginAndAPIAccess(unittest.TestCase):\n\n    def test_login_and_token_refresh(self):\n        # Login and get access token\n        login_response = requests.post('https://example.com/login', json={'username': 'user', 'password': 'password'})\n        self.assertEqual(login_response.status_code, 200)\n        access_token = login_response.json()['access_token']\n\n        # Refresh token\n        refresh_response = requests.post('https://example.com/refresh', json={'refresh_token': login_response.json()['refresh_token']})\n        self.assertEqual(refresh_response.status_code, 200)\n        new_access_token = refresh_response.json()['access_token']\n\n        # Access protected API using refreshed token\n        api_response = requests.get('https://example.com/protected', headers={'Authorization': f'Bearer {new_access_token}'})\n        self.assertEqual(api_response.status_code, 200)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test case validates the following:\n\n1. Successful login and retrieval of access token.\n2. Token refresh and retrieval of a new access token.\n3. Access to a protected API using the refreshed token."
    },
    {
      "question_id": "EQ3003",
      "question": "Which HTTP status code should a server return when a refresh token is expired?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "401 Unauthorized",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Expired refresh token means the client must log in again → 401 Unauthorized."
    },
    {
      "question_id": "EQ3004",
      "type": "Writing",
      "gold": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "To validate that a failed login attempt still prevents refresh token generation, we can design a chained test:\n\n1. First, attempt to login with invalid credentials.\n2. Verify that the login attempt is unsuccessful and a refresh token is not generated.\n3. Then, attempt to refresh the access token using the invalid refresh token from step 2.\n4. Verify that the refresh token generation is still blocked and an error response is returned.\n\nThis chained test ensures that even after a failed login attempt, the refresh token generation is still properly blocked."
    },
    {
      "question_id": "EQ3005",
      "question": "Which of the following maps an application-specific error code to the correct HTTP status?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "APP_1001 (User not found) → 404 Not Found",
        "B": "APP_2002 (Invalid password) → 201 Created",
        "C": "APP_3003 (Success) → 500 Internal Server Error",
        "D": "APP_9999 (Database error) → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Mapping user-not-found to 404 is the correct HTTP translation."
    },
    {
      "question_id": "EQ3006",
      "type": "Writing",
      "gold": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "To validate correct mapping of business codes to HTTP status codes in API responses, I would use a combination of automated testing and code reviews. Specifically, I would write unit tests to verify that the API's response mapping logic correctly maps business codes to the corresponding HTTP status codes, and also perform code reviews to ensure that the mapping logic is consistent and accurate across the codebase."
    },
    {
      "question_id": "EQ3007",
      "question": "Which scenario demonstrates chained negative testing?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Testing single GET /status request",
        "B": "Valid login followed by accessing /profile",
        "C": "Checking server uptime with GET /health",
        "D": "Logging in with expired password → 401, then retrying refresh token → 401"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Chained negative tests validate failures across endpoints."
    },
    {
      "question_id": "EQ3008",
      "type": "Writing",
      "gold": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "**Test Case: Order Creation, Payment, and Refund**\n\n**Scenario:** A customer places an order, pays for it, and then requests a refund.\n\n**Test Steps:**\n\n1. Create a new order using the `create_order` API with valid order details (e.g., product ID, quantity, customer ID).\n2. Verify that the order is created successfully and the order ID is returned.\n3. Use the `pay_order` API to process payment for the created order with a valid payment method (e.g., credit card, PayPal).\n4. Verify that the payment is processed successfully and the order status is updated to \"paid\".\n5. Simulate a refund request using the `refund_order` API with a valid refund reason.\n6. Verify that the refund is processed successfully and the order status is updated to \"refunded\".\n\n**Expected Outcome:** The order is created, paid, and refunded successfully, and the order status is updated accordingly."
    },
    {
      "question_id": "EQ3009",
      "question": "Which HTTP status code is correct for mapping a custom error ORDER_DUPLICATE to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "404 Not Found",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Duplicate order is a conflict → 409."
    },
    {
      "question_id": "EQ3010",
      "type": "Writing",
      "gold": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "One test case that validates token refresh works across multiple microservices is as follows: \"Test Case: Multi-Service Token Refresh\". In this test case, a user requests access to a protected resource in Microservice A, which redirects the user to the Authentication Service to obtain an access token. The user then refreshes the access token by requesting a new one from the Authentication Service, which should be accepted by Microservice B, verifying that the refreshed token is valid across both services."
    },
    {
      "question_id": "EQ3011",
      "question": "Which scenario correctly validates multi-hop error handling in an e-commerce workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Create order → invalid payment details → 402 Payment Required",
        "B": "Check inventory → product exists → 200 OK",
        "C": "Call healthcheck endpoint → 200 OK",
        "D": "Request product catalog → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Payment failure after order creation is a multi-hop negative test."
    },
    {
      "question_id": "EQ3012",
      "type": "Writing",
      "gold": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "Here's an example of a test that validates mapping of validation error codes to HTTP 400 responses using Python and the Flask testing framework:\n\n```python\nimport unittest\nfrom your_app import app\nfrom your_app import ValidationError\n\nclass TestValidationErrorMapping(unittest.TestCase):\n\n    def setUp(self):\n        self.app = app.test_client()\n\n    def test_validation_error_code_mapped_to_http_400(self):\n        # Test that a specific validation error code returns a 400 response\n        error_code = \"INVALID_EMAIL\"\n        response = self.app.get(\"/validate\", query_string={\"email\": \"invalid_email\"})\n        self.assertEqual(response.status_code, 400)\n        self.assertIn(error_code, response.json[\"error\"])\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nThis test case checks that a specific validation error code (`INVALID_EMAIL`) returns a 400 response with the corresponding error message. You can add more test cases to cover different validation error codes."
    },
    {
      "question_id": "EQ3013",
      "question": "Which of these represents a hard-level chained login test?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Only testing GET /login-docs",
        "B": "Logging in once and stopping",
        "C": "Login → refresh token → logout → confirm refresh fails",
        "D": "Checking GET /health endpoint"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Login → refresh token → logout → confirm refresh fails",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Combines multiple endpoints into a workflow validation."
    },
    {
      "question_id": "EQ3014",
      "type": "Writing",
      "gold": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "To test that expired refresh tokens cannot issue new access tokens, the test case can be designed as follows:\n\n1. Obtain a valid refresh token and access token.\n2. Wait for the refresh token to expire.\n3. Attempt to use the expired refresh token to obtain a new access token.\n4. Verify that the request to obtain a new access token fails, and a suitable error message is returned (e.g., \"refresh token has expired\").\n\nThis test case ensures that the authorization server correctly handles expired refresh tokens and prevents them from being used to obtain new access tokens."
    },
    {
      "question_id": "EQ3015",
      "question": "Which mapping is correct for business error PAYMENT_DECLINED?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Payment declined → 402 Payment Required."
    },
    {
      "question_id": "EQ3016",
      "type": "Writing",
      "gold": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Here's a multi-hop chained test that validates session invalidation after logout:\n\n1. **Step 1: Login**: Send a POST request to the login endpoint with valid credentials to obtain a session ID.\n2. **Step 2: Validate Session**: Send a GET request to a protected endpoint (e.g., user dashboard) to validate that the session ID is valid and the user is logged in.\n3. **Step 3: Logout**: Send a DELETE request to the logout endpoint to invalidate the session.\n4. **Step 4: Validate Session Invalidation**: Send a GET request to the same protected endpoint as in Step 2, but this time, the session ID should be invalid, and the user should be redirected to the login page.\n\nThis multi-hop test chain ensures that the session is properly invalidated after logout and that the application enforces the necessary security checks."
    },
    {
      "question_id": "EQ3017",
      "question": "Which scenario maps to the correct HTTP code for an internal application error?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "APP_TIMEOUT → 200 OK",
        "B": "APP_TIMEOUT → 504 Gateway Timeout",
        "C": "APP_TIMEOUT → 201 Created",
        "D": "APP_TIMEOUT → 400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Timeouts should map to 504 Gateway Timeout."
    },
    {
      "question_id": "EQ3018",
      "type": "Writing",
      "gold": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "To write a test case chaining signup, email verification, and login endpoints, you can use the following steps:\n\n1. Send a POST request to the signup endpoint with valid user credentials and verify the response.\n2. Send a GET request to the email verification endpoint with the user's email and verify the response.\n3. Send a POST request to the signup endpoint (again) with valid user credentials and verify the response.\n4. Send a POST request to the login endpoint with the user's credentials and verify the response.\n\nHere is a sample test case in Python using the `requests` library:\n```python\nimport requests\n\ndef test_signup_email_verification_login():\n    # Step 1: Signup\n    response = requests.post('http://localhost:8000/signup', json={'username': 'test_user', 'email': 'test_user@example.com', 'password': 'password'})\n    assert response.status_code == 201\n    \n    # Step 2: Email Verification\n    response = requests.get('http://localhost:8000/email/verify', params={'email': 'test_user@example.com'})\n    assert response.status_code == 200\n    \n    # Step 3: Signup (again)\n    response = requests.post('http://localhost:8000/signup', json={'username': 'test_user', 'email': 'test_user@example.com', 'password': 'password'})\n    assert response.status_code == 201\n    \n    # Step 4: Login\n    response = requests.post('http://localhost:8000/login', json={'username': 'test_user', 'password': 'password'})\n    assert response.status_code == 200\n```\nNote that this is a simplified example and you should handle errors and edge cases in a real-world test case."
    },
    {
      "question_id": "EQ3019",
      "question": "Which test validates chained role-based access?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login as user → access /admin → expect 403 Forbidden",
        "B": "Login as admin → access /admin → expect 200 OK",
        "C": "Login as user → view profile → 200 OK",
        "D": "GET /health → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Role mismatch leading to 403 is a multi-hop role validation."
    },
    {
      "question_id": "EQ3020",
      "type": "Writing",
      "gold": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "Here's a hard-level chained test validating a password reset flow:\n\n1. **Step 1: User Requests Password Reset**: Send a GET request to the password reset endpoint with a valid username, and verify that the response contains a reset token.\n2. **Step 2: User Submits Reset Token**: Send a POST request to the password reset token endpoint with the reset token, and verify that the response contains a success message.\n3. **Step 3: User Sets New Password**: Send a PATCH request to the password reset endpoint with the new password, and verify that the response contains a success message.\n4. **Step 4: Verify New Password**: Send a GET request to the login endpoint with the new password, and verify that the response contains a successful login message.\n\nThis chained test ensures that the entire password reset flow is working correctly, from requesting a password reset to verifying the new password."
    },
    {
      "question_id": "EQ3021",
      "question": "Which scenario validates a chained login, refresh, and logout sequence?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → use token once",
        "B": "Refresh token immediately after login",
        "C": "Logout only",
        "D": "Login → refresh token → logout → confirm refresh fails"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "This full sequence tests the entire authentication lifecycle."
    },
    {
      "question_id": "EQ3022",
      "type": "Writing",
      "gold": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "Here's an example of chained test case for validating user creation, profile update, and profile retrieval in Python using unittest:\n\n```python\nimport unittest\nfrom unittest.mock import patch\nfrom your_module import User\n\nclass TestUserFunctions(unittest.TestCase):\n\n    @patch('your_module.User.create')\n    def test_user_creation(self, mock_create):\n        # Create a new user\n        user = User.create('test_user', 'password')\n        mock_create.assert_called_once_with('test_user', 'password')\n\n    def test_user_profile_update(self):\n        # Create a new user and update their profile\n        user = User.create('test_user', 'password')\n        user.update_profile('new_name', 'new_email')\n        self.assertEqual(user.name, 'new_name')\n        self.assertEqual(user.email, 'new_email')\n\n    def test_user_profile_retrieval(self):\n        # Create a new user and retrieve their profile\n        user = User.create('test_user', 'password')\n        user.update_profile('new_name', 'new_email')\n        self.assertEqual(user.get_profile(), {'name': 'new_name', 'email': 'new_email'})\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this chained test case, we first create a new user, then update their profile, and finally retrieve their profile. The `@patch` decorator is used to mock the `User.create` method, which allows us to test the creation of a new user without actually creating one."
    },
    {
      "question_id": "EQ3023",
      "question": "Which mapping correctly translates a business error STOCK_OUT to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "201 Created",
        "D": "403 Forbidden"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Stock-out means a conflict with order fulfillment, mapping to 409."
    },
    {
      "question_id": "EQ3024",
      "type": "Writing",
      "gold": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "One test to validate that a refresh token cannot be used after logout is the \"Refresh Token Denial after Logout\" test. This test involves simulating a logout flow, then attempting to use the refresh token to obtain a new access token. The test should verify that the refresh token is denied or revoked after logout, and a new access token cannot be obtained."
    },
    {
      "question_id": "EQ3025",
      "question": "Which scenario validates chained negative testing for a shopping cart workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Add valid item to cart → 200 OK",
        "B": "Checkout with valid payment → 200 OK",
        "C": "Add item → remove item → checkout → expect 400 Bad Request",
        "D": "View cart after login → 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Empty cart checkout is a chained negative scenario."
    },
    {
      "question_id": "EQ3026",
      "type": "Writing",
      "gold": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "```python\nimport unittest\nfrom your_module import authenticate  # Assuming authenticate is the function or class mapping error codes\n\nclass TestAuthenticationErrorMapping(unittest.TestCase):\n    def test_auth_expired_http_status(self):\n        # Test that AUTH_EXPIRED maps to the correct HTTP status\n        self.assertEqual(authenticate.AUTH_EXPIRED, 401)  # Assuming 401 is the expected HTTP status\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this test case, we are asserting that the internal error code `AUTH_EXPIRED` is correctly mapped to the HTTP status `401` (Unauthorized). The `authenticate` module or class is assumed to contain the `AUTH_EXPIRED` error code."
    },
    {
      "question_id": "EQ3027",
      "question": "Which scenario best validates chained order cancellation?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Hard",
      "options": {
        "A": "Create order → cancel order → GET /orders/{id} shows status=cancelled",
        "B": "Cancel non-existent order → 404",
        "C": "Create order only",
        "D": "Check /status endpoint"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Covers lifecycle of order creation → cancellation → verification."
    },
    {
      "question_id": "EQ3028",
      "type": "Writing",
      "gold": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "A chained test for validating email verification failure when the token is invalid could be implemented as follows:\n\n```python\nimport pytest\n\ndef test_email_verification_invalid_token():\n    # Arrange\n    user = create_user()  # Create a user with a valid email\n    invalid_token = \"invalid_token\"  # Create an invalid token\n\n    # Act\n    verification_result = verify_email(user.email, invalid_token)\n\n    # Assert\n    assert verification_result == \"Email verification failed due to invalid token\"\n```\n\nIn this example, the `test_email_verification_invalid_token` function creates a user with a valid email and an invalid token, then calls the `verify_email` function to attempt email verification. The `assert` statement checks that the result of the verification is as expected, indicating that the token is indeed invalid."
    },
    {
      "question_id": "EQ3029",
      "question": "Which mapping correctly translates FILE_TOO_LARGE to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "404 Not Found",
        "D": "413 Payload Too Large"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "File too large should map to 413."
    },
    {
      "question_id": "EQ3030",
      "type": "Writing",
      "gold": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "Here's an example of a test case chaining loan application, credit check, and approval endpoints using Pytest and the requests library:\n\n```python\nimport pytest\nimport requests\n\n@pytest.fixture\ndef loan_application_data():\n    return {\"name\": \"John Doe\", \"age\": 30, \"income\": 50000, \"credit_score\": 700}\n\n@pytest.fixture\ndef credit_check_data():\n    return {\"credit_score\": 700, \"credit_history\": \"good\"}\n\ndef test_loan_application_and_approval(loan_application_data, credit_check_data):\n    # Step 1: Apply for a loan\n    loan_application_url = \"http://localhost:8080/loan-application\"\n    response = requests.post(loan_application_url, json=loan_application_data)\n    assert response.status_code == 201\n    \n    # Step 2: Perform a credit check\n    credit_check_url = \"http://localhost:8080/credit-check\"\n    response = requests.post(credit_check_url, json=credit_check_data)\n    assert response.status_code == 200\n    \n    # Step 3: Approve the loan\n    loan_approval_url = \"http://localhost:8080/loan-approval\"\n    response = requests.post(loan_approval_url, json={\"loan_id\": response.json()[\"loan_id\"]})\n    assert response.status_code == 200\n```\n\nThis test case assumes that the loan application, credit check, and approval endpoints are exposed by a backend service, and that the service returns the expected status codes and JSON responses."
    },
    {
      "question_id": "EQ3031",
      "question": "Which chained sequence validates refresh tokens across multiple sessions?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → logout only",
        "B": "Login → refresh token → logout → login again → confirm old refresh invalid",
        "C": "Refresh token without login",
        "D": "Check GET /status"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Ensures session handling across multiple logins."
    },
    {
      "question_id": "EQ3032",
      "type": "Writing",
      "gold": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "To design a test case chaining signup, password reset, and login with new credentials, the following steps can be taken:\n\n1. **Step 1: Signup**: Test the user successfully signs up with a valid username and password.\n2. **Step 2: Password Reset**: Test the user requests a password reset and successfully receives a reset link, then updates their password with a new valid password.\n3. **Step 3: Login with New Credentials**: Test the user attempts to log in with the newly created password and verify the login is successful.\n\nThis test case ensures the entire password reset process works correctly from signup to login with the new credentials."
    },
    {
      "question_id": "EQ3033",
      "question": "Which mapping is correct for mapping business error INVALID_COUPON?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Invalid coupon should map to 400 Bad Request."
    },
    {
      "question_id": "EQ3034",
      "type": "Writing",
      "gold": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "Here's an example of a test case chaining file upload, virus scan, and download endpoints in Python using the `unittest` framework:\n\n```python\nimport unittest\nimport requests\nimport os\n\nclass TestFileUploadVirusScanDownload(unittest.TestCase):\n\n    def test_file_upload_virus_scan_download(self):\n        # Step 1: Upload file\n        file_path = 'path/to/file.txt'\n        files = {'file': open(file_path, 'rb')}\n        upload_response = requests.post('https://example.com/upload', files=files)\n        self.assertEqual(upload_response.status_code, 201)\n        file_id = upload_response.json()['file_id']\n\n        # Step 2: Virus scan file\n        virus_scan_response = requests.post(f'https://example.com/virus-scan/{file_id}')\n        self.assertEqual(virus_scan_response.status_code, 200)\n        virus_scan_result = virus_scan_response.json()['result']\n\n        # Step 3: Download file if safe\n        if virus_scan_result =='safe':\n            download_response = requests.get(f'https://example.com/download/{file_id}')\n            self.assertEqual(download_response.status_code, 200)\n            self.assertTrue(os.path.isfile('downloaded_file.txt'))\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test case assumes that the endpoints for file upload, virus scan, and download are implemented and available at the specified URLs. The test case also assumes that the file to be uploaded and downloaded is located at the specified path. The test case will fail if the file upload, virus scan, or download fails, or if the virus scan result is not'safe'."
    },
    {
      "question_id": "EQ3035",
      "question": "Which scenario validates correct multi-hop error mapping in payment workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Payment API returns DECLINED → mapped to HTTP 402",
        "B": "Payment API returns APPROVED → mapped to HTTP 404",
        "C": "Payment API returns DECLINED → mapped to HTTP 201",
        "D": "Payment API returns ERROR → mapped to HTTP 200"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Payment declined correctly maps to 402 Payment Required."
    },
    {
      "question_id": "EQ3036",
      "type": "Writing",
      "gold": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "One chained test for validating refresh token reuse prevention is the \"Refresh Token Blacklisting\" test. In this test, a legitimate user logs out and a malicious actor attempts to use the user's previously obtained refresh token to obtain a new access token. The system should detect the blacklisted token and deny the malicious actor's request, demonstrating the refresh token reuse prevention mechanism is working as intended."
    },
    {
      "question_id": "EQ3037",
      "question": "Which mapping is correct for mapping RATE_LIMIT_EXCEEDED to HTTP?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rate limits exceeded should map to 429."
    },
    {
      "question_id": "EQ3038",
      "type": "Writing",
      "gold": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "Here's an example of test case chaining search, add-to-cart, and checkout APIs using Python and the Pytest framework:\n\n```python\nimport pytest\nfrom api_client import APIClient\n\n@pytest.fixture\ndef api_client():\n    return APIClient()\n\ndef test_search_and_checkout(api_client):\n    # Search for products\n    products = api_client.search_products(\"laptop\")\n    assert len(products) > 0\n    \n    # Add product to cart\n    product_id = products[0]['id']\n    api_client.add_product_to_cart(product_id)\n    \n    # Proceed to checkout\n    api_client.proceed_to_checkout()\n    \n    # Confirm order\n    api_client.confirm_order()\n\ndef test_search_and_checkout_negative(api_client):\n    # Search for products\n    products = api_client.search_products(\"non-existent-product\")\n    assert len(products) == 0\n    \n    # Try to add product to cart\n    with pytest.raises(Exception):\n        api_client.add_product_to_cart(123)\n    \n    # Proceed to checkout\n    with pytest.raises(Exception):\n        api_client.proceed_to_checkout()\n    \n    # Confirm order\n    with pytest.raises(Exception):\n        api_client.confirm_order()\n```\n\nIn this example, we have two test cases: `test_search_and_checkout` and `test_search_and_checkout_negative`. The first test case simulates a successful search, add-to-cart, and checkout flow, while the second test case simulates a failed search and checkout flow. The `api_client` fixture provides an instance of the `APIClient` class, which is used to interact with the APIs."
    },
    {
      "question_id": "EQ3039",
      "question": "Which scenario validates chained negative testing in ticket booking workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Book valid ticket → 200 OK",
        "B": "Book ticket → cancel ticket → attempt refund → expect 400 Bad Request",
        "C": "View available seats → 200 OK",
        "D": "Check GET /status → 200 OK"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Chained negative: refunding after cancel is invalid."
    },
    {
      "question_id": "EQ3040",
      "type": "Writing",
      "gold": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "One chained test for validating API session hijacking prevention involves simulating a login request with a valid session token, followed by sending a request to change the user's password or other sensitive information. The test then verifies that the API denies the password change request, as the session token is still valid and the user's session should not be terminated. This ensures the API properly prevents session hijacking by not allowing unauthorized changes to user data."
    },
    {
      "question_id": "EQ3041",
      "question": "Which chained flow correctly validates token rotation with refresh token reuse detection?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → call API once → logout",
        "B": "Login → refresh token → attempt reuse of old refresh → expect 401 Unauthorized",
        "C": "Login only",
        "D": "Refresh without login"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Token reuse must be rejected after rotation to prevent replay attacks."
    },
    {
      "question_id": "EQ3042",
      "type": "Writing",
      "gold": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "Here's a chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints:\n\n```python\ndef test_optimistic_concurrency():\n    # Create a resource\n    resource = client.post('/resources', data={'name': 'example', 'description': 'example'})\n    etag = resource.headers['ETag']\n    \n    # Update the resource\n    updated_resource = client.put(f'/resources/{resource.json()[\"id\"]}', data={'name': 'new_example'}, headers={'If-Match': etag})\n    assert updated_resource.status_code == 200\n    \n    # Read the updated resource to get the new ETag\n    updated_resource_etag = client.get(f'/resources/{resource.json()[\"id\"]}', headers={'If-Match': etag}).headers['ETag']\n    \n    # Attempt to update the resource again with the old ETag\n    outdated_resource = client.put(f'/resources/{resource.json()[\"id\"]}', data={'name': 'another_new_example'}, headers={'If-Match': etag})\n    assert outdated_resource.status_code == 412\n```\n\nThis test case simulates a scenario where multiple users are updating the same resource concurrently. The test case checks that the update operation fails when the user tries to update the resource with an outdated ETag, indicating that optimistic concurrency control is working correctly."
    },
    {
      "question_id": "EQ3043",
      "question": "Which HTTP status should be returned when an If-Match precondition fails due to stale ETag during PUT /resource/{id}?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "412 Precondition Failed",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Stale ETag should map to 412 Precondition Failed."
    },
    {
      "question_id": "EQ3044",
      "type": "Writing",
      "gold": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "To design a multi-hop test verifying an async export job, the following steps can be taken:\n\n1. **POST /exports**: Send a POST request to create a new export job.\n2. **Poll GET /jobs/{id}**: Continuously poll the GET /jobs/{id} endpoint until the job status is marked as \"completed\".\n3. **GET /exports/{id}**: Once the job is complete, retrieve the export by sending a GET request to /exports/{id} to verify its contents.\n\nThis multi-hop test ensures that the async export job is successfully created, executed, and completed, with the expected output verified at the final step."
    },
    {
      "question_id": "EQ3045",
      "question": "Which mapping from business code to HTTP is most appropriate for RESOURCE_VERSION_CONFLICT during update?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Version conflict maps correctly to 409 Conflict."
    },
    {
      "question_id": "EQ3046",
      "type": "Writing",
      "gold": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Here's a chained negative test for OAuth2 Authorization Code:\n\n1. Client attempts to authorize at `/authorize` with an invalid or missing scope, which should result in an error response.\n2. The authorization server should return an error to the client, indicating that the scope is invalid or missing.\n3. The client should not be able to obtain an access token at `/token` because the scope is missing, and therefore cannot make a resource call.\n\nThis test chain validates the authorization server's ability to handle invalid scope requests and prevents unauthorized access to resources."
    },
    {
      "question_id": "EQ3047",
      "question": "Which status code best represents a refresh token presented to the wrong client_id in a multi-tenant system?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "OAuth2 specifies invalid_grant (400) for wrong client/refresh usage."
    },
    {
      "question_id": "EQ3048",
      "type": "Writing",
      "gold": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "Here's an example of a chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints:\n\n```python\nimport pytest\n\n@pytest.mark.usefixtures(\"create_charge\")\ndef test_idempotent_charge_creation(create_charge, client):\n    # Create a charge with idempotency key\n    charge_id = create_charge.id\n    idempotency_key = create_charge.idempotency_key\n    \n    # Retry the charge creation with the same idempotency key\n    response = client.post(f\"/charges\", headers={\"Idempotency-Key\": idempotency_key})\n    assert response.status_code == 201\n    \n    # Refund the charge with the same idempotency key\n    response = client.post(f\"/charges/{charge_id}/refunds\", headers={\"Idempotency-Key\": idempotency_key})\n    assert response.status_code == 201\n    \n    # Verify that the charge and refund were created only once\n    charge_count = client.get(f\"/charges/count\").json()[\"count\"]\n    refund_count = client.get(f\"/refunds/count\").json()[\"count\"]\n    assert charge_count == 1\n    assert refund_count == 1\n\ndef create_charge(client):\n    # Create a charge without idempotency key\n    response = client.post(\"/charges\")\n    assert response.status_code == 201\n    return response.json()\n```\n\nThis test creates a charge without an idempotency key, then uses the `idempotency_key` from the charge to retry the charge creation and refund the charge. It verifies that the charge and refund were created only once."
    },
    {
      "question_id": "EQ3049",
      "question": "Which status mapping is correct for business code INSUFFICIENT_FUNDS from payment gateway?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Insufficient funds → 402 Payment Required."
    },
    {
      "question_id": "EQ3050",
      "type": "Writing",
      "gold": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "Here's an example of a chained test for a file processing pipeline using Python's `unittest` framework and the `requests` library:\n\n```python\nimport unittest\nimport requests\nimport time\n\nclass TestFileProcessingPipeline(unittest.TestCase):\n\n    def test_file_processing_pipeline(self):\n        # Upload a file\n        files = {'file': open('example.txt', 'rb')}\n        response = requests.post('http://localhost:8080/upload', files=files)\n        self.assertEqual(response.status_code, 201)\n        file_id = response.json()['file_id']\n\n        # POST /process with the uploaded file\n        response = requests.post(f'http://localhost:8080/process/{file_id}')\n        self.assertEqual(response.status_code, 202)\n\n        # Poll the status until it's completed\n        while True:\n            response = requests.get(f'http://localhost:8080/status/{file_id}')\n            if response.status_code == 200 and response.json()['status'] == 'completed':\n                break\n            time.sleep(1)\n\n        # Download the processed file\n        response = requests.get(f'http://localhost:8080/download/{file_id}', stream=True)\n        self.assertEqual(response.status_code, 200)\n        with open('processed_example.txt', 'wb') as f:\n            for chunk in response.iter_content(1024):\n                f.write(chunk)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test uploads a file, posts it to the processing endpoint, polls the status until it's completed, and then downloads the processed file. It includes handling for the 202 status code when the processing is in progress."
    },
    {
      "question_id": "EQ3051",
      "question": "Which scenario correctly validates backoff + retry policy across gateway 429 -> 200 transitions?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "options": {
        "A": "API returns 429 Too Many Requests → client retries with backoff → 200 OK",
        "B": "API returns 401 Unauthorized → retry succeeds",
        "C": "API returns 404 Not Found → retry succeeds",
        "D": "API returns 500 → retry without backoff"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Retry with exponential backoff is required for 429 handling."
    },
    {
      "question_id": "EQ3052",
      "type": "Writing",
      "gold": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "Here's a chained test:\n\n1. Log in to the application using a valid user credentials, this should establish a valid SSO session.\n2. Verify that the user can access the protected microservice endpoint without any issues.\n3. Revoke the SSO session using the identity provider's API or the application's admin interface.\n4. Immediately attempt to access the same microservice endpoint again, this should result in an authentication error or a 401 Unauthorized response.\n5. Verify that the error response or the 401 Unauthorized status code is returned to the client, indicating that the SSO session has been successfully revoked.\n\nThis chained test ensures that the SSO session revocation propagates to API gateway and microservice access, and that the application correctly handles the revocation of a valid SSO session."
    },
    {
      "question_id": "EQ3053",
      "question": "Which HTTP code should map to BUSINESS_LIMIT_EXCEEDED when per-user quota blocks a valid, authenticated request?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Quota exhaustion maps to 429 Too Many Requests."
    },
    {
      "question_id": "EQ3054",
      "type": "Writing",
      "gold": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "Here's a chained test for partial order fulfillment:\n\n```python\nimport unittest\nfrom unittest.mock import Mock\n\nclass TestOrderFulfillment(unittest.TestCase):\n\n    def test_partial_order_fulfillment(self):\n        # Create order\n        order_service = Mock()\n        order_service.create_order.return_value = {'id': 1, 'items': [{'product_id': 1, 'quantity': 10}]}\n        order = order_service.create_order('customer', ['product1', 'product2'])\n        \n        # Reserve inventory\n        inventory_service = Mock()\n        inventory_service.reserve_inventory.return_value = {'reserved': True}\n        inventory_service.reserve_inventory(order['id'], order['items'])\n        \n        # Partial ship\n        shipping_service = Mock()\n        shipping_service.partial_ship.return_value = {'shipped': True}\n        shipping_service.partial_ship(order['id'], order['items'][0])\n        \n        # Cancel remaining and refund delta\n        cancel_service = Mock()\n        cancel_service.cancel_remaining_items.return_value = {'cancelled': True}\n        cancel_service.cancel_remaining_items(order['id'])\n        \n        # Assert order status\n        self.assertEqual(order_service.create_order.return_value['status'], 'partial_ship')\n        self.assertEqual(inventory_service.reserve_inventory.return_value['reserved'], True)\n        self.assertEqual(shipping_service.partial_ship.return_value['shipped'], True)\n        self.assertEqual(cancel_service.cancel_remaining_items.return_value['cancelled'], True)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis chained test simulates the creation of an order, reserving inventory, partial shipping, and canceling remaining items with a refund delta. It uses mocking to isolate the dependencies and assert the expected behavior at each step."
    },
    {
      "question_id": "EQ3055",
      "question": "Which mapping is most accurate for error code SIGNATURE_INVALID on webhook delivery verification?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Invalid webhook signature should return 401 Unauthorized."
    },
    {
      "question_id": "EQ3056",
      "type": "Writing",
      "gold": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "Here's a chained negative test for 2FA login:\n\n1. Send a POST request to /login with valid credentials.\n2. Send a POST request to /2fa/verify with an incorrect 2FA code.\n3. Send a POST request to /refresh. The expected result should be a 401 Unauthorized response, indicating that the user is not authenticated due to the incorrect 2FA code."
    },
    {
      "question_id": "EQ3057",
      "question": "Which HTTP code best represents a soft-deleted resource requested by GET /resource/{id} after DELETE (with recoverable state)?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "204 No Content"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Soft-deleted resource should be treated as not found."
    },
    {
      "question_id": "EQ3058",
      "type": "Writing",
      "gold": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "Here's a chained test design:\n\n```python\nimport pytest\n\ndef test_pagination_consistency():\n    # Create 100 items\n    items = []\n    for i in range(100):\n        item = create_item(f\"Item {i}\")  # Assume create_item function exists\n        items.append(item)\n\n    # List items with pagination (page size 10, page 1)\n    page_1 = list_items(page_size=10, page=1)\n    assert len(page_1) == 10\n\n    # Delete first 20 items\n    for item in items[:20]:\n        delete_item(item.id)  # Assume delete_item function exists\n\n    # List items with pagination (page size 10, page 1)\n    page_1 = list_items(page_size=10, page=1)\n    assert len(page_1) == 0\n\n    # List items with pagination (page size 10, page 2)\n    page_2 = list_items(page_size=10, page=2)\n    assert len(page_2) == 80\n\n    # Verify total count\n    total_count = get_total_count()\n    assert total_count == 80\n```\n\nThis test creates 100 items, lists them with pagination, deletes the first 20 items, lists them again with pagination, and verifies the total count."
    },
    {
      "question_id": "EQ3059",
      "question": "Which mapping is correct when dependency outage triggers circuit breaker OPEN, causing gateway to reject requests immediately?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "400 Bad Request"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Circuit breaker OPEN maps to 503 Service Unavailable."
    },
    {
      "question_id": "EQ3060",
      "type": "Writing",
      "gold": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "Here is a chained test for session stickiness:\n\n```python\nimport pytest\nfrom pytest_bellavista.testcase import BellavistaTestCase\n\nclass TestSessionStickiness(BellavistaTestCase):\n    def test_session_stickiness(self):\n        # Login\n        login_response = self.bellavista.login(username=\"user1\", password=\"password1\")\n        token = login_response.json()[\"token\"]\n\n        # Subsequent calls via load balancer\n        subsequent_call_response = self.bellavista.subsequent_call(token=token)\n        assert subsequent_call_response.status_code == 200\n\n        # Logout\n        logout_response = self.bellavista.logout(token=token)\n        assert logout_response.status_code == 200\n\n        # Verify no node accepts old token\n        with pytest.raises(self.bellavista.exceptions.InvalidTokenError):\n            self.bellavista.subsequent_call(token=token)\n```\n\nThis chained test first logs in a user, then makes a subsequent call with the obtained token, logs out the user, and finally attempts to make another call with the old token to verify that the node does not accept it."
    },
    {
      "question_id": "EQ4001",
      "question": "Which chained flow correctly validates an order lifecycle with create → capture → refund, ensuring idempotency across retries?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Create order → retry refund twice → refund fails",
        "B": "Capture payment without creating order",
        "C": "Create order → capture payment → retry capture with same idempotency key → single charge → refund succeeds",
        "D": "Refund before order creation"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Idempotency must ensure duplicate captures do not create multiple charges."
    },
    {
      "question_id": "EQ4002",
      "type": "Writing",
      "gold": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "Here's a state-machine style test validating account lifecycle:\n\n```python\nimport unittest\n\nclass AccountLifecycleTest(unittest.TestCase):\n    def test_account_lifecycle(self):\n        # Create a new account\n        account = {\"status\": \"create\"}\n        \n        # Activate the account\n        self.assertEqual(account, {\"status\": \"activate\"})\n        \n        # Suspend the account\n        self.assertEqual(account, {\"status\": \"suspend\"})\n        \n        # Reactivate the account\n        self.assertEqual(account, {\"status\": \"activate\"})\n        \n        # Delete the account\n        self.assertEqual(account, {\"status\": \"delete\"})\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nHowever, the above code is not a traditional state-machine style test because it doesn't actually test the transitions between states. Here's a more accurate example using a state machine:\n\n```python\nimport unittest\n\nclass Account:\n    def __init__(self):\n        self.status = \"create\"\n        \n    def activate(self):\n        if self.status == \"create\":\n            self.status = \"activate\"\n            return True\n        else:\n            return False\n        \n    def suspend(self):\n        if self.status == \"activate\":\n            self.status = \"suspend\"\n            return True\n        else:\n            return False\n        \n    def reactivate(self):\n        if self.status == \"suspend\":\n            self.status = \"activate\"\n            return True\n        else:\n            return False\n        \n    def delete(self):\n        if self.status == \"activate\" or self.status == \"suspend\":\n            self.status = \"delete\"\n            return True\n        else:\n            return False\n\nclass AccountLifecycleTest(unittest.TestCase):\n    def test_account_lifecycle(self):\n        account = Account()\n        \n        # Create a new account\n        self.assertEqual(account.status, \"create\")\n        \n        # Activate the account\n        self.assertTrue(account.activate())\n        self.assertEqual(account.status, \"activate\")\n        \n        # Suspend the account\n        self.assertTrue(account.suspend())\n        self.assertEqual(account.status, \"suspend\")\n        \n        # Reactivate the account\n        self.assertTrue(account.reactivate())\n        self.assertEqual(account.status, \"activate\")\n        \n        # Delete the account\n        self.assertTrue(account.delete())\n        self.assertEqual(account.status, \"delete\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\nThis code uses a state-machine to validate account lifecycle by testing the transitions between states."
    },
    {
      "question_id": "EQ4003",
      "question": "Which mapping is correct for handling a duplicate transaction detected during a refund request?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Duplicate transaction must map to 409 Conflict."
    },
    {
      "question_id": "EQ4004",
      "type": "Writing",
      "gold": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "Here's a chained test design in Python using the unittest framework:\n\n```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom money_transfer_service import MoneyTransferService\n\nclass TestMoneyTransferService(unittest.TestCase):\n\n    @patch('money_transfer_service.Connection')\n    def setUp(self, mock_connection):\n        self.money_transfer_service = MoneyTransferService()\n\n    def test_successful_money_transfer(self):\n        # Arrange\n        amount = 100\n        self.money_transfer_service.amount = amount\n\n        # Act\n        result = self.money_transfer_service.transfer()\n\n        # Assert\n        self.assertTrue(result)\n\n    @patch('money_transfer_service.Connection.rollback')\n    @patch('money_transfer_service.Connection.commit')\n    def test_step_2_failure(self, mock_commit, mock_rollback):\n        # Arrange\n        amount = 100\n        self.money_transfer_service.amount = amount\n\n        # Act\n        with self.assertRaises(Exception):\n            self.money_transfer_service.transfer()\n\n        # Assert\n        mock_commit.assert_not_called()\n        mock_rollback.assert_called_once()\n\n    @patch('money_transfer_service.Connection.commit')\n    def test_step_3_failure(self, mock_commit):\n        # Arrange\n        amount = 100\n        self.money_transfer_service.amount = amount\n\n        # Act\n        with self.assertRaises(Exception):\n            self.money_transfer_service.transfer()\n\n        # Assert\n        mock_commit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis chained test consists of three test cases:\n\n1. `test_successful_money_transfer`: Verifies that a successful money transfer commits the transaction.\n2. `test_step_2_failure`: Tests that when step 2 of a 3-step money transfer fails, the transaction rolls back.\n3. `test_step_3_failure`: Verifies that when step 3 of a 3-step money transfer fails, the transaction rolls back."
    },
    {
      "question_id": "EQ4005",
      "question": "Which chained scenario validates proper error propagation in a distributed saga transaction?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Start saga → all steps succeed",
        "B": "Start saga → ignore error in step 2",
        "C": "Start saga → rollback ignored",
        "D": "Start saga → step 3 fails → compensating rollback of steps 1 & 2 executed"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Saga pattern ensures compensating actions on failure."
    },
    {
      "question_id": "EQ4006",
      "type": "Writing",
      "gold": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "```python\nimport pytest\nfrom unittest.mock import Mock\n\n# Mocked services\nlogin_service = Mock()\ncreate_order_service = Mock()\nprocess_payment_service = Mock()\ncancel_order_service = Mock()\n\n# Test case for multi-service chain\ndef test_login_create_order_process_payment_cancel_order_after_capture():\n    # Arrange\n    login_service.login.return_value = \"logged_in_user\"\n    create_order_service.create_order.return_value = \"order_id\"\n    process_payment_service.process_payment.return_value = \"payment_id\"\n    cancel_order_service.cancel_order.return_value = None\n\n    # Act\n    login_service.login()\n    create_order_service.create_order(\"logged_in_user\")\n    process_payment_service.process_payment(\"order_id\")\n    cancel_order_service.cancel_order(\"logged_in_user\", \"order_id\")\n\n    # Assert\n    assert login_service.login.called_once()\n    assert create_order_service.create_order.called_once_with(\"logged_in_user\")\n    assert process_payment_service.process_payment.called_once_with(\"order_id\")\n    assert cancel_order_service.cancel_order.called_once_with(\"logged_in_user\", \"order_id\")\n```\n\nThis test case validates the sequence of operations: login, create order, process payment, and cancel order after capture, by asserting that each service was called once with the expected arguments."
    },
    {
      "question_id": "EQ4007",
      "question": "Which error handling scenario best validates sanity checks in payment APIs?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Submitting refund > captured amount → 400 Bad Request",
        "B": "Submitting refund = captured amount → 200 OK",
        "C": "Submitting refund < captured amount → 200 OK",
        "D": "Refund without capture → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Refunds larger than capture must fail with 400."
    },
    {
      "question_id": "EQ4008",
      "type": "Writing",
      "gold": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "One state-machine test validating password lifecycle involves the following steps: \n\n1. Initially, the password is set to \"password123\" and expires after 90 days.\n2. The system checks if the password has expired (true) and allows the user to reset it to a new value, \"newpassword456\", which is not expired.\n3. The system checks if the new password has been reused within the last 180 days (false) and allows the user to proceed."
    },
    {
      "question_id": "EQ4009",
      "question": "Which mapping best validates format error handling for malformed JSON payloads?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Malformed JSON must result in 400 Bad Request."
    },
    {
      "question_id": "EQ4010",
      "type": "Writing",
      "gold": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "Here's an example of a complex chained test covering a loan application flow with branch failure in credit check:\n\n```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom loan_application import LoanApplication\n\nclass TestLoanApplication(unittest.TestCase):\n\n    @patch('loan_application.credit_check')\n    def test_loan_application_flow_with_credit_check_failure(self, mock_credit_check):\n        # Arrange\n        loan_application = LoanApplication('John Doe', 30000, 5)\n        \n        # Act\n        result = loan_application.apply()\n        \n        # Assert\n        self.assertFalse(result)\n        mock_credit_check.assert_called_once_with(loan_application.annual_income, loan_application.credit_history)\n```\n\nIn this example, the test uses the `@patch` decorator to mock the `credit_check` function, which is called during the loan application flow. The test then asserts that the loan application fails (i.e., `result` is `False`) when the credit check fails, and that the `credit_check` function was called with the expected arguments."
    },
    {
      "question_id": "EQ4011",
      "question": "Which chained flow validates consistent state during distributed booking workflow?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Reserve hotel only",
        "B": "Reserve hotel → book flight → flight fails → hotel reservation auto-cancelled",
        "C": "Book flight only",
        "D": "Book hotel and keep reservation even if payment fails"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Reserve hotel → book flight → flight fails → hotel reservation auto-cancelled",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Hotel auto-cancellation ensures consistent state across systems."
    },
    {
      "question_id": "EQ4012",
      "type": "Writing",
      "gold": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "To validate data integrity when concurrent writes occur, we can use the following test scenario:\n\n```python\nimport unittest\nfrom your_module import User\n\nclass TestDataIntegrity(unittest.TestCase):\n\n    def test_concurrent_writes(self):\n        # Create two users with the same ID\n        user1 = User(id=1, name='John', email='john@example.com')\n        user2 = User(id=1, name='Jane', email='jane@example.com')\n\n        # Save the users to the database (simulating concurrent writes)\n        user1.save()\n        user2.save()\n\n        # Verify that the data integrity is maintained\n        self.assertEqual(user1.get(), {'name': 'John', 'email': 'john@example.com'})\n        self.assertEqual(user2.get(), {'name': 'Jane', 'email': 'jane@example.com'})\n\n        # Check if the last write was successful\n        user1.update(name='John Updated', email='john_updated@example.com')\n        self.assertEqual(user1.get(), {'name': 'John Updated', 'email': 'john_updated@example.com'})\n```\n\nThis test ensures that when two users try to update the same user profile with conflicting values, the last write is successful and the data integrity is maintained."
    },
    {
      "question_id": "EQ4013",
      "question": "Which HTTP code is correct for validating sanity check on withdraw > account balance?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "400 Bad Request"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Over-withdrawal must be rejected as 400 Bad Request."
    },
    {
      "question_id": "EQ4014",
      "type": "Writing",
      "gold": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "**Chained Document Signing Test**\n\n**Step 1: Upload and Signing**\n\nUpload a PDF document to a secure server. Use a digital signature library (e.g., Java's Bouncy Castle) to create a digital signature for the uploaded document using a private key (PK) and a corresponding certificate (Cert). The signature is generated using the SHA-256 hash function and the RSA algorithm with a key size of 2048 bits.\n\n**Step 2: Verify the Signature**\n\nUse the same digital signature library to verify the signature using the public key (PK') corresponding to the certificate (Cert). The verification process should confirm that the signature is valid and that the document has not been tampered with.\n\n**Step 3: Tamper Detection**\n\nIntroduce a malicious modification to the signed document, such as adding a new paragraph or changing the content of an existing paragraph. Attempt to re-verify the signature using the same public key (PK') and certificate (Cert). The verification process should detect the tampering and fail to validate the signature.\n\n**Step 4: Re-signing and Re-verification**\n\nUpload the tampered document to the secure server and use the same digital signature library to create a new digital signature for the tampered document using the same private key (PK) and certificate (Cert). Verify the new signature using the public key (PK') corresponding to the certificate (Cert). The verification process should fail to validate the signature due to the tampering.\n\n**Evaluation Criteria**\n\n1. The uploaded document is successfully signed and verified.\n2. The tampered document fails to be verified.\n3. The re-signed tampered document fails to be verified.\n4. The test demonstrates the effectiveness of chained document signing in detecting tampering.\n\n**Assessment**\n\nPass: The test is successful if all criteria are met. Fail: The test fails if any criterion is not met."
    },
    {
      "question_id": "EQ4015",
      "question": "Which scenario validates state rollback when an API partially updates user info and DB transaction fails?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Update fails mid-way → no partial changes persist",
        "B": "Update fails mid-way → partial changes remain",
        "C": "Update fails mid-way → system crashes",
        "D": "Update succeeds despite DB rollback"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Proper rollback prevents partial/inconsistent data."
    },
    {
      "question_id": "EQ4016",
      "question": "Which chained scenario best validates the idempotency of a payment capture endpoint?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "POST /capture twice with different Idempotency-Key values → two charges",
        "B": "POST /capture twice with the same Idempotency-Key → single charge recorded",
        "C": "POST /refund without capture → success",
        "D": "GET /capture-status once"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Idempotency ensures duplicate requests with same key do not create multiple charges."
    },
    {
      "question_id": "EQ4017",
      "type": "Writing",
      "gold": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "Here's an example of a state-machine test validating subscription lifecycle:\n\n```python\nimport unittest\nfrom state_machine import SubscriptionStateMachine\n\nclass TestSubscriptionLifecycle(unittest.TestCase):\n\n    def test_subscription_lifecycle(self):\n        # Create a new subscription\n        subscription = SubscriptionStateMachine('active')\n        self.assertEqual(subscription.state, 'active')\n        \n        # Upgrade the subscription to a higher tier\n        subscription.upgrade('premium')\n        self.assertEqual(subscription.state, 'premium')\n        \n        # Downgrade the subscription to a lower tier\n        subscription.downgrade('basic')\n        self.assertEqual(subscription.state, 'basic')\n        \n        # Cancel the subscription\n        subscription.cancel()\n        self.assertEqual(subscription.state, 'cancelled')\n```\n\nThis test creates a subscription, upgrades it, downgrades it, and then cancels it, verifying that the state-machine transitions to the correct state at each step."
    },
    {
      "question_id": "EQ4018",
      "question": "Which mapping correctly handles application error LIMIT_EXCEEDED for per-account API quota?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rate/limit exceeded maps to 429 Too Many Requests."
    },
    {
      "question_id": "EQ4019",
      "type": "Writing",
      "gold": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom your_module import OrderSaga, Database\n\nclass TestOrderSagaRecovery(unittest.TestCase):\n\n    @patch('your_module.Database')\n    def test_recover_partial_failure(self, mock_db):\n        # Arrange\n        saga = OrderSaga()\n        saga.add_step('step1')\n        saga.add_step('step2')\n        saga.add_step('step3')\n\n        # Act\n        saga.execute()\n\n        # Assert\n        self.assertEqual(saga.status, 'pending')\n        self.assertEqual(saga.step_index, 0)\n\n        # Simulate partial failure\n        saga.fail_step('step1')\n        saga.fail_step('step2')\n\n        # Act\n        saga.recover()\n\n        # Assert\n        self.assertEqual(saga.status, 'failed')\n        self.assertEqual(saga.step_index, 2)\n        self.assertEqual(saga.failure_steps, ['step1','step2'])\n\n    @patch('your_module.Database')\n    def test_recover_partial_failure_with_dependencies(self, mock_db):\n        # Arrange\n        saga = OrderSaga()\n        saga.add_step('step1', dependencies=['step0'])\n        saga.add_step('step2', dependencies=['step1'])\n        saga.add_step('step3', dependencies=['step2'])\n\n        # Act\n        saga.execute()\n\n        # Simulate partial failure\n        saga.fail_step('step1')\n\n        # Act\n        saga.recover()\n\n        # Assert\n        self.assertEqual(saga.status, 'failed')\n        self.assertEqual(saga.step_index, 0)\n        self.assertEqual(saga.failure_steps, ['step1'])\n\n    @patch('your_module.Database')\n    def test_recover_partial_failure_with_cancellation(self, mock_db):\n        # Arrange\n        saga = OrderSaga()\n        saga.add_step('step1')\n        saga.add_step('step2')\n        saga.add_step('step3')\n\n        # Act\n        saga.execute()\n\n        # Simulate partial failure\n        saga.fail_step('step1')\n        saga.cancel_step('step2')\n\n        # Act\n        saga.recover()\n\n        # Assert\n        self.assertEqual(saga.status, 'canceled')\n        self.assertEqual(saga.step_index, 2)\n        self.assertEqual(saga.failure_steps, ['step1'])\n        self.assertEqual(saga.canceled_steps, ['step2'])\n```"
    },
    {
      "question_id": "EQ4020",
      "question": "Which chained flow validates OAuth2 token misuse detection across services?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "options": {
        "A": "Login once",
        "B": "Refresh token immediately",
        "C": "Login → get token → attempt to use token in another client → 403 Forbidden",
        "D": "Logout only"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Login → get token → attempt to use token in another client → 403 Forbidden",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Cross-client token misuse should be forbidden."
    },
    {
      "question_id": "EQ4021",
      "type": "Writing",
      "gold": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "**Financial Transaction Reversal Test**\n\n**Test Case:** Debit → Credit → Rollback\n\n**Test Steps:**\n\n1. Initialize a bank account with a balance of $100.\n2. Perform a debit transaction of $50, updating the balance to $50.\n3. Perform a credit transaction of $75, updating the balance to $125.\n4. Attempt to roll back the last credit transaction, restoring the balance to $50.\n5. Verify that the balance is correctly restored to $50.\n6. Attempt to roll back the last debit transaction, verifying that it is not allowed since the balance is already restored.\n7. Perform another debit transaction of $20, updating the balance to $30.\n8. Verify that the balance is correctly updated to $30.\n9. Perform a rollback of both the last debit and credit transactions, restoring the balance to $100.\n10. Verify that the balance is correctly restored to $100.\n\n**Expected Result:** All transactions are successfully rolled back, and the balance is correctly restored to its original state."
    },
    {
      "question_id": "EQ4022",
      "question": "Which scenario best validates format error handling for XML vs JSON input mismatch?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "Send XML body with Content-Type: application/json → 415 Unsupported Media Type",
        "B": "Send JSON body with application/json → 200 OK",
        "C": "Send XML body with application/xml → 200 OK",
        "D": "Send YAML → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Mismatch in body vs header must result in 415."
    },
    {
      "question_id": "EQ4023",
      "type": "Writing",
      "gold": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "To design a state-machine test for warehouse inventory, we can create a finite state machine with the following states and transitions:\n\n1. **Initial State**: Idle\n   - Transition to **Add Stock** when stock is added.\n\n2. **Add Stock**: Added\n   - Transition to **Allocate** when stock allocation request is received.\n\n3. **Allocate**: Allocated\n   - Transition to **Ship** when stock is allocated for shipping.\n\n4. **Ship**: Shipped\n   - Transition to **Return** when product is returned due to issues.\n\n5. **Return**: Returned\n   - Transition to **Reconcile** when returned product is reconciled.\n\n6. **Reconcile**: Reconciled\n   - Transition to **Idle** when all reconciliations are complete.\n\nThis state-machine test can help ensure that the warehouse inventory system correctly handles the different stages of stock management."
    },
    {
      "question_id": "EQ4024",
      "question": "Which HTTP status is correct when a schema validation error occurs for a nested field?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Schema validation errors must return 400."
    },
    {
      "question_id": "EQ4025",
      "type": "Writing",
      "gold": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "Here's a chained test validating mobile session lifecycle:\n\n```python\nimport unittest\n\nclass TestMobileSessionLifecycle(unittest.TestCase):\n\n    def test_mobile_session_lifecycle(self):\n        # Login and get the token\n        token = self.login()\n        \n        # Token refresh\n        new_token = self.refresh_token(token)\n        self.assertNotEqual(token, new_token)  # Token should be refreshed\n        \n        # Logout\n        self.logout()\n        \n        # Refresh with old token\n        with self.assertRaises(Exception):\n            self.refresh_token(token)  # Should fail with old token\n        \n        # Login again to get a new token\n        new_token = self.login()\n        \n        # Refresh with new token\n        new_token = self.refresh_token(new_token)\n        self.assertEqual(new_token, new_token)  # Token should be refreshed\n        \nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test covers the following scenarios:\n\n1. Login and get the token\n2. Token refresh (new token should be different from the old one)\n3. Logout\n4. Refresh with old token (should fail)\n5. Login again and refresh with new token (should be successful)"
    },
    {
      "question_id": "EQ4026",
      "question": "Which chained scenario validates proper rollback after multi-step booking (flight + hotel) when payment fails?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Book flight → 200 OK",
        "B": "Book hotel → 200 OK",
        "C": "Book flight + hotel → payment succeeds",
        "D": "Book flight + hotel → payment fails → rollback both bookings"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rollback ensures no inconsistent bookings remain."
    },
    {
      "question_id": "EQ4027",
      "type": "Writing",
      "gold": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "Here's an example of a chained test in Python using the `unittest` framework:\n\n```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom your_module import EmailDeliveryAPI\n\nclass TestEmailDeliveryAPI(unittest.TestCase):\n\n    @patch('your_module.EmailDeliveryAPI.send')\n    @patch('your_module.EmailDeliveryAPI.open_tracking')\n    @patch('your_module.EmailDeliveryAPI.unsubscribe')\n    @patch('your_module.EmailDeliveryAPI.send_email')\n    def test_chained_test(self, mock_send_email, mock_unsubscribe, mock_open_tracking, mock_send):\n        # Arrange\n        email_delivery_api = EmailDeliveryAPI('test@example.com')\n        mock_send_email.return_value = True\n        mock_open_tracking.return_value = True\n        mock_unsubscribe.return_value = True\n        mock_send.return_value = True\n\n        # Act\n        email_delivery_api.send('test@example.com')\n        email_delivery_api.open_tracking('test@example.com')\n        email_delivery_api.unsubscribe('test@example.com')\n        email_delivery_api.send('test@example.com')  # Ensure no further emails sent\n\n        # Assert\n        self.assertFalse(mock_send_email.called)  # No further emails sent\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this test, we're mocking the `send`, `open_tracking`, `unsubscribe`, and `send_email` methods of the `EmailDeliveryAPI` class. We then call these methods in order, ensuring that no further emails are sent after the user unsubscribes. The final assertion checks that the `send_email` method was not called after the user unsubscribed."
    },
    {
      "question_id": "EQ4028",
      "question": "Which mapping is correct for application code TOKEN_REPLAY_DETECTED?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Token replay must be treated as 401 Unauthorized."
    },
    {
      "question_id": "EQ4029",
      "type": "Writing",
      "gold": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "Here's an example of a chained test for purchase flow with coupon application and failure branch:\n\n```python\nimport pytest\n\n@pytest.mark.usefixtures(\"setup_test_data\")\nclass TestPurchaseFlow:\n    @pytest.fixture\n    def setup_test_data(self, request):\n        # Set up test data for the test\n        pass\n\n    def test_purchase_flow_with_coupon_application_and_failure(self):\n        # Apply coupon\n        coupon_code = \"COUPON10\"\n        response = apply_coupon(coupon_code)\n        assert response.status_code == 200\n        assert response.json()[\"message\"] == \"Coupon applied successfully\"\n\n        # Checkout\n        response = checkout()\n        assert response.status_code == 200\n        assert response.json()[\"message\"] == \"Order placed successfully\"\n\n        # Coupon invalid\n        invalid_coupon_code = \"INVALID_COUPON\"\n        response = apply_coupon(invalid_coupon_code)\n        assert response.status_code == 400\n        assert response.json()[\"message\"] == \"Invalid coupon code\"\n\n        # Rollback\n        response = rollback()\n        assert response.status_code == 200\n        assert response.json()[\"message\"] == \"Order rolled back successfully\"\n```\n\nNote that this is a high-level example and you would need to implement the `apply_coupon`, `checkout`, and `rollback` functions to interact with your application's API. Additionally, you would need to set up the test data fixture to provide the necessary data for the test."
    },
    {
      "question_id": "EQ4030",
      "question": "Which chained workflow validates asynchronous payment settlement with reconciliation?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Create order only",
        "B": "Create order → capture payment → async settlement → reconcile → final status=settled",
        "C": "Refund without settlement",
        "D": "Check API health"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Asynchronous settlement must reconcile correctly."
    },
    {
      "question_id": "EQ5001-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để truy xuất dữ liệu từ một API?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là phương thức chuẩn để truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5002-VN",
      "question": "Mã trạng thái HTTP 404 đại diện cho điều gì?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "OK",
        "B": "Unauthorized",
        "C": "Not Found",
        "D": "Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Not Found",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "404 cho biết tài nguyên được yêu cầu không thể tìm thấy."
    },
    {
      "question_id": "EQ5003-VN",
      "question": "Mục đích của phương thức HTTP POST là gì?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "Truy xuất dữ liệu",
        "B": "Gửi dữ liệu để tạo tài nguyên",
        "C": "Cập nhật tài nguyên hiện có",
        "D": "Xóa tài nguyên"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST được sử dụng để tạo tài nguyên mới với dữ liệu trong request body."
    },
    {
      "question_id": "EQ5004-VN",
      "type": "Writing",
      "gold": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "Dưới đây là một ví dụ về một test case positive đơn giản cho một API đăng nhập bằng ngôn ngữ Python và thư viện Pytest:\n\n```python\nimport pytest\n\n# Dữ liệu đăng nhập hợp lệ\ndang_nhap_hop_le = {\n    \"username\": \"tai_khoan_hop_le\",\n    \"password\": \"mat_khau_hop_le\"\n}\n\n# Test case đăng nhập hợp lệ\n@pytest.mark.parametrize(\"data, expected_status_code\", [\n    (dang_nhap_hop_le, 200)\n])\ndef test_dang_nhap(data, expected_status_code):\n    # Gửi yêu cầu đăng nhập\n    response = requests.post(\"https://api-dang-nhap.com/login\", json=data)\n    \n    # Kiểm tra trạng thái phản hồi\n    assert response.status_code == expected_status_code\n```\n\nTrong ví dụ trên, chúng ta đang kiểm tra trường hợp đăng nhập hợp lệ bằng cách sử dụng dữ liệu đăng nhập hợp lệ và trạng thái phản hồi mong đợi là 200 (OK)."
    },
    {
      "question_id": "EQ5005-VN",
      "question": "Mã trạng thái HTTP nào trong số này có nghĩa là 'Unauthorized'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
    },
    {
      "question_id": "EQ5006-VN",
      "type": "Writing",
      "gold": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là có một tài khoản người dùng đã đăng ký và được xác thực. Tài khoản này phải có thông tin cá nhân và hồ sơ phù hợp với yêu cầu của endpoint."
    },
    {
      "question_id": "EQ5007-VN",
      "question": "Phương thức HTTP nào được coi là idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "PUT",
        "D": "CONNECT"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PUT",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PUT là idempotent vì nhiều request giống hệt nhau có cùng một hiệu ứng."
    },
    {
      "question_id": "EQ5008-VN",
      "type": "Writing",
      "gold": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Dưới đây là một test negative đơn giản cho một API đăng ký:\n\n```python\nimport requests\n\n# Test trường hợp không cung cấp thông tin đăng ký\nresponse = requests.post('https://api.example.com/register', data={})\nassert response.status_code!= 200, \"Trường hợp không cung cấp thông tin đăng ký không được chặn\"\n\n# Test trường hợp cung cấp thông tin đăng ký không hợp lệ\nresponse = requests.post('https://api.example.com/register', data={'username': 'john', 'password': '123'})\nassert response.status_code!= 200, \"Trường hợp cung cấp thông tin đăng ký không hợp lệ không được chặn\"\n```\n\nLưu ý: Trong test này, chúng ta đang kiểm tra hai trường hợp không mong muốn: không cung cấp thông tin đăng ký và cung cấp thông tin đăng ký không hợp lệ. Chúng ta hy vọng rằng API sẽ trả lại mã trạng thái không đúng (không phải 200) trong cả hai trường hợp này."
    },
    {
      "question_id": "EQ5009-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'OK'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK là mã thành công chuẩn."
    },
    {
      "question_id": "EQ5010-VN",
      "type": "Writing",
      "gold": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "Vai trò của một schema trong API testing là xác định cấu trúc và quy định của dữ liệu mà API sẽ trả về hoặc nhận từ người dùng. Nó giúp kiểm tra xem dữ liệu có đáp ứng các yêu cầu về định dạng, loại và mối quan hệ hay không. Bằng cách sử dụng schema, các nhà phát triển có thể đảm bảo rằng API của họ luôn cung cấp dữ liệu chính xác và thống nhất."
    },
    {
      "question_id": "EQ5011-VN",
      "question": "Phương thức HTTP nào được sử dụng để xóa một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "DELETE xóa tài nguyên được chỉ định trong URL."
    },
    {
      "question_id": "EQ5012-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "Để validate một response 201 Created, ta có thể sử dụng test step sau:\n\n1. Gọi yêu cầu POST với nội dung cần tạo mới (ví dụ: tạo một tài khoản mới).\n2. Kiểm tra trạng thái HTTP response là 201 Created.\n3. Kiểm tra nội dung response có chứa thông tin về tài khoản mới được tạo, bao gồm cả ID và chi tiết của tài khoản."
    },
    {
      "question_id": "EQ5013-VN",
      "question": "HTTP header nào thường được sử dụng cho các authentication token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "Accept",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Authorization header mang thông tin xác thực hoặc token."
    },
    {
      "question_id": "EQ5014-VN",
      "type": "Writing",
      "gold": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mục đích của mocking trong API testing là tạo ra các đối tượng giả lập (fake) để thay thế các dịch vụ bên ngoài, giúp giảm thiểu phụ thuộc vào các dịch vụ đó và tăng tốc độ test. Bằng cách sử dụng mocking, các nhà phát triển có thể kiểm tra chức năng của ứng dụng mà không cần phải gọi đến các dịch vụ bên ngoài, tiết kiệm thời gian và tăng hiệu quả của quá trình test."
    },
    {
      "question_id": "EQ5015-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Created'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "403"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created xác nhận tạo tài nguyên thành công."
    },
    {
      "question_id": "EQ5016-VN",
      "type": "Writing",
      "gold": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "Dưới đây là một ví dụ về test case đơn giản cho API lấy danh sách sản phẩm:\n\n**Test Case 1: Lấy danh sách sản phẩm thành công**\n\n- **Mô tả**: Người dùng gửi yêu cầu GET đến endpoint lấy danh sách sản phẩm.\n- **Thiết lập**: endpoint lấy danh sách sản phẩm, token truy cập hợp lệ.\n- **Kịch bản**: Gửi yêu cầu GET đến endpoint, kiểm tra phản hồi có chứa danh sách sản phẩm và mã trạng thái là 200.\n- **Kết quả mong muốn**: Danh sách sản phẩm được trả về và mã trạng thái là 200.\n\n**Test Case 2: Lấy danh sách sản phẩm khi không có token truy cập**\n\n- **Mô tả**: Người dùng gửi yêu cầu GET đến endpoint lấy danh sách sản phẩm mà không có token truy cập.\n- **Thiết lập**: endpoint lấy danh sách sản phẩm.\n- **Kịch bản**: Gửi yêu cầu GET đến endpoint mà không có token truy cập, kiểm tra phản hồi có chứa thông báo lỗi và mã trạng thái là 401.\n- **Kết quả mong muốn**: Thông báo lỗi được trả về và mã trạng thái là 401."
    },
    {
      "question_id": "EQ5017-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Internal Server Error'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "403",
        "D": "500"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "500 cho biết lỗi không mong muốn phía server."
    },
    {
      "question_id": "EQ5018-VN",
      "type": "Writing",
      "gold": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Mục đích của một precondition trong một test case là đảm bảo rằng test case được thực hiện trong một trạng thái nhất định trước khi bắt đầu kiểm tra, giúp đảm bảo tính chính xác và đáng tin cậy của kết quả kiểm tra. Precondition giúp loại bỏ các yếu tố không liên quan và tập trung vào các thuộc tính hoặc hành vi cụ thể cần kiểm tra."
    },
    {
      "question_id": "EQ5019-VN",
      "question": "Trạng thái HTTP nào phù hợp cho quyền truy cập bị cấm với thông tin đăng nhập hợp lệ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden cho biết không đủ quyền hạn mặc dù đăng nhập hợp lệ."
    },
    {
      "question_id": "EQ5020-VN",
      "type": "Writing",
      "gold": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Dưới đây là một ví dụ về test negative cho việc upload file với định dạng không được hỗ trợ:\n\n```python\nimport unittest\nfrom unittest.mock import patch\nfrom myapp import upload_file\n\nclass TestUploadFile(unittest.TestCase):\n    @patch('myapp.upload_file')\n    def test_upload_file_invalid_format(self, mock_upload_file):\n        # Gán giá trị trả về của mock_upload_file\n        mock_upload_file.return_value = False\n        # Gọi hàm upload_file với file có định dạng không được hỗ trợ\n        result = upload_file('invalid_file.txt')\n        # Kiểm tra kết quả\n        self.assertFalse(result)\n```\n\nTrong ví dụ trên, chúng ta sử dụng `@patch` để mock hàm `upload_file` và gán giá trị trả về là `False`. Sau đó, chúng ta gọi hàm `upload_file` với file có định dạng không được hỗ trợ và kiểm tra kết quả bằng cách sử dụng `self.assertFalse`."
    },
    {
      "question_id": "EQ5021-VN",
      "question": "Phương thức HTTP nào thường được sử dụng cho các partial update?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PATCH",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PATCH được sử dụng để sửa đổi một phần của tài nguyên."
    },
    {
      "question_id": "EQ5022-VN",
      "type": "Writing",
      "gold": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "Mục đích của một test case description là giải thích rõ ràng và chi tiết về yêu cầu hoặc yêu cầu của hệ thống cần được kiểm tra, cũng như các bước cần thực hiện để kiểm tra và xác minh tính đúng đắn của hệ thống. Điều này giúp đảm bảo rằng các yêu cầu được hiểu và thực hiện đúng cách."
    },
    {
      "question_id": "EQ5023-VN",
      "question": "HTTP header nào cho biết định dạng của request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Accept-Encoding"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Content-Type",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Type định nghĩa kiểu media của request body."
    },
    {
      "question_id": "EQ5024-VN",
      "type": "Writing",
      "gold": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "Bước kiểm tra: \n- Tiến hành yêu cầu API.\n- Sử dụng thời gian bắt đầu và thời gian kết thúc để tính thời gian thực hiện.\n- So sánh thời gian thực hiện với thời gian mong muốn (dưới 1 giây) và xác nhận thời gian đáp ứng dưới 1 giây."
    },
    {
      "question_id": "EQ5025-VN",
      "question": "Mã trạng thái HTTP nào cho biết conflict, chẳng hạn như tạo tài nguyên trùng lặp?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict được sử dụng khi request conflict với trạng thái hiện tại."
    },
    {
      "question_id": "EQ5026-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'Bad Request'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 Bad Request cho biết cú pháp hoặc tham số không hợp lệ."
    },
    {
      "question_id": "EQ5027-VN",
      "type": "Writing",
      "gold": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "Dưới đây là một ví dụ về test positive đơn giản cho endpoint GET /health bằng cách sử dụng thư viện unittest của Python:\n\n```python\nimport unittest\nfrom unittest.mock import patch\nfrom your_module import app  # Thay thế bằng tên của module ứng dụng của bạn\n\nclass TestHealthEndpoint(unittest.TestCase):\n    @patch('your_module.app')\n    def test_health_endpoint(self, mock_app):\n        with mock_app.test_client() as client:\n            response = client.get('/health')\n            self.assertEqual(response.status_code, 200)\n            self.assertIn('healthy', response.json)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nLưu ý rằng bạn cần thay thế `your_module` bằng tên của module ứng dụng của mình. Điều này cho phép bạn kiểm tra xem endpoint GET /health có trả về trạng thái 200 và thông tin 'healthy' trong phản hồi JSON hay không."
    },
    {
      "question_id": "EQ5028-VN",
      "question": "Phương thức HTTP nào được sử dụng để cập nhật hoàn toàn một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. PUT",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT thay thế một tài nguyên hiện có bằng dữ liệu mới."
    },
    {
      "question_id": "EQ5029-VN",
      "type": "Writing",
      "gold": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "Mục đích của việc sử dụng test data management trong API testing là cung cấp và quản lý dữ liệu thử nghiệm chính xác và cập nhật cho các cuộc kiểm tra API. Điều này giúp đảm bảo tính nhất quán và hiệu quả của các cuộc kiểm tra, giảm thiểu thời gian và chi phí cần thiết để thực hiện các cuộc kiểm tra."
    },
    {
      "question_id": "EQ5030-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Forbidden'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "401",
        "D": "403"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "403 Forbidden có nghĩa là người dùng đã được xác thực nhưng không được authorization."
    },
    {
      "question_id": "EQ5031-VN",
      "type": "Writing",
      "gold": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Để viết một test negative dễ dàng cho một API mong đợi định dạng JSON, bạn có thể sử dụng các công cụ như Postman, Insomnia hoặc các thư viện kiểm tra tự động như Pytest, Unittest. Bạn có thể tạo các trường hợp test sau:\n\n- Test lỗi format JSON: Gửi yêu cầu với dữ liệu không đúng định dạng JSON.\n- Test lỗi dữ liệu trống: Gửi yêu cầu với dữ liệu trống hoặc không có thông tin cần thiết.\n- Test lỗi dữ liệu không hợp lệ: Gửi yêu cầu với dữ liệu không hợp lệ hoặc không phù hợp với yêu cầu của API.\n\nVí dụ, bạn có thể sử dụng Pytest và thư viện requests để tạo một test negative như sau:\n\n```python\nimport pytest\nimport requests\n\n@pytest.mark.parametrize(\"data\", [\n    {},  # dữ liệu trống\n    {\"name\": \"John\"},  # dữ liệu không đầy đủ\n    {\"name\": \"John\", \"age\": \"abc\"}  # dữ liệu không hợp lệ\n])\ndef test_api(data):\n    response = requests.post(\"https://api.example.com/users\", json=data)\n    assert response.status_code!= 200\n```\n\nTrong ví dụ trên, chúng ta đang kiểm tra xem API sẽ trả về mã trạng thái không phải là 200 khi gửi yêu cầu với dữ liệu không đúng định dạng JSON, trống hoặc không hợp lệ."
    },
    {
      "question_id": "EQ5032-VN",
      "question": "Mã trạng thái HTTP nào đại diện cho 'Too Many Requests'?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Easy",
      "options": {
        "A": "408",
        "B": "429",
        "C": "503",
        "D": "504"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "429 Too Many Requests được trả về khi rate limit bị vượt quá."
    },
    {
      "question_id": "EQ5033-VN",
      "type": "Writing",
      "gold": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "Vai trò của assertion trong API testing là xác minh rằng API đáp ứng được yêu cầu và chức năng mong muốn. Nó giúp phát hiện ra lỗi hoặc vấn đề trong API và cung cấp thông tin chi tiết để khắc phục. Bằng cách sử dụng assertion, các nhà phát triển có thể đảm bảo rằng API hoạt động đúng và ổn định."
    },
    {
      "question_id": "EQ5034-VN",
      "question": "Mã trạng thái HTTP nào cho biết một timeout từ server?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "400",
        "C": "200",
        "D": "504"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "504 Gateway Timeout cho biết server không phản hồi kịp thời."
    },
    {
      "question_id": "EQ5035-VN",
      "type": "Writing",
      "gold": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "Để kiểm tra DELETE /users/{id} hoạt động đúng, bạn có thể tạo một test case như sau:\n\n**Test Case: Xoá một người dùng**\n\n| ID           | Đặt tên cho test case | Mô tả                |\n|--------------|----------------------|----------------------|\n| TC_DELETE_USER| Xoá người dùng thành công| Xoá một người dùng có ID cụ thể|\n\n**Bước 1:** Tạo một người dùng mới với ID cụ thể\n\n**Bước 2:** Gửi yêu cầu DELETE đến /users/{id} với ID người dùng đã tạo\n\n**Bước 3:** Kiểm tra xem người dùng đã được xoá thành công hay không\n\n**Bước 4:** Kiểm tra xem trạng thái HTTP trả về là 200 (OK) hay không\n\n**Bước 5:** Kiểm tra xem người dùng có thể được tìm thấy trên hệ thống hay không"
    },
    {
      "question_id": "EQ5036-VN",
      "question": "Phương thức HTTP nào là safe (không thay đổi trạng thái server)?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là safe vì nó chỉ truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5037-VN",
      "type": "Writing",
      "gold": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "Mã trạng thái HTTP 201 Created cho biết yêu cầu tạo mới một tài nguyên thành công và tài nguyên đã được tạo thành công. Nó thường được sử dụng sau khi tạo mới một tài nguyên, chẳng hạn như một tài khoản hoặc một bài viết."
    },
    {
      "question_id": "EQ5038-VN",
      "question": "Trạng thái HTTP nào được trả về khi một client request được định dạng tốt nhưng bị unauthorized?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "401",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized được sử dụng cho thông tin đăng nhập không hợp lệ."
    },
    {
      "question_id": "EQ5039-VN",
      "type": "Writing",
      "gold": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "Dưới đây là một ví dụ đơn giản về cách viết một test cho API GET /users/{id} sử dụng Pytest và Flask:\n\n```python\nimport pytest\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\n# Định nghĩa route GET /users/{id}\n@app.route('/users/<int:id>', methods=['GET'])\ndef get_user(id):\n    # Tìm user theo id\n    user = {'id': id, 'name': f'User {id}', 'email': f'user{id}@example.com'}\n    return jsonify(user)\n\n# Chạy test\n@pytest.fixture\ndef client():\n    with app.test_client() as client:\n        yield client\n\ndef test_get_user(client):\n    # Gọi API GET /users/1\n    response = client.get('/users/1')\n    # Kiểm tra trạng thái response\n    assert response.status_code == 200\n    # Kiểm tra nội dung response\n    assert response.json == {'id': 1, 'name': 'User 1', 'email': 'user1@example.com'}\n```\n\nTrong ví dụ trên, chúng ta tạo một ứng dụng Flask với route GET /users/{id} và định nghĩa một test sử dụng Pytest để kiểm tra response của API GET /users/1."
    },
    {
      "question_id": "EQ5040-VN",
      "question": "Mã trạng thái HTTP nào cho biết thành công nhưng không có content nào được trả về?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content được trả về khi xóa thành công hoặc response rỗng."
    },
    {
      "question_id": "EQ5041-VN",
      "type": "Writing",
      "gold": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "Mục đích của một response 200 OK là xác nhận rằng yêu cầu của khách hàng đã được xử lý thành công và nội dung được yêu cầu đã được gửi đến. Response này cho biết yêu cầu đã được thực hiện một cách thành công và dữ liệu được yêu cầu đã được gửi đến."
    },
    {
      "question_id": "EQ5042-VN",
      "question": "Header nào được sử dụng để chỉ định các định dạng response được chấp nhận?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Accept",
        "C": "Authorization",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Accept header cho server biết những định dạng nào được mong đợi (ví dụ: application/json)."
    },
    {
      "question_id": "EQ5043-VN",
      "type": "Writing",
      "gold": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "Để viết một test negative để validate response cho một endpoint không hợp lệ, bạn có thể sử dụng các trường hợp sau:\n\n- **Test 1: Endpoint không tồn tại**: Gửi yêu cầu GET đến một endpoint không tồn tại, chẳng hạn như \"/api/non-existent\" và kiểm tra xem response có chứa mã lỗi 404 (Not Found) hay không.\n\n- **Test 2: Endpoint yêu cầu tham số không hợp lệ**: Gửi yêu cầu GET đến một endpoint nhưng không cung cấp tham số yêu cầu, chẳng hạn như \"/api/users\" mà không cung cấp ID người dùng và kiểm tra xem response có chứa mã lỗi 400 (Bad Request) hay không.\n\n- **Test 3: Endpoint yêu cầu phương thức không phù hợp**: Gửi yêu cầu đến một endpoint bằng phương thức không phù hợp, chẳng hạn như gửi yêu cầu POST đến một endpoint chỉ chấp nhận GET và kiểm tra xem response có chứa mã lỗi 405 (Method Not Allowed) hay không.\n\nVí dụ sử dụng Python và thư viện unittest để viết các test trên:\n\n```python\nimport unittest\nimport requests\n\nclass TestEndpoint(unittest.TestCase):\n\n    def test_endpoint_khong_ton_tai(self):\n        response = requests.get('http://example.com/api/non-existent')\n        self.assertEqual(response.status_code, 404)\n\n    def test_endpoint_yeu_cau_tham_so_khong_hop_le(self):\n        response = requests.get('http://example.com/api/users')\n        self.assertEqual(response.status_code, 400)\n\n    def test_endpoint_yeu_cau_phuong_thuc_khong_hop_le(self):\n        response = requests.post('http://example.com/api/users', data={'id': 1})\n        self.assertEqual(response.status_code, 405)\n\nif __name__ == '__main__':\n    unittest.main()\n```"
    },
    {
      "question_id": "EQ5044-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi client phải authenticate để truy cập một tài nguyên?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "403",
        "C": "401",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized yêu cầu thông tin xác thực."
    },
    {
      "question_id": "EQ5045-VN",
      "type": "Writing",
      "gold": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Một test case assertion là một phần của một test case, nó giúp kiểm tra xem một yêu cầu nào đó có được thực hiện đúng hay không. Nếu yêu cầu được thực hiện đúng, assertion sẽ được thực hiện thành công; ngược lại, nếu yêu cầu không được thực hiện đúng, assertion sẽ báo lỗi."
    },
    {
      "question_id": "EQ5046-VN",
      "question": "Trạng thái HTTP nào cho biết server không thể xử lý request do quá tải?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "503 Service Unavailable",
        "B": "200 OK",
        "C": "404 Not Found",
        "D": "201 Created"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "503 cho biết quá tải tạm thời hoặc đang bảo trì."
    },
    {
      "question_id": "EQ5047-VN",
      "type": "Writing",
      "gold": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "Dưới đây là một ví dụ về test positive cho endpoint upload file sử dụng Python và thư viện unittest:\n\n```python\nimport unittest\nfrom unittest.mock import Mock\nfrom your_module import upload_file\n\nclass TestUploadFile(unittest.TestCase):\n    def test_upload_file_success(self):\n        # Tạo mock cho endpoint upload file\n        mock_endpoint = Mock()\n        mock_endpoint.upload_file.return_value = {'file_id': 'file_id','message': 'File uploaded successfully'}\n        \n        # Gọi hàm upload_file với mock endpoint\n        file_id, message = upload_file(mock_endpoint, 'file_path')\n        \n        # Kiểm tra kết quả\n        self.assertEqual(file_id, 'file_id')\n        self.assertEqual(message, 'File uploaded successfully')\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nTrong ví dụ trên, chúng ta tạo một test case để kiểm tra hàm `upload_file` khi endpoint upload file hoạt động đúng. Hàm `upload_file` được gọi với mock endpoint và file path. Kết quả được kiểm tra để đảm bảo file được upload thành công."
    },
    {
      "question_id": "EQ5048-VN",
      "question": "Phương thức HTTP nào là safe và idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "GET",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "GET vừa là safe vừa là idempotent."
    },
    {
      "question_id": "EQ5049-VN",
      "type": "Writing",
      "gold": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "415 Unsupported Media Type là một mã trạng thái HTTP (Hypertext Transfer Protocol) chỉ định rằng phương thức yêu cầu không hỗ trợ phương thức yêu cầu hiện tại. Điều này có nghĩa là máy chủ không thể xử lý yêu cầu theo yêu cầu của trình duyệt hoặc ứng dụng khách. Mã trạng thái này thường xuất hiện khi trình duyệt hoặc ứng dụng khách yêu cầu một định dạng dữ liệu không được hỗ trợ bởi máy chủ."
    },
    {
      "question_id": "EQ5050-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'Request Timeout'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "408",
        "C": "500",
        "D": "429"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout cho biết client mất quá nhiều thời gian để gửi request."
    },
    {
      "question_id": "EQ5051-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để tạo một tài nguyên mới?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST là phương thức chuẩn để tạo tài nguyên."
    },
    {
      "question_id": "EQ5052-VN",
      "type": "Writing",
      "gold": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "Dưới đây là một ví dụ về test positive đơn giản để kiểm tra API chi tiết sản phẩm:\n\n```python\nimport requests\n\n# Gửi yêu cầu GET đến API để lấy chi tiết sản phẩm\nresponse = requests.get('https://api.example.com/product/123')\n\n# Kiểm tra mã trạng thái của phản hồi\nif response.status_code == 200:\n    # Kiểm tra xem dữ liệu trả về có đúng định dạng không\n    assert response.json()['name'] == 'Sản phẩm 123'\n    assert response.json()['price'] == 100.0\n    print('API chi tiết sản phẩm hoạt động đúng')\nelse:\n    print('API chi tiết sản phẩm không hoạt động đúng')\n```\n\nTrong ví dụ này, chúng ta đang gửi yêu cầu GET đến API để lấy chi tiết sản phẩm với ID là 123. Sau đó, chúng ta kiểm tra mã trạng thái của phản hồi và dữ liệu trả về để đảm bảo rằng API hoạt động đúng."
    },
    {
      "question_id": "EQ5053-VN",
      "question": "Mã trạng thái HTTP nào được trả về khi một tài nguyên được xóa thành công?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content xác nhận việc xóa thành công."
    },
    {
      "question_id": "EQ5054-VN",
      "type": "Writing",
      "gold": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "Mục đích của việc sử dụng Authorization headers trong API testing là để mô phỏng việc xác thực và cấp quyền truy cập cho các yêu cầu API. Điều này giúp kiểm tra tính bảo mật và khả năng bảo vệ của API trước các hành vi không được phép, đồng thời cũng kiểm tra tính hợp lệ của các yêu cầu API có chứa thông tin xác thực."
    },
    {
      "question_id": "EQ5055-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một client gửi một JSON payload không hợp lệ?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 cho biết request không thể hiểu được do cú pháp không hợp lệ."
    },
    {
      "question_id": "EQ5056-VN",
      "type": "Writing",
      "gold": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Dưới đây là một ví dụ về test negative case cho một API yêu cầu authentication:\n\n```python\nimport requests\n\ndef test_api_auth_negative():\n    # Gửi yêu cầu GET đến API mà không có token xác thực\n    response = requests.get('https://api.example.com/data', headers={'Authorization': ''})\n    \n    # Kiểm tra mã trạng thái và nội dung phản hồi\n    assert response.status_code == 401, f\"Expected status code 401, but got {response.status_code}\"\n    assert response.json()['error'] == 'Authentication failed', f\"Expected error message 'Authentication failed', but got {response.json()['error']}\"\n\n# Chạy thử nghiệm\ntest_api_auth_negative()\n```\n\nTrong thử nghiệm này, chúng ta gửi yêu cầu GET đến API mà không có token xác thực và kiểm tra mã trạng thái và nội dung phản hồi. Nếu mã trạng thái là 401 và nội dung phản hồi là 'Authentication failed', thì thử nghiệm sẽ thành công."
    },
    {
      "question_id": "EQ5057-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để cập nhật hoàn toàn một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT thay thế hoàn toàn tài nguyên bằng dữ liệu mới."
    },
    {
      "question_id": "EQ5058-VN",
      "type": "Writing",
      "gold": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "500 Internal Server Error là một mã lỗi HTTP thường xuất hiện trong API testing, biểu thị lỗi xảy ra tại phía máy chủ. Trong API testing, lỗi 500 có thể giúp phát hiện lỗi về cơ sở dữ liệu, kết nối mạng, hoặc lỗi logic trong mã nguồn, từ đó giúp nhà phát triển API cải thiện và sửa lỗi."
    },
    {
      "question_id": "EQ5059-VN",
      "question": "Trạng thái HTTP nào có nghĩa là 'Conflict'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "409"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict xảy ra khi việc tạo/cập nhật tài nguyên conflict với trạng thái."
    },
    {
      "question_id": "EQ5060-VN",
      "type": "Writing",
      "gold": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "Dưới đây là một ví dụ về test case positive cho một API trả về danh sách đơn hàng:\n\n**Tên test case:** \"Lấy danh sách đơn hàng thành công\"\n\n**Mô tả:** \"Gửi yêu cầu GET để lấy danh sách đơn hàng và kiểm tra kết quả trả về\"\n\n**Tham số input:**\n\n* URL: \"/api/orders\"\n* Phương thức: GET\n* Đầu vào: không có đầu vào\n\n**Kết quả mong đợi:**\n\n* Trả về danh sách đơn hàng thành công\n* Trả về mã trạng thái HTTP 200 (OK)"
    },
    {
      "question_id": "EQ5061-VN",
      "question": "Phương thức HTTP nào được sử dụng cho các partial update tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH chỉ sửa đổi một phần của tài nguyên."
    },
    {
      "question_id": "EQ5062-VN",
      "type": "Writing",
      "gold": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "Chức năng của response header trong API testing là cung cấp thông tin về trạng thái và nội dung của phản hồi từ server. Response header bao gồm các thông tin như mã trạng thái HTTP, loại nội dung (Content-Type), kích thước phản hồi (Content-Length), và các thông tin khác về phản hồi. Những thông tin này giúp người kiểm tra xác định phản hồi có thành công hay không và nội dung của nó như thế nào."
    },
    {
      "question_id": "EQ5063-VN",
      "question": "Mã trạng thái HTTP nào được trả về khi authentication là bắt buộc nhưng bị thiếu?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
    },
    {
      "question_id": "EQ5064-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "Dưới đây là một ví dụ về test negative cho việc tạo một tài nguyên trùng lặp:\n\n```python\nimport pytest\n\n# Định nghĩa một chức năng tạo tài nguyên\ndef tạo_tài_nguyên(tên_tài_nguyên):\n    tài_nguyên_trung_lặp = {\n        \"tên_tài_nguyên\": tên_tài_nguyên,\n        \"thông_tin\": \"thông tin về tài nguyên\"\n    }\n    return tài_nguyên_trung_lặp\n\n# Test trường hợp không tạo tài nguyên trùng lặp\ndef test_tạo_tài_nguyên_trung_lặp():\n    tên_tài_nguyên = \"tài nguyên 1\"\n    tài_nguyên = tạo_tài_nguyên(tên_tài_nguyên)\n    assert tài_nguyên[\"tên_tài_nguyên\"] == tên_tài_nguyên\n    # Không tạo tài nguyên trùng lặp nên không có thông tin về tài nguyên trùng lặp\n    assert \"tài nguyên trùng lặp\" not in tài_nguyên[\"thông_tin\"]\n\n# Test trường hợp tạo tài nguyên trùng lặp\ndef test_tạo_tài_nguyên_trùng_lặp():\n    tên_tài_nguyên = \"tài nguyên 1\"\n    tài_nguyên_trùng_lặp = tạo_tài_nguyên(tên_tài_nguyên)\n    assert tài_nguyên_trùng_lặp[\"tên_tài_nguyên\"] == tên_tài_nguyên\n    # Tạo tài nguyên trùng lặp nên có thông tin về tài nguyên trùng lặp\n    assert \"tài nguyên trùng lặp\" in tài_nguyên_trùng_lặp[\"thông_tin\"]\n\n# Test trường hợp tạo tài nguyên trùng lặp không thành công\ndef test_tạo_tài_nguyên_trùng_lặp_thất_bại():\n    tên_tài_nguyên = \"tài nguyên 1\"\n    tài_nguyên_trùng_lặp = tạo_tài_nguyên(tên_tài_nguyên)\n    assert tài_nguyên_trùng_lặp[\"tên_tài_nguyên\"] == tên_tài_nguyên\n    # Tạo tài nguyên trùng lặp không thành công nên không có thông tin về tài nguyên trùng lặp\n    assert \"tài nguyên trùng lặp\" not in tài_nguyên_trùng_lặp[\"thông_tin\"]\n```\n\nTrong ví dụ trên, chúng ta đã định nghĩa một chức năng tạo tài nguyên và các test trường hợp để kiểm tra việc"
    },
    {
      "question_id": "EQ5065-VN",
      "question": "Phương thức HTTP nào thường được sử dụng cho các read-only operation an toàn?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là safe và read-only."
    },
    {
      "question_id": "EQ5066-VN",
      "type": "Writing",
      "gold": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "Trong các API, \"202 Accepted\" là một trạng thái HTTP (Hypertext Transfer Protocol) được sử dụng để chỉ rằng yêu cầu của client đã được chấp nhận, nhưng không nhất thiết phải thực hiện ngay lập tức. Trạng thái này thường được sử dụng trong các trường hợp như tạo tài khoản, gửi email xác nhận, hoặc thực hiện các yêu cầu có liên quan đến việc chờ đợi hoặc xác nhận."
    },
    {
      "question_id": "EQ5067-VN",
      "question": "Trạng thái HTTP nào được trả về khi một tài nguyên đã được di chuyển vĩnh viễn?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "302",
        "C": "301",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "301 Moved Permanently cho biết redirection."
    },
    {
      "question_id": "EQ5068-VN",
      "type": "Writing",
      "gold": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Để kiểm tra schema của API response, bạn có thể sử dụng thư viện `pydantic` kết hợp với `pytest`. Dưới đây là một ví dụ về test positive để kiểm tra schema của API response:\n\n```python\nimport pytest\nfrom pydantic import BaseModel\nfrom fastapi import Response\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\ndef test_api_response_schema(api_client):\n    response = api_client.get(\"/users\")\n    assert response.status_code == 200\n    assert response.json() is not None\n    assert User.parse_obj(response.json()) is not None\n```\n\nTrong ví dụ này, chúng ta sử dụng `pydantic` để định nghĩa schema của dữ liệu người dùng, và `pytest` để kiểm tra xem API response có đúng với schema này hay không."
    },
    {
      "question_id": "EQ5069-VN",
      "question": "Trạng thái HTTP nào cho biết request hợp lệ nhưng không tìm thấy tài nguyên?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "404"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "404 Not Found có nghĩa là tài nguyên không tồn tại."
    },
    {
      "question_id": "EQ5070-VN",
      "type": "Writing",
      "gold": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Mục đích của response body trong API testing là kiểm tra xem API đã trả về dữ liệu như mong đợi hay chưa, bao gồm cả dữ liệu dạng JSON, XML hoặc các dạng dữ liệu khác. Điều này giúp đảm bảo rằng API đang hoạt động đúng và trả về dữ liệu chính xác."
    },
    {
      "question_id": "EQ5071-VN",
      "question": "Trạng thái HTTP nào cho biết client request timeout?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "500",
        "B": "408",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout có nghĩa là client không gửi xong kịp thời."
    },
    {
      "question_id": "EQ5072-VN",
      "type": "Writing",
      "gold": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "Để verify chức năng logout, ta có thể viết một test case như sau:\n\n**Test Case: Verify chức năng logout**\n\n1. **Precondition**: Đăng nhập vào hệ thống với tài khoản hợp lệ.\n2. **Step**: \n * Đăng xuất khỏi hệ thống.\n * Kiểm tra xem hệ thống đã được đăng xuất thành công hay chưa (ví dụ: kiểm tra trạng thái đăng nhập, nội dung trang web).\n3. **Expected Result**: Hệ thống đã được đăng xuất thành công, trạng thái đăng nhập là \"đang ngoại tuyến\" và nội dung trang web được cập nhật phù hợp với trạng thái đăng xuất.\n\n**Test Case ID**: Logout-01\n\n**Priority**: Cao\n\n**Test Case Type**: Funcional Test\n\n**Environment**: Môi trường thử nghiệm với hệ thống đã được cài đặt và cấu hình phù hợp."
    },
    {
      "question_id": "EQ5073-VN",
      "question": "Trạng thái HTTP nào cho biết một request thành công trả về dữ liệu JSON?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK là mã chuẩn cho các GET thành công."
    },
    {
      "question_id": "EQ5074-VN",
      "type": "Writing",
      "gold": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "Lỗi 415 Unsupported Media Type xảy ra khi máy chủ web không hỗ trợ loại dữ liệu (media type) được gửi trong yêu cầu HTTP. Ví dụ, nếu một ứng dụng yêu cầu dữ liệu JSON nhưng máy chủ web chỉ hỗ trợ dữ liệu XML, thì máy chủ sẽ trả lại lỗi 415."
    },
    {
      "question_id": "EQ5075-VN",
      "question": "Mã trạng thái HTTP nào cho biết server tạm thời ngừng hoạt động để bảo trì?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 được sử dụng khi dịch vụ không khả dụng do quá tải hoặc bảo trì."
    },
    {
      "question_id": "EQ5076-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để cập nhật chỉ một phần của tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH được thiết kế cho các partial update."
    },
    {
      "question_id": "EQ5077-VN",
      "type": "Writing",
      "gold": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Để viết một test positive đơn giản cho endpoint GET /status, bạn có thể sử dụng framework test như pytest hoặc unittest trong Python. Dưới đây là ví dụ về một test positive đơn giản:\n\n```python\nimport requests\n\ndef test_status_code():\n    response = requests.get('http://localhost:5000/status')\n    assert response.status_code == 200\n```\n\nTrong ví dụ này, chúng ta đang kiểm tra xem endpoint GET /status có trả về mã trạng thái HTTP 200 (OK) hay không."
    },
    {
      "question_id": "EQ5078-VN",
      "question": "Trạng thái HTTP nào cho biết việc tạo tài nguyên thành công?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "201 Created xác nhận việc tạo tài nguyên thành công."
    },
    {
      "question_id": "EQ5079-VN",
      "type": "Writing",
      "gold": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "Một response 204 No Content trong HTTP có nghĩa là yêu cầu đã được xử lý thành công, nhưng không có nội dung nào được cung cấp. Điều này thường xảy ra khi yêu cầu không yêu cầu nội dung, chẳng hạn như khi yêu cầu một tài nguyên đã bị xóa."
    },
    {
      "question_id": "EQ5080-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một request hợp lệ nhưng quyền truy cập bị cấm?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden có nghĩa là thông tin đăng nhập hợp lệ nhưng không đủ quyền."
    },
    {
      "question_id": "EQ5081-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Dưới đây là một test negative case cho việc gửi một Content-Type header không hợp lệ:\n\n```python\nimport unittest\nimport requests\n\nclass TestContent-TypeHeader(unittest.TestCase):\n    def test_content_type_header_khong_hop_le(self):\n        url = \"http://example.com\"\n        headers = {\"Content-Type\": \"application/json; charset=utf-8; invalid-key\"}\n        response = requests.get(url, headers=headers)\n        self.assertEqual(response.status_code, 400)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nTrong test này, chúng ta đang kiểm tra xem khi gửi một Content-Type header không hợp lệ, server sẽ trả về trạng thái 400 (Bad Request)."
    },
    {
      "question_id": "EQ5082-VN",
      "question": "Mã trạng thái HTTP nào cho biết thành công nhưng tài nguyên rỗng?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "400 Bad Request",
        "D": "204 No Content"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 được trả về khi không có body content."
    },
    {
      "question_id": "EQ5083-VN",
      "type": "Writing",
      "gold": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "Mục đích của Accept header trong các API request là để chỉ định loại dữ liệu mà client muốn nhận từ server. Điều này cho phép server biết được loại dữ liệu mà client có thể xử lý và trả về dữ liệu phù hợp. Ví dụ, nếu client chỉ định Accept: application/json, server sẽ trả về dữ liệu JSON."
    },
    {
      "question_id": "EQ5084-VN",
      "question": "Mã trạng thái HTTP nào phù hợp cho thông tin đăng nhập không hợp lệ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 Unauthorized",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thông tin đăng nhập không hợp lệ."
    },
    {
      "question_id": "EQ5085-VN",
      "type": "Writing",
      "gold": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "Dưới đây là một ví dụ về test case đơn giản cho API logout thành công:\n\n**Test Case:** Logout thành công\n\n**Mô tả:**\n\n- **Tham số:** Không yêu cầu tham số\n- **Trả về:** Trả về mã trạng thái HTTP 200 và thông báo \"Đăng xuất thành công\"\n\n**Cụ thể:**\n\n1. Gửi yêu cầu POST đến đường dẫn logout\n2. Kiểm tra mã trạng thái HTTP trả về là 200\n3. Kiểm tra thông báo trả về là \"Đăng xuất thành công\"\n\n**Ghi chú:** Test case này sẽ được thực hiện bằng công cụ kiểm tra API như Postman hoặc cURL."
    },
    {
      "question_id": "EQ5086-VN",
      "question": "Phương thức HTTP nào được sử dụng để truy xuất chi tiết tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET được sử dụng để truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5087-VN",
      "type": "Writing",
      "gold": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "401 Unauthorized là một mã lỗi HTTP phổ biến trong API testing, chỉ định rằng yêu cầu của người dùng đã được gửi nhưng không được xác thực. Điều này có nghĩa là người dùng chưa cung cấp thông tin xác thực (tên đăng nhập và mật khẩu) hoặc thông tin xác thực đó không hợp lệ."
    },
    {
      "question_id": "EQ5088-VN",
      "question": "Mã trạng thái HTTP nào cho biết nỗ lực tạo tài nguyên trùng lặp?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict có nghĩa là request trùng lặp hoặc conflict."
    },
    {
      "question_id": "EQ5089-VN",
      "type": "Writing",
      "gold": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "Để viết một test case positive dễ dàng để kiểm tra API chi tiết profile, chúng ta có thể thực hiện theo các bước sau:\n\n1. Gọi API chi tiết profile với một ID hợp lệ và kiểm tra xem trả về thông tin profile đúng không.\n2. Sử dụng các công cụ như Postman hoặc cURL để gửi yêu cầu GET đến API với tham số ID.\n3. Kiểm tra xem API trả về thông tin profile đúng và đầy đủ.\n\nVí dụ:\n\n- Test case: \"Kiểm tra thông tin profile\"\n- Điều kiện tiền đề: ID profile hợp lệ\n- Hoạt động: Gọi API chi tiết profile với ID hợp lệ\n- Kết quả mong muốn: Trả về thông tin profile đúng và đầy đủ."
    },
    {
      "question_id": "EQ5090-VN",
      "question": "Mã trạng thái HTTP nào cho biết request hợp lệ nhưng server không thể hoàn thành nó?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "500",
        "D": "201"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "500 Internal Server Error báo hiệu lỗi phía server."
    },
    {
      "question_id": "EQ5091-VN",
      "type": "Writing",
      "gold": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "Mục đích của 302 Found trong các API là chuyển hướng request đến một địa chỉ khác, thường là để cập nhật URL hoặc để thực hiện các yêu cầu khác. Điều này giúp tránh việc yêu cầu bị trùng lặp và cải thiện trải nghiệm người dùng."
    },
    {
      "question_id": "EQ5092-VN",
      "question": "Trạng thái HTTP nào là chính xác cho một tài nguyên được cập nhật thành công bằng PUT?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK cho biết tài nguyên đã được cập nhật thành công."
    },
    {
      "question_id": "EQ5093-VN",
      "type": "Writing",
      "gold": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "Dưới đây là một test case cho nỗ lực đăng nhập negative với mật khẩu sai:\n\n**Tên test case:** Đăng nhập với mật khẩu sai\n\n**Mô tả:** Kiểm tra việc đăng nhập với mật khẩu sai.\n\n**Thủ tục:**\n\n1. Mở trang đăng nhập.\n2. Nhập tên đăng nhập đúng.\n3. Nhập mật khẩu sai.\n4. Nhấn nút đăng nhập.\n5. Kiểm tra thông báo lỗi.\n\n**Kết quả mong đợi:** Thông báo lỗi về việc mật khẩu sai."
    },
    {
      "question_id": "EQ5094-VN",
      "question": "Phương thức HTTP nào là safe và cacheable?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "GET",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "GET vừa là safe, idempotent, và cacheable."
    },
    {
      "question_id": "EQ5095-VN",
      "type": "Writing",
      "gold": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "\"422 Unprocessable Entity\" là một mã lỗi HTTP cho biết hệ thống đã nhận được yêu cầu hợp lệ nhưng không thể xử lý được do một lý do nào đó, chẳng hạn như dữ liệu yêu cầu không hợp lệ hoặc không đủ thông tin. Mã lỗi này thường được sử dụng trong các tình huống khi hệ thống cần thêm thông tin hoặc dữ liệu để xử lý yêu cầu một cách chính xác."
    },
    {
      "question_id": "EQ5096-VN",
      "question": "Trạng thái HTTP nào phù hợp khi dịch vụ tạm thời quá tải?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "201",
        "B": "200",
        "C": "503",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 Service Unavailable cho biết quá tải hoặc bảo trì."
    },
    {
      "question_id": "EQ5097-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Dưới đây là một ví dụ về test positive cho endpoint POST /users:\n\n```python\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom app.main import app\n\nclient = TestClient(app)\n\ndef test_create_user():\n    # Tạo một yêu cầu POST với một user mới\n    response = client.post(\"/users\", json={\"name\": \"John Doe\", \"email\": \"john@example.com\"})\n    # Kiểm tra nếu trạng thái phản hồi là 201 (Tạo mới thành công)\n    assert response.status_code == 201\n    # Kiểm tra nếu dữ liệu user mới được tạo thành công\n    assert response.json()[\"name\"] == \"John Doe\"\n    assert response.json()[\"email\"] == \"john@example.com\"\n```\n\nLưu ý: Bất kỳ dữ liệu mẫu nào được sử dụng trong test này chỉ là ví dụ và có thể cần được thay thế bằng dữ liệu mẫu phù hợp với yêu cầu của ứng dụng."
    },
    {
      "question_id": "EQ5098-VN",
      "question": "HTTP header nào chỉ định kích thước của request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Length",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Cache-Control"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Length định nghĩa kích thước body theo byte."
    },
    {
      "question_id": "EQ5099-VN",
      "type": "Writing",
      "gold": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "Thuật ngữ 'happy path' trong testing có nghĩa là con đường hoặc trường hợp được kiểm tra khi mọi thứ diễn ra theo cách mong muốn, thuận lợi và không có lỗi. Nó thường được sử dụng để mô tả một kịch bản kiểm tra trong đó tất cả các điều kiện và yêu cầu đều được đáp ứng một cách chính xác."
    },
    {
      "question_id": "EQ5100-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một request method không được phép trên một tài nguyên?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "405 Method Not Allowed"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "405 được sử dụng khi phương thức HTTP không hợp lệ cho tài nguyên."
    },
    {
      "question_id": "EQ2001-VN",
      "question": "Khi thiết kế các bài kiểm tra API, kịch bản nào thể hiện rõ nhất một **điều kiện biên** cho tham số phân trang?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gửi page=2 khi total items=200",
        "B": "Gửi page=10 khi size=10 mỗi trang và total items=100",
        "C": "Gửi page=11 khi total items=100 với size=10",
        "D": "Gửi page=1 khi size=20 và total items=300"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Page=11 sẽ vượt quá phạm vi có sẵn (tối đa 10), kiểm tra một sự tràn **điều kiện biên**."
    },
    {
      "question_id": "EQ2002-VN",
      "type": "Writing",
      "gold": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "Để thiết kế một **test case âm tính** cho endpoint API yêu cầu **OAuth2 Bearer token**, bạn cần thực hiện các bước sau:\n\n- **Bước 1:** Không gửi token Bearer trong yêu cầu HTTP.\n- **Bước 2:** Kiểm tra xem API có yêu cầu xác thực OAuth2 Bearer token không.\n- **Bước 3:** Đảm bảo rằng API trả về mã trạng thái (status code) phù hợp cho trường hợp không cung cấp token Bearer (thường là 401 Unauthorized hoặc 403 Forbidden).\n\nBằng cách thực hiện các bước này, bạn có thể xác minh rằng API đang xử lý trường hợp không cung cấp token Bearer một cách chính xác."
    },
    {
      "question_id": "EQ2003-VN",
      "question": "Cách nào sau đây là hiệu quả nhất để xác thực thời gian phản hồi của API dưới **tải người dùng** mô phỏng?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi API tuần tự thủ công bằng đồng hồ bấm giờ",
        "B": "**Load test** tự động với **người dùng ảo** đồng thời",
        "C": "Thực hiện một yêu cầu duy nhất và đo thời gian phản hồi",
        "D": "**Unit testing** với các phản hồi được **mock**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Load testing** với **người dùng ảo** đồng thời mô phỏng điều kiện thực tế."
    },
    {
      "question_id": "EQ2004-VN",
      "type": "Writing",
      "gold": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "Dưới đây là hai **test case** cho endpoint API hoàn tiền thanh toán:\n\n**Test case happy-path:**\n\n- Tên test case: \"Hoàn tiền thanh toán thành công\"\n- Mô tả: Sử dụng tài khoản khách hàng có đủ số dư để hoàn tiền một giao dịch thanh toán đã thực hiện.\n- Input:\n + Thông tin khách hàng (tên, địa chỉ, số điện thoại)\n + Số dư tài khoản khách hàng\n + Mã giao dịch thanh toán\n + Số tiền cần hoàn tiền\n- Output: Thông báo hoàn tiền thành công, số dư tài khoản khách hàng được cập nhật.\n\n**Test case error-path:**\n\n- Tên test case: \"Hoàn tiền thanh toán không thành công do số dư tài khoản thấp\"\n- Mô tả: Sử dụng tài khoản khách hàng có số dư thấp để hoàn tiền một giao dịch thanh toán đã thực hiện.\n- Input:\n + Thông tin khách hàng (tên, địa chỉ, số điện thoại)\n + Số dư tài khoản khách hàng (dưới mức cho phép)\n + Mã giao dịch thanh toán\n + Số tiền cần hoàn tiền\n- Output: Thông báo số dư tài khoản thấp, không thể hoàn tiền."
    },
    {
      "question_id": "EQ2005-VN",
      "question": "Thực hành nào giúp giảm **sự flaky** của **automated API tests** chạy trong các **CI/CD pipelines**?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcode **API keys** trong các script",
        "B": "Sử dụng độ trễ ngủ ngẫu nhiên trước các **assertion**",
        "C": "Chỉ chạy **test** một lần mỗi bản phát hành",
        "D": "Sử dụng dữ liệu **test** ổn định và các **hook** thiết lập môi trường"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Sử dụng dữ liệu **test** ổn định và các **hook** thiết lập môi trường.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Dữ liệu **test** và thiết lập môi trường ổn định giúp giảm tính ngẫu nhiên và **sự flaky**."
    },
    {
      "question_id": "EQ2006-VN",
      "type": "Writing",
      "gold": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "Khi thực hiện một nâng cấp API tương thích ngược, bạn nên sử dụng phương pháp xác thực các thay đổi **schema** như sau:\n\n1. Sử dụng mô hình \"Canary Deployment\" hoặc \"Blue-Green Deployment\" để kiểm tra và xác thực các thay đổi **schema** trước khi triển khai chúng cho toàn bộ hệ thống.\n2. Sử dụng các công cụ kiểm tra và xác thực tự động như \"Swagger\" hoặc \"OpenAPI\" để đảm bảo rằng các thay đổi **schema** không ảnh hưởng đến các yêu cầu API hiện có.\n3. Thực hiện thử nghiệm và kiểm tra thủ công để đảm bảo rằng các thay đổi **schema** không gây ra bất kỳ lỗi hoặc vấn đề nào.\n\nBằng cách thực hiện các biện pháp này, bạn có thể xác thực các thay đổi **schema** một cách hiệu quả và đảm bảo rằng hệ thống của bạn luôn ổn định và tương thích ngược."
    },
    {
      "question_id": "EQ2007-VN",
      "question": "Điều nào sau đây thể hiện một **test case âm tính** chính xác cho việc xác thực đầu vào trên trường ngày sinh?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gửi **dateOfBirth**=‘2025-13-40’",
        "B": "Gửi **dateOfBirth**=‘1990-05-20’",
        "C": "Để trống **dateOfBirth** khi nó là tùy chọn",
        "D": "Gửi **dateOfBirth**=‘2000-01-01’"
      },
      "gold_answer": "A",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Tháng/ngày không hợp lệ làm cho nó trở thành một trường hợp xác thực đầu vào **âm tính** chính xác."
    },
    {
      "question_id": "EQ2008-VN",
      "type": "Writing",
      "gold": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "**Mocking** là một kỹ thuật giúp tạo ra một phiên bản giả của một dịch vụ hoặc API, cho phép chúng ta kiểm tra và thử nghiệm một ứng dụng mà không cần phải gọi dịch vụ thực. Trong trường hợp kiểm tra một API thanh toán, mocking có thể được sử dụng để tạo ra một phiên bản giả của dịch vụ ngân hàng, cho phép chúng ta thử nghiệm và kiểm tra ứng dụng mà không cần phải thực hiện giao dịch thực tế. Điều này giúp giảm thiểu rủi ro và tăng hiệu suất trong quá trình kiểm tra."
    },
    {
      "question_id": "EQ2009-VN",
      "question": "Cách tiếp cận giám sát nào giúp phát hiện các đợt tăng đột biến về tỷ lệ lỗi API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Báo cáo **code coverage**",
        "B": "Kiểm tra **log** thủ công mỗi tuần",
        "C": "Cảnh báo thời gian thực trên các chỉ số tỷ lệ lỗi",
        "D": "Phân tích **code** tĩnh"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Cảnh báo thời gian thực trên các chỉ số tỷ lệ lỗi\n\nGiải thích: Để phát hiện các đợt tăng đột biến về tỷ lệ lỗi API, cách tiếp cận giám sát hiệu quả nhất là sử dụng cảnh báo thời gian thực trên các chỉ số tỷ lệ lỗi. Điều này cho phép phát hiện và cảnh báo ngay lập tức khi tỷ lệ lỗi tăng đột biến, giúp các kỹ sư phát triển nhanh chóng xác định và sửa lỗi.\n\nCác phương pháp khác:\n\n- A. Báo cáo code coverage: giúp đo lường mức độ phủ sóng của mã, nhưng không trực tiếp liên quan đến tỷ lệ lỗi API.\n\n- B. Kiểm tra log thủ công mỗi tuần: có thể giúp phát hiện lỗi, nhưng không thể phát hiện đợt tăng đột biến về tỷ lệ lỗi.\n\n- D. Phân tích code tĩnh: giúp xác định lỗi trước khi chạy, nhưng không thể phát hiện đợt tăng đột biến về tỷ lệ lỗi sau khi chạy.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Cảnh báo thời gian thực đảm bảo phát hiện ngay lập tức các đợt tăng đột biến tỷ lệ lỗi."
    },
    {
      "question_id": "EQ2010-VN",
      "type": "Writing",
      "gold": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "**Boundary Test:**\n\n- Thử nghiệm giá trị biên trên: `age = 65` (giả sử người dùng đã đủ 65 tuổi)\n- Thử nghiệm giá trị biên dưới: `age = 18` (giả sử người dùng đã đủ 18 tuổi)\n\n**Invalid Test:**\n\n- Thử nghiệm giá trị nhỏ hơn 18: `age = 17` (giả sử người dùng chưa đủ 18 tuổi)\n- Thử nghiệm giá trị lớn hơn 65: `age = 66` (giả sử người dùng đã vượt quá tuổi tối đa)\n\nNhững giá trị này sẽ giúp kiểm tra tính đúng đắn của API `age` trong trường hợp người dùng cung cấp các giá trị biên hoặc không hợp lệ."
    },
    {
      "question_id": "EQ2011-VN",
      "question": "Điều nào sau đây là một ví dụ về **contract validation** trong **API testing**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra độ trễ phản hồi",
        "B": "Xác thực **JSON** phản hồi khớp với **OpenAPI schema**",
        "C": "Đo tải **CPU** của máy chủ",
        "D": "**Assert** các truy vấn **SQL** từ **log**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Xác thực **JSON** phản hồi khớp với **OpenAPI schema**",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Contract validation** đảm bảo các phản hồi khớp với **schema** đã xác định."
    },
    {
      "question_id": "EQ2012-VN",
      "type": "Writing",
      "gold": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "Để mô phỏng lỗi **network timeout** trong **API testing**, bạn có thể sử dụng các công cụ như **Postman** hoặc **SoapUI** với tính năng **delay** hoặc **pause**. Bạn có thể thêm một bước **delay** vào quá trình yêu cầu API để mô phỏng tình huống mạng chậm hoặc mất kết nối. Điều này sẽ giúp bạn kiểm tra xem API có thể xử lý lỗi **timeout** một cách đúng đắn hay không."
    },
    {
      "question_id": "EQ2013-VN",
      "question": "Kịch bản nào thể hiện rõ nhất một **load test** trung gian?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "10.000 **người dùng ảo** đồng thời cho **stress testing**",
        "B": "Kiểm tra chức năng một người dùng",
        "C": "**Unit testing** một chức năng",
        "D": "100–200 **người dùng ảo** đồng thời mô phỏng lưu lượng truy cập trung bình"
      },
      "gold_answer": "D",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Các **load test** trung gian mô phỏng lưu lượng truy cập người dùng vừa phải, thực tế."
    },
    {
      "question_id": "EQ2014-VN",
      "type": "Writing",
      "gold": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "Một ví dụ về một **precondition** API và một **step** theo sau nó là:\n\nAPI: `GET /users/:id`\n**Precondition**: Người dùng phải được xác thực (login) trước khi thực hiện yêu cầu này.\n**Step**: Sau khi xác thực thành công, người dùng có thể thực hiện yêu cầu `GET /users/:id` để lấy thông tin của một người dùng cụ thể."
    },
    {
      "question_id": "EQ2015-VN",
      "question": "Cách tiếp cận nào giúp phát hiện các nỗ lực truy cập trái phép trong một API?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "**Penetration test** sử dụng **token** không hợp lệ hoặc thiếu",
        "B": "**Unit test** trên các chức năng hỗ trợ",
        "C": "Thành công **build** **CI pipeline**",
        "D": "Chạy API ở chế độ **debug**"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Penetration test** tiết lộ điểm yếu trong việc xử lý ủy quyền."
    },
    {
      "question_id": "EQ2016-VN",
      "type": "Writing",
      "gold": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "**Test Case: Xác thực API rate limiting**\n\n**Tên test:** \"API rate limiting\"\n\n**Mô tả:** Xác thực rằng API rate limiting được thực thi đúng khi số lượng yêu cầu vượt quá giới hạn cho phép.\n\n**Thử nghiệm:**\n\n1. Gửi một số lượng yêu cầu đến API trong thời gian ngắn.\n2. Kiểm tra số lượng yêu cầu được chấp nhận và số lượng yêu cầu bị từ chối do vượt quá giới hạn.\n3. So sánh số lượng yêu cầu được chấp nhận với số lượng yêu cầu cho phép và xác thực rằng số lượng yêu cầu bị từ chối đúng.\n\n**Kết quả mong muốn:**\n\n* Số lượng yêu cầu được chấp nhận không vượt quá giới hạn cho phép.\n* Số lượng yêu cầu bị từ chối đúng khi số lượng yêu cầu vượt quá giới hạn cho phép."
    },
    {
      "question_id": "EQ2017-VN",
      "question": "Chiến lược nào đảm bảo khả năng tái tạo của các **integration API tests**?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chạy với dữ liệu sản phẩm ngẫu nhiên",
        "B": "Sử dụng các cơ sở dữ liệu **test** được **seed** và các **script reset**",
        "C": "Hardcode **timestamp** trong các yêu cầu",
        "D": "Vô hiệu hóa các **cleanup step** sau khi **test**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Dữ liệu **test** được **seed** đảm bảo khả năng tái tạo nhất quán."
    },
    {
      "question_id": "EQ2018-VN",
      "type": "Writing",
      "gold": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "Lợi thế của việc sử dụng **service virtualization** trong **API testing** là khả năng tạo ra các bản sao ảo của các dịch vụ hoặc hệ thống thực tế, cho phép các nhà phát triển và kỹ sư kiểm thử thực hiện các cuộc kiểm thử hiệu quả mà không cần truy cập vào các dịch vụ hoặc hệ thống thực tế. Điều này giúp tiết kiệm thời gian và chi phí, đồng thời tăng cường hiệu quả của quá trình kiểm thử."
    },
    {
      "question_id": "EQ2019-VN",
      "question": "Điều nào trong số này là một **recovery step** thích hợp nếu giám sát API phát hiện lỗi **500** nhất quán?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Bỏ qua chúng cho đến bản phát hành tiếp theo",
        "B": "Thêm logic **retry** ngẫu nhiên cho tất cả các máy khách",
        "C": "Cảnh báo đội ngũ vận hành và kích hoạt **rollback** của **deployment** gần đây",
        "D": "Tắt **log** lỗi"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Rollback** và cảnh báo đảm bảo giảm thiểu nhanh chóng."
    },
    {
      "question_id": "EQ2020-VN",
      "type": "Writing",
      "gold": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "Để thiết kế một **test case tích cực** và một **boundary test case** cho API đăng nhập yêu cầu tên người dùng và mật khẩu, chúng ta thực hiện như sau:\n\n- **Test case tích cực**: Thiết kế một trường hợp thử nghiệm với tên người dùng và mật khẩu hợp lệ, chẳng hạn như \"test_user\" và \"password123\", để kiểm tra xem API có xử lý đăng nhập thành công hay không.\n- **Boundary test case**: Thiết kế một trường hợp thử nghiệm với tên người dùng và mật khẩu ở giới hạn biên, chẳng hạn như tên người dùng trống và mật khẩu là \"123456\", hoặc tên người dùng dài quá giới hạn và mật khẩu hợp lệ, để kiểm tra xem API có xử lý lỗi hay không."
    },
    {
      "question_id": "EQ2021-VN",
      "question": "Kịch bản nào sau đây là một ví dụ về một **chained API test case**?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi GET /status lặp đi lặp lại",
        "B": "Tạo một người dùng, sau đó sử dụng ID của người dùng đó trong GET /profile",
        "C": "Kiểm tra một endpoint với các **header** không hợp lệ",
        "D": "Đo độ trễ trung bình của một endpoint"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Tạo một người dùng, sau đó sử dụng ID của người dùng đó trong GET /profile",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Chained test case** phụ thuộc vào đầu ra của một API là đầu vào cho API khác."
    },
    {
      "question_id": "EQ2022-VN",
      "type": "Writing",
      "gold": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "Để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác, ta có thể sử dụng **test step** sau:\n\n**Test Step:**\n\n1. Gửi yêu cầu POST đến API với nội dung không phù hợp (ví dụ: một JSON không hợp lệ).\n2. Xác định rằng API trả về trạng thái HTTP **415** và nội dung trả về là \"Unsupported Media Type\".\n3. Kiểm tra rằng lỗi không được ẩn dưới dạng trạng thái HTTP khác hoặc nội dung trả về khác.\n\n**Test Case:**\n\n| ID | Mô tả | Trạng thái |\n| --- | --- | --- |\n| TC_001 | Gửi yêu cầu POST với nội dung không phù hợp | 415 |\n\n**Expected Result:**\n\nAPI trả về trạng thái HTTP **415** và nội dung trả về là \"Unsupported Media Type\"."
    },
    {
      "question_id": "EQ2023-VN",
      "question": "Thực hành nào giúp phát hiện vi phạm **contract** sớm trong **CI/CD pipeline**?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "**Load testing** trong **production** thôi",
        "B": "Kiểm tra **regression** thủ công mỗi tháng một lần",
        "C": "**Schema validation tests** được tích hợp vào **pipeline**",
        "D": "Sử dụng **mock** cho tất cả các phụ thuộc bên ngoài"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Automated schema validation** trong **CI/CD** phát hiện các thay đổi gây lỗi nhanh chóng."
    },
    {
      "question_id": "EQ2024-VN",
      "type": "Writing",
      "gold": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "Để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm, bạn có thể thực hiện các bước sau:\n\n- **Lưu lượng truy cập**: Sử dụng công cụ như Apache JMeter hoặc Locust để tạo ra lưu lượng truy cập giả lập cho API, mô phỏng các trường hợp sử dụng thực tế.\n- **Thời gian phản hồi**: Sử dụng công cụ như Prometheus hoặc New Relic để theo dõi thời gian phản hồi của API và xác định xem có bất kỳ sự chậm chạp nào trong truy vấn cơ sở dữ liệu hay không.\n- **Xác định nguyên nhân**: Sử dụng công cụ như ELK Stack hoặc Splunk để phân tích dữ liệu và xác định nguyên nhân của sự chậm chạp, có thể là do lỗi trong mã, quá tải cơ sở dữ liệu hoặc các vấn đề khác."
    },
    {
      "question_id": "EQ2025-VN",
      "question": "Điều nào sau đây là một ví dụ về một **negative authorization test**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi **DELETE /users** mà không có đặc quyền quản trị",
        "B": "Gọi **GET /users** với **token** hợp lệ",
        "C": "Đăng nhập với thông tin đăng nhập hợp lệ",
        "D": "Làm mới một **session token** hợp lệ"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Gọi **DELETE /users** mà không có đặc quyền quản trị",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Cố gắng xóa người dùng mà không có đặc quyền kiểm tra các hạn chế truy cập."
    },
    {
      "question_id": "EQ2026-VN",
      "type": "Writing",
      "gold": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Để kiểm tra **API idempotency** cho một kịch bản **retry**, bạn sẽ cần thực hiện các bước sau:\n\n1. **Thực hiện yêu cầu**: Gửi yêu cầu đến API và lưu trữ ID của yêu cầu.\n2. **Xử lý lỗi**: Nếu yêu cầu bị lỗi, hãy thử lại yêu cầu và so sánh ID của yêu cầu mới với ID đã lưu trữ.\n3. **Kiểm tra idempotency**: Nếu ID của yêu cầu mới trùng với ID đã lưu trữ, điều đó có nghĩa là yêu cầu đã được xử lý trước đó và API đã áp dụng **idempotency**."
    },
    {
      "question_id": "EQ2027-VN",
      "question": "Phương pháp nào đảm bảo các **API keys** nhạy cảm không bị lộ trong quá trình **automated testing**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcode chúng trong các **test script**",
        "B": "In chúng trong các **log CI/CD**",
        "C": "Lưu trữ chúng trong các **repo GitHub** công khai",
        "D": "Sử dụng các biến môi trường được mã hóa"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Các biến môi trường được mã hóa giữ bí mật an toàn."
    },
    {
      "question_id": "EQ2028-VN",
      "type": "Writing",
      "gold": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "Dưới đây là một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB:\n\n*   **Boundary test**: Chọn một file có kích thước 5 MB và gửi đến API để kiểm tra xem API có chấp nhận file này hay không.\n*   **Invalid test**: Chọn một file có kích thước lớn hơn 5 MB (ví dụ 10 MB) và gửi đến API để kiểm tra xem API có trả về lỗi phù hợp hay không."
    },
    {
      "question_id": "EQ2029-VN",
      "question": "Chỉ số giám sát nào sẽ tốt nhất để chỉ ra rò rỉ bộ nhớ trong một API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Tăng đột biến độ trễ trung bình",
        "B": "Sử dụng bộ nhớ tăng dần",
        "C": "Sử dụng CPU giảm",
        "D": "Tăng ngẫu nhiên tỷ lệ **cache hit**"
      },
      "gold_answer": "B",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Rò rỉ bộ nhớ biểu hiện dưới dạng sử dụng bộ nhớ liên tục tăng."
    },
    {
      "question_id": "EQ2030-VN",
      "type": "Writing",
      "gold": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "Dưới đây là một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu:\n\n**Test Case:** Xử lý lỗi khi gọi API với trường email bị thiếu\n\n**Mô tả:** Gọi API với dữ liệu không có trường email và xác thực lỗi trả về phù hợp.\n\n**Thủ tục:**\n\n1. Gọi API với dữ liệu không có trường email.\n2. Xác thực lỗi trả về có mã lỗi và thông điệp phù hợp (ví dụ: \"Email không thể bỏ qua\").\n3. Xác thực lỗi không ảnh hưởng đến trạng thái hệ thống.\n\n**Tham số:**\n\n* `email`: Không có giá trị (bị thiếu)\n\n**Kết quả mong đợi:**\n\n* Lỗi trả về có mã lỗi và thông điệp phù hợp.\n* Trạng thái hệ thống không bị ảnh hưởng."
    },
    {
      "question_id": "EQ2031-VN",
      "question": "Điều nào sau đây mô tả rõ nhất **service virtualization**?",
      "type": "MCQ",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chỉ chạy API trong **production**",
        "B": "Sử dụng bản sao cơ sở dữ liệu cục bộ",
        "C": "Mô phỏng các phụ thuộc không có sẵn với các dịch vụ ảo",
        "D": "Thay thế logic **backend** bằng các **microservice** mới"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Service virtualization** cho phép kiểm tra mà không có các phụ thuộc thực."
    },
    {
      "question_id": "EQ2032-VN",
      "type": "Writing",
      "gold": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "Để thiết kế một **test** xác thực logic **retry**, chúng ta có thể thực hiện theo các bước sau:\n\n1. Tạo một **mock API** giả lập tình huống **503** xảy ra.\n2. Gọi API này từ ứng dụng thực tế và theo dõi hành động **retry** của ứng dụng.\n3. Kiểm tra xem ứng dụng đã **retry** đúng số lần, đã xử lý tình huống **503** một cách thích hợp hay chưa.\n\nVí dụ, sử dụng ngôn ngữ Python và thư viện **unittest**, bạn có thể thiết kế một **test** như sau:\n\n```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom your_module import your_function\n\nclass TestRetryLogic(unittest.TestCase):\n    @patch('your_module.your_function')\n    def test_retry_logic(self, mock_api):\n        # Tạo một mock API giả lập tình huống **503** xảy ra\n        mock_api.return_value = MagicMock(status_code=503)\n\n        # Gọi API này từ ứng dụng thực tế và theo dõi hành động **retry** của ứng dụng\n        your_function(mock_api)\n\n        # Kiểm tra xem ứng dụng đã **retry** đúng số lần\n        self.assertEqual(mock_api.call_count, 3)  # 3 lần retry\n```\n\nLưu ý: Mã nguồn trên chỉ là một ví dụ và bạn cần phải điều chỉnh nó để phù hợp với môi trường và yêu cầu của bạn."
    },
    {
      "question_id": "EQ2033-VN",
      "question": "Kịch bản lỗi nào thể hiện rõ nhất một lỗi phía máy khách?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "HTTP 400 Bad Request",
        "B": "HTTP 500 Internal Server Error",
        "C": "Lỗi **timeout** cơ sở dữ liệu",
        "D": "**Out-of-memory** trên máy chủ"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**400 Bad Request** chỉ ra yêu cầu không hợp lệ từ phía máy khách."
    },
    {
      "question_id": "EQ2034-VN",
      "type": "Writing",
      "gold": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "Để xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**, ta có thể tạo một **test case** như sau:\n\n**Test Case:** Tương quan log bằng trace ID header\n\n**Mô tả:**\n\n1. Gửi yêu cầu đến ứng dụng với header \"Trace-ID\" chứa một giá trị duy nhất.\n2. Ứng dụng lưu trữ giá trị này trong log của nó.\n3. Khi yêu cầu được xử lý, ứng dụng thêm giá trị \"Trace-ID\" vào log của nó.\n4. Khi yêu cầu được hoàn thành, ứng dụng trả về phản hồi với header \"Trace-ID\" chứa giá trị đã lưu trữ.\n\n**Thử nghiệm:**\n\n- Gửi yêu cầu đến ứng dụng với header \"Trace-ID\" chứa một giá trị duy nhất.\n- Kiểm tra log của ứng dụng để đảm bảo giá trị \"Trace-ID\" được lưu trữ và thêm vào log.\n- Kiểm tra phản hồi của ứng dụng để đảm bảo header \"Trace-ID\" chứa giá trị đã lưu trữ."
    },
    {
      "question_id": "EQ2035-VN",
      "question": "Kịch bản nào trong số này yêu cầu **schema validation** trong quá trình **testing**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra thời gian phản hồi API trung bình",
        "B": "Đảm bảo các trường **JSON** phản hồi khớp với định nghĩa **OpenAPI**",
        "C": "Đo **throughput** dưới **tải**",
        "D": "Phân tích **log** truy vấn **SQL**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Schema validation** đảm bảo tính chính xác về cấu trúc của các phản hồi."
    },
    {
      "question_id": "EQ2036-VN",
      "type": "Writing",
      "gold": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "Để thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting**, chúng ta có thể thực hiện theo các bước sau:\n\n1. Chuẩn bị: Tạo một ứng dụng máy khách (client) và một dịch vụ API.\n2. Thiết kế: Sử dụng công cụ kiểm tra (testing tool) như Postman hoặccurl để tạo nhiều yêu cầu (requests) đến dịch vụ API trong một khoảng thời gian ngắn.\n3. Xác thực: Xác thực rằng dịch vụ API đã giới hạn số lượng yêu cầu trong khoảng thời gian đó, và các yêu cầu sau khi vượt quá giới hạn sẽ bị chặn hoặc trả về trạng thái lỗi (error).\n\nVí dụ, nếu dịch vụ API cho phép 10 yêu cầu mỗi phút, chúng ta có thể tạo 11 yêu cầu trong 1 phút và xác thực rằng yêu cầu thứ 11 bị chặn hoặc trả về trạng thái lỗi."
    },
    {
      "question_id": "EQ2037-VN",
      "question": "Điều nào sau đây cải thiện khả năng tái tạo của các **API tests** trong nhiều môi trường?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sử dụng các **URL** môi trường được **hardcode**",
        "B": "Ngẫu nhiên hóa tất cả dữ liệu **test**",
        "C": "Thực hiện **test** trên dữ liệu **production**",
        "D": "Tham số hóa các **endpoint** và sử dụng cấu hình môi trường"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Parameterization** đảm bảo cùng một logic **test** hoạt động trên các môi trường."
    },
    {
      "question_id": "EQ2038-VN",
      "type": "Writing",
      "gold": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "Dưới đây là mô tả của hai **test case**:\n\n- **Test case tích cực**: \"Gửi mã SMS thành công khi nhập số điện thoại hợp lệ và mã xác minh hợp lệ\": Trong trường hợp này, người dùng nhập số điện thoại hợp lệ và mã xác minh hợp lệ, và endpoint API gửi mã SMS thành công.\n- **Test case âm tính**: \"Gửi mã SMS thất bại khi nhập số điện thoại không hợp lệ hoặc mã xác minh không hợp lệ\": Trong trường hợp này, người dùng nhập số điện thoại không hợp lệ hoặc mã xác minh không hợp lệ, và endpoint API gửi mã SMS thất bại."
    },
    {
      "question_id": "EQ2039-VN",
      "question": "Điều nào trong số này mô tả rõ nhất **performance baseline testing**?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đo thời gian phản hồi bình thường dưới **tải** dự kiến",
        "B": "Kiểm tra API với các đầu vào không hợp lệ",
        "C": "Xác thực API so với **OpenAPI spec**",
        "D": "Mô phỏng lưu lượng truy cập **peak** gấp 10 lần"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Baseline testing** nắm bắt hiệu suất bình thường dự kiến."
    },
    {
      "question_id": "EQ2040-VN",
      "type": "Writing",
      "gold": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Khi **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại, lợi thế chính là giảm thời gian và chi phí liên quan đến việc truy cập vào các API thực tế. Điều này cho phép bạn tập trung vào việc kiểm tra logic và hành vi của ứng dụng của mình, độc lập với các vấn đề về kết nối mạng hoặc lỗi từ bên ngoài."
    },
    {
      "question_id": "EQ2041-VN",
      "question": "Điều nào trong số này là một **test case** chính xác để xác thực hết hạn **session**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đăng nhập với thông tin đăng nhập hợp lệ, mong đợi **200 OK**",
        "B": "Gửi yêu cầu với **token** hợp lệ ngay sau khi đăng nhập",
        "C": "Gửi yêu cầu với **token** sau khi hết **timeout session**, mong đợi **401 Unauthorized**",
        "D": "Gửi yêu cầu không có **token**, mong đợi **200 OK**"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Gửi yêu cầu với **token** sau khi hết **timeout session**, mong đợi **401 Unauthorized**",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Session** đã hết hạn phải trả về **401 Unauthorized**."
    },
    {
      "question_id": "EQ2042-VN",
      "type": "Writing",
      "gold": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "**Test Case:** Xử lý lỗi khi API trả về JSON bị định dạng sai\n\n**Mô tả:**\n\n1. **Precondition:** API đã được triển khai và đang hoạt động.\n2. **Test Case:**\n * Gửi yêu cầu đến API với JSON bị định dạng sai (ví dụ: thiếu hoặc thừa dấu ngoặc kép, dấu phẩy sai vị trí, v.v.).\n * Kiểm tra phản hồi từ API:\n + Nếu API xử lý lỗi đúng cách, phản hồi sẽ chứa thông tin lỗi và mã trạng thái 400 (Bad Request).\n + Nếu API không xử lý lỗi đúng cách, phản hồi sẽ chứa thông tin lỗi và mã trạng thái khác (ví dụ: 500, Internal Server Error).\n3. **Expected Result:** API xử lý lỗi đúng cách và phản hồi chứa thông tin lỗi và mã trạng thái 400 (Bad Request).\n\n**Test Data:**\n\n* JSON bị định dạng sai (ví dụ: `{\"name\":\"John\",\"age\":30,\"city\":\"New York\"};` thay vì `{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}`)\n* Yêu cầu gửi đến API (ví dụ: GET, POST, PUT, DELETE)\n\n**Test Case:** Xử lý lỗi khi API trả về JSON bị định dạng sai (tiếp theo)\n\n4. **Test Case:**\n * Gửi yêu cầu đến API với JSON bị định dạng sai (ví dụ: thiếu hoặc thừa dấu ngoặc kép, dấu phẩy sai vị trí, v.v.).\n * Kiểm tra phản hồi từ API:\n + Nếu API xử lý lỗi đúng cách, phản hồi sẽ chứa thông tin lỗi và mã trạng thái 400 (Bad Request).\n + Nếu API không xử lý lỗi đúng cách, phản hồi sẽ chứa thông tin lỗi và mã trạng thái khác (ví dụ: 500, Internal Server Error).\n5. **Expected Result:** API xử lý lỗi đúng cách và phản hồi chứa thông tin lỗi và mã trạng thái 400 (Bad Request)."
    },
    {
      "question_id": "EQ2043-VN",
      "question": "Chiến lược nào giúp xác thực **tương thích ngược** sau khi thêm các trường tùy chọn mới?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đảm bảo các máy khách cũ vẫn hoạt động mà không cần gửi các trường mới",
        "B": "Buộc các máy khách cập nhật ngay lập tức",
        "C": "Xóa các trường cũ khỏi phản hồi",
        "D": "Yêu cầu các thay đổi **schema** phải gây lỗi"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Tương thích ngược** có nghĩa là các máy khách cũ vẫn phải hoạt động mà không cần các trường mới."
    },
    {
      "question_id": "EQ2044-VN",
      "type": "Writing",
      "gold": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "Để thiết kế một **test step** xác nhận các **rate limiting header**, bạn có thể thực hiện theo các bước sau:\n\n1. Gửi yêu cầu đến máy chủ (ví dụ: sử dụng tool như Postman hoặc curl).\n2. Kiểm tra phản hồi của máy chủ để xác định xem các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt hay không.\n3. Sử dụng các chỉ số như giá trị của **X-RateLimit-Remaining** để xác định xem máy chủ đã áp dụng giới hạn tốc độ truy cập hay chưa."
    },
    {
      "question_id": "EQ2045-VN",
      "question": "Cách hiệu quả nhất để kiểm tra khả năng phục hồi khi một dịch vụ **downstream** của API bị lỗi là gì?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "options": {
        "A": "Vô hiệu hóa **retry** ở máy khách",
        "B": "Ngừng **testing** cho đến khi dịch vụ phục hồi",
        "C": "Chỉ chạy **unit tests**",
        "D": "Chèn lỗi bằng cách sử dụng **chaos testing** hoặc **mock**"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Chaos testing/mocks** cho phép mô phỏng có kiểm soát các lỗi phụ thuộc."
    },
    {
      "question_id": "EQ2046-VN",
      "type": "Writing",
      "gold": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Khi tách dữ liệu **test** khỏi logic **test** trong **API testing**, chúng ta có thể dễ dàng thay đổi hoặc cập nhật dữ liệu mà không ảnh hưởng đến logic kiểm tra, giúp quá trình thử nghiệm trở nên linh hoạt và hiệu quả hơn. Điều này cho phép các kỹ sư thử nghiệm tập trung vào việc kiểm tra logic của API một cách độc lập với dữ liệu."
    },
    {
      "question_id": "EQ2047-VN",
      "question": "**Response status code** nào thích hợp cho một yêu cầu bị chặn do thiếu **authorization header**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 Unauthorized",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Thiếu ủy quyền dẫn đến **401 Unauthorized**."
    },
    {
      "question_id": "EQ2048-VN",
      "type": "Writing",
      "gold": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "Dưới đây là một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn:\n\n**Test case**: \"Suy thoái khi cache API không có sẵn\"\n\n* **Mô tả**: Kiểm tra xem ứng dụng có thể hoạt động bình thường khi **cache** API không có sẵn.\n* **Hành động**:\n + Gọi một yêu cầu đến ứng dụng.\n + Đảm bảo **cache** API không có sẵn.\n + Kiểm tra xem ứng dụng có thể trả về một phản hồi hợp lệ.\n* **Kiểm tra**:\n + Phản hồi của ứng dụng phải không chứa lỗi về **cache**.\n + Ứng dụng phải có thể tiếp tục hoạt động bình thường."
    },
    {
      "question_id": "EQ2049-VN",
      "question": "Điều nào sau đây thể hiện một **boundary test** thích hợp cho trường độ dài mật khẩu (**min**=8, **max**=20)?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra với 7, 8, 20, và 21 ký tự",
        "B": "Chỉ kiểm tra với 10 ký tự",
        "C": "Chỉ kiểm tra với 15 ký tự",
        "D": "Chỉ kiểm tra với mật khẩu trống"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Kiểm tra với 7, 8, 20, và 21 ký tự\n\nBoundary test là một kỹ thuật kiểm tra thử nghiệm, trong đó chúng ta kiểm tra các giá trị ở ranh giới của miền giá trị để đảm bảo rằng hệ thống hoạt động đúng trong các trường hợp này. Trong trường hợp này, chúng ta cần kiểm tra các giá trị ở ranh giới của độ dài mật khẩu, tức là 7, 8, 20 và 21 ký tự.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Boundary testing** bao gồm các giá trị ở, dưới và trên giới hạn."
    },
    {
      "question_id": "EQ2050-VN",
      "type": "Writing",
      "gold": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu, bạn có thể sử dụng kỹ thuật **logging** có thể được mã hóa như **logging** với SSL/TLS hoặc sử dụng **logging** trung gian như **logging** với bộ nhớ đệm (cache) hoặc sử dụng **logging** với sự đồng ý (consent) của người dùng trước khi ghi nhận các thông tin nhạy cảm."
    },
    {
      "question_id": "EQ2051-VN",
      "question": "Phương pháp giám sát nào giúp xác định sự gia tăng độ trễ dần dần qua các tuần?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đo thời gian bằng đồng hồ bấm giờ cho một yêu cầu duy nhất",
        "B": "Gỡ lỗi thủ công trong các sự cố",
        "C": "Phân tích xu hướng chuỗi thời gian bằng **dashboard**",
        "D": "Các chỉ số **code coverage**"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Dashboard** và giám sát chuỗi thời gian làm nổi bật các xu hướng độ trễ."
    },
    {
      "question_id": "EQ2052-VN",
      "type": "Writing",
      "gold": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "**Test case âm tính:** Kiểm tra trường tiền tệ với giá trị rỗng (\"\") để đảm bảo ứng dụng không bị lỗi khi nhận được dữ liệu trống.\n\n**Boundary test case:** Kiểm tra trường tiền tệ với giá trị là mã ISO 4217 cực đại (\"ZZZZ\") hoặc cực tiểu (\"A\") để đảm bảo ứng dụng xử lý trường hợp ngoài phạm vi hợp lệ một cách chính xác."
    },
    {
      "question_id": "EQ2053-VN",
      "question": "Chiến lược nào đảm bảo các **contract test** vẫn hữu ích khi API phát triển?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Không bao giờ cập nhật **schema tests**",
        "B": "Xóa các trường tùy chọn khỏi **test**",
        "C": "Chỉ chạy các **regression test** thủ công",
        "D": "Phiên bản hóa các **schema contract** và duy trì **tương thích ngược**"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Phiên bản hóa các **schema contract** và duy trì **tương thích ngược**",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Versioning** và **tương thích ngược** giữ cho các **contract test** đáng tin cậy."
    },
    {
      "question_id": "EQ2054-VN",
      "type": "Writing",
      "gold": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "Để xác thực hành vi API dưới tình trạng mất gói mạng, chúng ta có thể viết một **test case** như sau:\n\n**Tên test case:** \"Thử nghiệm mất gói mạng\"\n\n**Mô tả:** Kiểm tra xem API vẫn hoạt động bình thường khi mất gói mạng.\n\n**Thử nghiệm:**\n\n1. Mất gói mạng bằng cách tắt kết nối internet hoặc sử dụng công cụ giả lập mạng.\n2. Gửi yêu cầu đến API và kiểm tra xem API có trả về lỗi kết nối hay không.\n3. Khởi động lại kết nối internet và kiểm tra xem API hoạt động bình thường.\n\n**Kết quả mong đợi:** API sẽ trả về lỗi kết nối khi mất gói mạng và hoạt động bình thường khi kết nối được khôi phục."
    },
    {
      "question_id": "EQ2055-VN",
      "question": "Kịch bản nào trong số này xác thực chính xác **observability** API bằng cách sử dụng **distributed tracing**?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chỉ kiểm tra các **HTTP status codes**",
        "B": "Theo dõi một **trace ID** trên nhiều **microservice**",
        "C": "Kiểm tra việc sử dụng bộ nhớ trong các **log** máy chủ",
        "D": "Sử dụng các ghi chú **test** thủ công"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Trace ID** theo dõi các yêu cầu trên các dịch vụ."
    },
    {
      "question_id": "EQ2056-VN",
      "type": "Writing",
      "gold": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Phương pháp xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test** là sử dụng **script** tự động kiểm tra dữ liệu **test** trước và sau khi thực hiện **API test**. Script sẽ so sánh dữ liệu **test** trước và sau để xác minh liệu dữ liệu đã được dọn dẹp đúng cách hay chưa. Nếu dữ liệu không được dọn dẹp đúng cách, script sẽ báo lỗi để người dùng có thể khắc phục."
    },
    {
      "question_id": "EQ2057-VN",
      "question": "Điều nào sau đây chỉ ra một lỗ hổng **denial-of-service**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "API chấp nhận yêu cầu không giới hạn mà không cần **throttling**",
        "B": "API trả về **404 Not Found**",
        "C": "**API schema** thiếu trường mô tả",
        "D": "**Unit test coverage** thấp"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Các yêu cầu không bị hạn chế có thể làm cạn kiệt tài nguyên, gây ra **DoS**."
    },
    {
      "question_id": "EQ2058-VN",
      "type": "Writing",
      "gold": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "Để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần, chúng ta có thể viết một **test case** như sau:\n\n**Test Case: Rollback trong giao dịch nhiều bước**\n\n**Mô tả:** Xác minh rằng khi một giao dịch nhiều bước thất bại một phần, hệ thống sẽ **rollback** đúng cách và giữ nguyên trạng thái ban đầu.\n\n**Thử nghiệm:**\n\n1. Tạo một giao dịch nhiều bước với các bước A, B và C.\n2. Thử nghiệm bước A và B thành công, bước C thất bại.\n3. Xác minh rằng hệ thống đã **rollback** đúng cách và giữ nguyên trạng thái ban đầu.\n4. Lặp lại bước 2 và 3 nhiều lần để đảm bảo tính ổn định của hệ thống.\n\n**Kết quả mong muốn:** Hệ thống sẽ **rollback** đúng cách và giữ nguyên trạng thái ban đầu khi giao dịch nhiều bước thất bại một phần."
    },
    {
      "question_id": "EQ2059-VN",
      "question": "**HTTP status code** nào nên được xác thực khi một yêu cầu API được định dạng tốt nhưng bị cấm do hạn chế vai trò?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**403 Forbidden** chỉ ra máy khách đã được xác thực nhưng không được ủy quyền."
    },
    {
      "question_id": "EQ2060-VN",
      "type": "Writing",
      "gold": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "Một cách tiếp cận để xác thực các thông báo lỗi tuân theo một JSON schema nhất quán trên tất cả các endpoint là sử dụng một công cụ như Swagger hoặc OpenAPI để định nghĩa và kiểm tra JSON schema cho từng endpoint. Sau đó, sử dụng một thư viện hoặc framework như JSON Schema Validator để xác thực các thông báo lỗi trước khi gửi đến khách hàng. Điều này đảm bảo rằng các thông báo lỗi luôn tuân theo một JSON schema nhất quán trên tất cả các endpoint."
    },
    {
      "question_id": "EQ3001-VN",
      "question": "Kịch bản nào sau đây thể hiện rõ nhất một bài kiểm tra multi-hop (đa bước) liên quan đến các endpoint đăng nhập và làm mới token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Gửi yêu cầu tới GET /health",
        "B": "Nhận access token qua POST /login, sau đó sử dụng POST /refresh để gia hạn session",
        "C": "Gửi yêu cầu với token đã hết hạn tới một endpoint được bảo vệ",
        "D": "Kiểm tra trạng thái 200 trên GET /docs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Kiểm tra multi-hop có nghĩa là nối chuỗi đăng nhập với việc sử dụng refresh token sau đó."
    },
    {
      "question_id": "EQ3002-VN",
      "type": "Writing",
      "gold": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "Dưới đây là một ví dụ về test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới:\n\n**Test Case:** Xác thực đăng nhập, làm mới token và truy cập API được bảo vệ\n\n**Bước 1:** Đăng nhập với tài khoản hợp lệ và nhận token\n\n*   Đầu vào: Tài khoản hợp lệ và mật khẩu hợp lệ\n*   Đầu ra: Token hợp lệ\n\n**Bước 2:** Làm mới token đã được cấp\n\n*   Đầu vào: Token hợp lệ và mật khẩu hợp lệ\n*   Đầu ra: Token mới hợp lệ\n\n**Bước 3:** Truy cập API được bảo vệ bằng token mới\n\n*   Đầu vào: Token mới hợp lệ và yêu cầu API\n*   Đầu ra: Trả về dữ liệu từ API\n\n**Kết quả mong muốn:** Xác thực thành công và truy cập vào API được bảo vệ bằng token đã được làm mới."
    },
    {
      "question_id": "EQ3003-VN",
      "question": "Một server nên trả về mã trạng thái HTTP nào khi một refresh token đã hết hạn?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "401 Unauthorized",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "B. 403 Forbidden",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Refresh token đã hết hạn có nghĩa là client phải đăng nhập lại → 401 Unauthorized."
    },
    {
      "question_id": "EQ3004-VN",
      "type": "Writing",
      "gold": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "Để thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token, bạn có thể thực hiện các bước sau:\n\n1. Tạo một ứng dụng khách giả (client) và một dịch vụ chứng thực giả (authorization server) để mô phỏng quá trình đăng nhập.\n2. Khi ứng dụng khách giả gửi yêu cầu đăng nhập đến dịch vụ chứng thực giả, hãy giả lập một nỗ lực đăng nhập không thành công bằng cách trả về mã lỗi hoặc trạng thái không thành công.\n3. Sau khi nỗ lực đăng nhập không thành công, hãy kiểm tra xem dịch vụ chứng thực giả có tạo refresh token hay không. Nếu không, thì bài kiểm tra đã thành công.\n\nVí dụ trong Python:\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n# Mô phỏng ứng dụng khách giả\n@app.post(\"/login\")\nasync def login(username: str, password: str):\n    # Giả lập nỗ lực đăng nhập không thành công\n    if username!= \"tài khoản\" or password!= \"mật khẩu\":\n        raise HTTPException(status_code=401, detail=\"Mật khẩu không đúng\")\n    \n    # Giả lập tạo refresh token\n    refresh_token = \"refresh_token_123\"\n    return {\"refresh_token\": refresh_token}\n\n# Mô phỏng dịch vụ chứng thực giả\n@app.post(\"/refresh-token\")\nasync def refresh_token(refresh_token: str):\n    # Kiểm tra xem refresh token có tồn tại hay không\n    if refresh_token!= \"refresh_token_123\":\n        raise HTTPException(status_code=401, detail=\"Refresh token không tồn tại\")\n    \n    # Tạo mới access token\n    access_token = \"access_token_123\"\n    return {\"access_token\": access_token}\n```\n\nTrong ví dụ trên, khi ứng dụng khách giả gửi yêu cầu đăng nhập đến dịch vụ chứng thực giả, dịch vụ chứng thực giả sẽ trả về mã lỗi 401 nếu nỗ lực đăng nhập không thành công. Sau đó, dịch vụ chứng thực giả sẽ không tạo refresh token, vì vậy ứng dụng khách giả sẽ không thể tạo refresh token."
    },
    {
      "question_id": "EQ3005-VN",
      "question": "Cái nào sau đây ánh xạ một mã lỗi cụ thể của ứng dụng tới mã trạng thái HTTP chính xác?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "APP_1001 (User not found) → 404 Not Found",
        "B": "APP_2002 (Invalid password) → 201 Created",
        "C": "APP_3003 (Success) → 500 Internal Server Error",
        "D": "APP_9999 (Database error) → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Ánh xạ lỗi người dùng không tìm thấy tới 404 là một bản dịch HTTP chính xác."
    },
    {
      "question_id": "EQ3006-VN",
      "type": "Writing",
      "gold": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Để xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API, tôi sẽ sử dụng các phương pháp sau:\n\n1. **Tạo một kho dữ liệu mã nghiệp vụ**: Tôi sẽ tạo một kho dữ liệu chứa tất cả các mã nghiệp vụ (ví dụ: ORDER_001, ORDER_002,...) và các mã trạng thái HTTP (ví dụ: 200, 400, 500,...).\n\n2. **Ánh xạ mã nghiệp vụ tới mã trạng thái HTTP**: Tôi sẽ ánh xạ các mã nghiệp vụ tới các mã trạng thái HTTP trong kho dữ liệu, đảm bảo rằng mỗi mã nghiệp vụ chỉ được ánh xạ tới một mã trạng thái HTTP.\n\n3. **Sử dụng kiểm tra mã nghiệp vụ**: Trước khi gửi phản hồi API, tôi sẽ kiểm tra mã nghiệp vụ và ánh xạ nó tới mã trạng thái HTTP tương ứng trong kho dữ liệu để đảm bảo rằng phản hồi API được gửi ra đúng mã trạng thái HTTP.\n\nBằng cách sử dụng các phương pháp này, tôi có thể xác thực việc ánh xạ chính xác các mã nghiệp vụ tới các mã trạng thái HTTP trong các phản hồi API."
    },
    {
      "question_id": "EQ3007-VN",
      "question": "Kịch bản nào thể hiện việc kiểm tra tiêu cực chuỗi (chained negative testing)?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Kiểm tra yêu cầu GET /status đơn lẻ",
        "B": "Đăng nhập hợp lệ sau đó truy cập /profile",
        "C": "Kiểm tra thời gian hoạt động của server với GET /health",
        "D": "Đăng nhập với mật khẩu hết hạn → 401, sau đó thử lại refresh token → 401"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Các bài kiểm tra tiêu cực chuỗi xác thực các thất bại trên nhiều endpoint."
    },
    {
      "question_id": "EQ3008-VN",
      "type": "Writing",
      "gold": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "Dưới đây là một ví dụ về test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền:\n\n**Test Case:** Chuỗi tạo đơn hàng, thanh toán và hoàn tiền\n\n**Mô tả:** Kiểm tra tính toàn diện của hệ thống khi tạo đơn hàng, thanh toán và hoàn tiền.\n\n**Trường hợp sử dụng:**\n\n1. Gọi API tạo đơn hàng với thông tin đơn hàng hợp lệ.\n2. Gọi API xác nhận đơn hàng.\n3. Gọi API thanh toán với thông tin thanh toán hợp lệ.\n4. Gọi API hoàn tiền với thông tin hoàn tiền hợp lệ.\n5. Kiểm tra trạng thái đơn hàng, trạng thái thanh toán và trạng thái hoàn tiền.\n\n**Thử nghiệm:**\n\n| Scenario | Triggers | Expected Result |\n| --- | --- | --- |\n| Tạo đơn hàng thành công | Gọi API tạo đơn hàng | Đơn hàng được tạo thành công |\n| Xác nhận đơn hàng thành công | Gọi API xác nhận đơn hàng | Đơn hàng được xác nhận thành công |\n| Thanh toán thành công | Gọi API thanh toán | Thanh toán được thực hiện thành công |\n| Hoàn tiền thành công | Gọi API hoàn tiền | Hoàn tiền được thực hiện thành công |\n| Đơn hàng bị hủy | Gọi API hủy đơn hàng | Đơn hàng bị hủy thành công |\n\n**Thử nghiệm ngoại lệ:**\n\n| Scenario | Triggers | Expected Result |\n| --- | --- | --- |\n| Thông tin đơn hàng không hợp lệ | Gọi API tạo đơn hàng với thông tin không hợp lệ | Lỗi tạo đơn hàng |\n| Thông tin thanh toán không hợp lệ | Gọi API thanh toán với thông tin không hợp lệ | Lỗi thanh toán |\n| Thông tin hoàn tiền không hợp lệ | Gọi API hoàn tiền với thông tin không hợp lệ | Lỗi hoàn tiền |\n| Đơn hàng đã được hủy | Gọi API xác nhận đơn hàng | Lỗi xác nhận đơn hàng |\n| Thanh toán đã được thực hiện | Gọi API thanh toán | Lỗi thanh toán |\n| Hoàn tiền đã được thực hiện | Gọi API hoàn tiền | Lỗi hoàn tiền |"
    },
    {
      "question_id": "EQ3009-VN",
      "question": "Mã trạng thái HTTP nào là chính xác để ánh xạ một lỗi tùy chỉnh ORDER_DUPLICATE tới HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "404 Not Found",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Đơn hàng trùng lặp là một xung đột → 409."
    },
    {
      "question_id": "EQ3010-VN",
      "type": "Writing",
      "gold": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case xác thực việc làm mới token hoạt động trên nhiều microservice có thể bao gồm các bước sau:\n\n1. Gọi API tạo token mới trên microservice xác thực.\n2. Gọi API yêu cầu dữ liệu từ microservice dữ liệu người dùng.\n3. Gọi API yêu cầu dữ liệu từ microservice dữ liệu quyền hạn.\n4. Kiểm tra xem token mới có thể được sử dụng để yêu cầu dữ liệu từ các microservice khác hay không.\n\nBằng cách thực hiện các bước này, chúng ta có thể xác thực việc làm mới token hoạt động trên nhiều microservice và đảm bảo rằng token mới có thể được sử dụng để truy cập dữ liệu từ các microservice khác."
    },
    {
      "question_id": "EQ3011-VN",
      "question": "Kịch bản nào xác thực việc xử lý lỗi đa bước (multi-hop) chính xác trong một quy trình thương mại điện tử?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Tạo đơn hàng → chi tiết thanh toán không hợp lệ → 402 Payment Required",
        "B": "Kiểm tra kho hàng → sản phẩm tồn tại → 200 OK",
        "C": "Gọi endpoint healthcheck → 200 OK",
        "D": "Yêu cầu danh mục sản phẩm → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Tạo đơn hàng → chi tiết thanh toán không hợp lệ → 402 Payment Required",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thanh toán thất bại sau khi tạo đơn hàng là một bài kiểm tra tiêu cực multi-hop."
    },
    {
      "question_id": "EQ3012-VN",
      "type": "Writing",
      "gold": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "Dưới đây là một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400:\n\n**Kiểm tra xác thực ánh xạ mã lỗi xác thực tới các phản hồi HTTP 400**\n\n**Mã lỗi xác thực** | **Phản hồi HTTP 400**\n---------------------|----------------------\nInvalidUsername      | 400 Bad Request: Tên đăng nhập không hợp lệ\nInvalidPassword      | 400 Bad Request: Mật khẩu không hợp lệ\nInvalidEmail          | 400 Bad Request: Địa chỉ email không hợp lệ\nInvalidPhoneNumber    | 400 Bad Request: Số điện thoại không hợp lệ\n\n**Lưu ý:** Các mã lỗi xác thực và phản hồi HTTP 400 có thể được điều chỉnh tùy theo yêu cầu cụ thể của dự án."
    },
    {
      "question_id": "EQ3013-VN",
      "question": "Cái nào trong số này thể hiện một bài kiểm tra đăng nhập chuỗi cấp độ khó?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Chỉ kiểm tra GET /login-docs",
        "B": "Chỉ đăng nhập một lần và dừng lại",
        "C": "Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại",
        "D": "Kiểm tra endpoint GET /health"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Kết hợp nhiều endpoint vào một quy trình xác thực."
    },
    {
      "question_id": "EQ3014-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "Để thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới, chúng ta có thể thực hiện như sau:\n\n**Tên test case:** \"Refresh token đã hết hạn không thể cấp access token mới\"\n\n**Giả sử:** Refresh token đã hết hạn và không được cấp lại\n\n**Thủ tục:**\n\n1. Gửi yêu cầu refresh token đã hết hạn đến server\n2. Xác thực rằng server trả về trạng thái lỗi hoặc thông báo refresh token đã hết hạn\n3. Xác thực rằng access token mới không được cấp\n\n**Kết quả mong muốn:** Refresh token đã hết hạn không thể cấp access token mới."
    },
    {
      "question_id": "EQ3015-VN",
      "question": "Ánh xạ nào là chính xác cho lỗi nghiệp vụ PAYMENT_DECLINED?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Thanh toán bị từ chối → 402 Payment Required."
    },
    {
      "question_id": "EQ3016-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất là một quá trình kiểm tra nghiêm ngặt bao gồm các bước sau:\n\n- Bước 1: Người dùng thực hiện việc đăng nhập vào hệ thống.\n- Bước 2: Sau khi đăng nhập thành công, người dùng thực hiện việc đăng xuất khỏi hệ thống.\n- Bước 3: Hệ thống xác thực việc hủy bỏ session của người dùng sau khi đăng xuất.\n\nBài kiểm tra này nhằm mục đích đảm bảo rằng hệ thống đã thực sự hủy bỏ session của người dùng sau khi đăng xuất, ngăn chặn khả năng người dùng tiếp tục sử dụng session đã đăng xuất."
    },
    {
      "question_id": "EQ3017-VN",
      "question": "Kịch bản nào ánh xạ tới mã HTTP chính xác cho một lỗi ứng dụng nội bộ?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "APP_TIMEOUT → 200 OK",
        "B": "APP_TIMEOUT → 504 Gateway Timeout",
        "C": "APP_TIMEOUT → 201 Created",
        "D": "APP_TIMEOUT → 400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Các lỗi timeout nên ánh xạ tới 504 Gateway Timeout."
    },
    {
      "question_id": "EQ3018-VN",
      "type": "Writing",
      "gold": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "Dưới đây là một ví dụ về test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập:\n\n**Test Case:** Đăng ký, xác minh email và đăng nhập thành công\n\n**Mô tả:**\n\n1. **Bước 1:** Đăng ký tài khoản mới với thông tin hợp lệ (endpoint: POST /api/register)\n * Dữ liệu yêu cầu: { \"email\": \"test@example.com\", \"password\": \"password123\", \"name\": \"Test User\" }\n * Trả về: Mã xác minh email được gửi đến địa chỉ email đã đăng ký\n2. **Bước 2:** Xác minh email bằng liên kết được gửi đến (endpoint: GET /api/verify-email)\n * Dữ liệu yêu cầu: Mã xác minh email được gửi đến\n * Trả về: Thông báo xác minh email thành công\n3. **Bước 3:** Đăng nhập với tài khoản đã xác minh (endpoint: POST /api/login)\n * Dữ liệu yêu cầu: { \"email\": \"test@example.com\", \"password\": \"password123\" }\n * Trả về: Token truy cập thành công\n\n**Kết quả mong đợi:** Tất cả các bước đều thành công và tài khoản được xác minh thành công."
    },
    {
      "question_id": "EQ3019-VN",
      "question": "Bài kiểm tra nào xác thực quyền truy cập dựa trên vai trò chuỗi?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập với vai trò user → truy cập /admin → mong đợi 403 Forbidden",
        "B": "Đăng nhập với vai trò admin → truy cập /admin → mong đợi 200 OK",
        "C": "Đăng nhập với vai trò user → xem hồ sơ → 200 OK",
        "D": "GET /health → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Đăng nhập với vai trò user → truy cập /admin → mong đợi 403 Forbidden",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Vai trò không khớp dẫn đến 403 là một xác thực vai trò multi-hop."
    },
    {
      "question_id": "EQ3020-VN",
      "type": "Writing",
      "gold": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu có thể bao gồm các câu hỏi sau:\n\n1. Câu hỏi dễ: \"Bạn cần thực hiện bước nào để bắt đầu quy trình đặt lại mật khẩu?\"\n (Trả lời: Nhập địa chỉ email hoặc số điện thoại)\n\n2. Câu hỏi trung bình: \"Quy trình đặt lại mật khẩu thường yêu cầu người dùng nhập thông tin gì để xác minh danh tính?\"\n (Trả lời: Mã xác thực được gửi đến email hoặc số điện thoại)\n\n3. Câu hỏi khó: \"Tại sao quy trình đặt lại mật khẩu nên yêu cầu người dùng nhập mật khẩu mới và xác minh lại?\"\n (Trả lời: Để đảm bảo mật khẩu mới không trùng với mật khẩu cũ và để tránh khả năng xảy ra lỗi trong quá trình đặt lại mật khẩu)\n\n4. Câu hỏi khó hơn: \"Một số nền tảng xác thực có yêu cầu người dùng phải chờ một khoảng thời gian trước khi đặt lại mật khẩu. Lợi ích của yêu cầu này là gì?\"\n (Trả lời: Để tránh khả năng xảy ra hành vi giả mạo và đảm bảo tính toàn vẹn của thông tin người dùng)"
    },
    {
      "question_id": "EQ3021-VN",
      "question": "Kịch bản nào xác thực một chuỗi đăng nhập, làm mới và đăng xuất?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập → sử dụng token một lần",
        "B": "Làm mới token ngay sau khi đăng nhập",
        "C": "Chỉ đăng xuất",
        "D": "Đăng nhập → làm mới token → đăng xuất → xác nhận làm mới thất bại"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Đăng nhập → làm mới token → đăng xuất → xác nhận làm mới thất bại",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Chuỗi đầy đủ này kiểm tra toàn bộ vòng đời xác thực."
    },
    {
      "question_id": "EQ3022-VN",
      "type": "Writing",
      "gold": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "Dưới đây là một ví dụ về các test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ:\n\n**Test Case 1: Tạo người dùng thành công**\n\n* Đặt tên người dùng: \"test_user\"\n* Đặt mật khẩu: \"test_password\"\n* Xác thực: Người dùng mới được tạo thành công.\n\n**Test Case 2: Cập nhật hồ sơ thành công**\n\n* Tạo người dùng trước đó\n* Cập nhật tên người dùng: \"test_user_update\"\n* Xác thực: Hồ sơ người dùng được cập nhật thành công.\n\n**Test Case 3: Truy xuất hồ sơ thành công**\n\n* Tạo người dùng trước đó\n* Truy xuất hồ sơ người dùng\n* Xác thực: Hồ sơ người dùng được truy xuất thành công.\n\n**Test Case 4: Tạo người dùng thất bại (sử dụng tên người dùng đã tồn tại)**\n\n* Đặt tên người dùng: \"test_user\" (đã tồn tại)\n* Đặt mật khẩu: \"test_password\"\n* Xác thực: Tạo người dùng thất bại do tên người dùng đã tồn tại.\n\n**Test Case 5: Cập nhật hồ sơ thất bại (không có quyền truy cập)**\n\n* Tạo người dùng trước đó\n* Cập nhật tên người dùng mà không có quyền truy cập\n* Xác thực: Cập nhật hồ sơ thất bại do không có quyền truy cập.\n\n**Test Case 6: Truy xuất hồ sơ thất bại (không tìm thấy hồ sơ)**\n\n* Tạo người dùng trước đó\n* Xoá hồ sơ người dùng\n* Truy xuất hồ sơ người dùng\n* Xác thực: Truy xuất hồ sơ thất bại do không tìm thấy hồ sơ."
    },
    {
      "question_id": "EQ3023-VN",
      "question": "Ánh xạ nào dịch chính xác một lỗi nghiệp vụ STOCK_OUT sang HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "201 Created",
        "D": "403 Forbidden"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Hết hàng có nghĩa là một xung đột với việc thực hiện đơn hàng, ánh xạ tới 409."
    },
    {
      "question_id": "EQ3024-VN",
      "type": "Writing",
      "gold": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra này nhằm xác thực refresh token không thể được sử dụng sau khi đăng xuất bởi vì:\n\nKhi người dùng đăng xuất, refresh token cũng được xóa cùng với session của họ. Nếu refresh token vẫn còn hoạt động sau khi đăng xuất, điều đó có nghĩa là kẻ tấn công có thể sử dụng token này để lấy được access token và thực hiện các hành động trên tài khoản của người dùng đã đăng xuất. Vì vậy, việc xác thực refresh token không thể được sử dụng sau khi đăng xuất là một cách để đảm bảo an toàn cho người dùng."
    },
    {
      "question_id": "EQ3025-VN",
      "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi cho một quy trình giỏ hàng?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Thêm mặt hàng hợp lệ vào giỏ hàng → 200 OK",
        "B": "Thanh toán với thanh toán hợp lệ → 200 OK",
        "C": "Thêm mặt hàng → xóa mặt hàng → thanh toán → mong đợi 400 Bad Request",
        "D": "Xem giỏ hàng sau khi đăng nhập → 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Thanh toán giỏ hàng trống là một kịch bản tiêu cực chuỗi."
    },
    {
      "question_id": "EQ3026-VN",
      "type": "Writing",
      "gold": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "Để xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP, chúng ta có thể viết một test case như sau:\n\n```python\nimport unittest\nfrom flask import Flask, jsonify\n\nclass TestAuthExpired(unittest.TestCase):\n    def setUp(self):\n        self.app = Flask(__name__)\n        self.app.config['ERROR_MAPPING'] = {\n            'AUTH_EXPIRED': 401\n        }\n\n    def test_auth_expired(self):\n        # Tạo một yêu cầu giả với mã lỗi AUTH_EXPIRED\n        with self.app.test_request_context('/'):\n            self.assertEqual(self.app.config['ERROR_MAPPING']['AUTH_EXPIRED'], 401)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nTrong test case này, chúng ta tạo một ứng dụng Flask và ánh xạ mã lỗi AUTH_EXPIRED tới trạng thái HTTP 401. Sau đó, chúng ta tạo một yêu cầu giả và kiểm tra xem mã lỗi được ánh xạ đúng hay không."
    },
    {
      "question_id": "EQ3027-VN",
      "question": "Kịch bản nào thể hiện rõ nhất việc xác thực việc hủy đơn hàng chuỗi?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Hard",
      "options": {
        "A": "Tạo đơn hàng → hủy đơn hàng → GET /orders/{id} hiển thị status=cancelled",
        "B": "Hủy đơn hàng không tồn tại → 404",
        "C": "Chỉ tạo đơn hàng",
        "D": "Kiểm tra endpoint /status"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Tạo đơn hàng → hủy đơn hàng → GET /orders/{id} hiển thị status=cancelled",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Bao gồm vòng đời của việc tạo đơn hàng → hủy bỏ → xác minh."
    },
    {
      "question_id": "EQ3028-VN",
      "type": "Writing",
      "gold": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ là một quá trình xác minh mà trong đó chuỗi xác thực không được chấp nhận do token không hợp lệ. Trong trường hợp này, hệ thống sẽ yêu cầu người dùng nhập lại email hoặc yêu cầu xác minh lại thông qua một phương thức khác. Điều này nhằm đảm bảo tính bảo mật và ngăn chặn các cuộc tấn công giả mạo."
    },
    {
      "question_id": "EQ3029-VN",
      "question": "Ánh xạ nào dịch chính xác FILE_TOO_LARGE sang HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "404 Not Found",
        "D": "413 Payload Too Large"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "File quá lớn nên ánh xạ tới 413."
    },
    {
      "question_id": "EQ3030-VN",
      "type": "Writing",
      "gold": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "Dưới đây là một ví dụ về test case cấp độ khó cho chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt:\n\n**Test Case:** Chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt\n\n**Mô tả:** Kiểm tra xem chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt hoạt động đúng như mong đợi.\n\n**Bước 1: Nộp đơn vay**\n\n* **Endpoint:** POST /loan-application\n* **Tham số:** Tên, tuổi, thu nhập, nợ vay (ví dụ: {\"name\": \"Nguyễn Văn A\", \"age\": 30, \"income\": 5000, \"debt\": 1000})\n* **Trả về:** ID đơn vay thành công\n\n**Bước 2: Kiểm tra tín dụng**\n\n* **Endpoint:** GET /credit-check\n* **Tham số:** ID đơn vay thành công\n* **Trả về:** Tình trạng tín dụng (ví dụ: \"tín dụng tốt\")\n\n**Bước 3: Phê duyệt vay**\n\n* **Endpoint:** POST /loan-approval\n* **Tham số:** ID đơn vay thành công\n* **Trả về:** Tình trạng phê duyệt (ví dụ: \"phê duyệt thành công\")\n\n**Kịch bản thử nghiệm:**\n\n1. Gửi yêu cầu POST đến endpoint /loan-application với tham số cần thiết.\n2. Lấy ID đơn vay thành công từ trả về của bước 1.\n3. Gửi yêu cầu GET đến endpoint /credit-check với tham số cần thiết.\n4. Lấy tình trạng tín dụng từ trả về của bước 3.\n5. Nếu tình trạng tín dụng tốt, gửi yêu cầu POST đến endpoint /loan-approval với tham số cần thiết.\n6. Lấy tình trạng phê duyệt từ trả về của bước 5.\n\n**Kiểm tra:**\n\n* ID đơn vay thành công được tạo thành công.\n* Tình trạng tín dụng được trả về đúng.\n* Tình trạng phê duyệt được trả về đúng."
    },
    {
      "question_id": "EQ3031-VN",
      "question": "Chuỗi nào xác thực các refresh token trên nhiều session?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Chỉ đăng nhập → đăng xuất",
        "B": "Đăng nhập → làm mới token → đăng xuất → đăng nhập lại → xác nhận refresh token cũ không hợp lệ",
        "C": "Làm mới token mà không đăng nhập",
        "D": "Kiểm tra GET /status"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đăng nhập → làm mới token → đăng xuất → đăng nhập lại → xác nhận refresh token cũ không hợp lệ",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Đảm bảo xử lý session trên nhiều lần đăng nhập."
    },
    {
      "question_id": "EQ3032-VN",
      "type": "Writing",
      "gold": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Dưới đây là một thiết kế test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới:\n\n**Test Case 1: Đăng ký thành công**\n\n* Điều kiện tiền đề: Người dùng chưa có tài khoản trên hệ thống.\n* Hoàn cảnh: Người dùng nhập thông tin đăng ký hợp lệ (tên, địa chỉ email, mật khẩu).\n* Thử nghiệm: Người dùng submit form đăng ký.\n* Kết quả mong muốn: Người dùng được tạo thành công tài khoản mới.\n\n**Test Case 2: Đặt lại mật khẩu thành công**\n\n* Điều kiện tiền đề: Người dùng đã có tài khoản trên hệ thống và quên mật khẩu.\n* Hoàn cảnh: Người dùng nhập địa chỉ email và mật khẩu cũ hợp lệ để yêu cầu đặt lại mật khẩu.\n* Thử nghiệm: Người dùng nhận được email chứa liên kết đặt lại mật khẩu và click vào liên kết để đặt lại mật khẩu mới.\n* Kết quả mong muốn: Người dùng được đặt lại mật khẩu thành công.\n\n**Test Case 3: Đăng nhập với thông tin đăng nhập mới**\n\n* Điều kiện tiền đề: Người dùng đã đặt lại mật khẩu thành công trong Test Case 2.\n* Hoàn cảnh: Người dùng nhập thông tin đăng nhập mới (tên, địa chỉ email, mật khẩu mới).\n* Thử nghiệm: Người dùng submit form đăng nhập.\n* Kết quả mong muốn: Người dùng được đăng nhập thành công với thông tin đăng nhập mới."
    },
    {
      "question_id": "EQ3033-VN",
      "question": "Ánh xạ nào là chính xác để ánh xạ lỗi nghiệp vụ INVALID_COUPON?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Coupon không hợp lệ nên ánh xạ tới 400 Bad Request."
    },
    {
      "question_id": "EQ3034-VN",
      "type": "Writing",
      "gold": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Dưới đây là một ví dụ về các test case cho chuỗi các endpoint tải lên file, quét virus và tải xuống:\n\n**Test Case 1: Tải lên file thành công**\n\n* Mô tả: Tải lên một file hợp lệ (ví dụ: file văn bản) lên server.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để nhận file.\n* Đầu vào: File văn bản (có thể chọn file từ máy tính).\n* Đầu ra: File được tải lên thành công và lưu trữ trên server.\n* Kiểm tra: File được lưu trữ trên server và có thể được tải xuống.\n\n**Test Case 2: Tải lên file không hợp lệ**\n\n* Mô tả: Tải lên một file không hợp lệ (ví dụ: file virus) lên server.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để nhận file.\n* Đầu vào: File virus (có thể chọn file từ máy tính).\n* Đầu ra: Server báo lỗi và không cho phép tải lên file.\n* Kiểm tra: File không được lưu trữ trên server và không có thể được tải xuống.\n\n**Test Case 3: Quét virus thành công**\n\n* Mô tả: Quét một file hợp lệ (ví dụ: file văn bản) trên server để tìm virus.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để quét file.\n* Đầu vào: File văn bản (có thể chọn file từ máy tính).\n* Đầu ra: Server báo rằng file không chứa virus.\n* Kiểm tra: File không chứa virus và có thể được tải xuống.\n\n**Test Case 4: Quét virus không thành công**\n\n* Mô tả: Quét một file không hợp lệ (ví dụ: file virus) trên server để tìm virus.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để quét file.\n* Đầu vào: File virus (có thể chọn file từ máy tính).\n* Đầu ra: Server báo rằng file chứa virus.\n* Kiểm tra: File chứa virus và không thể được tải xuống.\n\n**Test Case 5: Tải xuống file thành công**\n\n* Mô tả: Tải xuống một file hợp lệ (ví dụ: file văn bản) từ server.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để tải xuống file.\n* Đầu vào: File văn bản (có thể chọn file từ máy tính).\n* Đầu ra: File được"
    },
    {
      "question_id": "EQ3035-VN",
      "question": "Kịch bản nào xác thực ánh xạ lỗi đa bước (multi-hop) chính xác trong quy trình thanh toán?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 402",
        "B": "API thanh toán trả về APPROVED → được ánh xạ tới HTTP 404",
        "C": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 201",
        "D": "API thanh toán trả về ERROR → được ánh xạ tới HTTP 200"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thanh toán bị từ chối ánh xạ chính xác tới 402 Payment Required."
    },
    {
      "question_id": "EQ3036-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Để xác thực việc ngăn chặn việc sử dụng lại refresh token, bạn có thể sử dụng một bài kiểm tra chuỗi (token blacklisting) như sau:\n\n1. Khi một token refresh bị sử dụng lại, bạn gửi yêu cầu đến server để xóa token refresh đó khỏi cơ sở dữ liệu.\n2. Khi một yêu cầu xác thực mới được gửi đến, bạn kiểm tra cơ sở dữ liệu để xem token refresh đã được xóa chưa. Nếu đã được xóa, bạn sẽ không chấp nhận token refresh đó.\n3. Nếu token refresh hợp lệ, bạn sẽ chấp nhận và tạo ra một token mới.\n\nBằng cách thực hiện bài kiểm tra chuỗi này, bạn có thể ngăn chặn việc sử dụng lại token refresh đã bị xóa, đảm bảo tính bảo mật và ngăn chặn việc sử dụng lại token refresh."
    },
    {
      "question_id": "EQ3037-VN",
      "question": "Ánh xạ nào là chính xác để ánh xạ RATE_LIMIT_EXCEEDED sang HTTP?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Vượt quá giới hạn tốc độ nên ánh xạ tới 429."
    },
    {
      "question_id": "EQ3038-VN",
      "type": "Writing",
      "gold": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "Dưới đây là một ví dụ về test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán:\n\n**Test Case:** Tìm kiếm sản phẩm, thêm vào giỏ hàng và thanh toán\n\n**Mô tả:** Kiểm tra việc tìm kiếm sản phẩm, thêm vào giỏ hàng và thanh toán sản phẩm thành công.\n\n**Bước 1:** Tìm kiếm sản phẩm\n\n* Gọi API tìm kiếm sản phẩm với từ khóa \"sản phẩm cần tìm kiếm\"\n* Kiểm tra kết quả tìm kiếm có đúng hay không\n\n**Bước 2:** Thêm vào giỏ hàng\n\n* Gọi API thêm sản phẩm vào giỏ hàng\n* Kiểm tra giỏ hàng có chứa sản phẩm vừa thêm hay không\n\n**Bước 3:** Thanh toán\n\n* Gọi API thanh toán sản phẩm\n* Kiểm tra giao dịch thanh toán thành công hay không\n\n**Thử nghiệm:**\n\n* Sử dụng các trường hợp thử nghiệm khác nhau (ví dụ: tìm kiếm sản phẩm không tồn tại, thêm sản phẩm vào giỏ hàng với số lượng không hợp lệ)\n* Kiểm tra các lỗi có thể xảy ra trong quá trình tìm kiếm, thêm vào giỏ hàng và thanh toán."
    },
    {
      "question_id": "EQ3039-VN",
      "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi trong quy trình đặt vé?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Đặt vé hợp lệ → 200 OK",
        "B": "Đặt vé → hủy vé → thử hoàn tiền → mong đợi 400 Bad Request",
        "C": "Xem các ghế có sẵn → 200 OK",
        "D": "Kiểm tra GET /status → 200 OK"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tiêu cực chuỗi: hoàn tiền sau khi hủy là không hợp lệ."
    },
    {
      "question_id": "EQ3040-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Một bài kiểm tra chuỗi (token) là một chuỗi ký tự được tạo ra bởi một hệ thống để xác thực việc ngăn chặn tấn công chiếm đoạt session (tấn công session hijacking). Khi một người dùng đăng nhập vào hệ thống, hệ thống sẽ tạo một chuỗi token và gửi nó đến trình duyệt của người dùng. Mỗi yêu cầu sau đó đến server sẽ bao gồm chuỗi token này để xác thực tính hợp lệ của người dùng và ngăn chặn tấn công chiếm đoạt session."
    },
    {
      "question_id": "EQ3041-VN",
      "question": "Chuỗi nào xác thực chính xác việc xoay vòng token với phát hiện việc sử dụng lại refresh token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập → gọi API một lần → đăng xuất",
        "B": "Đăng nhập → làm mới token → thử sử dụng lại refresh token cũ → mong đợi 401 Unauthorized",
        "C": "Chỉ đăng nhập",
        "D": "Làm mới mà không đăng nhập"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đăng nhập → làm mới token → thử sử dụng lại refresh token cũ → mong đợi 401 Unauthorized",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Việc sử dụng lại token phải bị từ chối sau khi xoay vòng để ngăn chặn các cuộc tấn công replay."
    },
    {
      "question_id": "EQ3042-VN",
      "type": "Writing",
      "gold": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "Dưới đây là một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc:\n\n**Test case 1: Cập nhật và đọc**\n\n1. Tạo một tài nguyên mới với một ETag nhất định.\n2. Cập nhật tài nguyên này với một giá trị mới và nhận một ETag mới.\n3. Đọc tài nguyên này và kiểm tra ETag mới.\n4. Cập nhật tài nguyên này với một giá trị mới và nhận một ETag mới.\n5. Đọc tài nguyên này và kiểm tra ETag mới.\n6. Sử dụng If-Match với ETag cũ để cập nhật tài nguyên này.\n7. Kiểm tra nếu cập nhật thành công và ETag mới vẫn còn tồn tại.\n\n**Test case 2: Đồng thời cập nhật**\n\n1. Tạo một tài nguyên mới với một ETag nhất định.\n2. Hai người dùng cập nhật tài nguyên này đồng thời với giá trị mới và nhận ETag mới.\n3. Sử dụng If-Match với ETag cũ để cập nhật tài nguyên này.\n4. Kiểm tra nếu cập nhật thành công và ETag mới vẫn còn tồn tại.\n\n**Test case 3: Cập nhật và đọc với If-Match**\n\n1. Tạo một tài nguyên mới với một ETag nhất định.\n2. Cập nhật tài nguyên này với một giá trị mới và nhận một ETag mới.\n3. Sử dụng If-Match với ETag cũ để cập nhật tài nguyên này.\n4. Đọc tài nguyên này và kiểm tra ETag mới.\n5. Kiểm tra nếu cập nhật thành công và ETag mới vẫn còn tồn tại."
    },
    {
      "question_id": "EQ3043-VN",
      "question": "Mã trạng thái HTTP nào nên được trả về khi một điều kiện tiên quyết If-Match thất bại do ETag cũ trong quá trình PUT /resource/{id}?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "412 Precondition Failed",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "ETag cũ nên ánh xạ tới 412 Precondition Failed."
    },
    {
      "question_id": "EQ3044-VN",
      "type": "Writing",
      "gold": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Dưới đây là thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ:\n\n1. **Bước 1: POST /exports**\n * Gửi yêu cầu POST đến endpoint /exports với dữ liệu cần xuất.\n * Kiểm tra trạng thái yêu cầu và chờ đợi cho đến khi trạng thái là \"Đang xuất\" hoặc \"Hoàn thành\".\n\n2. **Bước 2: Lặp lại thăm dò GET /jobs/{id}**\n * Lặp lại việc gửi yêu cầu GET đến endpoint /jobs/{id} với ID công việc được tạo ở bước 1.\n * Kiểm tra trạng thái công việc và chờ đợi cho đến khi trạng thái là \"Hoàn thành\".\n\n3. **Bước 3: GET /exports/{id}**\n * Gửi yêu cầu GET đến endpoint /exports/{id} với ID xuất được tạo ở bước 1.\n * Kiểm tra trạng thái yêu cầu và xác nhận rằng xuất đã hoàn thành thành công.\n\nLưu ý: Các bước trên có thể được thực hiện trong một vòng lặp để đảm bảo rằng xuất đã hoàn thành trước khi kiểm tra trạng thái cuối cùng."
    },
    {
      "question_id": "EQ3045-VN",
      "question": "Ánh xạ nào từ mã nghiệp vụ tới HTTP là phù hợp nhất cho RESOURCE_VERSION_CONFLICT trong quá trình cập nhật?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Xung đột phiên bản ánh xạ chính xác tới 409 Conflict."
    },
    {
      "question_id": "EQ3046-VN",
      "type": "Writing",
      "gold": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "Dưới đây là một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code:\n\n1. **Trường hợp 1: Không cung cấp code authorization**\n * Request đến /authorize mà không cung cấp code authorization.\n * Trả về lỗi 400 Bad Request.\n2. **Trường hợp 2: Không cung cấp client_id**\n * Request đến /authorize mà không cung cấp client_id.\n * Trả về lỗi 400 Bad Request.\n3. **Trường hợp 3: Không cung cấp scope**\n * Request đến /token với scope bị thiếu.\n * Trả về lỗi 400 Bad Request.\n4. **Trường hợp 4: Không cung cấp grant_type**\n * Request đến /token mà không cung cấp grant_type.\n * Trả về lỗi 400 Bad Request.\n\nVí dụ request và response cho trường hợp 3:\n\nRequest:\n```http\nPOST /token HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nclient_id=client1&client_secret=secret1&code=abc123\n```\n\nResponse:\n```http\nHTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_request\",\n  \"error_description\": \"Missing scope parameter\"\n}\n```"
    },
    {
      "question_id": "EQ3047-VN",
      "question": "Mã trạng thái nào thể hiện rõ nhất một refresh token được trình bày cho một client_id sai trong một hệ thống đa người thuê (multi-tenant)?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": false,
      "explanation": "OAuth2 chỉ định invalid_grant (400) cho việc sử dụng client/refresh sai."
    },
    {
      "question_id": "EQ3048-VN",
      "type": "Writing",
      "gold": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "Dưới đây là một bài kiểm tra chuỗi về việc tạo charge idempotent với Idempotency-Key trên các endpoint thử lại và hoàn tiền:\n\n1. **Tạo charge idempotent:**\n   - Gửi yêu cầu tạo charge với Idempotency-Key\n   - Nếu charge đã tồn tại với Idempotency-Key tương ứng, không tạo charge mới\n\n2. **Endpoint thử lại:**\n   - Khi nhận được yêu cầu thử lại, kiểm tra xem charge đã tồn tại với Idempotency-Key tương ứng\n   - Nếu charge đã tồn tại, trả lại kết quả của charge đó\n   - Nếu charge chưa tồn tại, tạo charge mới với Idempotency-Key tương ứng\n\n3. **Endpoint hoàn tiền:**\n   - Khi nhận được yêu cầu hoàn tiền, kiểm tra xem charge đã tồn tại với Idempotency-Key tương ứng\n   - Nếu charge đã tồn tại, hoàn tiền cho charge đó\n   - Nếu charge chưa tồn tại, trả lại lỗi rằng charge chưa tồn tại\n\nLưu ý: Idempotency-Key là một chuỗi ký tự duy nhất cho mỗi charge, giúp xác định xem charge đã tồn tại hay chưa."
    },
    {
      "question_id": "EQ3049-VN",
      "question": "Ánh xạ trạng thái nào là chính xác cho mã nghiệp vụ INSUFFICIENT_FUNDS từ cổng thanh toán?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Không đủ tiền → 402 Payment Required."
    },
    {
      "question_id": "EQ3050-VN",
      "type": "Writing",
      "gold": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Dưới đây là một bài kiểm tra chuỗi cho quy trình xử lý file bạn vừa mô tả:\n\n1. **Tải lên**: Gửi yêu cầu HTTP POST đến server với tệp tin cần xử lý.\n2. **POST /process**: Server nhận tệp tin và bắt đầu xử lý nó.\n3. **Trả về trạng thái 202**: Server trả về trạng thái 202 (Tạo hoặc thay đổi đã được chấp nhận) để thông báo cho client rằng tệp tin đã được tiếp nhận và đang được xử lý.\n4. **Thăm dò trạng thái**: Client gửi yêu cầu HTTP GET đến server để hỏi về trạng thái xử lý của tệp tin.\n5. **Trả về trạng thái hiện tại**: Server trả về trạng thái hiện tại của tệp tin, chẳng hạn như \"Đang xử lý\" hoặc \"Xử lý hoàn thành\".\n6. **Tải xuống**: Nếu tệp tin đã được xử lý thành công, client gửi yêu cầu HTTP GET đến server để tải xuống tệp tin đã xử lý."
    },
    {
      "question_id": "EQ3051-VN",
      "question": "Kịch bản nào xác thực chính xác chính sách backoff + thử lại trên các chuyển đổi 429 -> 200 của gateway?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "options": {
        "A": "API trả về 429 Too Many Requests → client thử lại với backoff → 200 OK",
        "B": "API trả về 401 Unauthorized → thử lại thành công",
        "C": "API trả về 404 Not Found → thử lại thành công",
        "D": "API trả về 500 → thử lại mà không có backoff"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thử lại với backoff lũy thừa là cần thiết để xử lý 429."
    },
    {
      "question_id": "EQ3052-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "Để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice, bạn có thể thực hiện các bước sau:\n\n1. **Kiểm tra header**: Kiểm tra header của yêu cầu vào API gateway để xác định có chứa token SSO hay không.\n2. **Kiểm tra token SSO**: Kiểm tra token SSO để xác định đã hết hạn hay chưa. Nếu đã hết hạn, hủy bỏ session SSO.\n3. **Truy cập microservice**: Nếu session SSO còn hiệu lực, truy cập microservice cần thiết và thực hiện các hoạt động phù hợp.\n\nVí dụ về mã Python:\n\n```python\nimport requests\n\ndef kiểm_tra_sso(header):\n    # Kiểm tra header để xác định có chứa token SSO hay không\n    if 'Authorization' not in header:\n        return False\n\n    # Kiểm tra token SSO\n    token = header['Authorization'].split(' ')[1]\n    if not token or token == '':\n        return False\n\n    # Hủy bỏ session SSO nếu đã hết hạn\n    #...\n    return True\n\ndef truy_cap_microservice(header):\n    # Kiểm tra session SSO\n    if not kiểm_tra_sso(header):\n        return False\n\n    # Truy cập microservice cần thiết\n    #...\n    return True\n\n# Sử dụng\nheader = {'Authorization': 'Bearer token_sso'}\nif truy_cap_microservice(header):\n    print('Truy cập microservice thành công')\nelse:\n    print('Truy cập microservice thất bại')\n```"
    },
    {
      "question_id": "EQ3053-VN",
      "question": "Mã HTTP nào nên ánh xạ tới BUSINESS_LIMIT_EXCEEDED khi hạn ngạch (quota) trên mỗi người dùng chặn một yêu cầu hợp lệ, đã xác thực?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Hạn ngạch cạn kiệt ánh xạ tới 429 Too Many Requests."
    },
    {
      "question_id": "EQ3054-VN",
      "type": "Writing",
      "gold": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "Dưới đây là một ví dụ về test case chuỗi cho việc thực hiện đơn hàng một phần:\n\n**Test Case 1: Tạo đơn hàng**\n\n- Điều kiện tiền đề: Có hàng tồn kho sẵn có\n- Hoạt động: Tạo đơn hàng với số lượng 10 sản phẩm\n- Kết quả mong muốn: Đơn hàng được tạo thành công\n\n**Test Case 2: Dự trữ hàng tồn kho**\n\n- Điều kiện tiền đề: Đơn hàng đã được tạo thành công\n- Hoạt động: Dự trữ hàng tồn kho cho đơn hàng\n- Kết quả mong muốn: Hàng tồn kho được dự trữ thành công\n\n**Test Case 3: Ship một phần**\n\n- Điều kiện tiền đề: Hàng tồn kho đã được dự trữ thành công\n- Hoạt động: Ship một phần của đơn hàng (5 sản phẩm)\n- Kết quả mong muốn: Hàng hóa được ship thành công\n\n**Test Case 4: Hủy phần còn lại và hoàn tiền chênh lệch**\n\n- Điều kiện tiền đề: Đơn hàng đã được ship một phần\n- Hoạt động: Hủy phần còn lại của đơn hàng và hoàn tiền chênh lệch\n- Kết quả mong muốn: Phần còn lại của đơn hàng được hủy thành công và tiền chênh lệch được hoàn trả cho khách hàng"
    },
    {
      "question_id": "EQ3055-VN",
      "question": "Ánh xạ nào là chính xác nhất cho mã lỗi SIGNATURE_INVALID trên xác minh giao hàng webhook?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Chữ ký webhook không hợp lệ nên trả về 401 Unauthorized."
    },
    {
      "question_id": "EQ3056-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "Dưới đây là một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA:\n\n1. POST /login: Gửi yêu cầu đăng nhập với thông tin tài khoản và mật khẩu hợp lệ.\n2. POST /2fa/verify: Gửi yêu cầu xác minh mã 2FA với mã sai (ví dụ: mã không tồn tại hoặc mã đã hết hạn).\n3. POST /refresh: Gửi yêu cầu refresh token để xem hệ thống có phản hồi lại yêu cầu xác minh mã 2FA hay không, nếu không thì hệ thống sẽ không cho phép truy cập.\n\nĐây là một bài kiểm tra tiêu cực chuỗi để đánh giá khả năng bảo vệ của hệ thống trước các cuộc tấn công giả mạo mã 2FA."
    },
    {
      "question_id": "EQ3057-VN",
      "question": "Mã HTTP nào thể hiện rõ nhất một tài nguyên đã bị xóa mềm (soft-deleted) được yêu cầu bởi GET /resource/{id} sau DELETE (với trạng thái có thể khôi phục)?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "204 No Content"
      },
      "gold_answer": "B",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": false,
      "explanation": "Tài nguyên đã bị xóa mềm nên được coi là không tìm thấy."
    },
    {
      "question_id": "EQ3058-VN",
      "type": "Writing",
      "gold": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Dưới đây là thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê:\n\n**Bài kiểm tra chuỗi xác minh tính nhất quán phân trang**\n\n1. **Tạo dữ liệu**: Tạo một danh sách phân trang với 100 bản ghi, mỗi bản ghi có một trường \"ID\" và một trường \"Tên\".\n2. **Liệt kê dữ liệu**: Liệt kê 10 bản ghi đầu tiên của danh sách phân trang.\n3. **Xóa dữ liệu**: Xóa 5 bản ghi đầu tiên của danh sách phân trang.\n4. **Liệt kê dữ liệu sau xóa**: Liệt kê 10 bản ghi đầu tiên của danh sách phân trang sau khi xóa.\n5. **Xác nhận tổng số đếm**: Xác nhận rằng tổng số bản ghi trong danh sách phân trang sau khi xóa là 95 (100 - 5).\n\n**Thời gian thực hiện**: 5 phút\n\n**Mục tiêu**: Xác minh tính nhất quán phân trang trên các thao tác tạo, liệt kê, xóa và liệt kê."
    },
    {
      "question_id": "EQ3059-VN",
      "question": "Ánh xạ nào là chính xác khi sự cố phụ thuộc kích hoạt mạch ngắt (circuit breaker) MỞ, khiến gateway từ chối yêu cầu ngay lập tức?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "400 Bad Request"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Mạch ngắt MỞ ánh xạ tới 503 Service Unavailable."
    },
    {
      "question_id": "EQ3060-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "**Bài kiểm tra chuỗi cho tính dính session (session stickiness)**\n\n1. **Đăng nhập**: Client gửi yêu cầu đăng nhập đến Node A trong cụm Load Balancer (LB). Node A xác thực và tạo ra một token session. Client nhận được token này và lưu trữ nó.\n\n2. **Các cuộc gọi tiếp theo qua LB**: Khi Client thực hiện các cuộc gọi tiếp theo đến ứng dụng, LB sẽ phân phối yêu cầu đến các Node khác (Node B hoặc Node C). Vì tính dính session được kích hoạt, LB sẽ sử dụng token session của Client để xác định Node đã xử lý yêu cầu đăng nhập trước đó (Node A). LB sẽ phân phối yêu cầu đến Node A để tiếp tục xử lý.\n\n3. **Đăng xuất**: Khi Client đăng xuất, token session sẽ bị hủy bỏ.\n\n4. **Xác minh không có node nào chấp nhận token cũ**: Sau khi Client đăng xuất, nếu một Node khác (Node B hoặc Node C) nhận được yêu cầu với token session cũ, nó sẽ không chấp nhận token này vì đã bị hủy bỏ. Node sẽ yêu cầu Client đăng nhập lại để tạo ra một token session mới."
    },
    {
      "question_id": "EQ4001-VN",
      "question": "Luồng **chained** nào xác thực chính xác vòng đời đơn hàng với tạo → ghi nhận → hoàn tiền, đảm bảo **idempotency** trên các lần **retry**?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Tạo đơn hàng → **retry** hoàn tiền hai lần → hoàn tiền thất bại",
        "B": "Ghi nhận thanh toán mà không tạo đơn hàng",
        "C": "Tạo đơn hàng → ghi nhận thanh toán → **retry** ghi nhận với cùng **idempotency key** → một lần ghi nhận duy nhất → hoàn tiền thành công",
        "D": "Hoàn tiền trước khi tạo đơn hàng"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Tạo đơn hàng → ghi nhận thanh toán → **retry** ghi nhận với cùng **idempotency key** → một lần ghi nhận duy nhất → hoàn tiền thành công",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Idempotency** phải đảm bảo các lần ghi nhận trùng lặp không tạo ra nhiều lần ghi nhận."
    },
    {
      "question_id": "EQ4002-VN",
      "type": "Writing",
      "gold": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "Dưới đây là một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản:\n```python\nimport unittest\n\nclass TaiKhoan:\n    def __init__(self):\n        self.trang_thai = \"tao\"\n\n    def tao(self):\n        self.trang_thai = \"kich_hoat\"\n        return self.trang_thai\n\n    def kich_hoat(self):\n        if self.trang_thai == \"tao\":\n            self.trang_thai = \"kich_hoat\"\n        elif self.trang_thai == \"tam_ngung\":\n            self.trang_thai = \"kich_hoat_lai\"\n        return self.trang_thai\n\n    def tam_ngung(self):\n        if self.trang_thai == \"kich_hoat\":\n            self.trang_thai = \"tam_ngung\"\n        return self.trang_thai\n\n    def kich_hoat_lai(self):\n        if self.trang_thai == \"tam_ngung\":\n            self.trang_thai = \"kich_hoat\"\n        return self.trang_thai\n\n    def xoa(self):\n        self.trang_thai = \"xoa\"\n        return self.trang_thai\n\nclass TestTaiKhoan(unittest.TestCase):\n    def test_tao_kich_hoat(self):\n        tk = TaiKhoan()\n        self.assertEqual(tk.tao(), \"kich_hoat\")\n\n    def test_kich_hoat_tao(self):\n        tk = TaiKhoan()\n        tk.tao()\n        self.assertEqual(tk.kich_hoat(), \"kich_hoat\")\n\n    def test_kich_hoat_kich_hoat(self):\n        tk = TaiKhoan()\n        tk.tao()\n        tk.kich_hoat()\n        self.assertEqual(tk.kich_hoat(), \"kich_hoat\")\n\n    def test_tam_ngung_tam_ngung(self):\n        tk = TaiKhoan()\n        tk.tao()\n        tk.kich_hoat()\n        tk.tam_ngung()\n        self.assertEqual(tk.tam_ngung(), \"tam_ngung\")\n\n    def test_kich_hoat_lai_tam_ngung(self):\n        tk = TaiKhoan()\n        tk.tao()\n        tk.kich_hoat()\n        tk.tam_ngung()\n        tk.kich_hoat_lai()\n        self.assertEqual(tk.kich_hoat"
    },
    {
      "question_id": "EQ4003-VN",
      "question": "Ánh xạ nào là đúng để xử lý một giao dịch trùng lặp được phát hiện trong quá trình yêu cầu hoàn tiền?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Giao dịch trùng lặp phải ánh xạ tới **409 Conflict**."
    },
    {
      "question_id": "EQ4004-VN",
      "type": "Writing",
      "gold": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "Dưới đây là thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại:\n\n1. **Bước 1: Tạo tài khoản và tạo giao dịch chuyển tiền**\n * Tạo tài khoản người gửi và người nhận\n * Tạo giao dịch chuyển tiền từ tài khoản người gửi sang tài khoản người nhận\n\n2. **Bước 2: Thực hiện bước 2 của giao dịch chuyển tiền (thất bại)**\n * Gọi phương thức chuyển tiền và giả lập lỗi (ví dụ: lỗi kết nối mạng)\n * Kiểm tra rằng giao dịch chuyển tiền không thành công\n\n3. **Bước 3: Thực hiện bước 3 của giao dịch chuyển tiền (thất bại)**\n * Gọi phương thức chuyển tiền và giả lập lỗi (ví dụ: lỗi kết nối mạng)\n * Kiểm tra rằng giao dịch chuyển tiền không thành công\n\n4. **Bước 4: Xác thực rollback giao dịch**\n * Kiểm tra rằng giao dịch chuyển tiền đã được rollback\n * Kiểm tra rằng tài khoản người gửi và người nhận không bị ảnh hưởng bởi giao dịch chuyển tiền thất bại\n\n5. **Bước 5: Xác thực dữ liệu cơ sở**\n * Kiểm tra rằng dữ liệu cơ sở (ví dụ: số dư tài khoản) được cập nhật đúng theo giao dịch chuyển tiền thất bại."
    },
    {
      "question_id": "EQ4005-VN",
      "question": "Kịch bản **chained** nào xác thực đúng việc truyền lỗi trong một giao dịch **distributed saga**?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Bắt đầu saga → tất cả các bước thành công",
        "B": "Bắt đầu saga → bỏ qua lỗi ở bước 2",
        "C": "Bắt đầu saga → **rollback** bị bỏ qua",
        "D": "Bắt đầu saga → bước 3 thất bại → **rollback** bù trừ của các bước 1 & 2 được thực thi"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Mô hình **saga** đảm bảo các hành động bù trừ khi thất bại."
    },
    {
      "question_id": "EQ4006-VN",
      "type": "Writing",
      "gold": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Dưới đây là một ví dụ về **test** xác thực chuỗi nhiều dịch vụ:\n\n**Test Case:** Chuỗi tạo đơn hàng và hủy đơn hàng\n\n**Mô tả:** \n1. Đăng nhập vào hệ thống với tư cách người dùng thông thường.\n2. Tạo một đơn hàng mới bằng cách chọn sản phẩm và đặt hàng.\n3. Xử lý thanh toán cho đơn hàng vừa tạo.\n4. Hủy đơn hàng vừa tạo.\n5. Xác minh rằng đơn hàng đã được hủy thành công.\n\n**Thí dụ sử dụng ngôn ngữ đầu cuối (Gherkin):**\n```\nFeature: Chuỗi tạo đơn hàng và hủy đơn hàng\n  Scenario: Tạo đơn hàng và hủy đơn hàng\n    Given Tôi đã đăng nhập vào hệ thống\n    When Tôi tạo một đơn hàng mới\n    And Tôi xử lý thanh toán cho đơn hàng\n    And Tôi hủy đơn hàng vừa tạo\n    Then Đơn hàng đã được hủy thành công\n```"
    },
    {
      "question_id": "EQ4007-VN",
      "question": "Kịch bản xử lý lỗi nào tốt nhất để xác thực các kiểm tra hợp lý trong **payment APIs**?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Gửi hoàn tiền > số tiền đã ghi nhận → **400 Bad Request**",
        "B": "Gửi hoàn tiền = số tiền đã ghi nhận → **200 OK**",
        "C": "Gửi hoàn tiền < số tiền đã ghi nhận → **200 OK**",
        "D": "Hoàn tiền mà không ghi nhận → **200 OK**"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Số tiền hoàn tiền lớn hơn số tiền đã ghi nhận phải thất bại với **400**."
    },
    {
      "question_id": "EQ4008-VN",
      "type": "Writing",
      "gold": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "Test state-machine xác thực vòng đời mật khẩu như sau:\n\n1. **Đặt** (Create): Mật khẩu được tạo và trạng thái là \"đã đặt\".\n2. **Hết hạn** (Expire): Mật khẩu hết hạn và trạng thái chuyển sang \"hết hạn\".\n3. **Đặt lại** (Reset): Mật khẩu được đặt lại và trạng thái chuyển sang \"đã đặt\".\n4. **Ngăn tái sử dụng** (Disallow Reuse): Mật khẩu không được phép tái sử dụng và trạng thái chuyển sang \"ngăn tái sử dụng\".\n\nTest state-machine này đảm bảo vòng đời mật khẩu được quản lý một cách hợp lý."
    },
    {
      "question_id": "EQ4009-VN",
      "question": "Ánh xạ nào tốt nhất để xác thực xử lý lỗi định dạng cho các tải trọng **JSON** bị định dạng sai?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**JSON** bị định dạng sai phải dẫn đến **400 Bad Request**."
    },
    {
      "question_id": "EQ4010-VN",
      "type": "Writing",
      "gold": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "Dưới đây là một ví dụ về test chained phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng:\n\n```python\nimport unittest\nfrom unittest.mock import Mock, patch\n\nclass TestDangKyKhoanVay(unittest.TestCase):\n\n    @patch('khoan_vay.check_tin_dung')\n    @patch('khoan_vay.thanh_toan')\n    def test_dang_ky_khoan_vay_thanh_cong(self, mock_thanh_toan, mock_check_tin_dung):\n        # Tạo mock cho kiểm tra tín dụng và thanh toán\n        mock_check_tin_dung.return_value = True\n        mock_thanh_toan.return_value = True\n\n        # Gọi phương thức đăng ký khoản vay\n        khoan_vay.dang_ky_khoan_vay()\n\n        # Kiểm tra xem phương thức thanh toán đã được gọi hay chưa\n        self.assertTrue(mock_thanh_toan.called)\n\n    @patch('khoan_vay.check_tin_dung')\n    def test_dang_ky_khoan_vay_thua(self, mock_check_tin_dung):\n        # Tạo mock cho kiểm tra tín dụng\n        mock_check_tin_dung.return_value = False\n\n        # Gọi phương thức đăng ký khoản vay\n        khoan_vay.dang_ky_khoan_vay()\n\n        # Kiểm tra xem phương thức thanh toán chưa được gọi\n        self.assertFalse(khoan_vay.thanh_toan.called)\n```\n\nTrong ví dụ trên, chúng ta sử dụng các phương thức `patch` và `Mock` để tạo mock cho các phương thức `check_tin_dung` và `thanh_toan`. Sau đó, chúng ta tạo hai test: `test_dang_ky_khoan_vay_thanh_cong` và `test_dang_ky_khoan_vay_thua`. Test đầu tiên kiểm tra xem phương thức thanh toán đã được gọi khi kiểm tra tín dụng thành công. Test thứ hai kiểm tra xem phương thức thanh toán chưa được gọi khi kiểm tra tín dụng thất bại."
    },
    {
      "question_id": "EQ4011-VN",
      "question": "Luồng **chained** nào xác thực trạng thái nhất quán trong quy trình đặt phòng phân tán?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Chỉ đặt khách sạn",
        "B": "Đặt khách sạn → đặt chuyến bay → chuyến bay thất bại → đặt phòng khách sạn tự động bị hủy",
        "C": "Chỉ đặt chuyến bay",
        "D": "Đặt khách sạn và giữ đặt phòng ngay cả khi thanh toán thất bại"
      },
      "gold_answer": "B",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": false,
      "explanation": "Việc tự động hủy khách sạn đảm bảo trạng thái nhất quán trên các hệ thống."
    },
    {
      "question_id": "EQ4012-VN",
      "type": "Writing",
      "gold": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "Để xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra, bạn có thể sử dụng cơ chế **Optimistic Locking**. Khi cập nhật hồ sơ người dùng, bạn sẽ kiểm tra xem phiên bản của dữ liệu đã được cập nhật là phiên bản mới nhất hay chưa. Nếu không phải phiên bản mới nhất, bạn sẽ phải cập nhật phiên bản và thử lại."
    },
    {
      "question_id": "EQ4013-VN",
      "question": "**HTTP code** nào là đúng để xác thực kiểm tra hợp lý khi rút tiền > số dư tài khoản?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "400 Bad Request"
      },
      "gold_answer": "D",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Rút tiền quá số dư phải bị từ chối với **400 Bad Request**."
    },
    {
      "question_id": "EQ4014-VN",
      "type": "Writing",
      "gold": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Để viết một **test chained** xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo, bạn có thể thực hiện các bước sau:\n\n1. Tạo một tài liệu mẫu (file) với nội dung cần ký.\n2. Sử dụng một thư viện ký số (ví dụ: PKCS#11) để tạo một khóa số và ký số cho file mẫu.\n3. Sử dụng một thư viện xác thực (ví dụ: OpenSSL) để xác minh tính hợp lệ của file ký số.\n4. Sử dụng một thư viện phát hiện giả mạo (ví dụ: SHA-256) để kiểm tra tính toàn vẹn của file ký số.\n5. Viết một chương trình test sử dụng các thư viện trên để thực hiện các bước trên và xác nhận kết quả.\n\nVí dụ, bạn có thể sử dụng Python với các thư viện PyCryptography, cryptography và hashlib để thực hiện các bước trên:\n\n```python\nimport os\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS"
    },
    {
      "question_id": "EQ4015-VN",
      "question": "Kịch bản nào xác thực **rollback** trạng thái khi một API cập nhật thông tin người dùng một phần và giao dịch **DB** thất bại?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Cập nhật thất bại giữa chừng → không có thay đổi một phần nào tồn tại",
        "B": "Cập nhật thất bại giữa chừng → thay đổi một phần vẫn còn",
        "C": "Cập nhật thất bại giữa chừng → hệ thống bị lỗi",
        "D": "Cập nhật thành công mặc dù **DB rollback**"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Cập nhật thất bại giữa chừng → không có thay đổi một phần nào tồn tại",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Rollback** thích hợp ngăn ngừa dữ liệu một phần/không nhất quán."
    },
    {
      "question_id": "EQ4016-VN",
      "question": "Kịch bản **chained** nào tốt nhất để xác thực **idempotency** của một **endpoint** ghi nhận thanh toán?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "POST /capture hai lần với các giá trị **Idempotency-Key** khác nhau → hai lần ghi nhận",
        "B": "POST /capture hai lần với cùng một **Idempotency-Key** → một lần ghi nhận duy nhất được ghi lại",
        "C": "POST /refund mà không ghi nhận → thành công",
        "D": "GET /capture-status một lần"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. POST /capture hai lần với cùng một **Idempotency-Key** → một lần ghi nhận duy nhất được ghi lại",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Idempotency** đảm bảo các yêu cầu trùng lặp với cùng một khóa không tạo ra nhiều lần ghi nhận."
    },
    {
      "question_id": "EQ4017-VN",
      "type": "Writing",
      "gold": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "Dưới đây là một test state-machine xác thực vòng đời đăng ký:\n```python\nimport unittest\n\nclass RegisterState:\n    def __init__(self):\n        self.state = \"tạo\"\n\n    def tạo(self):\n        self.state = \"tạo\"\n        return self\n\n    def nâng_cấp(self):\n        if self.state == \"tạo\":\n            self.state = \"nâng cấp\"\n            return self\n        else:\n            raise ValueError(\"Không thể nâng cấp khi không ở trạng thái 'tạo'\")\n\n    def hạ_cấp(self):\n        if self.state == \"nâng cấp\":\n            self.state = \"hạ cấp\"\n            return self\n        else:\n            raise ValueError(\"Không thể hạ cấp khi không ở trạng thái 'nâng cấp'\")\n\n    def hủy(self):\n        if self.state == \"hạ cấp\":\n            self.state = \"hủy\"\n            return self\n        else:\n            raise ValueError(\"Không thể hủy khi không ở trạng thái 'hạ cấp'\")\n\n\nclass TestRegisterState(unittest.TestCase):\n\n    def test_tạo(self):\n        register_state = RegisterState()\n        self.assertEqual(register_state.state, \"tạo\")\n\n    def test_nâng_cấp(self):\n        register_state = RegisterState()\n        register_state.tạo().nâng_cấp()\n        self.assertEqual(register_state.state, \"nâng cấp\")\n\n    def test_hạ_cấp(self):\n        register_state = RegisterState()\n        register_state.tạo().nâng_cấp().hạ_cấp()\n        self.assertEqual(register_state.state, \"hạ cấp\")\n\n    def test_hủy(self):\n        register_state = RegisterState()\n        register_state.tạo().nâng_cấp().hạ_cấp().hủy()\n        self.assertEqual(register_state.state, \"hủy\")\n\n    def test_nâng_cấp_khi_bị_hủy(self):\n        register_state = RegisterState()\n        register_state.tạo().hủy()\n        with self.assertRaises(ValueError):\n            register_state.nâng_cấp()\n\n    def test_hạ_cấp_khi_bị_hủy(self):\n        register_state = RegisterState()\n        register_state.tạo().hủy()\n        with self.assertRaises(ValueError):\n            register_state.hạ_cấp()\n\n    def test_hủy_khi_bị_hủy(self):\n        register_state = RegisterState()\n        register_state.tạo().hủy()\n        with self.assertRaises(ValueError):\n            register_state.hủy()\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\nTr"
    },
    {
      "question_id": "EQ4018-VN",
      "question": "Ánh xạ nào là đúng để xử lý mã lỗi ứng dụng **LIMIT_EXCEEDED** cho hạn ngạch API mỗi tài khoản?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Vượt quá giới hạn/hạn ngạch ánh xạ tới **429 Too Many Requests**."
    },
    {
      "question_id": "EQ4019-VN",
      "type": "Writing",
      "gold": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Một **test chained** có thể không đủ mạnh để xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga** vì các yếu tố sau:\n\n- Nó chỉ kiểm tra một chuỗi các bước cụ thể và có thể không bao quát được tất cả các trường hợp thất bại.\n- Nó không thể mô phỏng được các sự kiện bất ngờ hoặc thất bại ngẫu nhiên trong hệ thống phân phối.\n- Nó không thể xác định được khả năng phục hồi của hệ thống trong trường hợp thất bại một phần.\n\nĐể khắc phục những hạn chế này, chúng ta nên sử dụng các phương pháp kiểm tra khác như **test parallel** hoặc **test stateful** để mô phỏng và kiểm tra khả năng phục hồi sau thất bại một phần trong một **distributed order saga**."
    },
    {
      "question_id": "EQ4020-VN",
      "question": "Luồng **chained** nào xác thực việc phát hiện lạm dụng **OAuth2 token** trên các dịch vụ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "options": {
        "A": "Đăng nhập một lần",
        "B": "Làm mới **token** ngay lập tức",
        "C": "Đăng nhập → lấy **token** → cố gắng sử dụng **token** trong một máy khách khác → **403 Forbidden**",
        "D": "Chỉ đăng xuất"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Việc lạm dụng **token** chéo máy khách phải bị cấm."
    },
    {
      "question_id": "EQ4021-VN",
      "type": "Writing",
      "gold": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "Để viết một **test** khó xác minh việc đảo ngược giao dịch tài chính, chúng ta có thể sử dụng mô hình sau:\n\n1. Ghi nợ: Thực hiện giao dịch ghi nợ (chẳng hạn, giảm số dư tài khoản).\n2. Ghi có: Thực hiện giao dịch ghi có (chẳng hạn, tăng số dư tài khoản).\n3. **Rollback**: Đảo ngược giao dịch ghi có, trở về tình trạng trước khi thực hiện giao dịch ghi có (số dư tài khoản trở về trước khi tăng).\n\nTest này có thể bao gồm các trường hợp như: số dư tài khoản không đủ để thực hiện giao dịch, lỗi trong quá trình thực hiện giao dịch, v.v."
    },
    {
      "question_id": "EQ4022-VN",
      "question": "Kịch bản nào tốt nhất để xác thực xử lý lỗi định dạng cho sự không khớp đầu vào **XML vs JSON**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "Gửi thân **XML** với **Content-Type: application/json** → **415 Unsupported Media Type**",
        "B": "Gửi thân **JSON** với **application/json** → **200 OK**",
        "C": "Gửi thân **XML** với **application/xml** → **200 OK**",
        "D": "Gửi **YAML** → **200 OK**"
      },
      "gold_answer": "A",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Sự không khớp trong thân so với **header** phải dẫn đến **415**."
    },
    {
      "question_id": "EQ4023-VN",
      "type": "Writing",
      "gold": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Dưới đây là thiết kế một **test state-machine** cho kho hàng:\n\n**Test State-Machine**:\n1. **Thêm hàng** (Add): thêm hàng vào kho hàng\n2. **Phân bổ** (Allocate): phân bổ hàng cho các đơn vị cần thiết\n3. **Vận chuyển** (Transport): vận chuyển hàng đến địa điểm cần thiết\n4. **Trả lại** (Return): trả lại hàng khi đã hoàn thành việc sử dụng\n5. **Đối chiếu** (Verify): đối chiếu số lượng hàng thực tế và số lượng hàng được phân bổ\n\n**Giao diện**:\n- **Add**: thêm hàng vào kho hàng\n- **Allocate**: phân bổ hàng cho các đơn vị cần thiết\n- **Transport**: vận chuyển hàng đến địa điểm cần thiết\n- **Return**: trả lại hàng khi đã hoàn thành việc sử dụng\n- **Verify**: đối chiếu số lượng hàng thực tế và số lượng hàng được phân bổ\n\n**Tính năng**:\n- Theo dõi số lượng hàng trong kho hàng\n- Theo dõi số lượng hàng đã phân bổ\n- Theo dõi số lượng hàng đã vận chuyển\n- Theo dõi số lượng hàng đã trả lại\n- Theo dõi số lượng hàng đã đối chiếu"
    },
    {
      "question_id": "EQ4024-VN",
      "question": "**HTTP status** nào là đúng khi xảy ra lỗi xác thực **schema** cho một trường lồng nhau?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Lỗi xác thực **schema** phải trả về **400**."
    },
    {
      "question_id": "EQ4025-VN",
      "type": "Writing",
      "gold": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "Dưới đây là một **test chained** xác thực vòng đời **session mobile**:\n\n1. **Đăng nhập**: Gửi yêu cầu đăng nhập với thông tin tài khoản hợp lệ và nhận token mới.\n2. **Làm mới token**: Gửi yêu cầu làm mới token với token mới nhận được và nhận token mới.\n3. **Đăng xuất**: Gửi yêu cầu đăng xuất với token mới nhận được.\n4. **Làm mới với token cũ**: Gửi yêu cầu làm mới token với token cũ và kiểm tra kết quả thất bại.\n\nMã test có thể được viết bằng ngôn ngữ lập trình như Python hoặc Java, sử dụng thư viện thử nghiệm như Pytest hoặc JUnit."
    },
    {
      "question_id": "EQ4026-VN",
      "question": "Kịch bản **chained** nào xác thực **rollback** thích hợp sau khi đặt phòng nhiều bước (chuyến bay + khách sạn) khi thanh toán thất bại?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Đặt chuyến bay → **200 OK**",
        "B": "Đặt khách sạn → **200 OK**",
        "C": "Đặt chuyến bay + khách sạn → thanh toán thành công",
        "D": "Đặt chuyến bay + khách sạn → thanh toán thất bại → **rollback** cả hai đặt phòng"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Rollback** đảm bảo không còn đặt phòng không nhất quán."
    },
    {
      "question_id": "EQ4027-VN",
      "type": "Writing",
      "gold": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "Để viết một **test chained** xác thực API gửi email, bạn có thể thực hiện các bước sau:\n\n1. **Gửi**: Gửi một yêu cầu gửi email và kiểm tra xem email đã được gửi thành công hay chưa.\n2. **Theo dõi mở**: Theo dõi xem người nhận đã mở email hay chưa, và đảm bảo rằng email đã được mở.\n3. **Hủy đăng ký**: Hủy đăng ký email của người nhận và kiểm tra xem email đã được hủy thành công hay chưa.\n4. **Đảm bảo không gửi thêm email nào nữa**: Kiểm tra xem hệ thống đã ngăn chặn việc gửi email thêm cho người nhận hay chưa.\n\nMã test có thể như sau:\n\n```python\nimport unittest\nfrom unittest.mock import patch\nfrom your_module import send_email, check_email_open, cancel_subscription\n\nclass TestEmailAPI(unittest.TestCase):\n\n    @patch('your_module.send_email')\n    def test_send_email(self, mock_send_email):\n        # Gửi email\n        send_email('nguyenvandat@gmail.com')\n        mock_send_email.assert_called_once_with('nguyenvandat@gmail.com')\n\n    @patch('your_module.check_email_open')\n    def test_check_email_open(self, mock_check_email_open):\n        # Theo dõi mở email\n        check_email_open('nguyenvandat@gmail.com')\n        mock_check_email_open.assert_called_once_with('nguyenvandat@gmail.com')\n\n    @patch('your_module.cancel_subscription')\n    def test_cancel_subscription(self, mock_cancel_subscription):\n        # Hủy đăng ký email\n        cancel_subscription('nguyenvandat@gmail.com')\n        mock_cancel_subscription.assert_called_once_with('nguyenvandat@gmail.com')\n\n    def test_no_more_email(self):\n        # Đảm bảo không gửi thêm email nào nữa\n        self.assertEqual(send_email('nguyenvandat@gmail.com'), None)\n\nif __name__ == '__main__':\n    unittest.main()\n```"
    },
    {
      "question_id": "EQ4028-VN",
      "question": "Ánh xạ nào là đúng cho mã ứng dụng **TOKEN_REPLAY_DETECTED**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Tái sử dụng **token** phải được xử lý như **401 Unauthorized**."
    },
    {
      "question_id": "EQ4029-VN",
      "type": "Writing",
      "gold": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Dưới đây là một ví dụ về **test chained** cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại:\n\n```python\nimport unittest\n\nclass TestLuongMuaHang(unittest.TestCase):\n\n    def test_ap_dung_phi_lieu_giam_gia(self):\n        # Tạo một đơn hàng mới\n        don_hang = DonHang()\n        \n        # Áp dụng phiếu giảm giá\n        phi_lieu_giam_gia = PhiLieuGiamGia(\"phi-lieu-1\")\n        don_hang.ap_dung_phi_lieu_giam_gia(phi_lieu_giam_gia)\n        \n        # Thanh toán\n        don_hang.thanh_toan()\n        \n        # Kiểm tra giá trị đơn hàng sau khi áp dụng phiếu giảm giá\n        self.assertEqual(don_hang.tong_tien(), 100)\n    \n    def test_phi_lieu_giam_gia_khong_hop_le(self):\n        # Tạo một đơn hàng mới\n        don_hang = DonHang()\n        \n        # Áp dụng một phiếu giảm giá không hợp lệ\n        phi_lieu_giam_gia = PhiLieuGiamGia(\"phi-lieu-2\")\n        don_hang.ap_dung_phi_lieu_giam_gia(phi_lieu_giam_gia)\n        \n        # Kiểm tra giá trị đơn hàng sau khi áp dụng phiếu giảm giá không hợp lệ\n        self.assertEqual(don_hang.tong_tien(), 1000)\n    \n    def test_rollback_khi_phi_lieu_giam_gia_khong_hop_le(self):\n        # Tạo một đơn hàng mới\n        don_hang = DonHang()\n        \n        # Áp dụng một phiếu giảm giá không hợp lệ\n        phi_lieu_giam_gia = PhiLieuGiamGia(\"phi-lieu-2\")\n        don_hang.ap_dung_phi_lieu_giam_gia(phi_lieu_giam_gia)\n        \n        # Thanh toán\n        don_hang.thanh_toan()\n        \n        # Kiểm tra giá trị đơn hàng sau khi thanh toán\n        self.assertEqual(don_hang.tong_tien(), 1000)\n        \n        # Rollback\n        don_hang.rollback()\n        \n        # Kiểm tra giá trị đơn hàng sau khi rollback\n        self.assertEqual(don_hang.tong_tien(), 100)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nTrong ví dụ trên, chúng ta đã"
    },
    {
      "question_id": "EQ4030-VN",
      "question": "Luồng **chained** nào xác thực việc thanh toán không đồng bộ với đối chiếu?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Chỉ tạo đơn hàng",
        "B": "Tạo đơn hàng → ghi nhận thanh toán → đối chiếu không đồng bộ → trạng thái cuối cùng=đã đối chiếu",
        "C": "Hoàn tiền mà không đối chiếu",
        "D": "Kiểm tra tình trạng API"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Tạo đơn hàng → ghi nhận thanh toán → đối chiếu không đồng bộ → trạng thái cuối cùng=đã đối chiếu",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Thanh toán không đồng bộ phải đối chiếu chính xác."
    }
  ],
  "writing_for_review": [
    {
      "question_id": "EQ5004",
      "question": "Write one simple positive test case for a login API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "Here is a simple positive test case for a login API:\n\n**Test Case:** Successful Login with Valid Credentials\n\n**Description:** Verify that the login API returns a successful response with a valid username and password combination.\n\n**Preconditions:** The user has a valid account with a registered username and password.\n\n**Steps:**\n\n1. Send a POST request to the login API with the valid username and password.\n2. Verify that the response status code is 200 (OK).\n3. Verify that the response contains the user's details, such as their username and role.\n\n**Expected Result:** The user is successfully logged in, and the response contains the expected user details."
    },
    {
      "question_id": "EQ5006",
      "question": "What is a common precondition for testing a user profile endpoint?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "User must be logged in and have a valid token.",
      "model_answer": "A common precondition for testing a user profile endpoint is that the user account must exist in the system, with a valid username and password (or API key) for authentication. Additionally, the user's profile information should be populated with relevant data, such as name, email, and other attributes. This ensures that the endpoint can be successfully queried and returns the expected data."
    },
    {
      "question_id": "EQ5008",
      "question": "Write a simple negative test for a register API.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Here's a simple negative test for a register API:\n\n```python\nimport requests\n\ndef test_register_negative():\n    # Test case 1: Register with empty username and password\n    response = requests.post('http://localhost/register', json={'username': '', 'password': 'password'})\n    assert response.status_code == 400\n    \n    # Test case 2: Register with invalid username (too long)\n    response = requests.post('http://localhost/register', json={'username': 'a'*256, 'password': 'password'})\n    assert response.status_code == 400\n    \n    # Test case 3: Register with invalid password (too short)\n    response = requests.post('http://localhost/register', json={'username': 'username', 'password': 'pw'})\n    assert response.status_code == 400\n    \n    # Test case 4: Register with existing username\n    response = requests.post('http://localhost/register', json={'username': 'existing_username', 'password': 'password'})\n    assert response.status_code == 400\n```\n\nThis test suite covers four different negative test cases for the register API:\n\n*   Register with empty username and password\n*   Register with invalid username (too long)\n*   Register with invalid password (too short)\n*   Register with existing username"
    },
    {
      "question_id": "EQ5010",
      "question": "What is the role of a schema in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "To define the expected structure of request and response data.",
      "model_answer": "In API testing, a schema serves as a blueprint or a contract that defines the structure and format of the data expected from the API, including the types of fields, their relationships, and constraints. This schema helps testers and developers understand the API's data model and ensures that the API returns data in the expected format, making it easier to write and execute API tests."
    },
    {
      "question_id": "EQ5012",
      "question": "Write a simple test step for validating a 201 Created response.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "To validate a 201 Created response, you can use the following test step:\n\n1. Verify that the HTTP status code is 201.\n2. Check that the response body contains the expected data, such as a unique identifier for the created resource.\n3. Ensure that the response headers include a Location header with the URL of the newly created resource.\n\nExample in Python using the unittest framework:\n```python\ndef test_create_resource(self):\n    response = self.client.post('/resources', data={'name': 'Example Resource'})\n    self.assertEqual(response.status_code, 201)\n    self.assertIn('id', response.json())\n    self.assertIn('Location', response.headers)\n```"
    },
    {
      "question_id": "EQ5014",
      "question": "What is the purpose of mocking in API testing?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "The purpose of mocking in API testing is to isolate dependencies and simulate the behavior of external services, such as APIs, databases, or file systems, without actually making requests to them. This allows developers to test the functionality of their code in a controlled environment, reducing the complexity and time required for testing. By mocking, developers can focus on testing the logic of their code rather than the external dependencies."
    },
    {
      "question_id": "EQ5016",
      "question": "Write one easy test case for an API that fetches product list.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "Here's an example test case for an API that fetches a product list:\n\n**Test Case:** \"Fetch Product List\"\n\n**Description:** Send a GET request to the `/products` endpoint to retrieve a list of products and verify that the response is successful (200 OK) with at least one product in the response body.\n\n**Expected Result:**\n\n- Status Code: 200 OK\n- Response Body: A list of products with at least one product."
    },
    {
      "question_id": "EQ5018",
      "question": "What is the purpose of a precondition in a test case?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "The purpose of a precondition in a test case is to ensure that the test environment is in a known state before the test is executed, by setting up any necessary conditions or dependencies. This helps to prevent test failures due to external factors and ensures that the test results are reliable and accurate. Preconditions can include setup or initialization of variables, database records, or other system states."
    },
    {
      "question_id": "EQ5020",
      "question": "Write one negative test for file upload with an unsupported format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Here is a negative test for file upload with an unsupported format:\n\n**Test Case:** Unsupported File Format Upload\n\n**Description:** When uploading a file with an unsupported format, the application should not allow the file to be uploaded and should display an error message.\n\n**Test Steps:**\n\n1. Open the file upload interface.\n2. Select a file with an unsupported format (e.g..txt).\n3. Click the upload button.\n4. Verify that an error message is displayed indicating that the file format is not supported.\n\n**Expected Result:** The file is not uploaded and an error message is displayed."
    },
    {
      "question_id": "EQ5022",
      "question": "What is the purpose of a test case description?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "To explain the objective and scope of a test scenario.",
      "model_answer": "The purpose of a test case description is to provide a clear and concise explanation of the test case, including its objectives, inputs, expected results, and any assumptions made. This description serves as a reference for the test team, stakeholders, and developers, ensuring everyone is on the same page regarding the test case's purpose and expected outcomes. It also facilitates communication and collaboration among team members."
    },
    {
      "question_id": "EQ5024",
      "question": "Write a test step to validate response time under 1 second.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "**Test Step: Validate Response Time**\n\n1. Send a GET request to the application's homepage.\n2. Measure the time taken for the response using a timer or a tool like Selenium's `time.sleep()` function.\n3. Verify that the response time is less than 1 second (e.g., assert response_time <= 1000)."
    },
    {
      "question_id": "EQ5027",
      "question": "Write one simple positive test for GET /health endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "To write a simple positive test for the GET /health endpoint, you can use the following example in Python with the unittest framework:\n\n```python\nimport unittest\nimport requests\n\nclass TestHealthEndpoint(unittest.TestCase):\n\n    def test_health_endpoint(self):\n        response = requests.get('http://localhost:5000/health')\n        self.assertEqual(response.status_code, 200)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test sends a GET request to the /health endpoint and checks if the response status code is 200, indicating a successful response."
    },
    {
      "question_id": "EQ5029",
      "question": "What is the purpose of using test data management in API testing?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "The purpose of using test data management in API testing is to ensure that sensitive and personal data is not exposed during testing, while still allowing for realistic and relevant test scenarios to be created. It helps to manage and generate test data, such as user credentials, payment information, and other sensitive details, in a secure and controlled manner. This approach helps to maintain data privacy and compliance with regulations."
    },
    {
      "question_id": "EQ5031",
      "question": "Write one easy negative test case for an API expecting JSON format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "One easy negative test case for an API expecting JSON format is to send a request with a non-JSON body, such as a plain text string. For example, sending a GET request to the API with the query parameter \"name=John\" instead of a JSON payload. This should result in a server error or an invalid request response."
    },
    {
      "question_id": "EQ5033",
      "question": "What is the role of assertions in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions play a crucial role in API testing by verifying the expected outcome of a test, ensuring that the actual response matches the expected response. They help identify whether the API is functioning correctly, or if there are errors or bugs that need to be addressed. By using assertions, developers can write robust tests that catch issues early in the development cycle."
    },
    {
      "question_id": "EQ5035",
      "question": "Write a test case to check DELETE /users/{id} works correctly.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "Here's a test case in Python using the Pytest framework to check the DELETE /users/{id} endpoint:\n\n```python\nimport pytest\nfrom fastapi import status\nfrom fastapi.testclient import TestClient\n\ndef test_delete_user(client, user):\n    # Arrange\n    user_id = user['id']\n    response = client.delete(f'/users/{user_id}')\n\n    # Assert\n    assert response.status_code == status.HTTP_204_NO_CONTENT\n    assert get_user(client, user_id) is None\n\ndef get_user(client, user_id):\n    response = client.get(f'/users/{user_id}')\n    return response.json()\n```\n\nIn this test case, we first delete a user and then verify that the user is indeed deleted by checking if a GET request to the same user ID returns a 404 status code."
    },
    {
      "question_id": "EQ5037",
      "question": "What does HTTP status 201 Created indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "A new resource has been successfully created.",
      "model_answer": "HTTP status 201 Created indicates that a new resource has been successfully created on the server. The request was successful, and the new resource can be found at the URI provided in the Location header of the response. This status code is often used in response to a POST request."
    },
    {
      "question_id": "EQ5039",
      "question": "Write one simple test for GET /users/{id} returning correct response.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "To test the GET /users/{id} endpoint, you can use the following example in a testing framework like Pytest or Unittest:\n\n```python\ndef test_get_user_by_id(client):\n    response = client.get('/users/1')\n    assert response.status_code == 200\n    assert response.json()['id'] == 1\n```\n\nThis test sends a GET request to the endpoint with the user ID 1, checks if the response status code is 200 (OK), and verifies that the response JSON contains the expected user ID."
    },
    {
      "question_id": "EQ5041",
      "question": "What is the purpose of a 200 OK response?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It confirms that the request has succeeded.",
      "model_answer": "A 200 OK response is a standard HTTP status code that indicates a successful request. It signifies that the server has received and processed the request, and the response is being returned with a successful status. This code is used to confirm that the request was successful and the data was retrieved or processed correctly."
    },
    {
      "question_id": "EQ5043",
      "question": "Write one negative test to validate response for an invalid endpoint.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "To validate the response for an invalid endpoint, you can use the following negative test:\n\n```python\ndef test_invalid_endpoint():\n    response = requests.get('http://example.com/invalid')\n    assert response.status_code == 404\n    assert response.json()['error'] == 'Not Found'\n```\n\nIn this test, we send a GET request to an invalid endpoint and verify that the response status code is 404 (Not Found) and the JSON response contains an 'error' key with the value 'Not Found'."
    },
    {
      "question_id": "EQ5045",
      "question": "What does a test case assertion do?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion is a statement in a test case that checks if the actual output or result of a program matches the expected output or result. If the assertion fails, the test case is considered failed, and an error message is typically displayed to indicate the discrepancy. Assertions help ensure that the program behaves as expected and facilitate the debugging process."
    },
    {
      "question_id": "EQ5047",
      "question": "Write one positive test for file upload endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "**Test: Successful File Upload**\n\nGiven a valid file and endpoint URL,\nWhen I send a POST request to the endpoint with the file,\nThen the response status code is 201 and the file is successfully uploaded."
    },
    {
      "question_id": "EQ5049",
      "question": "What is the role of 415 Unsupported Media Type?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "The 415 Unsupported Media Type error is a HTTP status code indicating that the server cannot process the requested media type. This error typically occurs when the server does not support the format of the data being sent in the request, such as an unsupported file type or an incorrect content type. The client should retry the request with a supported media type or adjust the request accordingly."
    },
    {
      "question_id": "EQ5052",
      "question": "Write a simple positive test for checking product details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "Here's a simple positive test for checking product details API:\n\n```python\nimport requests\nimport json\n\ndef test_product_details_api():\n    # Send a GET request to the product details API\n    response = requests.get('https://example.com/product/123')\n    \n    # Check if the response status code is 200 (OK)\n    assert response.status_code == 200\n    \n    # Parse the response content as JSON\n    product_details = json.loads(response.content)\n    \n    # Check if the product details contain the expected information\n    assert product_details['name'] == 'Example Product'\n    assert product_details['price'] == 9.99\n    assert product_details['description'] == 'This is an example product.'\n\ntest_product_details_api()\n```\n\nThis test sends a GET request to the product details API, checks if the response status code is 200, and then verifies that the product details contain the expected information."
    },
    {
      "question_id": "EQ5054",
      "question": "What is the purpose of using Authorization headers in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The purpose of using Authorization headers in API testing is to simulate the authentication process, allowing testers to mimic the behavior of a legitimate user and verify the API's security and access control mechanisms. This helps ensure that the API is properly restricting access to authorized users and data. By incorporating Authorization headers, testers can thoroughly test the API's authentication workflow."
    },
    {
      "question_id": "EQ5056",
      "question": "Write a negative test case for an API requiring authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "To write a negative test case for an API requiring authentication, we can test what happens when a request is made without providing valid credentials. This can be done by sending a GET or POST request to the API endpoint without including an Authorization header or with invalid credentials, and verifying that the response is a 401 Unauthorized error."
    },
    {
      "question_id": "EQ5058",
      "question": "What is the role of 500 Internal Server Error in API testing?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "In API testing, a 500 Internal Server Error is an HTTP status code indicating a server-side error occurred, such as a syntax error in the code, a database connection issue, or an unexpected exception. This error helps identify server-side problems that need to be addressed, and it's a crucial part of API testing to ensure the system's robustness and reliability. By testing for 500 errors, developers can catch and fix issues before they affect users."
    },
    {
      "question_id": "EQ5060",
      "question": "Write one positive test case for an API returning list of orders.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "Here's a positive test case for an API returning a list of orders:\n\n**Test Case:** Retrieve a list of orders successfully\n\n**Description:** Send a GET request to the API endpoint \"/orders\" and verify that the response status code is 200 (OK) and the response body contains a list of at least 5 orders with valid order IDs, customer names, and order dates."
    },
    {
      "question_id": "EQ5062",
      "question": "What is the function of response headers in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "In API testing, response headers serve as metadata that provide additional information about the response, such as caching instructions, content encoding, and security details. They help developers understand how to process the response, including whether it should be cached, how it should be decoded, and whether it requires authentication. By verifying the response headers, testers can ensure that the API is correctly configured and behaving as expected."
    },
    {
      "question_id": "EQ5064",
      "question": "Write one negative test for creating a duplicate resource.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Here's a negative test for creating a duplicate resource:\n\n**Test Case:** Duplicate Resource Creation\n\n**Precondition:** The resource already exists in the database.\n\n**Test Steps:**\n\n1. Send a POST request to create a new resource with the same attributes as the existing resource.\n2. Verify that the server returns a 400 Bad Request response, indicating that the resource already exists.\n\n**Expected Result:** The server returns a 400 Bad Request response with a message indicating that the resource already exists."
    },
    {
      "question_id": "EQ5066",
      "question": "What is the role of 202 Accepted in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "In APIs, the \"202 Accepted\" status code is used to indicate that a request has been accepted for processing, but the processing has not been completed yet. This status code is typically used in asynchronous APIs, where the server acknowledges the request and will send a follow-up response once the processing is complete. It provides a way to confirm that the request was received and is being processed, without waiting for the final response."
    },
    {
      "question_id": "EQ5068",
      "question": "Write one easy positive test for checking API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "One easy positive test for checking API response schema is to verify that the response contains the expected fields when a valid request is made. This can be achieved by asserting that the response JSON has a specific key-value pair, such as `assert response.json['name'] == 'John'`."
    },
    {
      "question_id": "EQ5070",
      "question": "What is the purpose of response body in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To provide the actual data returned from an endpoint.",
      "model_answer": "The purpose of the response body in API testing is to verify that the API returns the expected data in the correct format, such as JSON or XML. It allows testers to check the accuracy and completeness of the data, including the presence of required fields and the absence of unnecessary ones. This helps ensure that the API behaves as expected and returns the necessary information to the client."
    },
    {
      "question_id": "EQ5072",
      "question": "Write one test case for verifying logout functionality.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Logout Verification**\n\n1. **Test Case Name:** Verify Successful Logout\n2. **Preconditions:** User is logged in with valid credentials.\n3. **Steps:**\n   - Navigate to the logout page.\n   - Click the logout button.\n   - Verify that the user is redirected to the login page and the session is terminated.\n4. **Expected Result:** The user is successfully logged out, and the session is cleared.\n\n**Test Data:**\n\n- Valid username and password for login.\n\n**Test Environment:** Web browser (e.g., Chrome, Firefox) with the application under test."
    },
    {
      "question_id": "EQ5074",
      "question": "What does a 415 Unsupported Media Type error validate?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "That the server rejects unsupported request body formats.",
      "model_answer": "A 415 Unsupported Media Type error validates the type of media or data being sent in the request, specifically that the client is attempting to send a request with a media type that the server does not support. This error typically occurs when a client sends a request with a specific content type, such as JSON or XML, that the server cannot process. The server is essentially saying that it cannot handle the media type being sent."
    },
    {
      "question_id": "EQ5077",
      "question": "Write one simple positive test for GET /status endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "Here's a simple positive test for the GET /status endpoint:\n\n```python\nimport requests\n\ndef test_status_endpoint():\n    response = requests.get('http://localhost:5000/status')\n    assert response.status_code == 200\n    assert response.json() == {'status': 'ok'}\n\ntest_status_endpoint()\n```\n\nThis test sends a GET request to the /status endpoint and checks that the response status code is 200 and the response body is as expected."
    },
    {
      "question_id": "EQ5079",
      "question": "What does a 204 No Content response mean?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content response is an HTTP status code that indicates the server successfully processed the request, but there is no additional content to return. This response is often used for actions like deleting a resource or updating a resource without returning any new data. The client can assume the request was successful, but no new data is provided."
    },
    {
      "question_id": "EQ5081",
      "question": "Write a negative test case for sending an invalid Content-Type header.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "**Negative Test Case: Invalid Content-Type Header**\n\n**Test Case Name:** InvalidContentTypeHeaderTest\n\n**Description:** Verify that sending an invalid Content-Type header in a request results in a 415 Unsupported Media Type error response.\n\n**Test Steps:**\n\n1. Send a POST request with a valid payload to the server.\n2. Set the Content-Type header to an invalid value, such as \"application/invalid\".\n3. Verify that the server returns a 415 Unsupported Media Type error response."
    },
    {
      "question_id": "EQ5083",
      "question": "What is the purpose of the Accept header in API requests?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header in API requests is used to specify the data format or media type that the client is able to understand. This allows the server to respond with a format that the client can handle, such as JSON or XML. By including the Accept header, the client can indicate its preferred response format and the server can tailor its response accordingly."
    },
    {
      "question_id": "EQ5085",
      "question": "Write a simple test case for a successful logout API call.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "To write a simple test case for a successful logout API call, you can use the following steps:\n\n1. Send a POST request to the logout API endpoint with the required headers (e.g., authorization token).\n2. Verify that the response status code is 200 (OK) or another expected status code.\n3. Assert that the response body contains the expected message, such as \"Logged out successfully.\"\n\n```python\nimport requests\n\ndef test_successful_logout():\n    # Send a POST request to the logout API endpoint\n    response = requests.post('https://example.com/logout', headers={'Authorization': 'Bearer token'})\n\n    # Verify the response status code\n    assert response.status_code == 200\n\n    # Verify the response body\n    assert response.json()['message'] == 'Logged out successfully.'\n```"
    },
    {
      "question_id": "EQ5087",
      "question": "What is the meaning of 401 Unauthorized in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "It means the client must provide valid authentication credentials.",
      "model_answer": "In API testing, a \"401 Unauthorized\" response indicates that the client (usually a web application or a testing tool) is not authenticated or authorized to access the requested resource. This error typically occurs when the client has not provided a valid authentication token, such as a session ID or an API key, or when the authentication credentials are invalid. The server is refusing to provide the requested data due to a lack of proper authorization."
    },
    {
      "question_id": "EQ5089",
      "question": "Write one easy positive test case for checking profile details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "**Test Case:** Verify Profile Details API\n\n**Description:** As a logged-in user, when I call the profile details API, I expect to receive a successful response with the user's profile information.\n\n**Test Steps:**\n\n1. Call the profile details API with a valid user ID.\n2. Verify the API returns a successful response (200 OK).\n3. Check the response contains the expected profile information (e.g., name, email, etc.)."
    },
    {
      "question_id": "EQ5091",
      "question": "What is the purpose of 302 Found in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates temporary redirection to another URL.",
      "model_answer": "In APIs (Application Programming Interfaces), the \"302 Found\" status code is used to indicate a temporary redirect of the requested resource. This means that the server is redirecting the client to a different URL, often for security, maintenance, or to update the resource location. The client should automatically follow the redirect to the new URL."
    },
    {
      "question_id": "EQ5093",
      "question": "Write a test case for negative login attempt with wrong password.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "**Negative Login Test Case**\n\n**Test Case Name:** Invalid Password Login Attempt\n\n**Description:** This test case verifies that the application correctly handles a negative login attempt with a wrong password.\n\n**Test Steps:**\n\n1. Navigate to the login page.\n2. Enter a valid username.\n3. Enter an incorrect password.\n4. Submit the login form.\n5. Verify that an error message is displayed indicating an invalid password.\n\n**Expected Result:** The application should display an error message and prevent access to the user's account."
    },
    {
      "question_id": "EQ5095",
      "question": "What does 422 Unprocessable Entity indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "A 422 Unprocessable Entity (also known as HTTP 422 Unprocessable Entity) is an HTTP status code indicating that the server understands the syntax of the request body but was unable to process it due to semantic errors. This error typically occurs when the server can't process the request data due to validation issues, such as missing or invalid data."
    },
    {
      "question_id": "EQ5097",
      "question": "Write a positive test for POST /users endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "Here's a positive test for the POST /users endpoint:\n\n```python\nimport requests\n\ndef test_create_user():\n    # Send a POST request to create a new user\n    response = requests.post('http://localhost:8000/users', json={\n        'name': 'John Doe',\n        'email': 'john@example.com',\n        'password': 'password123'\n    })\n\n    # Assert that the response status code is 201 (Created)\n    assert response.status_code == 201\n\n    # Assert that the response JSON contains the newly created user\n    user = response.json()\n    assert user['name'] == 'John Doe'\n    assert user['email'] == 'john@example.com'\n```\n\nThis test sends a POST request to the /users endpoint with a JSON payload containing the user's details. It then asserts that the response status code is 201 (Created) and that the response JSON contains the newly created user with the expected details."
    },
    {
      "question_id": "EQ5099",
      "question": "What does the term 'happy path' mean in testing?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It refers to the expected successful execution scenario.",
      "model_answer": "In testing, the term 'happy path' refers to a scenario where all inputs or conditions are valid, and the system or application behaves as expected without any errors or issues. This path is often considered the most straightforward or typical use case, where everything goes right, and the system functions correctly. The happy path is typically used as a baseline for testing, to ensure that the system works as intended."
    },
    {
      "question_id": "EQ2002",
      "question": "Explain how you would design a negative test case for an API endpoint that requires OAuth2 Bearer tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "To design a negative test case for an API endpoint that requires OAuth2 Bearer tokens, you would intentionally omit or provide an invalid token, and then verify that the API returns an expected error response, such as a 401 Unauthorized status code. You would also test scenarios where the token is missing, expired, or invalid."
    },
    {
      "question_id": "EQ2004",
      "question": "Provide one happy-path and one error-path test case for a payment refund API endpoint.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "Here are the test cases for a payment refund API endpoint:\n\n**Happy-path test case:**\nTest case: Successful refund\n- Input: Valid payment ID and refund amount\n- Expected outcome: Refund successful, payment status updated to \"refunded\", and response code 200\n\n**Error-path test case:**\nTest case: Invalid payment ID\n- Input: Invalid payment ID and refund amount\n- Expected outcome: Error message returned, payment status remains unchanged, and response code 404"
    },
    {
      "question_id": "EQ2006",
      "question": "How would you validate schema changes in a backward-compatible API upgrade?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "To validate schema changes in a backward-compatible API upgrade, you can use techniques such as: \n\n1. **Dry-run testing**: Test the updated schema with existing data to ensure compatibility without affecting production data.\n2. **Mocking and stubbing**: Use mock data and stubs to simulate real-world scenarios and verify the updated schema's behavior.\n3. **Automated testing**: Write comprehensive unit tests and integration tests to cover various scenarios and validate the schema's changes.\n\nThese methods help ensure that the updated schema maintains backward compatibility and functions as expected."
    },
    {
      "question_id": "EQ2008",
      "question": "Explain how mocking can be used to test a payment API without calling the real bank service.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "Mocking is used to isolate the payment API from the real bank service by creating a fake implementation that simulates the bank's responses, allowing the payment API to be tested independently. This is achieved by using a mocking library to create mock objects that mimic the behavior of the bank service, such as returning a successful transaction or throwing an error. By mocking the bank service, the payment API can be thoroughly tested without incurring any costs or risk."
    },
    {
      "question_id": "EQ2010",
      "question": "Design one boundary test and one invalid test for an API field `age` (range 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "**Boundary Test:** \nTest name: \"Age Boundary Test\"\nInput: `age=18` and `age=65`\nExpected result: Both inputs should be valid and return a successful response.\n\n**Invalid Test:** \nTest name: \"Age Invalid Test\"\nInput: `age=-1` and `age=70`\nExpected result: Both inputs should be invalid and return an error response indicating that the age is out of range."
    },
    {
      "question_id": "EQ2012",
      "question": "Explain how you would simulate a network timeout error in API testing.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "To simulate a network timeout error in API testing, you can use tools like Fiddler or Postman to set a custom timeout value for the API request, allowing it to fail after a specified duration. Alternatively, you can use a tool like Apache JMeter to simulate a network delay or timeout, mimicking real-world network conditions. This helps identify and troubleshoot issues related to timeouts in your API."
    },
    {
      "question_id": "EQ2014",
      "question": "Give one example of an API precondition and one step that follows it.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "API precondition: \"The user must have a valid login session.\" \n\nOne step that follows this precondition is: \"The server checks the user's session cookie to verify the login status before processing the request.\""
    },
    {
      "question_id": "EQ2016",
      "question": "Write one test case to validate that API rate limiting is enforced correctly.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "```python\nimport requests\nimport time\n\ndef test_api_rate_limiting():\n    # Make initial request to get the rate limit\n    response = requests.get('https://api.example.com/rate_limit')\n    initial_rate_limit = int(response.json()['rate_limit'])\n\n    # Make multiple requests within the rate limit window\n    for _ in range(initial_rate_limit):\n        requests.get('https://api.example.com/resource')\n\n    # Wait for the rate limit window to expire\n    time.sleep(initial_rate_limit * 0.9)\n\n    # Attempt to make a request after the rate limit has been exceeded\n    try:\n        requests.get('https://api.example.com/resource')\n        assert False, 'Expected API rate limiting to block this request'\n    except requests.exceptions.RequestException as e:\n        assert 'Rate Limit Exceeded' in str(e), 'Expected Rate Limit Exceeded error'\n\ntest_api_rate_limiting()\n```\n\nThis test case makes multiple requests within the rate limit window and then attempts to make another request after the rate limit has been exceeded, verifying that the API rate limiting is enforced correctly."
    },
    {
      "question_id": "EQ2018",
      "question": "Explain one advantage of using service virtualization in API testing.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "One advantage of using service virtualization in API testing is that it allows developers to test APIs in isolation, without relying on the actual backend services. This enables faster testing and reduces the risk of downstream dependencies, making it easier to identify and fix issues early in the development cycle."
    },
    {
      "question_id": "EQ2020",
      "question": "Describe how to design one positive and one boundary test case for a login API requiring username and password.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "To design a positive test case, provide a valid username and password, such as \"admin\" and \"password123\". For a boundary test case, test the API with a username and password at their maximum allowed lengths, such as \"a\" repeated 20 times and \"password123\" repeated 20 times."
    },
    {
      "question_id": "EQ2022",
      "question": "Write one test step to validate that an API correctly returns 415 Unsupported Media Type.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Test step: \"Send a request with an invalid media type (e.g., 'application/json' with a binary file attachment) to the API endpoint and verify that the response status code is 415 and the response body contains an error message indicating 'Unsupported Media Type'.\""
    },
    {
      "question_id": "EQ2024",
      "question": "Describe one way to test observability when an API experiences a slow database query.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "To test observability when an API experiences a slow database query, you can use a tool like New Relic or Prometheus to instrument the API and database, and then simulate a high load on the API to trigger the slow query. This will allow you to observe the impact of the slow query on the API's performance, including latency, throughput, and error rates. By analyzing the metrics and logs, you can identify the root cause of the slow query and implement optimizations to improve the database's performance."
    },
    {
      "question_id": "EQ2026",
      "question": "Explain how you would test API idempotency for a retry scenario.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "To test API idempotency for a retry scenario, you would send the same request multiple times with the same parameters, verifying that the server either returns the same response or indicates that the request has already been processed, without causing any unintended side effects. This can be achieved using tools like curl or Postman to simulate the retry scenario."
    },
    {
      "question_id": "EQ2028",
      "question": "Give one boundary and one invalid test for a file upload API accepting max 5 MB files.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "Boundary Test: \n- File size: 6 MB, which exceeds the maximum allowed size of 5 MB.\n\nInvalid Test:\n- File type:.docx, which is not a supported file type for the API."
    },
    {
      "question_id": "EQ2030",
      "question": "Write a test case to validate proper error handling when an API is called with a missing required field `email`.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "**Test Case: Missing Required Field 'email' Error Handling**\n\n```python\nimport unittest\nfrom your_module import api_client\n\nclass TestApiErrorHandling(unittest.TestCase):\n\n    def test_missing_email_field(self):\n        # Arrange\n        data = {'name': 'John Doe', 'password': 'password123'}\n        \n        # Act\n        response = api_client.create_user(data)\n        \n        # Assert\n        self.assertEqual(response.status_code, 400)\n        self.assertIn('email', response.json()['errors'])\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this test case, we're verifying that the API returns a 400 error status code and includes 'email' in the error messages when the required 'email' field is missing from the request data."
    },
    {
      "question_id": "EQ2032",
      "question": "How would you design a test to validate retry logic when an API occasionally returns 503?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "To validate retry logic when an API occasionally returns 503, you can design a test with the following steps: \n\n1. Set up a mock API that returns 503 at a certain percentage of requests (e.g., 20%).\n2. Implement the retry logic in your application, specifying the number of retries and the delay between retries.\n3. Test the application's behavior when interacting with the mock API, verifying that it successfully completes the task after the specified number of retries."
    },
    {
      "question_id": "EQ2034",
      "question": "Write a test case that validates log correlation using a trace ID header.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "Here's an example of a test case that validates log correlation using a trace ID header:\n\n```python\nimport requests\nfrom unittest import TestCase\n\nclass LogCorrelationTestCase(TestCase):\n    def test_log_correlation(self):\n        # Send a request with a trace ID header\n        headers = {'trace-id': '1234567890'}\n        response = requests.get('https://example.com', headers=headers)\n\n        # Verify that the response contains the original trace ID\n        self.assertEqual(response.headers['trace-id'], '1234567890')\n\n        # Verify that the log correlation is successful\n        self.assertIn('trace-id: 1234567890', response.text)\n```\n\nThis test case sends a GET request with a `trace-id` header, verifies that the response contains the original `trace-id` header, and checks that the log correlation is successful by verifying that the `trace-id` is present in the response text."
    },
    {
      "question_id": "EQ2036",
      "question": "Design one intermediate-level test case for validating API rate limiting when multiple clients are involved.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "**Test Case: \"API Rate Limiting with Multiple Clients\"**\n\n**Description:** Validate that the API correctly enforces rate limiting when multiple clients are making requests simultaneously.\n\n**Test Steps:**\n\n1. Set up two clients, Client A and Client B, to make concurrent requests to the API at a rate that exceeds the rate limit.\n2. Verify that Client A's requests are successfully processed within the allowed rate limit.\n3. Verify that Client B's requests are blocked or throttled due to exceeding the rate limit.\n\n**Expected Result:** Client B's requests are successfully blocked or throttled, while Client A's requests are processed within the allowed rate limit."
    },
    {
      "question_id": "EQ2038",
      "question": "Describe one positive and one negative test case for an API endpoint that sends SMS codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "Positive test case: The API endpoint receives a valid request with a phone number and a valid SMS code, and it successfully sends the code to the phone number and returns a success response. \n\nNegative test case: The API endpoint receives a request with an invalid phone number, and it returns an error response with a message indicating that the phone number is invalid."
    },
    {
      "question_id": "EQ2040",
      "question": "Explain one advantage of mocking external APIs when testing failure scenarios.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "One advantage of mocking external APIs when testing failure scenarios is that it allows you to control the response and simulate different failure conditions, such as network errors, timeouts, or invalid responses, without relying on external dependencies that may be unavailable or unstable. This enables you to write more comprehensive and robust tests that cover a wide range of failure scenarios, improving the overall quality and reliability of your code."
    },
    {
      "question_id": "EQ2042",
      "question": "Write one test case to validate error handling when API returns malformed JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "Here's an example test case in Python using the unittest framework to validate error handling when an API returns malformed JSON:\n\n```python\nimport unittest\nimport json\nfrom your_api_module import get_data  # replace with your actual API module\n\nclass TestAPIErrorHandling(unittest.TestCase):\n    def test_malformed_json(self):\n        # Simulate a malformed JSON response from the API\n        response = {'key': 'value'}  # invalid JSON format\n        with self.assertRaises(json.JSONDecodeError):\n            get_data(response)  # expected to raise an error\n```"
    },
    {
      "question_id": "EQ2044",
      "question": "Design one test step to confirm rate limiting headers (e.g., X-RateLimit-Remaining) are present.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "Test Step: Verify Rate Limiting Headers\n\n* Send a request to the rate-limited resource and verify that the response contains the rate limiting headers, such as X-RateLimit-Remaining, X-RateLimit-Limit, and X-RateLimit-Reset."
    },
    {
      "question_id": "EQ2046",
      "question": "Describe one advantage of separating test data from test logic in API testing.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "One advantage of separating test data from test logic in API testing is that it makes the tests more reusable and maintainable. By keeping test data separate, you can easily modify or update test data without affecting the test logic, making it easier to adapt to changing requirements or data formats. This separation also facilitates collaboration among team members."
    },
    {
      "question_id": "EQ2048",
      "question": "Write a test case for validating graceful degradation when API cache is unavailable.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "Here's a test case for validating graceful degradation when API cache is unavailable:\n\n```python\nimport requests\nimport unittest\n\nclass TestGraciousDegradation(unittest.TestCase):\n    def test_api_cache_unavailable(self):\n        # Simulate API cache unavailability by setting a mock cache status code\n        mock_cache_status_code = 500\n        \n        # Send a request to the API with the mock cache status code\n        response = requests.get('https://api.example.com', status_code=mock_cache_status_code)\n        \n        # Assert that the application gracefully degrades and returns a meaningful error message\n        self.assertIn('API cache unavailable', response.text)\n```\n\nThis test case checks if the application correctly handles the scenario where the API cache is unavailable by sending a request to the API with a mock cache status code and asserting that the response contains a meaningful error message."
    },
    {
      "question_id": "EQ2050",
      "question": "Explain one way to validate logging for sensitive fields such as passwords.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "One way to validate logging for sensitive fields such as passwords is to use a masked logging approach, where the actual password is replaced with a placeholder or asterisks (*) before being logged. This ensures that the password is not stored or transmitted in plain text, reducing the risk of a data breach. The placeholder can be reconstructed to display the actual password to authorized personnel."
    },
    {
      "question_id": "EQ2052",
      "question": "Provide one negative and one boundary test case for a currency field that must match ISO 4217 codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "Negative test case: A non-ISO 4217 code, such as \"USD123\", should be rejected or highlighted as invalid.\n\nBoundary test case: An ISO 4217 code with a single character, such as \"A\" (for Australian dollar, but not an official ISO 4217 code), should also be rejected or highlighted as invalid."
    },
    {
      "question_id": "EQ2054",
      "question": "Write one test case to validate API behavior under network packet loss.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "To validate API behavior under network packet loss, we can create a test case using a tool like `locust` or `k6`. Here's an example test case in `locust`:\n\n```python\nimport locust\nfrom locust import HttpUser, task\n\nclass NetworkLossUser(HttpUser):\n    @task(1)\n    def request_with_packet_loss(self):\n        # Simulate a network packet loss by setting a timeout\n        with self.client.get(\"/api/endpoint\", timeout=1) as response:\n            if response.status_code == 200:\n                self.assertGreater(response.elapsed.total_seconds(), 1)\n            else:\n                self.fail(f\"Expected 200, got {response.status_code}\")\n```\n\nThis test case sends a GET request to the `/api/endpoint` and checks if the response takes longer than 1 second to arrive, simulating a network packet loss. If the response is received within the expected time, the test fails."
    },
    {
      "question_id": "EQ2056",
      "question": "Describe one method to verify test data cleanup after API test execution.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "One method to verify test data cleanup after API test execution is to use an automated script or API that checks the database or data storage for any remaining test data. This can be achieved by querying the database for test data identifiers and verifying that they have been deleted or marked as inactive. If the test data is not found, it indicates successful cleanup."
    },
    {
      "question_id": "EQ2058",
      "question": "Write a test case to verify proper rollback when a multi-step transaction partially fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "To verify proper rollback when a multi-step transaction partially fails, you can write a test case as follows:\n\n```python\nimport unittest\nfrom your_module import DatabaseConnection\n\nclass TestTransactionRollback(unittest.TestCase):\n    def test_partial_failure(self):\n        # Create a database connection\n        conn = DatabaseConnection()\n\n        # Start a transaction\n        conn.start_transaction()\n\n        # Perform a series of operations\n        conn.execute(\"INSERT INTO table1 VALUES (1, 'value1')\")\n        conn.execute(\"INSERT INTO table2 VALUES (2, 'value2')\")\n        conn.execute(\"INSERT INTO table3 VALUES (3, 'value3')\")  # This operation will fail\n\n        # Attempt to commit the transaction\n        with self.assertRaises(Exception):\n            conn.commit()\n\n        # Verify that the failed operation was rolled back\n        self.assertFalse(conn.execute(\"SELECT * FROM table3\").fetchone())\n\n        # Verify that the successful operations were rolled back\n        self.assertFalse(conn.execute(\"SELECT * FROM table1\").fetchone())\n        self.assertFalse(conn.execute(\"SELECT * FROM table2\").fetchone())\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test case simulates a multi-step transaction that partially fails due to an error in the third operation. It then verifies that the failed operation was rolled back, and that the successful operations were also rolled back."
    },
    {
      "question_id": "EQ2060",
      "question": "Explain one approach to validating error messages follow a consistent JSON schema across all endpoints.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "One approach to validating error messages follow a consistent JSON schema across all endpoints is to use a centralized error message repository, where all error messages are defined and validated against a standard JSON schema. This repository can be used to generate error responses across all endpoints, ensuring consistency in error message format and content."
    },
    {
      "question_id": "EQ3002",
      "question": "Write a test case that validates login, token refresh, and accessing a protected API using the refreshed token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "Here's a sample test case in Python using the `unittest` framework:\n\n```python\nimport unittest\nimport requests\n\nclass TestLoginAndAPIAccess(unittest.TestCase):\n\n    def test_login_and_token_refresh(self):\n        # Login and get access token\n        login_response = requests.post('https://example.com/login', json={'username': 'user', 'password': 'password'})\n        self.assertEqual(login_response.status_code, 200)\n        access_token = login_response.json()['access_token']\n\n        # Refresh token\n        refresh_response = requests.post('https://example.com/refresh', json={'refresh_token': login_response.json()['refresh_token']})\n        self.assertEqual(refresh_response.status_code, 200)\n        new_access_token = refresh_response.json()['access_token']\n\n        # Access protected API using refreshed token\n        api_response = requests.get('https://example.com/protected', headers={'Authorization': f'Bearer {new_access_token}'})\n        self.assertEqual(api_response.status_code, 200)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test case validates the following:\n\n1. Successful login and retrieval of access token.\n2. Token refresh and retrieval of a new access token.\n3. Access to a protected API using the refreshed token."
    },
    {
      "question_id": "EQ3004",
      "question": "Design a chained test validating that a failed login attempt still prevents refresh token generation.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "To validate that a failed login attempt still prevents refresh token generation, we can design a chained test:\n\n1. First, attempt to login with invalid credentials.\n2. Verify that the login attempt is unsuccessful and a refresh token is not generated.\n3. Then, attempt to refresh the access token using the invalid refresh token from step 2.\n4. Verify that the refresh token generation is still blocked and an error response is returned.\n\nThis chained test ensures that even after a failed login attempt, the refresh token generation is still properly blocked."
    },
    {
      "question_id": "EQ3006",
      "question": "Explain how you would validate correct mapping of business codes (e.g., ORDER_001) to HTTP status codes in API responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "To validate correct mapping of business codes to HTTP status codes in API responses, I would use a combination of automated testing and code reviews. Specifically, I would write unit tests to verify that the API's response mapping logic correctly maps business codes to the corresponding HTTP status codes, and also perform code reviews to ensure that the mapping logic is consistent and accurate across the codebase."
    },
    {
      "question_id": "EQ3008",
      "question": "Write one hard-level test case chaining order creation, payment, and refund APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "**Test Case: Order Creation, Payment, and Refund**\n\n**Scenario:** A customer places an order, pays for it, and then requests a refund.\n\n**Test Steps:**\n\n1. Create a new order using the `create_order` API with valid order details (e.g., product ID, quantity, customer ID).\n2. Verify that the order is created successfully and the order ID is returned.\n3. Use the `pay_order` API to process payment for the created order with a valid payment method (e.g., credit card, PayPal).\n4. Verify that the payment is processed successfully and the order status is updated to \"paid\".\n5. Simulate a refund request using the `refund_order` API with a valid refund reason.\n6. Verify that the refund is processed successfully and the order status is updated to \"refunded\".\n\n**Expected Outcome:** The order is created, paid, and refunded successfully, and the order status is updated accordingly."
    },
    {
      "question_id": "EQ3010",
      "question": "Explain one test case that validates token refresh works across multiple microservices.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "One test case that validates token refresh works across multiple microservices is as follows: \"Test Case: Multi-Service Token Refresh\". In this test case, a user requests access to a protected resource in Microservice A, which redirects the user to the Authentication Service to obtain an access token. The user then refreshes the access token by requesting a new one from the Authentication Service, which should be accepted by Microservice B, verifying that the refreshed token is valid across both services."
    },
    {
      "question_id": "EQ3012",
      "question": "Write a test that validates mapping of validation error codes to HTTP 400 responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "Here's an example of a test that validates mapping of validation error codes to HTTP 400 responses using Python and the Flask testing framework:\n\n```python\nimport unittest\nfrom your_app import app\nfrom your_app import ValidationError\n\nclass TestValidationErrorMapping(unittest.TestCase):\n\n    def setUp(self):\n        self.app = app.test_client()\n\n    def test_validation_error_code_mapped_to_http_400(self):\n        # Test that a specific validation error code returns a 400 response\n        error_code = \"INVALID_EMAIL\"\n        response = self.app.get(\"/validate\", query_string={\"email\": \"invalid_email\"})\n        self.assertEqual(response.status_code, 400)\n        self.assertIn(error_code, response.json[\"error\"])\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nThis test case checks that a specific validation error code (`INVALID_EMAIL`) returns a 400 response with the corresponding error message. You can add more test cases to cover different validation error codes."
    },
    {
      "question_id": "EQ3014",
      "question": "Design a test case validating expired refresh tokens cannot issue new access tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "To test that expired refresh tokens cannot issue new access tokens, the test case can be designed as follows:\n\n1. Obtain a valid refresh token and access token.\n2. Wait for the refresh token to expire.\n3. Attempt to use the expired refresh token to obtain a new access token.\n4. Verify that the request to obtain a new access token fails, and a suitable error message is returned (e.g., \"refresh token has expired\").\n\nThis test case ensures that the authorization server correctly handles expired refresh tokens and prevents them from being used to obtain new access tokens."
    },
    {
      "question_id": "EQ3016",
      "question": "Explain one multi-hop chained test that validates session invalidation after logout.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Here's a multi-hop chained test that validates session invalidation after logout:\n\n1. **Step 1: Login**: Send a POST request to the login endpoint with valid credentials to obtain a session ID.\n2. **Step 2: Validate Session**: Send a GET request to a protected endpoint (e.g., user dashboard) to validate that the session ID is valid and the user is logged in.\n3. **Step 3: Logout**: Send a DELETE request to the logout endpoint to invalidate the session.\n4. **Step 4: Validate Session Invalidation**: Send a GET request to the same protected endpoint as in Step 2, but this time, the session ID should be invalid, and the user should be redirected to the login page.\n\nThis multi-hop test chain ensures that the session is properly invalidated after logout and that the application enforces the necessary security checks."
    },
    {
      "question_id": "EQ3018",
      "question": "Write a test case chaining signup, email verification, and login endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "To write a test case chaining signup, email verification, and login endpoints, you can use the following steps:\n\n1. Send a POST request to the signup endpoint with valid user credentials and verify the response.\n2. Send a GET request to the email verification endpoint with the user's email and verify the response.\n3. Send a POST request to the signup endpoint (again) with valid user credentials and verify the response.\n4. Send a POST request to the login endpoint with the user's credentials and verify the response.\n\nHere is a sample test case in Python using the `requests` library:\n```python\nimport requests\n\ndef test_signup_email_verification_login():\n    # Step 1: Signup\n    response = requests.post('http://localhost:8000/signup', json={'username': 'test_user', 'email': 'test_user@example.com', 'password': 'password'})\n    assert response.status_code == 201\n    \n    # Step 2: Email Verification\n    response = requests.get('http://localhost:8000/email/verify', params={'email': 'test_user@example.com'})\n    assert response.status_code == 200\n    \n    # Step 3: Signup (again)\n    response = requests.post('http://localhost:8000/signup', json={'username': 'test_user', 'email': 'test_user@example.com', 'password': 'password'})\n    assert response.status_code == 201\n    \n    # Step 4: Login\n    response = requests.post('http://localhost:8000/login', json={'username': 'test_user', 'password': 'password'})\n    assert response.status_code == 200\n```\nNote that this is a simplified example and you should handle errors and edge cases in a real-world test case."
    },
    {
      "question_id": "EQ3020",
      "question": "Design one hard-level chained test validating a password reset flow.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "Here's a hard-level chained test validating a password reset flow:\n\n1. **Step 1: User Requests Password Reset**: Send a GET request to the password reset endpoint with a valid username, and verify that the response contains a reset token.\n2. **Step 2: User Submits Reset Token**: Send a POST request to the password reset token endpoint with the reset token, and verify that the response contains a success message.\n3. **Step 3: User Sets New Password**: Send a PATCH request to the password reset endpoint with the new password, and verify that the response contains a success message.\n4. **Step 4: Verify New Password**: Send a GET request to the login endpoint with the new password, and verify that the response contains a successful login message.\n\nThis chained test ensures that the entire password reset flow is working correctly, from requesting a password reset to verifying the new password."
    },
    {
      "question_id": "EQ3022",
      "question": "Write a chained test case for validating user creation, profile update, and profile retrieval.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "Here's an example of chained test case for validating user creation, profile update, and profile retrieval in Python using unittest:\n\n```python\nimport unittest\nfrom unittest.mock import patch\nfrom your_module import User\n\nclass TestUserFunctions(unittest.TestCase):\n\n    @patch('your_module.User.create')\n    def test_user_creation(self, mock_create):\n        # Create a new user\n        user = User.create('test_user', 'password')\n        mock_create.assert_called_once_with('test_user', 'password')\n\n    def test_user_profile_update(self):\n        # Create a new user and update their profile\n        user = User.create('test_user', 'password')\n        user.update_profile('new_name', 'new_email')\n        self.assertEqual(user.name, 'new_name')\n        self.assertEqual(user.email, 'new_email')\n\n    def test_user_profile_retrieval(self):\n        # Create a new user and retrieve their profile\n        user = User.create('test_user', 'password')\n        user.update_profile('new_name', 'new_email')\n        self.assertEqual(user.get_profile(), {'name': 'new_name', 'email': 'new_email'})\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this chained test case, we first create a new user, then update their profile, and finally retrieve their profile. The `@patch` decorator is used to mock the `User.create` method, which allows us to test the creation of a new user without actually creating one."
    },
    {
      "question_id": "EQ3024",
      "question": "Explain one test to validate refresh token cannot be used after logout.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "One test to validate that a refresh token cannot be used after logout is the \"Refresh Token Denial after Logout\" test. This test involves simulating a logout flow, then attempting to use the refresh token to obtain a new access token. The test should verify that the refresh token is denied or revoked after logout, and a new access token cannot be obtained."
    },
    {
      "question_id": "EQ3026",
      "question": "Write a test case validating correct mapping of internal error code AUTH_EXPIRED to HTTP status.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "```python\nimport unittest\nfrom your_module import authenticate  # Assuming authenticate is the function or class mapping error codes\n\nclass TestAuthenticationErrorMapping(unittest.TestCase):\n    def test_auth_expired_http_status(self):\n        # Test that AUTH_EXPIRED maps to the correct HTTP status\n        self.assertEqual(authenticate.AUTH_EXPIRED, 401)  # Assuming 401 is the expected HTTP status\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this test case, we are asserting that the internal error code `AUTH_EXPIRED` is correctly mapped to the HTTP status `401` (Unauthorized). The `authenticate` module or class is assumed to contain the `AUTH_EXPIRED` error code."
    },
    {
      "question_id": "EQ3028",
      "question": "Explain a chained test validating email verification failure if token is invalid.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "A chained test for validating email verification failure when the token is invalid could be implemented as follows:\n\n```python\nimport pytest\n\ndef test_email_verification_invalid_token():\n    # Arrange\n    user = create_user()  # Create a user with a valid email\n    invalid_token = \"invalid_token\"  # Create an invalid token\n\n    # Act\n    verification_result = verify_email(user.email, invalid_token)\n\n    # Assert\n    assert verification_result == \"Email verification failed due to invalid token\"\n```\n\nIn this example, the `test_email_verification_invalid_token` function creates a user with a valid email and an invalid token, then calls the `verify_email` function to attempt email verification. The `assert` statement checks that the result of the verification is as expected, indicating that the token is indeed invalid."
    },
    {
      "question_id": "EQ3030",
      "question": "Write a hard-level test case chaining loan application, credit check, and approval endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "Here's an example of a test case chaining loan application, credit check, and approval endpoints using Pytest and the requests library:\n\n```python\nimport pytest\nimport requests\n\n@pytest.fixture\ndef loan_application_data():\n    return {\"name\": \"John Doe\", \"age\": 30, \"income\": 50000, \"credit_score\": 700}\n\n@pytest.fixture\ndef credit_check_data():\n    return {\"credit_score\": 700, \"credit_history\": \"good\"}\n\ndef test_loan_application_and_approval(loan_application_data, credit_check_data):\n    # Step 1: Apply for a loan\n    loan_application_url = \"http://localhost:8080/loan-application\"\n    response = requests.post(loan_application_url, json=loan_application_data)\n    assert response.status_code == 201\n    \n    # Step 2: Perform a credit check\n    credit_check_url = \"http://localhost:8080/credit-check\"\n    response = requests.post(credit_check_url, json=credit_check_data)\n    assert response.status_code == 200\n    \n    # Step 3: Approve the loan\n    loan_approval_url = \"http://localhost:8080/loan-approval\"\n    response = requests.post(loan_approval_url, json={\"loan_id\": response.json()[\"loan_id\"]})\n    assert response.status_code == 200\n```\n\nThis test case assumes that the loan application, credit check, and approval endpoints are exposed by a backend service, and that the service returns the expected status codes and JSON responses."
    },
    {
      "question_id": "EQ3032",
      "question": "Design a test case chaining signup, password reset, and login with new credentials.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "To design a test case chaining signup, password reset, and login with new credentials, the following steps can be taken:\n\n1. **Step 1: Signup**: Test the user successfully signs up with a valid username and password.\n2. **Step 2: Password Reset**: Test the user requests a password reset and successfully receives a reset link, then updates their password with a new valid password.\n3. **Step 3: Login with New Credentials**: Test the user attempts to log in with the newly created password and verify the login is successful.\n\nThis test case ensures the entire password reset process works correctly from signup to login with the new credentials."
    },
    {
      "question_id": "EQ3034",
      "question": "Write a test case chaining file upload, virus scan, and download endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "Here's an example of a test case chaining file upload, virus scan, and download endpoints in Python using the `unittest` framework:\n\n```python\nimport unittest\nimport requests\nimport os\n\nclass TestFileUploadVirusScanDownload(unittest.TestCase):\n\n    def test_file_upload_virus_scan_download(self):\n        # Step 1: Upload file\n        file_path = 'path/to/file.txt'\n        files = {'file': open(file_path, 'rb')}\n        upload_response = requests.post('https://example.com/upload', files=files)\n        self.assertEqual(upload_response.status_code, 201)\n        file_id = upload_response.json()['file_id']\n\n        # Step 2: Virus scan file\n        virus_scan_response = requests.post(f'https://example.com/virus-scan/{file_id}')\n        self.assertEqual(virus_scan_response.status_code, 200)\n        virus_scan_result = virus_scan_response.json()['result']\n\n        # Step 3: Download file if safe\n        if virus_scan_result =='safe':\n            download_response = requests.get(f'https://example.com/download/{file_id}')\n            self.assertEqual(download_response.status_code, 200)\n            self.assertTrue(os.path.isfile('downloaded_file.txt'))\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test case assumes that the endpoints for file upload, virus scan, and download are implemented and available at the specified URLs. The test case also assumes that the file to be uploaded and downloaded is located at the specified path. The test case will fail if the file upload, virus scan, or download fails, or if the virus scan result is not'safe'."
    },
    {
      "question_id": "EQ3036",
      "question": "Explain one chained test for validating refresh token reuse prevention.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "One chained test for validating refresh token reuse prevention is the \"Refresh Token Blacklisting\" test. In this test, a legitimate user logs out and a malicious actor attempts to use the user's previously obtained refresh token to obtain a new access token. The system should detect the blacklisted token and deny the malicious actor's request, demonstrating the refresh token reuse prevention mechanism is working as intended."
    },
    {
      "question_id": "EQ3038",
      "question": "Write a test case chaining search, add-to-cart, and checkout APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "Here's an example of test case chaining search, add-to-cart, and checkout APIs using Python and the Pytest framework:\n\n```python\nimport pytest\nfrom api_client import APIClient\n\n@pytest.fixture\ndef api_client():\n    return APIClient()\n\ndef test_search_and_checkout(api_client):\n    # Search for products\n    products = api_client.search_products(\"laptop\")\n    assert len(products) > 0\n    \n    # Add product to cart\n    product_id = products[0]['id']\n    api_client.add_product_to_cart(product_id)\n    \n    # Proceed to checkout\n    api_client.proceed_to_checkout()\n    \n    # Confirm order\n    api_client.confirm_order()\n\ndef test_search_and_checkout_negative(api_client):\n    # Search for products\n    products = api_client.search_products(\"non-existent-product\")\n    assert len(products) == 0\n    \n    # Try to add product to cart\n    with pytest.raises(Exception):\n        api_client.add_product_to_cart(123)\n    \n    # Proceed to checkout\n    with pytest.raises(Exception):\n        api_client.proceed_to_checkout()\n    \n    # Confirm order\n    with pytest.raises(Exception):\n        api_client.confirm_order()\n```\n\nIn this example, we have two test cases: `test_search_and_checkout` and `test_search_and_checkout_negative`. The first test case simulates a successful search, add-to-cart, and checkout flow, while the second test case simulates a failed search and checkout flow. The `api_client` fixture provides an instance of the `APIClient` class, which is used to interact with the APIs."
    },
    {
      "question_id": "EQ3040",
      "question": "Explain one chained test for validating API session hijacking prevention.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "One chained test for validating API session hijacking prevention involves simulating a login request with a valid session token, followed by sending a request to change the user's password or other sensitive information. The test then verifies that the API denies the password change request, as the session token is still valid and the user's session should not be terminated. This ensures the API properly prevents session hijacking by not allowing unauthorized changes to user data."
    },
    {
      "question_id": "EQ3042",
      "question": "Provide exactly one chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "Here's a chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints:\n\n```python\ndef test_optimistic_concurrency():\n    # Create a resource\n    resource = client.post('/resources', data={'name': 'example', 'description': 'example'})\n    etag = resource.headers['ETag']\n    \n    # Update the resource\n    updated_resource = client.put(f'/resources/{resource.json()[\"id\"]}', data={'name': 'new_example'}, headers={'If-Match': etag})\n    assert updated_resource.status_code == 200\n    \n    # Read the updated resource to get the new ETag\n    updated_resource_etag = client.get(f'/resources/{resource.json()[\"id\"]}', headers={'If-Match': etag}).headers['ETag']\n    \n    # Attempt to update the resource again with the old ETag\n    outdated_resource = client.put(f'/resources/{resource.json()[\"id\"]}', data={'name': 'another_new_example'}, headers={'If-Match': etag})\n    assert outdated_resource.status_code == 412\n```\n\nThis test case simulates a scenario where multiple users are updating the same resource concurrently. The test case checks that the update operation fails when the user tries to update the resource with an outdated ETag, indicating that optimistic concurrency control is working correctly."
    },
    {
      "question_id": "EQ3044",
      "question": "Design a multi-hop test verifying async export job: POST /exports -> poll GET /jobs/{id} until complete -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "To design a multi-hop test verifying an async export job, the following steps can be taken:\n\n1. **POST /exports**: Send a POST request to create a new export job.\n2. **Poll GET /jobs/{id}**: Continuously poll the GET /jobs/{id} endpoint until the job status is marked as \"completed\".\n3. **GET /exports/{id}**: Once the job is complete, retrieve the export by sending a GET request to /exports/{id} to verify its contents.\n\nThis multi-hop test ensures that the async export job is successfully created, executed, and completed, with the expected output verified at the final step."
    },
    {
      "question_id": "EQ3046",
      "question": "Give one chained negative test for OAuth2 Authorization Code: /authorize -> /token -> resource call with missing scope.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Here's a chained negative test for OAuth2 Authorization Code:\n\n1. Client attempts to authorize at `/authorize` with an invalid or missing scope, which should result in an error response.\n2. The authorization server should return an error to the client, indicating that the scope is invalid or missing.\n3. The client should not be able to obtain an access token at `/token` because the scope is missing, and therefore cannot make a resource call.\n\nThis test chain validates the authorization server's ability to handle invalid scope requests and prevents unauthorized access to resources."
    },
    {
      "question_id": "EQ3048",
      "question": "Write one chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "Here's an example of a chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints:\n\n```python\nimport pytest\n\n@pytest.mark.usefixtures(\"create_charge\")\ndef test_idempotent_charge_creation(create_charge, client):\n    # Create a charge with idempotency key\n    charge_id = create_charge.id\n    idempotency_key = create_charge.idempotency_key\n    \n    # Retry the charge creation with the same idempotency key\n    response = client.post(f\"/charges\", headers={\"Idempotency-Key\": idempotency_key})\n    assert response.status_code == 201\n    \n    # Refund the charge with the same idempotency key\n    response = client.post(f\"/charges/{charge_id}/refunds\", headers={\"Idempotency-Key\": idempotency_key})\n    assert response.status_code == 201\n    \n    # Verify that the charge and refund were created only once\n    charge_count = client.get(f\"/charges/count\").json()[\"count\"]\n    refund_count = client.get(f\"/refunds/count\").json()[\"count\"]\n    assert charge_count == 1\n    assert refund_count == 1\n\ndef create_charge(client):\n    # Create a charge without idempotency key\n    response = client.post(\"/charges\")\n    assert response.status_code == 201\n    return response.json()\n```\n\nThis test creates a charge without an idempotency key, then uses the `idempotency_key` from the charge to retry the charge creation and refund the charge. It verifies that the charge and refund were created only once."
    },
    {
      "question_id": "EQ3050",
      "question": "Provide one chained test for file processing pipeline: upload -> POST /process -> poll status -> download, including 202 handling.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "Here's an example of a chained test for a file processing pipeline using Python's `unittest` framework and the `requests` library:\n\n```python\nimport unittest\nimport requests\nimport time\n\nclass TestFileProcessingPipeline(unittest.TestCase):\n\n    def test_file_processing_pipeline(self):\n        # Upload a file\n        files = {'file': open('example.txt', 'rb')}\n        response = requests.post('http://localhost:8080/upload', files=files)\n        self.assertEqual(response.status_code, 201)\n        file_id = response.json()['file_id']\n\n        # POST /process with the uploaded file\n        response = requests.post(f'http://localhost:8080/process/{file_id}')\n        self.assertEqual(response.status_code, 202)\n\n        # Poll the status until it's completed\n        while True:\n            response = requests.get(f'http://localhost:8080/status/{file_id}')\n            if response.status_code == 200 and response.json()['status'] == 'completed':\n                break\n            time.sleep(1)\n\n        # Download the processed file\n        response = requests.get(f'http://localhost:8080/download/{file_id}', stream=True)\n        self.assertEqual(response.status_code, 200)\n        with open('processed_example.txt', 'wb') as f:\n            for chunk in response.iter_content(1024):\n                f.write(chunk)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test uploads a file, posts it to the processing endpoint, polls the status until it's completed, and then downloads the processed file. It includes handling for the 202 status code when the processing is in progress."
    },
    {
      "question_id": "EQ3052",
      "question": "Give one chained test to validate SSO session revocation propagates to API gateway and microservice access.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "Here's a chained test:\n\n1. Log in to the application using a valid user credentials, this should establish a valid SSO session.\n2. Verify that the user can access the protected microservice endpoint without any issues.\n3. Revoke the SSO session using the identity provider's API or the application's admin interface.\n4. Immediately attempt to access the same microservice endpoint again, this should result in an authentication error or a 401 Unauthorized response.\n5. Verify that the error response or the 401 Unauthorized status code is returned to the client, indicating that the SSO session has been successfully revoked.\n\nThis chained test ensures that the SSO session revocation propagates to API gateway and microservice access, and that the application correctly handles the revocation of a valid SSO session."
    },
    {
      "question_id": "EQ3054",
      "question": "Write one chained test for partial order fulfillment: create order -> reserve inventory -> partial ship -> cancel remaining and refund delta.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "Here's a chained test for partial order fulfillment:\n\n```python\nimport unittest\nfrom unittest.mock import Mock\n\nclass TestOrderFulfillment(unittest.TestCase):\n\n    def test_partial_order_fulfillment(self):\n        # Create order\n        order_service = Mock()\n        order_service.create_order.return_value = {'id': 1, 'items': [{'product_id': 1, 'quantity': 10}]}\n        order = order_service.create_order('customer', ['product1', 'product2'])\n        \n        # Reserve inventory\n        inventory_service = Mock()\n        inventory_service.reserve_inventory.return_value = {'reserved': True}\n        inventory_service.reserve_inventory(order['id'], order['items'])\n        \n        # Partial ship\n        shipping_service = Mock()\n        shipping_service.partial_ship.return_value = {'shipped': True}\n        shipping_service.partial_ship(order['id'], order['items'][0])\n        \n        # Cancel remaining and refund delta\n        cancel_service = Mock()\n        cancel_service.cancel_remaining_items.return_value = {'cancelled': True}\n        cancel_service.cancel_remaining_items(order['id'])\n        \n        # Assert order status\n        self.assertEqual(order_service.create_order.return_value['status'], 'partial_ship')\n        self.assertEqual(inventory_service.reserve_inventory.return_value['reserved'], True)\n        self.assertEqual(shipping_service.partial_ship.return_value['shipped'], True)\n        self.assertEqual(cancel_service.cancel_remaining_items.return_value['cancelled'], True)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis chained test simulates the creation of an order, reserving inventory, partial shipping, and canceling remaining items with a refund delta. It uses mocking to isolate the dependencies and assert the expected behavior at each step."
    },
    {
      "question_id": "EQ3056",
      "question": "Provide exactly one chained negative test for 2FA login: POST /login -> POST /2fa/verify with wrong code -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "Here's a chained negative test for 2FA login:\n\n1. Send a POST request to /login with valid credentials.\n2. Send a POST request to /2fa/verify with an incorrect 2FA code.\n3. Send a POST request to /refresh. The expected result should be a 401 Unauthorized response, indicating that the user is not authenticated due to the incorrect 2FA code."
    },
    {
      "question_id": "EQ3058",
      "question": "Design a chained test verifying pagination consistency across create -> list -> delete -> list (with total count assertions).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "Here's a chained test design:\n\n```python\nimport pytest\n\ndef test_pagination_consistency():\n    # Create 100 items\n    items = []\n    for i in range(100):\n        item = create_item(f\"Item {i}\")  # Assume create_item function exists\n        items.append(item)\n\n    # List items with pagination (page size 10, page 1)\n    page_1 = list_items(page_size=10, page=1)\n    assert len(page_1) == 10\n\n    # Delete first 20 items\n    for item in items[:20]:\n        delete_item(item.id)  # Assume delete_item function exists\n\n    # List items with pagination (page size 10, page 1)\n    page_1 = list_items(page_size=10, page=1)\n    assert len(page_1) == 0\n\n    # List items with pagination (page size 10, page 2)\n    page_2 = list_items(page_size=10, page=2)\n    assert len(page_2) == 80\n\n    # Verify total count\n    total_count = get_total_count()\n    assert total_count == 80\n```\n\nThis test creates 100 items, lists them with pagination, deletes the first 20 items, lists them again with pagination, and verifies the total count."
    },
    {
      "question_id": "EQ3060",
      "question": "Write one chained test for session stickiness: login -> subsequent calls via load balancer -> logout -> verify no node accepts old token.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "Here is a chained test for session stickiness:\n\n```python\nimport pytest\nfrom pytest_bellavista.testcase import BellavistaTestCase\n\nclass TestSessionStickiness(BellavistaTestCase):\n    def test_session_stickiness(self):\n        # Login\n        login_response = self.bellavista.login(username=\"user1\", password=\"password1\")\n        token = login_response.json()[\"token\"]\n\n        # Subsequent calls via load balancer\n        subsequent_call_response = self.bellavista.subsequent_call(token=token)\n        assert subsequent_call_response.status_code == 200\n\n        # Logout\n        logout_response = self.bellavista.logout(token=token)\n        assert logout_response.status_code == 200\n\n        # Verify no node accepts old token\n        with pytest.raises(self.bellavista.exceptions.InvalidTokenError):\n            self.bellavista.subsequent_call(token=token)\n```\n\nThis chained test first logs in a user, then makes a subsequent call with the obtained token, logs out the user, and finally attempts to make another call with the old token to verify that the node does not accept it."
    },
    {
      "question_id": "EQ4002",
      "question": "Write a state-machine style test validating account lifecycle: create → activate → suspend → reactivate → delete.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "Here's a state-machine style test validating account lifecycle:\n\n```python\nimport unittest\n\nclass AccountLifecycleTest(unittest.TestCase):\n    def test_account_lifecycle(self):\n        # Create a new account\n        account = {\"status\": \"create\"}\n        \n        # Activate the account\n        self.assertEqual(account, {\"status\": \"activate\"})\n        \n        # Suspend the account\n        self.assertEqual(account, {\"status\": \"suspend\"})\n        \n        # Reactivate the account\n        self.assertEqual(account, {\"status\": \"activate\"})\n        \n        # Delete the account\n        self.assertEqual(account, {\"status\": \"delete\"})\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nHowever, the above code is not a traditional state-machine style test because it doesn't actually test the transitions between states. Here's a more accurate example using a state machine:\n\n```python\nimport unittest\n\nclass Account:\n    def __init__(self):\n        self.status = \"create\"\n        \n    def activate(self):\n        if self.status == \"create\":\n            self.status = \"activate\"\n            return True\n        else:\n            return False\n        \n    def suspend(self):\n        if self.status == \"activate\":\n            self.status = \"suspend\"\n            return True\n        else:\n            return False\n        \n    def reactivate(self):\n        if self.status == \"suspend\":\n            self.status = \"activate\"\n            return True\n        else:\n            return False\n        \n    def delete(self):\n        if self.status == \"activate\" or self.status == \"suspend\":\n            self.status = \"delete\"\n            return True\n        else:\n            return False\n\nclass AccountLifecycleTest(unittest.TestCase):\n    def test_account_lifecycle(self):\n        account = Account()\n        \n        # Create a new account\n        self.assertEqual(account.status, \"create\")\n        \n        # Activate the account\n        self.assertTrue(account.activate())\n        self.assertEqual(account.status, \"activate\")\n        \n        # Suspend the account\n        self.assertTrue(account.suspend())\n        self.assertEqual(account.status, \"suspend\")\n        \n        # Reactivate the account\n        self.assertTrue(account.reactivate())\n        self.assertEqual(account.status, \"activate\")\n        \n        # Delete the account\n        self.assertTrue(account.delete())\n        self.assertEqual(account.status, \"delete\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\nThis code uses a state-machine to validate account lifecycle by testing the transitions between states."
    },
    {
      "question_id": "EQ4004",
      "question": "Design a chained test that validates transaction rollback when step 2 of a 3-step money transfer fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "Here's a chained test design in Python using the unittest framework:\n\n```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom money_transfer_service import MoneyTransferService\n\nclass TestMoneyTransferService(unittest.TestCase):\n\n    @patch('money_transfer_service.Connection')\n    def setUp(self, mock_connection):\n        self.money_transfer_service = MoneyTransferService()\n\n    def test_successful_money_transfer(self):\n        # Arrange\n        amount = 100\n        self.money_transfer_service.amount = amount\n\n        # Act\n        result = self.money_transfer_service.transfer()\n\n        # Assert\n        self.assertTrue(result)\n\n    @patch('money_transfer_service.Connection.rollback')\n    @patch('money_transfer_service.Connection.commit')\n    def test_step_2_failure(self, mock_commit, mock_rollback):\n        # Arrange\n        amount = 100\n        self.money_transfer_service.amount = amount\n\n        # Act\n        with self.assertRaises(Exception):\n            self.money_transfer_service.transfer()\n\n        # Assert\n        mock_commit.assert_not_called()\n        mock_rollback.assert_called_once()\n\n    @patch('money_transfer_service.Connection.commit')\n    def test_step_3_failure(self, mock_commit):\n        # Arrange\n        amount = 100\n        self.money_transfer_service.amount = amount\n\n        # Act\n        with self.assertRaises(Exception):\n            self.money_transfer_service.transfer()\n\n        # Assert\n        mock_commit.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis chained test consists of three test cases:\n\n1. `test_successful_money_transfer`: Verifies that a successful money transfer commits the transaction.\n2. `test_step_2_failure`: Tests that when step 2 of a 3-step money transfer fails, the transaction rolls back.\n3. `test_step_3_failure`: Verifies that when step 3 of a 3-step money transfer fails, the transaction rolls back."
    },
    {
      "question_id": "EQ4006",
      "question": "Write one test validating a multi-service chain: login → create order → process payment → cancel order after capture.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "```python\nimport pytest\nfrom unittest.mock import Mock\n\n# Mocked services\nlogin_service = Mock()\ncreate_order_service = Mock()\nprocess_payment_service = Mock()\ncancel_order_service = Mock()\n\n# Test case for multi-service chain\ndef test_login_create_order_process_payment_cancel_order_after_capture():\n    # Arrange\n    login_service.login.return_value = \"logged_in_user\"\n    create_order_service.create_order.return_value = \"order_id\"\n    process_payment_service.process_payment.return_value = \"payment_id\"\n    cancel_order_service.cancel_order.return_value = None\n\n    # Act\n    login_service.login()\n    create_order_service.create_order(\"logged_in_user\")\n    process_payment_service.process_payment(\"order_id\")\n    cancel_order_service.cancel_order(\"logged_in_user\", \"order_id\")\n\n    # Assert\n    assert login_service.login.called_once()\n    assert create_order_service.create_order.called_once_with(\"logged_in_user\")\n    assert process_payment_service.process_payment.called_once_with(\"order_id\")\n    assert cancel_order_service.cancel_order.called_once_with(\"logged_in_user\", \"order_id\")\n```\n\nThis test case validates the sequence of operations: login, create order, process payment, and cancel order after capture, by asserting that each service was called once with the expected arguments."
    },
    {
      "question_id": "EQ4008",
      "question": "Describe one state-machine test validating password lifecycle: set → expire → reset → reuse prevention.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "One state-machine test validating password lifecycle involves the following steps: \n\n1. Initially, the password is set to \"password123\" and expires after 90 days.\n2. The system checks if the password has expired (true) and allows the user to reset it to a new value, \"newpassword456\", which is not expired.\n3. The system checks if the new password has been reused within the last 180 days (false) and allows the user to proceed."
    },
    {
      "question_id": "EQ4010",
      "question": "Write one complex chained test covering a loan application flow with branch failure in credit check.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "Here's an example of a complex chained test covering a loan application flow with branch failure in credit check:\n\n```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom loan_application import LoanApplication\n\nclass TestLoanApplication(unittest.TestCase):\n\n    @patch('loan_application.credit_check')\n    def test_loan_application_flow_with_credit_check_failure(self, mock_credit_check):\n        # Arrange\n        loan_application = LoanApplication('John Doe', 30000, 5)\n        \n        # Act\n        result = loan_application.apply()\n        \n        # Assert\n        self.assertFalse(result)\n        mock_credit_check.assert_called_once_with(loan_application.annual_income, loan_application.credit_history)\n```\n\nIn this example, the test uses the `@patch` decorator to mock the `credit_check` function, which is called during the loan application flow. The test then asserts that the loan application fails (i.e., `result` is `False`) when the credit check fails, and that the `credit_check` function was called with the expected arguments."
    },
    {
      "question_id": "EQ4012",
      "question": "Write a test validating data integrity when concurrent writes occur: update user profile with conflicting values.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "To validate data integrity when concurrent writes occur, we can use the following test scenario:\n\n```python\nimport unittest\nfrom your_module import User\n\nclass TestDataIntegrity(unittest.TestCase):\n\n    def test_concurrent_writes(self):\n        # Create two users with the same ID\n        user1 = User(id=1, name='John', email='john@example.com')\n        user2 = User(id=1, name='Jane', email='jane@example.com')\n\n        # Save the users to the database (simulating concurrent writes)\n        user1.save()\n        user2.save()\n\n        # Verify that the data integrity is maintained\n        self.assertEqual(user1.get(), {'name': 'John', 'email': 'john@example.com'})\n        self.assertEqual(user2.get(), {'name': 'Jane', 'email': 'jane@example.com'})\n\n        # Check if the last write was successful\n        user1.update(name='John Updated', email='john_updated@example.com')\n        self.assertEqual(user1.get(), {'name': 'John Updated', 'email': 'john_updated@example.com'})\n```\n\nThis test ensures that when two users try to update the same user profile with conflicting values, the last write is successful and the data integrity is maintained."
    },
    {
      "question_id": "EQ4014",
      "question": "Write one very hard test validating chained document signing: upload → sign → verify → tamper detection.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "**Chained Document Signing Test**\n\n**Step 1: Upload and Signing**\n\nUpload a PDF document to a secure server. Use a digital signature library (e.g., Java's Bouncy Castle) to create a digital signature for the uploaded document using a private key (PK) and a corresponding certificate (Cert). The signature is generated using the SHA-256 hash function and the RSA algorithm with a key size of 2048 bits.\n\n**Step 2: Verify the Signature**\n\nUse the same digital signature library to verify the signature using the public key (PK') corresponding to the certificate (Cert). The verification process should confirm that the signature is valid and that the document has not been tampered with.\n\n**Step 3: Tamper Detection**\n\nIntroduce a malicious modification to the signed document, such as adding a new paragraph or changing the content of an existing paragraph. Attempt to re-verify the signature using the same public key (PK') and certificate (Cert). The verification process should detect the tampering and fail to validate the signature.\n\n**Step 4: Re-signing and Re-verification**\n\nUpload the tampered document to the secure server and use the same digital signature library to create a new digital signature for the tampered document using the same private key (PK) and certificate (Cert). Verify the new signature using the public key (PK') corresponding to the certificate (Cert). The verification process should fail to validate the signature due to the tampering.\n\n**Evaluation Criteria**\n\n1. The uploaded document is successfully signed and verified.\n2. The tampered document fails to be verified.\n3. The re-signed tampered document fails to be verified.\n4. The test demonstrates the effectiveness of chained document signing in detecting tampering.\n\n**Assessment**\n\nPass: The test is successful if all criteria are met. Fail: The test fails if any criterion is not met."
    },
    {
      "question_id": "EQ4017",
      "question": "Write one state-machine test validating subscription lifecycle: create → upgrade → downgrade → cancel.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "Here's an example of a state-machine test validating subscription lifecycle:\n\n```python\nimport unittest\nfrom state_machine import SubscriptionStateMachine\n\nclass TestSubscriptionLifecycle(unittest.TestCase):\n\n    def test_subscription_lifecycle(self):\n        # Create a new subscription\n        subscription = SubscriptionStateMachine('active')\n        self.assertEqual(subscription.state, 'active')\n        \n        # Upgrade the subscription to a higher tier\n        subscription.upgrade('premium')\n        self.assertEqual(subscription.state, 'premium')\n        \n        # Downgrade the subscription to a lower tier\n        subscription.downgrade('basic')\n        self.assertEqual(subscription.state, 'basic')\n        \n        # Cancel the subscription\n        subscription.cancel()\n        self.assertEqual(subscription.state, 'cancelled')\n```\n\nThis test creates a subscription, upgrades it, downgrades it, and then cancels it, verifying that the state-machine transitions to the correct state at each step."
    },
    {
      "question_id": "EQ4019",
      "question": "Write a very hard chained test validating recovery after partial failure in a distributed order saga.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom your_module import OrderSaga, Database\n\nclass TestOrderSagaRecovery(unittest.TestCase):\n\n    @patch('your_module.Database')\n    def test_recover_partial_failure(self, mock_db):\n        # Arrange\n        saga = OrderSaga()\n        saga.add_step('step1')\n        saga.add_step('step2')\n        saga.add_step('step3')\n\n        # Act\n        saga.execute()\n\n        # Assert\n        self.assertEqual(saga.status, 'pending')\n        self.assertEqual(saga.step_index, 0)\n\n        # Simulate partial failure\n        saga.fail_step('step1')\n        saga.fail_step('step2')\n\n        # Act\n        saga.recover()\n\n        # Assert\n        self.assertEqual(saga.status, 'failed')\n        self.assertEqual(saga.step_index, 2)\n        self.assertEqual(saga.failure_steps, ['step1','step2'])\n\n    @patch('your_module.Database')\n    def test_recover_partial_failure_with_dependencies(self, mock_db):\n        # Arrange\n        saga = OrderSaga()\n        saga.add_step('step1', dependencies=['step0'])\n        saga.add_step('step2', dependencies=['step1'])\n        saga.add_step('step3', dependencies=['step2'])\n\n        # Act\n        saga.execute()\n\n        # Simulate partial failure\n        saga.fail_step('step1')\n\n        # Act\n        saga.recover()\n\n        # Assert\n        self.assertEqual(saga.status, 'failed')\n        self.assertEqual(saga.step_index, 0)\n        self.assertEqual(saga.failure_steps, ['step1'])\n\n    @patch('your_module.Database')\n    def test_recover_partial_failure_with_cancellation(self, mock_db):\n        # Arrange\n        saga = OrderSaga()\n        saga.add_step('step1')\n        saga.add_step('step2')\n        saga.add_step('step3')\n\n        # Act\n        saga.execute()\n\n        # Simulate partial failure\n        saga.fail_step('step1')\n        saga.cancel_step('step2')\n\n        # Act\n        saga.recover()\n\n        # Assert\n        self.assertEqual(saga.status, 'canceled')\n        self.assertEqual(saga.step_index, 2)\n        self.assertEqual(saga.failure_steps, ['step1'])\n        self.assertEqual(saga.canceled_steps, ['step2'])\n```"
    },
    {
      "question_id": "EQ4021",
      "question": "Write one very hard test verifying financial transaction reversals: debit → credit → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "**Financial Transaction Reversal Test**\n\n**Test Case:** Debit → Credit → Rollback\n\n**Test Steps:**\n\n1. Initialize a bank account with a balance of $100.\n2. Perform a debit transaction of $50, updating the balance to $50.\n3. Perform a credit transaction of $75, updating the balance to $125.\n4. Attempt to roll back the last credit transaction, restoring the balance to $50.\n5. Verify that the balance is correctly restored to $50.\n6. Attempt to roll back the last debit transaction, verifying that it is not allowed since the balance is already restored.\n7. Perform another debit transaction of $20, updating the balance to $30.\n8. Verify that the balance is correctly updated to $30.\n9. Perform a rollback of both the last debit and credit transactions, restoring the balance to $100.\n10. Verify that the balance is correctly restored to $100.\n\n**Expected Result:** All transactions are successfully rolled back, and the balance is correctly restored to its original state."
    },
    {
      "question_id": "EQ4023",
      "question": "Design a state-machine test for warehouse inventory: add stock → allocate → ship → return → reconcile.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "To design a state-machine test for warehouse inventory, we can create a finite state machine with the following states and transitions:\n\n1. **Initial State**: Idle\n   - Transition to **Add Stock** when stock is added.\n\n2. **Add Stock**: Added\n   - Transition to **Allocate** when stock allocation request is received.\n\n3. **Allocate**: Allocated\n   - Transition to **Ship** when stock is allocated for shipping.\n\n4. **Ship**: Shipped\n   - Transition to **Return** when product is returned due to issues.\n\n5. **Return**: Returned\n   - Transition to **Reconcile** when returned product is reconciled.\n\n6. **Reconcile**: Reconciled\n   - Transition to **Idle** when all reconciliations are complete.\n\nThis state-machine test can help ensure that the warehouse inventory system correctly handles the different stages of stock management."
    },
    {
      "question_id": "EQ4025",
      "question": "Write one chained test validating mobile session lifecycle: login → token refresh → logout → refresh with old token → fail.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "Here's a chained test validating mobile session lifecycle:\n\n```python\nimport unittest\n\nclass TestMobileSessionLifecycle(unittest.TestCase):\n\n    def test_mobile_session_lifecycle(self):\n        # Login and get the token\n        token = self.login()\n        \n        # Token refresh\n        new_token = self.refresh_token(token)\n        self.assertNotEqual(token, new_token)  # Token should be refreshed\n        \n        # Logout\n        self.logout()\n        \n        # Refresh with old token\n        with self.assertRaises(Exception):\n            self.refresh_token(token)  # Should fail with old token\n        \n        # Login again to get a new token\n        new_token = self.login()\n        \n        # Refresh with new token\n        new_token = self.refresh_token(new_token)\n        self.assertEqual(new_token, new_token)  # Token should be refreshed\n        \nif __name__ == '__main__':\n    unittest.main()\n```\n\nThis test covers the following scenarios:\n\n1. Login and get the token\n2. Token refresh (new token should be different from the old one)\n3. Logout\n4. Refresh with old token (should fail)\n5. Login again and refresh with new token (should be successful)"
    },
    {
      "question_id": "EQ4027",
      "question": "Write one chained test validating email delivery API: send → open-tracking → unsubscribe → ensure no further emails sent.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "Here's an example of a chained test in Python using the `unittest` framework:\n\n```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom your_module import EmailDeliveryAPI\n\nclass TestEmailDeliveryAPI(unittest.TestCase):\n\n    @patch('your_module.EmailDeliveryAPI.send')\n    @patch('your_module.EmailDeliveryAPI.open_tracking')\n    @patch('your_module.EmailDeliveryAPI.unsubscribe')\n    @patch('your_module.EmailDeliveryAPI.send_email')\n    def test_chained_test(self, mock_send_email, mock_unsubscribe, mock_open_tracking, mock_send):\n        # Arrange\n        email_delivery_api = EmailDeliveryAPI('test@example.com')\n        mock_send_email.return_value = True\n        mock_open_tracking.return_value = True\n        mock_unsubscribe.return_value = True\n        mock_send.return_value = True\n\n        # Act\n        email_delivery_api.send('test@example.com')\n        email_delivery_api.open_tracking('test@example.com')\n        email_delivery_api.unsubscribe('test@example.com')\n        email_delivery_api.send('test@example.com')  # Ensure no further emails sent\n\n        # Assert\n        self.assertFalse(mock_send_email.called)  # No further emails sent\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this test, we're mocking the `send`, `open_tracking`, `unsubscribe`, and `send_email` methods of the `EmailDeliveryAPI` class. We then call these methods in order, ensuring that no further emails are sent after the user unsubscribes. The final assertion checks that the `send_email` method was not called after the user unsubscribed."
    },
    {
      "question_id": "EQ4029",
      "question": "Write one very hard chained test for purchase flow with coupon application and failure branch: apply coupon → checkout → coupon invalid → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "Here's an example of a chained test for purchase flow with coupon application and failure branch:\n\n```python\nimport pytest\n\n@pytest.mark.usefixtures(\"setup_test_data\")\nclass TestPurchaseFlow:\n    @pytest.fixture\n    def setup_test_data(self, request):\n        # Set up test data for the test\n        pass\n\n    def test_purchase_flow_with_coupon_application_and_failure(self):\n        # Apply coupon\n        coupon_code = \"COUPON10\"\n        response = apply_coupon(coupon_code)\n        assert response.status_code == 200\n        assert response.json()[\"message\"] == \"Coupon applied successfully\"\n\n        # Checkout\n        response = checkout()\n        assert response.status_code == 200\n        assert response.json()[\"message\"] == \"Order placed successfully\"\n\n        # Coupon invalid\n        invalid_coupon_code = \"INVALID_COUPON\"\n        response = apply_coupon(invalid_coupon_code)\n        assert response.status_code == 400\n        assert response.json()[\"message\"] == \"Invalid coupon code\"\n\n        # Rollback\n        response = rollback()\n        assert response.status_code == 200\n        assert response.json()[\"message\"] == \"Order rolled back successfully\"\n```\n\nNote that this is a high-level example and you would need to implement the `apply_coupon`, `checkout`, and `rollback` functions to interact with your application's API. Additionally, you would need to set up the test data fixture to provide the necessary data for the test."
    },
    {
      "question_id": "EQ5004-VN",
      "question": "Viết một test case positive đơn giản cho một API đăng nhập.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "Dưới đây là một ví dụ về một test case positive đơn giản cho một API đăng nhập bằng ngôn ngữ Python và thư viện Pytest:\n\n```python\nimport pytest\n\n# Dữ liệu đăng nhập hợp lệ\ndang_nhap_hop_le = {\n    \"username\": \"tai_khoan_hop_le\",\n    \"password\": \"mat_khau_hop_le\"\n}\n\n# Test case đăng nhập hợp lệ\n@pytest.mark.parametrize(\"data, expected_status_code\", [\n    (dang_nhap_hop_le, 200)\n])\ndef test_dang_nhap(data, expected_status_code):\n    # Gửi yêu cầu đăng nhập\n    response = requests.post(\"https://api-dang-nhap.com/login\", json=data)\n    \n    # Kiểm tra trạng thái phản hồi\n    assert response.status_code == expected_status_code\n```\n\nTrong ví dụ trên, chúng ta đang kiểm tra trường hợp đăng nhập hợp lệ bằng cách sử dụng dữ liệu đăng nhập hợp lệ và trạng thái phản hồi mong đợi là 200 (OK)."
    },
    {
      "question_id": "EQ5006-VN",
      "question": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là có một tài khoản người dùng đã đăng ký và được xác thực. Tài khoản này phải có thông tin cá nhân và hồ sơ phù hợp với yêu cầu của endpoint."
    },
    {
      "question_id": "EQ5008-VN",
      "question": "Viết một test negative đơn giản cho một API đăng ký.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Dưới đây là một test negative đơn giản cho một API đăng ký:\n\n```python\nimport requests\n\n# Test trường hợp không cung cấp thông tin đăng ký\nresponse = requests.post('https://api.example.com/register', data={})\nassert response.status_code!= 200, \"Trường hợp không cung cấp thông tin đăng ký không được chặn\"\n\n# Test trường hợp cung cấp thông tin đăng ký không hợp lệ\nresponse = requests.post('https://api.example.com/register', data={'username': 'john', 'password': '123'})\nassert response.status_code!= 200, \"Trường hợp cung cấp thông tin đăng ký không hợp lệ không được chặn\"\n```\n\nLưu ý: Trong test này, chúng ta đang kiểm tra hai trường hợp không mong muốn: không cung cấp thông tin đăng ký và cung cấp thông tin đăng ký không hợp lệ. Chúng ta hy vọng rằng API sẽ trả lại mã trạng thái không đúng (không phải 200) trong cả hai trường hợp này."
    },
    {
      "question_id": "EQ5010-VN",
      "question": "Vai trò của một schema trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "Vai trò của một schema trong API testing là xác định cấu trúc và quy định của dữ liệu mà API sẽ trả về hoặc nhận từ người dùng. Nó giúp kiểm tra xem dữ liệu có đáp ứng các yêu cầu về định dạng, loại và mối quan hệ hay không. Bằng cách sử dụng schema, các nhà phát triển có thể đảm bảo rằng API của họ luôn cung cấp dữ liệu chính xác và thống nhất."
    },
    {
      "question_id": "EQ5012-VN",
      "question": "Viết một test step đơn giản để validate một response 201 Created.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "Để validate một response 201 Created, ta có thể sử dụng test step sau:\n\n1. Gọi yêu cầu POST với nội dung cần tạo mới (ví dụ: tạo một tài khoản mới).\n2. Kiểm tra trạng thái HTTP response là 201 Created.\n3. Kiểm tra nội dung response có chứa thông tin về tài khoản mới được tạo, bao gồm cả ID và chi tiết của tài khoản."
    },
    {
      "question_id": "EQ5014-VN",
      "question": "Mục đích của mocking trong API testing là gì?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mục đích của mocking trong API testing là tạo ra các đối tượng giả lập (fake) để thay thế các dịch vụ bên ngoài, giúp giảm thiểu phụ thuộc vào các dịch vụ đó và tăng tốc độ test. Bằng cách sử dụng mocking, các nhà phát triển có thể kiểm tra chức năng của ứng dụng mà không cần phải gọi đến các dịch vụ bên ngoài, tiết kiệm thời gian và tăng hiệu quả của quá trình test."
    },
    {
      "question_id": "EQ5016-VN",
      "question": "Viết một test case dễ dàng cho một API lấy danh sách sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "Dưới đây là một ví dụ về test case đơn giản cho API lấy danh sách sản phẩm:\n\n**Test Case 1: Lấy danh sách sản phẩm thành công**\n\n- **Mô tả**: Người dùng gửi yêu cầu GET đến endpoint lấy danh sách sản phẩm.\n- **Thiết lập**: endpoint lấy danh sách sản phẩm, token truy cập hợp lệ.\n- **Kịch bản**: Gửi yêu cầu GET đến endpoint, kiểm tra phản hồi có chứa danh sách sản phẩm và mã trạng thái là 200.\n- **Kết quả mong muốn**: Danh sách sản phẩm được trả về và mã trạng thái là 200.\n\n**Test Case 2: Lấy danh sách sản phẩm khi không có token truy cập**\n\n- **Mô tả**: Người dùng gửi yêu cầu GET đến endpoint lấy danh sách sản phẩm mà không có token truy cập.\n- **Thiết lập**: endpoint lấy danh sách sản phẩm.\n- **Kịch bản**: Gửi yêu cầu GET đến endpoint mà không có token truy cập, kiểm tra phản hồi có chứa thông báo lỗi và mã trạng thái là 401.\n- **Kết quả mong muốn**: Thông báo lỗi được trả về và mã trạng thái là 401."
    },
    {
      "question_id": "EQ5018-VN",
      "question": "Mục đích của một precondition trong một test case là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Mục đích của một precondition trong một test case là đảm bảo rằng test case được thực hiện trong một trạng thái nhất định trước khi bắt đầu kiểm tra, giúp đảm bảo tính chính xác và đáng tin cậy của kết quả kiểm tra. Precondition giúp loại bỏ các yếu tố không liên quan và tập trung vào các thuộc tính hoặc hành vi cụ thể cần kiểm tra."
    },
    {
      "question_id": "EQ5020-VN",
      "question": "Viết một test negative cho việc upload file với định dạng không được hỗ trợ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Dưới đây là một ví dụ về test negative cho việc upload file với định dạng không được hỗ trợ:\n\n```python\nimport unittest\nfrom unittest.mock import patch\nfrom myapp import upload_file\n\nclass TestUploadFile(unittest.TestCase):\n    @patch('myapp.upload_file')\n    def test_upload_file_invalid_format(self, mock_upload_file):\n        # Gán giá trị trả về của mock_upload_file\n        mock_upload_file.return_value = False\n        # Gọi hàm upload_file với file có định dạng không được hỗ trợ\n        result = upload_file('invalid_file.txt')\n        # Kiểm tra kết quả\n        self.assertFalse(result)\n```\n\nTrong ví dụ trên, chúng ta sử dụng `@patch` để mock hàm `upload_file` và gán giá trị trả về là `False`. Sau đó, chúng ta gọi hàm `upload_file` với file có định dạng không được hỗ trợ và kiểm tra kết quả bằng cách sử dụng `self.assertFalse`."
    },
    {
      "question_id": "EQ5022-VN",
      "question": "Mục đích của một test case description là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "Mục đích của một test case description là giải thích rõ ràng và chi tiết về yêu cầu hoặc yêu cầu của hệ thống cần được kiểm tra, cũng như các bước cần thực hiện để kiểm tra và xác minh tính đúng đắn của hệ thống. Điều này giúp đảm bảo rằng các yêu cầu được hiểu và thực hiện đúng cách."
    },
    {
      "question_id": "EQ5024-VN",
      "question": "Viết một test step để validate thời gian response dưới 1 giây.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "Bước kiểm tra: \n- Tiến hành yêu cầu API.\n- Sử dụng thời gian bắt đầu và thời gian kết thúc để tính thời gian thực hiện.\n- So sánh thời gian thực hiện với thời gian mong muốn (dưới 1 giây) và xác nhận thời gian đáp ứng dưới 1 giây."
    },
    {
      "question_id": "EQ5027-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /health.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "Dưới đây là một ví dụ về test positive đơn giản cho endpoint GET /health bằng cách sử dụng thư viện unittest của Python:\n\n```python\nimport unittest\nfrom unittest.mock import patch\nfrom your_module import app  # Thay thế bằng tên của module ứng dụng của bạn\n\nclass TestHealthEndpoint(unittest.TestCase):\n    @patch('your_module.app')\n    def test_health_endpoint(self, mock_app):\n        with mock_app.test_client() as client:\n            response = client.get('/health')\n            self.assertEqual(response.status_code, 200)\n            self.assertIn('healthy', response.json)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nLưu ý rằng bạn cần thay thế `your_module` bằng tên của module ứng dụng của mình. Điều này cho phép bạn kiểm tra xem endpoint GET /health có trả về trạng thái 200 và thông tin 'healthy' trong phản hồi JSON hay không."
    },
    {
      "question_id": "EQ5029-VN",
      "question": "Mục đích của việc sử dụng test data management trong API testing là gì?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "Mục đích của việc sử dụng test data management trong API testing là cung cấp và quản lý dữ liệu thử nghiệm chính xác và cập nhật cho các cuộc kiểm tra API. Điều này giúp đảm bảo tính nhất quán và hiệu quả của các cuộc kiểm tra, giảm thiểu thời gian và chi phí cần thiết để thực hiện các cuộc kiểm tra."
    },
    {
      "question_id": "EQ5031-VN",
      "question": "Viết một test negative dễ dàng cho một API mong đợi định dạng JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Để viết một test negative dễ dàng cho một API mong đợi định dạng JSON, bạn có thể sử dụng các công cụ như Postman, Insomnia hoặc các thư viện kiểm tra tự động như Pytest, Unittest. Bạn có thể tạo các trường hợp test sau:\n\n- Test lỗi format JSON: Gửi yêu cầu với dữ liệu không đúng định dạng JSON.\n- Test lỗi dữ liệu trống: Gửi yêu cầu với dữ liệu trống hoặc không có thông tin cần thiết.\n- Test lỗi dữ liệu không hợp lệ: Gửi yêu cầu với dữ liệu không hợp lệ hoặc không phù hợp với yêu cầu của API.\n\nVí dụ, bạn có thể sử dụng Pytest và thư viện requests để tạo một test negative như sau:\n\n```python\nimport pytest\nimport requests\n\n@pytest.mark.parametrize(\"data\", [\n    {},  # dữ liệu trống\n    {\"name\": \"John\"},  # dữ liệu không đầy đủ\n    {\"name\": \"John\", \"age\": \"abc\"}  # dữ liệu không hợp lệ\n])\ndef test_api(data):\n    response = requests.post(\"https://api.example.com/users\", json=data)\n    assert response.status_code!= 200\n```\n\nTrong ví dụ trên, chúng ta đang kiểm tra xem API sẽ trả về mã trạng thái không phải là 200 khi gửi yêu cầu với dữ liệu không đúng định dạng JSON, trống hoặc không hợp lệ."
    },
    {
      "question_id": "EQ5033-VN",
      "question": "Vai trò của assertion trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "Vai trò của assertion trong API testing là xác minh rằng API đáp ứng được yêu cầu và chức năng mong muốn. Nó giúp phát hiện ra lỗi hoặc vấn đề trong API và cung cấp thông tin chi tiết để khắc phục. Bằng cách sử dụng assertion, các nhà phát triển có thể đảm bảo rằng API hoạt động đúng và ổn định."
    },
    {
      "question_id": "EQ5035-VN",
      "question": "Viết một test case để kiểm tra DELETE /users/{id} hoạt động đúng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "Để kiểm tra DELETE /users/{id} hoạt động đúng, bạn có thể tạo một test case như sau:\n\n**Test Case: Xoá một người dùng**\n\n| ID           | Đặt tên cho test case | Mô tả                |\n|--------------|----------------------|----------------------|\n| TC_DELETE_USER| Xoá người dùng thành công| Xoá một người dùng có ID cụ thể|\n\n**Bước 1:** Tạo một người dùng mới với ID cụ thể\n\n**Bước 2:** Gửi yêu cầu DELETE đến /users/{id} với ID người dùng đã tạo\n\n**Bước 3:** Kiểm tra xem người dùng đã được xoá thành công hay không\n\n**Bước 4:** Kiểm tra xem trạng thái HTTP trả về là 200 (OK) hay không\n\n**Bước 5:** Kiểm tra xem người dùng có thể được tìm thấy trên hệ thống hay không"
    },
    {
      "question_id": "EQ5037-VN",
      "question": "Mã trạng thái HTTP 201 Created cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "Mã trạng thái HTTP 201 Created cho biết yêu cầu tạo mới một tài nguyên thành công và tài nguyên đã được tạo thành công. Nó thường được sử dụng sau khi tạo mới một tài nguyên, chẳng hạn như một tài khoản hoặc một bài viết."
    },
    {
      "question_id": "EQ5039-VN",
      "question": "Viết một test đơn giản cho GET /users/{id} trả về response chính xác.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "Dưới đây là một ví dụ đơn giản về cách viết một test cho API GET /users/{id} sử dụng Pytest và Flask:\n\n```python\nimport pytest\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\n# Định nghĩa route GET /users/{id}\n@app.route('/users/<int:id>', methods=['GET'])\ndef get_user(id):\n    # Tìm user theo id\n    user = {'id': id, 'name': f'User {id}', 'email': f'user{id}@example.com'}\n    return jsonify(user)\n\n# Chạy test\n@pytest.fixture\ndef client():\n    with app.test_client() as client:\n        yield client\n\ndef test_get_user(client):\n    # Gọi API GET /users/1\n    response = client.get('/users/1')\n    # Kiểm tra trạng thái response\n    assert response.status_code == 200\n    # Kiểm tra nội dung response\n    assert response.json == {'id': 1, 'name': 'User 1', 'email': 'user1@example.com'}\n```\n\nTrong ví dụ trên, chúng ta tạo một ứng dụng Flask với route GET /users/{id} và định nghĩa một test sử dụng Pytest để kiểm tra response của API GET /users/1."
    },
    {
      "question_id": "EQ5041-VN",
      "question": "Mục đích của một response 200 OK là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "Mục đích của một response 200 OK là xác nhận rằng yêu cầu của khách hàng đã được xử lý thành công và nội dung được yêu cầu đã được gửi đến. Response này cho biết yêu cầu đã được thực hiện một cách thành công và dữ liệu được yêu cầu đã được gửi đến."
    },
    {
      "question_id": "EQ5043-VN",
      "question": "Viết một test negative để validate response cho một endpoint không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "Để viết một test negative để validate response cho một endpoint không hợp lệ, bạn có thể sử dụng các trường hợp sau:\n\n- **Test 1: Endpoint không tồn tại**: Gửi yêu cầu GET đến một endpoint không tồn tại, chẳng hạn như \"/api/non-existent\" và kiểm tra xem response có chứa mã lỗi 404 (Not Found) hay không.\n\n- **Test 2: Endpoint yêu cầu tham số không hợp lệ**: Gửi yêu cầu GET đến một endpoint nhưng không cung cấp tham số yêu cầu, chẳng hạn như \"/api/users\" mà không cung cấp ID người dùng và kiểm tra xem response có chứa mã lỗi 400 (Bad Request) hay không.\n\n- **Test 3: Endpoint yêu cầu phương thức không phù hợp**: Gửi yêu cầu đến một endpoint bằng phương thức không phù hợp, chẳng hạn như gửi yêu cầu POST đến một endpoint chỉ chấp nhận GET và kiểm tra xem response có chứa mã lỗi 405 (Method Not Allowed) hay không.\n\nVí dụ sử dụng Python và thư viện unittest để viết các test trên:\n\n```python\nimport unittest\nimport requests\n\nclass TestEndpoint(unittest.TestCase):\n\n    def test_endpoint_khong_ton_tai(self):\n        response = requests.get('http://example.com/api/non-existent')\n        self.assertEqual(response.status_code, 404)\n\n    def test_endpoint_yeu_cau_tham_so_khong_hop_le(self):\n        response = requests.get('http://example.com/api/users')\n        self.assertEqual(response.status_code, 400)\n\n    def test_endpoint_yeu_cau_phuong_thuc_khong_hop_le(self):\n        response = requests.post('http://example.com/api/users', data={'id': 1})\n        self.assertEqual(response.status_code, 405)\n\nif __name__ == '__main__':\n    unittest.main()\n```"
    },
    {
      "question_id": "EQ5045-VN",
      "question": "Một test case assertion làm gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Một test case assertion là một phần của một test case, nó giúp kiểm tra xem một yêu cầu nào đó có được thực hiện đúng hay không. Nếu yêu cầu được thực hiện đúng, assertion sẽ được thực hiện thành công; ngược lại, nếu yêu cầu không được thực hiện đúng, assertion sẽ báo lỗi."
    },
    {
      "question_id": "EQ5047-VN",
      "question": "Viết một test positive cho endpoint upload file.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "Dưới đây là một ví dụ về test positive cho endpoint upload file sử dụng Python và thư viện unittest:\n\n```python\nimport unittest\nfrom unittest.mock import Mock\nfrom your_module import upload_file\n\nclass TestUploadFile(unittest.TestCase):\n    def test_upload_file_success(self):\n        # Tạo mock cho endpoint upload file\n        mock_endpoint = Mock()\n        mock_endpoint.upload_file.return_value = {'file_id': 'file_id','message': 'File uploaded successfully'}\n        \n        # Gọi hàm upload_file với mock endpoint\n        file_id, message = upload_file(mock_endpoint, 'file_path')\n        \n        # Kiểm tra kết quả\n        self.assertEqual(file_id, 'file_id')\n        self.assertEqual(message, 'File uploaded successfully')\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nTrong ví dụ trên, chúng ta tạo một test case để kiểm tra hàm `upload_file` khi endpoint upload file hoạt động đúng. Hàm `upload_file` được gọi với mock endpoint và file path. Kết quả được kiểm tra để đảm bảo file được upload thành công."
    },
    {
      "question_id": "EQ5049-VN",
      "question": "Vai trò của 415 Unsupported Media Type là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "415 Unsupported Media Type là một mã trạng thái HTTP (Hypertext Transfer Protocol) chỉ định rằng phương thức yêu cầu không hỗ trợ phương thức yêu cầu hiện tại. Điều này có nghĩa là máy chủ không thể xử lý yêu cầu theo yêu cầu của trình duyệt hoặc ứng dụng khách. Mã trạng thái này thường xuất hiện khi trình duyệt hoặc ứng dụng khách yêu cầu một định dạng dữ liệu không được hỗ trợ bởi máy chủ."
    },
    {
      "question_id": "EQ5052-VN",
      "question": "Viết một test positive đơn giản để kiểm tra API chi tiết sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "Dưới đây là một ví dụ về test positive đơn giản để kiểm tra API chi tiết sản phẩm:\n\n```python\nimport requests\n\n# Gửi yêu cầu GET đến API để lấy chi tiết sản phẩm\nresponse = requests.get('https://api.example.com/product/123')\n\n# Kiểm tra mã trạng thái của phản hồi\nif response.status_code == 200:\n    # Kiểm tra xem dữ liệu trả về có đúng định dạng không\n    assert response.json()['name'] == 'Sản phẩm 123'\n    assert response.json()['price'] == 100.0\n    print('API chi tiết sản phẩm hoạt động đúng')\nelse:\n    print('API chi tiết sản phẩm không hoạt động đúng')\n```\n\nTrong ví dụ này, chúng ta đang gửi yêu cầu GET đến API để lấy chi tiết sản phẩm với ID là 123. Sau đó, chúng ta kiểm tra mã trạng thái của phản hồi và dữ liệu trả về để đảm bảo rằng API hoạt động đúng."
    },
    {
      "question_id": "EQ5054-VN",
      "question": "Mục đích của việc sử dụng Authorization headers trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "Mục đích của việc sử dụng Authorization headers trong API testing là để mô phỏng việc xác thực và cấp quyền truy cập cho các yêu cầu API. Điều này giúp kiểm tra tính bảo mật và khả năng bảo vệ của API trước các hành vi không được phép, đồng thời cũng kiểm tra tính hợp lệ của các yêu cầu API có chứa thông tin xác thực."
    },
    {
      "question_id": "EQ5056-VN",
      "question": "Viết một test negative case cho một API yêu cầu authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Dưới đây là một ví dụ về test negative case cho một API yêu cầu authentication:\n\n```python\nimport requests\n\ndef test_api_auth_negative():\n    # Gửi yêu cầu GET đến API mà không có token xác thực\n    response = requests.get('https://api.example.com/data', headers={'Authorization': ''})\n    \n    # Kiểm tra mã trạng thái và nội dung phản hồi\n    assert response.status_code == 401, f\"Expected status code 401, but got {response.status_code}\"\n    assert response.json()['error'] == 'Authentication failed', f\"Expected error message 'Authentication failed', but got {response.json()['error']}\"\n\n# Chạy thử nghiệm\ntest_api_auth_negative()\n```\n\nTrong thử nghiệm này, chúng ta gửi yêu cầu GET đến API mà không có token xác thực và kiểm tra mã trạng thái và nội dung phản hồi. Nếu mã trạng thái là 401 và nội dung phản hồi là 'Authentication failed', thì thử nghiệm sẽ thành công."
    },
    {
      "question_id": "EQ5058-VN",
      "question": "Vai trò của 500 Internal Server Error trong API testing là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "500 Internal Server Error là một mã lỗi HTTP thường xuất hiện trong API testing, biểu thị lỗi xảy ra tại phía máy chủ. Trong API testing, lỗi 500 có thể giúp phát hiện lỗi về cơ sở dữ liệu, kết nối mạng, hoặc lỗi logic trong mã nguồn, từ đó giúp nhà phát triển API cải thiện và sửa lỗi."
    },
    {
      "question_id": "EQ5060-VN",
      "question": "Viết một test case positive cho một API trả về danh sách đơn hàng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "Dưới đây là một ví dụ về test case positive cho một API trả về danh sách đơn hàng:\n\n**Tên test case:** \"Lấy danh sách đơn hàng thành công\"\n\n**Mô tả:** \"Gửi yêu cầu GET để lấy danh sách đơn hàng và kiểm tra kết quả trả về\"\n\n**Tham số input:**\n\n* URL: \"/api/orders\"\n* Phương thức: GET\n* Đầu vào: không có đầu vào\n\n**Kết quả mong đợi:**\n\n* Trả về danh sách đơn hàng thành công\n* Trả về mã trạng thái HTTP 200 (OK)"
    },
    {
      "question_id": "EQ5062-VN",
      "question": "Chức năng của response header trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "Chức năng của response header trong API testing là cung cấp thông tin về trạng thái và nội dung của phản hồi từ server. Response header bao gồm các thông tin như mã trạng thái HTTP, loại nội dung (Content-Type), kích thước phản hồi (Content-Length), và các thông tin khác về phản hồi. Những thông tin này giúp người kiểm tra xác định phản hồi có thành công hay không và nội dung của nó như thế nào."
    },
    {
      "question_id": "EQ5064-VN",
      "question": "Viết một test negative cho việc tạo một tài nguyên trùng lặp.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "Dưới đây là một ví dụ về test negative cho việc tạo một tài nguyên trùng lặp:\n\n```python\nimport pytest\n\n# Định nghĩa một chức năng tạo tài nguyên\ndef tạo_tài_nguyên(tên_tài_nguyên):\n    tài_nguyên_trung_lặp = {\n        \"tên_tài_nguyên\": tên_tài_nguyên,\n        \"thông_tin\": \"thông tin về tài nguyên\"\n    }\n    return tài_nguyên_trung_lặp\n\n# Test trường hợp không tạo tài nguyên trùng lặp\ndef test_tạo_tài_nguyên_trung_lặp():\n    tên_tài_nguyên = \"tài nguyên 1\"\n    tài_nguyên = tạo_tài_nguyên(tên_tài_nguyên)\n    assert tài_nguyên[\"tên_tài_nguyên\"] == tên_tài_nguyên\n    # Không tạo tài nguyên trùng lặp nên không có thông tin về tài nguyên trùng lặp\n    assert \"tài nguyên trùng lặp\" not in tài_nguyên[\"thông_tin\"]\n\n# Test trường hợp tạo tài nguyên trùng lặp\ndef test_tạo_tài_nguyên_trùng_lặp():\n    tên_tài_nguyên = \"tài nguyên 1\"\n    tài_nguyên_trùng_lặp = tạo_tài_nguyên(tên_tài_nguyên)\n    assert tài_nguyên_trùng_lặp[\"tên_tài_nguyên\"] == tên_tài_nguyên\n    # Tạo tài nguyên trùng lặp nên có thông tin về tài nguyên trùng lặp\n    assert \"tài nguyên trùng lặp\" in tài_nguyên_trùng_lặp[\"thông_tin\"]\n\n# Test trường hợp tạo tài nguyên trùng lặp không thành công\ndef test_tạo_tài_nguyên_trùng_lặp_thất_bại():\n    tên_tài_nguyên = \"tài nguyên 1\"\n    tài_nguyên_trùng_lặp = tạo_tài_nguyên(tên_tài_nguyên)\n    assert tài_nguyên_trùng_lặp[\"tên_tài_nguyên\"] == tên_tài_nguyên\n    # Tạo tài nguyên trùng lặp không thành công nên không có thông tin về tài nguyên trùng lặp\n    assert \"tài nguyên trùng lặp\" not in tài_nguyên_trùng_lặp[\"thông_tin\"]\n```\n\nTrong ví dụ trên, chúng ta đã định nghĩa một chức năng tạo tài nguyên và các test trường hợp để kiểm tra việc"
    },
    {
      "question_id": "EQ5066-VN",
      "question": "Vai trò của 202 Accepted trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "Trong các API, \"202 Accepted\" là một trạng thái HTTP (Hypertext Transfer Protocol) được sử dụng để chỉ rằng yêu cầu của client đã được chấp nhận, nhưng không nhất thiết phải thực hiện ngay lập tức. Trạng thái này thường được sử dụng trong các trường hợp như tạo tài khoản, gửi email xác nhận, hoặc thực hiện các yêu cầu có liên quan đến việc chờ đợi hoặc xác nhận."
    },
    {
      "question_id": "EQ5068-VN",
      "question": "Viết một test positive dễ dàng để kiểm tra API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Để kiểm tra schema của API response, bạn có thể sử dụng thư viện `pydantic` kết hợp với `pytest`. Dưới đây là một ví dụ về test positive để kiểm tra schema của API response:\n\n```python\nimport pytest\nfrom pydantic import BaseModel\nfrom fastapi import Response\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\ndef test_api_response_schema(api_client):\n    response = api_client.get(\"/users\")\n    assert response.status_code == 200\n    assert response.json() is not None\n    assert User.parse_obj(response.json()) is not None\n```\n\nTrong ví dụ này, chúng ta sử dụng `pydantic` để định nghĩa schema của dữ liệu người dùng, và `pytest` để kiểm tra xem API response có đúng với schema này hay không."
    },
    {
      "question_id": "EQ5070-VN",
      "question": "Mục đích của response body trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Mục đích của response body trong API testing là kiểm tra xem API đã trả về dữ liệu như mong đợi hay chưa, bao gồm cả dữ liệu dạng JSON, XML hoặc các dạng dữ liệu khác. Điều này giúp đảm bảo rằng API đang hoạt động đúng và trả về dữ liệu chính xác."
    },
    {
      "question_id": "EQ5072-VN",
      "question": "Viết một test case để verify chức năng logout.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "Để verify chức năng logout, ta có thể viết một test case như sau:\n\n**Test Case: Verify chức năng logout**\n\n1. **Precondition**: Đăng nhập vào hệ thống với tài khoản hợp lệ.\n2. **Step**: \n * Đăng xuất khỏi hệ thống.\n * Kiểm tra xem hệ thống đã được đăng xuất thành công hay chưa (ví dụ: kiểm tra trạng thái đăng nhập, nội dung trang web).\n3. **Expected Result**: Hệ thống đã được đăng xuất thành công, trạng thái đăng nhập là \"đang ngoại tuyến\" và nội dung trang web được cập nhật phù hợp với trạng thái đăng xuất.\n\n**Test Case ID**: Logout-01\n\n**Priority**: Cao\n\n**Test Case Type**: Funcional Test\n\n**Environment**: Môi trường thử nghiệm với hệ thống đã được cài đặt và cấu hình phù hợp."
    },
    {
      "question_id": "EQ5074-VN",
      "question": "Lỗi 415 Unsupported Media Type validate điều gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "Lỗi 415 Unsupported Media Type xảy ra khi máy chủ web không hỗ trợ loại dữ liệu (media type) được gửi trong yêu cầu HTTP. Ví dụ, nếu một ứng dụng yêu cầu dữ liệu JSON nhưng máy chủ web chỉ hỗ trợ dữ liệu XML, thì máy chủ sẽ trả lại lỗi 415."
    },
    {
      "question_id": "EQ5077-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /status.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Để viết một test positive đơn giản cho endpoint GET /status, bạn có thể sử dụng framework test như pytest hoặc unittest trong Python. Dưới đây là ví dụ về một test positive đơn giản:\n\n```python\nimport requests\n\ndef test_status_code():\n    response = requests.get('http://localhost:5000/status')\n    assert response.status_code == 200\n```\n\nTrong ví dụ này, chúng ta đang kiểm tra xem endpoint GET /status có trả về mã trạng thái HTTP 200 (OK) hay không."
    },
    {
      "question_id": "EQ5079-VN",
      "question": "Một response 204 No Content có nghĩa là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "Một response 204 No Content trong HTTP có nghĩa là yêu cầu đã được xử lý thành công, nhưng không có nội dung nào được cung cấp. Điều này thường xảy ra khi yêu cầu không yêu cầu nội dung, chẳng hạn như khi yêu cầu một tài nguyên đã bị xóa."
    },
    {
      "question_id": "EQ5081-VN",
      "question": "Viết một test negative case cho việc gửi một Content-Type header không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Dưới đây là một test negative case cho việc gửi một Content-Type header không hợp lệ:\n\n```python\nimport unittest\nimport requests\n\nclass TestContent-TypeHeader(unittest.TestCase):\n    def test_content_type_header_khong_hop_le(self):\n        url = \"http://example.com\"\n        headers = {\"Content-Type\": \"application/json; charset=utf-8; invalid-key\"}\n        response = requests.get(url, headers=headers)\n        self.assertEqual(response.status_code, 400)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nTrong test này, chúng ta đang kiểm tra xem khi gửi một Content-Type header không hợp lệ, server sẽ trả về trạng thái 400 (Bad Request)."
    },
    {
      "question_id": "EQ5083-VN",
      "question": "Mục đích của Accept header trong các API request là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "Mục đích của Accept header trong các API request là để chỉ định loại dữ liệu mà client muốn nhận từ server. Điều này cho phép server biết được loại dữ liệu mà client có thể xử lý và trả về dữ liệu phù hợp. Ví dụ, nếu client chỉ định Accept: application/json, server sẽ trả về dữ liệu JSON."
    },
    {
      "question_id": "EQ5085-VN",
      "question": "Viết một test case đơn giản cho một API logout thành công.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "Dưới đây là một ví dụ về test case đơn giản cho API logout thành công:\n\n**Test Case:** Logout thành công\n\n**Mô tả:**\n\n- **Tham số:** Không yêu cầu tham số\n- **Trả về:** Trả về mã trạng thái HTTP 200 và thông báo \"Đăng xuất thành công\"\n\n**Cụ thể:**\n\n1. Gửi yêu cầu POST đến đường dẫn logout\n2. Kiểm tra mã trạng thái HTTP trả về là 200\n3. Kiểm tra thông báo trả về là \"Đăng xuất thành công\"\n\n**Ghi chú:** Test case này sẽ được thực hiện bằng công cụ kiểm tra API như Postman hoặc cURL."
    },
    {
      "question_id": "EQ5087-VN",
      "question": "Ý nghĩa của 401 Unauthorized trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "401 Unauthorized là một mã lỗi HTTP phổ biến trong API testing, chỉ định rằng yêu cầu của người dùng đã được gửi nhưng không được xác thực. Điều này có nghĩa là người dùng chưa cung cấp thông tin xác thực (tên đăng nhập và mật khẩu) hoặc thông tin xác thực đó không hợp lệ."
    },
    {
      "question_id": "EQ5089-VN",
      "question": "Viết một test case positive dễ dàng để kiểm tra API chi tiết profile.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "Để viết một test case positive dễ dàng để kiểm tra API chi tiết profile, chúng ta có thể thực hiện theo các bước sau:\n\n1. Gọi API chi tiết profile với một ID hợp lệ và kiểm tra xem trả về thông tin profile đúng không.\n2. Sử dụng các công cụ như Postman hoặc cURL để gửi yêu cầu GET đến API với tham số ID.\n3. Kiểm tra xem API trả về thông tin profile đúng và đầy đủ.\n\nVí dụ:\n\n- Test case: \"Kiểm tra thông tin profile\"\n- Điều kiện tiền đề: ID profile hợp lệ\n- Hoạt động: Gọi API chi tiết profile với ID hợp lệ\n- Kết quả mong muốn: Trả về thông tin profile đúng và đầy đủ."
    },
    {
      "question_id": "EQ5091-VN",
      "question": "Mục đích của 302 Found trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "Mục đích của 302 Found trong các API là chuyển hướng request đến một địa chỉ khác, thường là để cập nhật URL hoặc để thực hiện các yêu cầu khác. Điều này giúp tránh việc yêu cầu bị trùng lặp và cải thiện trải nghiệm người dùng."
    },
    {
      "question_id": "EQ5093-VN",
      "question": "Viết một test case cho nỗ lực đăng nhập negative với mật khẩu sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "Dưới đây là một test case cho nỗ lực đăng nhập negative với mật khẩu sai:\n\n**Tên test case:** Đăng nhập với mật khẩu sai\n\n**Mô tả:** Kiểm tra việc đăng nhập với mật khẩu sai.\n\n**Thủ tục:**\n\n1. Mở trang đăng nhập.\n2. Nhập tên đăng nhập đúng.\n3. Nhập mật khẩu sai.\n4. Nhấn nút đăng nhập.\n5. Kiểm tra thông báo lỗi.\n\n**Kết quả mong đợi:** Thông báo lỗi về việc mật khẩu sai."
    },
    {
      "question_id": "EQ5095-VN",
      "question": "422 Unprocessable Entity cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "\"422 Unprocessable Entity\" là một mã lỗi HTTP cho biết hệ thống đã nhận được yêu cầu hợp lệ nhưng không thể xử lý được do một lý do nào đó, chẳng hạn như dữ liệu yêu cầu không hợp lệ hoặc không đủ thông tin. Mã lỗi này thường được sử dụng trong các tình huống khi hệ thống cần thêm thông tin hoặc dữ liệu để xử lý yêu cầu một cách chính xác."
    },
    {
      "question_id": "EQ5097-VN",
      "question": "Viết một test positive cho endpoint POST /users.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Dưới đây là một ví dụ về test positive cho endpoint POST /users:\n\n```python\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom app.main import app\n\nclient = TestClient(app)\n\ndef test_create_user():\n    # Tạo một yêu cầu POST với một user mới\n    response = client.post(\"/users\", json={\"name\": \"John Doe\", \"email\": \"john@example.com\"})\n    # Kiểm tra nếu trạng thái phản hồi là 201 (Tạo mới thành công)\n    assert response.status_code == 201\n    # Kiểm tra nếu dữ liệu user mới được tạo thành công\n    assert response.json()[\"name\"] == \"John Doe\"\n    assert response.json()[\"email\"] == \"john@example.com\"\n```\n\nLưu ý: Bất kỳ dữ liệu mẫu nào được sử dụng trong test này chỉ là ví dụ và có thể cần được thay thế bằng dữ liệu mẫu phù hợp với yêu cầu của ứng dụng."
    },
    {
      "question_id": "EQ5099-VN",
      "question": "Thuật ngữ 'happy path' trong testing có nghĩa là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "Thuật ngữ 'happy path' trong testing có nghĩa là con đường hoặc trường hợp được kiểm tra khi mọi thứ diễn ra theo cách mong muốn, thuận lợi và không có lỗi. Nó thường được sử dụng để mô tả một kịch bản kiểm tra trong đó tất cả các điều kiện và yêu cầu đều được đáp ứng một cách chính xác."
    },
    {
      "question_id": "EQ2002-VN",
      "question": "Hãy giải thích cách bạn thiết kế một **test case âm tính** cho một endpoint API yêu cầu **OAuth2 Bearer token**.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "Để thiết kế một **test case âm tính** cho endpoint API yêu cầu **OAuth2 Bearer token**, bạn cần thực hiện các bước sau:\n\n- **Bước 1:** Không gửi token Bearer trong yêu cầu HTTP.\n- **Bước 2:** Kiểm tra xem API có yêu cầu xác thực OAuth2 Bearer token không.\n- **Bước 3:** Đảm bảo rằng API trả về mã trạng thái (status code) phù hợp cho trường hợp không cung cấp token Bearer (thường là 401 Unauthorized hoặc 403 Forbidden).\n\nBằng cách thực hiện các bước này, bạn có thể xác minh rằng API đang xử lý trường hợp không cung cấp token Bearer một cách chính xác."
    },
    {
      "question_id": "EQ2004-VN",
      "question": "Cung cấp một **test case happy-path** và một **test case error-path** cho một endpoint API hoàn tiền thanh toán.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "Dưới đây là hai **test case** cho endpoint API hoàn tiền thanh toán:\n\n**Test case happy-path:**\n\n- Tên test case: \"Hoàn tiền thanh toán thành công\"\n- Mô tả: Sử dụng tài khoản khách hàng có đủ số dư để hoàn tiền một giao dịch thanh toán đã thực hiện.\n- Input:\n + Thông tin khách hàng (tên, địa chỉ, số điện thoại)\n + Số dư tài khoản khách hàng\n + Mã giao dịch thanh toán\n + Số tiền cần hoàn tiền\n- Output: Thông báo hoàn tiền thành công, số dư tài khoản khách hàng được cập nhật.\n\n**Test case error-path:**\n\n- Tên test case: \"Hoàn tiền thanh toán không thành công do số dư tài khoản thấp\"\n- Mô tả: Sử dụng tài khoản khách hàng có số dư thấp để hoàn tiền một giao dịch thanh toán đã thực hiện.\n- Input:\n + Thông tin khách hàng (tên, địa chỉ, số điện thoại)\n + Số dư tài khoản khách hàng (dưới mức cho phép)\n + Mã giao dịch thanh toán\n + Số tiền cần hoàn tiền\n- Output: Thông báo số dư tài khoản thấp, không thể hoàn tiền."
    },
    {
      "question_id": "EQ2006-VN",
      "question": "Bạn sẽ xác thực các thay đổi **schema** trong một nâng cấp API **tương thích ngược** như thế nào?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "Khi thực hiện một nâng cấp API tương thích ngược, bạn nên sử dụng phương pháp xác thực các thay đổi **schema** như sau:\n\n1. Sử dụng mô hình \"Canary Deployment\" hoặc \"Blue-Green Deployment\" để kiểm tra và xác thực các thay đổi **schema** trước khi triển khai chúng cho toàn bộ hệ thống.\n2. Sử dụng các công cụ kiểm tra và xác thực tự động như \"Swagger\" hoặc \"OpenAPI\" để đảm bảo rằng các thay đổi **schema** không ảnh hưởng đến các yêu cầu API hiện có.\n3. Thực hiện thử nghiệm và kiểm tra thủ công để đảm bảo rằng các thay đổi **schema** không gây ra bất kỳ lỗi hoặc vấn đề nào.\n\nBằng cách thực hiện các biện pháp này, bạn có thể xác thực các thay đổi **schema** một cách hiệu quả và đảm bảo rằng hệ thống của bạn luôn ổn định và tương thích ngược."
    },
    {
      "question_id": "EQ2008-VN",
      "question": "Giải thích cách **mocking** có thể được sử dụng để kiểm tra một API thanh toán mà không gọi dịch vụ ngân hàng thực.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "**Mocking** là một kỹ thuật giúp tạo ra một phiên bản giả của một dịch vụ hoặc API, cho phép chúng ta kiểm tra và thử nghiệm một ứng dụng mà không cần phải gọi dịch vụ thực. Trong trường hợp kiểm tra một API thanh toán, mocking có thể được sử dụng để tạo ra một phiên bản giả của dịch vụ ngân hàng, cho phép chúng ta thử nghiệm và kiểm tra ứng dụng mà không cần phải thực hiện giao dịch thực tế. Điều này giúp giảm thiểu rủi ro và tăng hiệu suất trong quá trình kiểm tra."
    },
    {
      "question_id": "EQ2010-VN",
      "question": "Thiết kế một **boundary test** và một **invalid test** cho trường API `age` (phạm vi 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "**Boundary Test:**\n\n- Thử nghiệm giá trị biên trên: `age = 65` (giả sử người dùng đã đủ 65 tuổi)\n- Thử nghiệm giá trị biên dưới: `age = 18` (giả sử người dùng đã đủ 18 tuổi)\n\n**Invalid Test:**\n\n- Thử nghiệm giá trị nhỏ hơn 18: `age = 17` (giả sử người dùng chưa đủ 18 tuổi)\n- Thử nghiệm giá trị lớn hơn 65: `age = 66` (giả sử người dùng đã vượt quá tuổi tối đa)\n\nNhững giá trị này sẽ giúp kiểm tra tính đúng đắn của API `age` trong trường hợp người dùng cung cấp các giá trị biên hoặc không hợp lệ."
    },
    {
      "question_id": "EQ2012-VN",
      "question": "Giải thích cách bạn mô phỏng lỗi **network timeout** trong **API testing**.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "Để mô phỏng lỗi **network timeout** trong **API testing**, bạn có thể sử dụng các công cụ như **Postman** hoặc **SoapUI** với tính năng **delay** hoặc **pause**. Bạn có thể thêm một bước **delay** vào quá trình yêu cầu API để mô phỏng tình huống mạng chậm hoặc mất kết nối. Điều này sẽ giúp bạn kiểm tra xem API có thể xử lý lỗi **timeout** một cách đúng đắn hay không."
    },
    {
      "question_id": "EQ2014-VN",
      "question": "Đưa ra một ví dụ về một **precondition** API và một **step** theo sau nó.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "Một ví dụ về một **precondition** API và một **step** theo sau nó là:\n\nAPI: `GET /users/:id`\n**Precondition**: Người dùng phải được xác thực (login) trước khi thực hiện yêu cầu này.\n**Step**: Sau khi xác thực thành công, người dùng có thể thực hiện yêu cầu `GET /users/:id` để lấy thông tin của một người dùng cụ thể."
    },
    {
      "question_id": "EQ2016-VN",
      "question": "Viết một **test case** để xác thực rằng **API rate limiting** được thực thi đúng.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "**Test Case: Xác thực API rate limiting**\n\n**Tên test:** \"API rate limiting\"\n\n**Mô tả:** Xác thực rằng API rate limiting được thực thi đúng khi số lượng yêu cầu vượt quá giới hạn cho phép.\n\n**Thử nghiệm:**\n\n1. Gửi một số lượng yêu cầu đến API trong thời gian ngắn.\n2. Kiểm tra số lượng yêu cầu được chấp nhận và số lượng yêu cầu bị từ chối do vượt quá giới hạn.\n3. So sánh số lượng yêu cầu được chấp nhận với số lượng yêu cầu cho phép và xác thực rằng số lượng yêu cầu bị từ chối đúng.\n\n**Kết quả mong muốn:**\n\n* Số lượng yêu cầu được chấp nhận không vượt quá giới hạn cho phép.\n* Số lượng yêu cầu bị từ chối đúng khi số lượng yêu cầu vượt quá giới hạn cho phép."
    },
    {
      "question_id": "EQ2018-VN",
      "question": "Giải thích một lợi thế của việc sử dụng **service virtualization** trong **API testing**.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "Lợi thế của việc sử dụng **service virtualization** trong **API testing** là khả năng tạo ra các bản sao ảo của các dịch vụ hoặc hệ thống thực tế, cho phép các nhà phát triển và kỹ sư kiểm thử thực hiện các cuộc kiểm thử hiệu quả mà không cần truy cập vào các dịch vụ hoặc hệ thống thực tế. Điều này giúp tiết kiệm thời gian và chi phí, đồng thời tăng cường hiệu quả của quá trình kiểm thử."
    },
    {
      "question_id": "EQ2020-VN",
      "question": "Mô tả cách thiết kế một **test case tích cực** và một **boundary test case** cho một API đăng nhập yêu cầu tên người dùng và mật khẩu.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "Để thiết kế một **test case tích cực** và một **boundary test case** cho API đăng nhập yêu cầu tên người dùng và mật khẩu, chúng ta thực hiện như sau:\n\n- **Test case tích cực**: Thiết kế một trường hợp thử nghiệm với tên người dùng và mật khẩu hợp lệ, chẳng hạn như \"test_user\" và \"password123\", để kiểm tra xem API có xử lý đăng nhập thành công hay không.\n- **Boundary test case**: Thiết kế một trường hợp thử nghiệm với tên người dùng và mật khẩu ở giới hạn biên, chẳng hạn như tên người dùng trống và mật khẩu là \"123456\", hoặc tên người dùng dài quá giới hạn và mật khẩu hợp lệ, để kiểm tra xem API có xử lý lỗi hay không."
    },
    {
      "question_id": "EQ2022-VN",
      "question": "Viết một **test step** để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "Để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác, ta có thể sử dụng **test step** sau:\n\n**Test Step:**\n\n1. Gửi yêu cầu POST đến API với nội dung không phù hợp (ví dụ: một JSON không hợp lệ).\n2. Xác định rằng API trả về trạng thái HTTP **415** và nội dung trả về là \"Unsupported Media Type\".\n3. Kiểm tra rằng lỗi không được ẩn dưới dạng trạng thái HTTP khác hoặc nội dung trả về khác.\n\n**Test Case:**\n\n| ID | Mô tả | Trạng thái |\n| --- | --- | --- |\n| TC_001 | Gửi yêu cầu POST với nội dung không phù hợp | 415 |\n\n**Expected Result:**\n\nAPI trả về trạng thái HTTP **415** và nội dung trả về là \"Unsupported Media Type\"."
    },
    {
      "question_id": "EQ2024-VN",
      "question": "Mô tả một cách để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "Để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm, bạn có thể thực hiện các bước sau:\n\n- **Lưu lượng truy cập**: Sử dụng công cụ như Apache JMeter hoặc Locust để tạo ra lưu lượng truy cập giả lập cho API, mô phỏng các trường hợp sử dụng thực tế.\n- **Thời gian phản hồi**: Sử dụng công cụ như Prometheus hoặc New Relic để theo dõi thời gian phản hồi của API và xác định xem có bất kỳ sự chậm chạp nào trong truy vấn cơ sở dữ liệu hay không.\n- **Xác định nguyên nhân**: Sử dụng công cụ như ELK Stack hoặc Splunk để phân tích dữ liệu và xác định nguyên nhân của sự chậm chạp, có thể là do lỗi trong mã, quá tải cơ sở dữ liệu hoặc các vấn đề khác."
    },
    {
      "question_id": "EQ2026-VN",
      "question": "Giải thích cách bạn sẽ kiểm tra **API idempotency** cho một kịch bản **retry**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Để kiểm tra **API idempotency** cho một kịch bản **retry**, bạn sẽ cần thực hiện các bước sau:\n\n1. **Thực hiện yêu cầu**: Gửi yêu cầu đến API và lưu trữ ID của yêu cầu.\n2. **Xử lý lỗi**: Nếu yêu cầu bị lỗi, hãy thử lại yêu cầu và so sánh ID của yêu cầu mới với ID đã lưu trữ.\n3. **Kiểm tra idempotency**: Nếu ID của yêu cầu mới trùng với ID đã lưu trữ, điều đó có nghĩa là yêu cầu đã được xử lý trước đó và API đã áp dụng **idempotency**."
    },
    {
      "question_id": "EQ2028-VN",
      "question": "Đưa ra một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "Dưới đây là một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB:\n\n*   **Boundary test**: Chọn một file có kích thước 5 MB và gửi đến API để kiểm tra xem API có chấp nhận file này hay không.\n*   **Invalid test**: Chọn một file có kích thước lớn hơn 5 MB (ví dụ 10 MB) và gửi đến API để kiểm tra xem API có trả về lỗi phù hợp hay không."
    },
    {
      "question_id": "EQ2030-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "Dưới đây là một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu:\n\n**Test Case:** Xử lý lỗi khi gọi API với trường email bị thiếu\n\n**Mô tả:** Gọi API với dữ liệu không có trường email và xác thực lỗi trả về phù hợp.\n\n**Thủ tục:**\n\n1. Gọi API với dữ liệu không có trường email.\n2. Xác thực lỗi trả về có mã lỗi và thông điệp phù hợp (ví dụ: \"Email không thể bỏ qua\").\n3. Xác thực lỗi không ảnh hưởng đến trạng thái hệ thống.\n\n**Tham số:**\n\n* `email`: Không có giá trị (bị thiếu)\n\n**Kết quả mong đợi:**\n\n* Lỗi trả về có mã lỗi và thông điệp phù hợp.\n* Trạng thái hệ thống không bị ảnh hưởng."
    },
    {
      "question_id": "EQ2032-VN",
      "question": "Bạn sẽ thiết kế một **test** để xác thực logic **retry** như thế nào khi một API thỉnh thoảng trả về **503**?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "Để thiết kế một **test** xác thực logic **retry**, chúng ta có thể thực hiện theo các bước sau:\n\n1. Tạo một **mock API** giả lập tình huống **503** xảy ra.\n2. Gọi API này từ ứng dụng thực tế và theo dõi hành động **retry** của ứng dụng.\n3. Kiểm tra xem ứng dụng đã **retry** đúng số lần, đã xử lý tình huống **503** một cách thích hợp hay chưa.\n\nVí dụ, sử dụng ngôn ngữ Python và thư viện **unittest**, bạn có thể thiết kế một **test** như sau:\n\n```python\nimport unittest\nfrom unittest.mock import patch, MagicMock\nfrom your_module import your_function\n\nclass TestRetryLogic(unittest.TestCase):\n    @patch('your_module.your_function')\n    def test_retry_logic(self, mock_api):\n        # Tạo một mock API giả lập tình huống **503** xảy ra\n        mock_api.return_value = MagicMock(status_code=503)\n\n        # Gọi API này từ ứng dụng thực tế và theo dõi hành động **retry** của ứng dụng\n        your_function(mock_api)\n\n        # Kiểm tra xem ứng dụng đã **retry** đúng số lần\n        self.assertEqual(mock_api.call_count, 3)  # 3 lần retry\n```\n\nLưu ý: Mã nguồn trên chỉ là một ví dụ và bạn cần phải điều chỉnh nó để phù hợp với môi trường và yêu cầu của bạn."
    },
    {
      "question_id": "EQ2034-VN",
      "question": "Viết một **test case** xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "Để xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**, ta có thể tạo một **test case** như sau:\n\n**Test Case:** Tương quan log bằng trace ID header\n\n**Mô tả:**\n\n1. Gửi yêu cầu đến ứng dụng với header \"Trace-ID\" chứa một giá trị duy nhất.\n2. Ứng dụng lưu trữ giá trị này trong log của nó.\n3. Khi yêu cầu được xử lý, ứng dụng thêm giá trị \"Trace-ID\" vào log của nó.\n4. Khi yêu cầu được hoàn thành, ứng dụng trả về phản hồi với header \"Trace-ID\" chứa giá trị đã lưu trữ.\n\n**Thử nghiệm:**\n\n- Gửi yêu cầu đến ứng dụng với header \"Trace-ID\" chứa một giá trị duy nhất.\n- Kiểm tra log của ứng dụng để đảm bảo giá trị \"Trace-ID\" được lưu trữ và thêm vào log.\n- Kiểm tra phản hồi của ứng dụng để đảm bảo header \"Trace-ID\" chứa giá trị đã lưu trữ."
    },
    {
      "question_id": "EQ2036-VN",
      "question": "Thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting** khi có nhiều máy khách tham gia.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "Để thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting**, chúng ta có thể thực hiện theo các bước sau:\n\n1. Chuẩn bị: Tạo một ứng dụng máy khách (client) và một dịch vụ API.\n2. Thiết kế: Sử dụng công cụ kiểm tra (testing tool) như Postman hoặccurl để tạo nhiều yêu cầu (requests) đến dịch vụ API trong một khoảng thời gian ngắn.\n3. Xác thực: Xác thực rằng dịch vụ API đã giới hạn số lượng yêu cầu trong khoảng thời gian đó, và các yêu cầu sau khi vượt quá giới hạn sẽ bị chặn hoặc trả về trạng thái lỗi (error).\n\nVí dụ, nếu dịch vụ API cho phép 10 yêu cầu mỗi phút, chúng ta có thể tạo 11 yêu cầu trong 1 phút và xác thực rằng yêu cầu thứ 11 bị chặn hoặc trả về trạng thái lỗi."
    },
    {
      "question_id": "EQ2038-VN",
      "question": "Mô tả một **test case tích cực** và một **test case âm tính** cho một endpoint API gửi mã **SMS**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "Dưới đây là mô tả của hai **test case**:\n\n- **Test case tích cực**: \"Gửi mã SMS thành công khi nhập số điện thoại hợp lệ và mã xác minh hợp lệ\": Trong trường hợp này, người dùng nhập số điện thoại hợp lệ và mã xác minh hợp lệ, và endpoint API gửi mã SMS thành công.\n- **Test case âm tính**: \"Gửi mã SMS thất bại khi nhập số điện thoại không hợp lệ hoặc mã xác minh không hợp lệ\": Trong trường hợp này, người dùng nhập số điện thoại không hợp lệ hoặc mã xác minh không hợp lệ, và endpoint API gửi mã SMS thất bại."
    },
    {
      "question_id": "EQ2040-VN",
      "question": "Giải thích một lợi thế của việc **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Khi **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại, lợi thế chính là giảm thời gian và chi phí liên quan đến việc truy cập vào các API thực tế. Điều này cho phép bạn tập trung vào việc kiểm tra logic và hành vi của ứng dụng của mình, độc lập với các vấn đề về kết nối mạng hoặc lỗi từ bên ngoài."
    },
    {
      "question_id": "EQ2042-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi khi API trả về **JSON** bị định dạng sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "**Test Case:** Xử lý lỗi khi API trả về JSON bị định dạng sai\n\n**Mô tả:**\n\n1. **Precondition:** API đã được triển khai và đang hoạt động.\n2. **Test Case:**\n * Gửi yêu cầu đến API với JSON bị định dạng sai (ví dụ: thiếu hoặc thừa dấu ngoặc kép, dấu phẩy sai vị trí, v.v.).\n * Kiểm tra phản hồi từ API:\n + Nếu API xử lý lỗi đúng cách, phản hồi sẽ chứa thông tin lỗi và mã trạng thái 400 (Bad Request).\n + Nếu API không xử lý lỗi đúng cách, phản hồi sẽ chứa thông tin lỗi và mã trạng thái khác (ví dụ: 500, Internal Server Error).\n3. **Expected Result:** API xử lý lỗi đúng cách và phản hồi chứa thông tin lỗi và mã trạng thái 400 (Bad Request).\n\n**Test Data:**\n\n* JSON bị định dạng sai (ví dụ: `{\"name\":\"John\",\"age\":30,\"city\":\"New York\"};` thay vì `{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}`)\n* Yêu cầu gửi đến API (ví dụ: GET, POST, PUT, DELETE)\n\n**Test Case:** Xử lý lỗi khi API trả về JSON bị định dạng sai (tiếp theo)\n\n4. **Test Case:**\n * Gửi yêu cầu đến API với JSON bị định dạng sai (ví dụ: thiếu hoặc thừa dấu ngoặc kép, dấu phẩy sai vị trí, v.v.).\n * Kiểm tra phản hồi từ API:\n + Nếu API xử lý lỗi đúng cách, phản hồi sẽ chứa thông tin lỗi và mã trạng thái 400 (Bad Request).\n + Nếu API không xử lý lỗi đúng cách, phản hồi sẽ chứa thông tin lỗi và mã trạng thái khác (ví dụ: 500, Internal Server Error).\n5. **Expected Result:** API xử lý lỗi đúng cách và phản hồi chứa thông tin lỗi và mã trạng thái 400 (Bad Request)."
    },
    {
      "question_id": "EQ2044-VN",
      "question": "Thiết kế một **test step** để xác nhận các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "Để thiết kế một **test step** xác nhận các **rate limiting header**, bạn có thể thực hiện theo các bước sau:\n\n1. Gửi yêu cầu đến máy chủ (ví dụ: sử dụng tool như Postman hoặc curl).\n2. Kiểm tra phản hồi của máy chủ để xác định xem các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt hay không.\n3. Sử dụng các chỉ số như giá trị của **X-RateLimit-Remaining** để xác định xem máy chủ đã áp dụng giới hạn tốc độ truy cập hay chưa."
    },
    {
      "question_id": "EQ2046-VN",
      "question": "Mô tả một lợi thế của việc tách dữ liệu **test** khỏi logic **test** trong **API testing**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Khi tách dữ liệu **test** khỏi logic **test** trong **API testing**, chúng ta có thể dễ dàng thay đổi hoặc cập nhật dữ liệu mà không ảnh hưởng đến logic kiểm tra, giúp quá trình thử nghiệm trở nên linh hoạt và hiệu quả hơn. Điều này cho phép các kỹ sư thử nghiệm tập trung vào việc kiểm tra logic của API một cách độc lập với dữ liệu."
    },
    {
      "question_id": "EQ2048-VN",
      "question": "Viết một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "Dưới đây là một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn:\n\n**Test case**: \"Suy thoái khi cache API không có sẵn\"\n\n* **Mô tả**: Kiểm tra xem ứng dụng có thể hoạt động bình thường khi **cache** API không có sẵn.\n* **Hành động**:\n + Gọi một yêu cầu đến ứng dụng.\n + Đảm bảo **cache** API không có sẵn.\n + Kiểm tra xem ứng dụng có thể trả về một phản hồi hợp lệ.\n* **Kiểm tra**:\n + Phản hồi của ứng dụng phải không chứa lỗi về **cache**.\n + Ứng dụng phải có thể tiếp tục hoạt động bình thường."
    },
    {
      "question_id": "EQ2050-VN",
      "question": "Giải thích một cách để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu, bạn có thể sử dụng kỹ thuật **logging** có thể được mã hóa như **logging** với SSL/TLS hoặc sử dụng **logging** trung gian như **logging** với bộ nhớ đệm (cache) hoặc sử dụng **logging** với sự đồng ý (consent) của người dùng trước khi ghi nhận các thông tin nhạy cảm."
    },
    {
      "question_id": "EQ2052-VN",
      "question": "Cung cấp một **test case âm tính** và một **boundary test case** cho một trường tiền tệ phải khớp với mã **ISO 4217**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "**Test case âm tính:** Kiểm tra trường tiền tệ với giá trị rỗng (\"\") để đảm bảo ứng dụng không bị lỗi khi nhận được dữ liệu trống.\n\n**Boundary test case:** Kiểm tra trường tiền tệ với giá trị là mã ISO 4217 cực đại (\"ZZZZ\") hoặc cực tiểu (\"A\") để đảm bảo ứng dụng xử lý trường hợp ngoài phạm vi hợp lệ một cách chính xác."
    },
    {
      "question_id": "EQ2054-VN",
      "question": "Viết một **test case** để xác thực hành vi API dưới tình trạng mất gói mạng.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "Để xác thực hành vi API dưới tình trạng mất gói mạng, chúng ta có thể viết một **test case** như sau:\n\n**Tên test case:** \"Thử nghiệm mất gói mạng\"\n\n**Mô tả:** Kiểm tra xem API vẫn hoạt động bình thường khi mất gói mạng.\n\n**Thử nghiệm:**\n\n1. Mất gói mạng bằng cách tắt kết nối internet hoặc sử dụng công cụ giả lập mạng.\n2. Gửi yêu cầu đến API và kiểm tra xem API có trả về lỗi kết nối hay không.\n3. Khởi động lại kết nối internet và kiểm tra xem API hoạt động bình thường.\n\n**Kết quả mong đợi:** API sẽ trả về lỗi kết nối khi mất gói mạng và hoạt động bình thường khi kết nối được khôi phục."
    },
    {
      "question_id": "EQ2056-VN",
      "question": "Mô tả một phương pháp để xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Phương pháp xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test** là sử dụng **script** tự động kiểm tra dữ liệu **test** trước và sau khi thực hiện **API test**. Script sẽ so sánh dữ liệu **test** trước và sau để xác minh liệu dữ liệu đã được dọn dẹp đúng cách hay chưa. Nếu dữ liệu không được dọn dẹp đúng cách, script sẽ báo lỗi để người dùng có thể khắc phục."
    },
    {
      "question_id": "EQ2058-VN",
      "question": "Viết một **test case** để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "Để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần, chúng ta có thể viết một **test case** như sau:\n\n**Test Case: Rollback trong giao dịch nhiều bước**\n\n**Mô tả:** Xác minh rằng khi một giao dịch nhiều bước thất bại một phần, hệ thống sẽ **rollback** đúng cách và giữ nguyên trạng thái ban đầu.\n\n**Thử nghiệm:**\n\n1. Tạo một giao dịch nhiều bước với các bước A, B và C.\n2. Thử nghiệm bước A và B thành công, bước C thất bại.\n3. Xác minh rằng hệ thống đã **rollback** đúng cách và giữ nguyên trạng thái ban đầu.\n4. Lặp lại bước 2 và 3 nhiều lần để đảm bảo tính ổn định của hệ thống.\n\n**Kết quả mong muốn:** Hệ thống sẽ **rollback** đúng cách và giữ nguyên trạng thái ban đầu khi giao dịch nhiều bước thất bại một phần."
    },
    {
      "question_id": "EQ2060-VN",
      "question": "Giải thích một cách tiếp cận để xác thực các thông báo lỗi tuân theo một **JSON schema** nhất quán trên tất cả các **endpoint**.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "Một cách tiếp cận để xác thực các thông báo lỗi tuân theo một JSON schema nhất quán trên tất cả các endpoint là sử dụng một công cụ như Swagger hoặc OpenAPI để định nghĩa và kiểm tra JSON schema cho từng endpoint. Sau đó, sử dụng một thư viện hoặc framework như JSON Schema Validator để xác thực các thông báo lỗi trước khi gửi đến khách hàng. Điều này đảm bảo rằng các thông báo lỗi luôn tuân theo một JSON schema nhất quán trên tất cả các endpoint."
    },
    {
      "question_id": "EQ3002-VN",
      "question": "Viết một test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "Dưới đây là một ví dụ về test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới:\n\n**Test Case:** Xác thực đăng nhập, làm mới token và truy cập API được bảo vệ\n\n**Bước 1:** Đăng nhập với tài khoản hợp lệ và nhận token\n\n*   Đầu vào: Tài khoản hợp lệ và mật khẩu hợp lệ\n*   Đầu ra: Token hợp lệ\n\n**Bước 2:** Làm mới token đã được cấp\n\n*   Đầu vào: Token hợp lệ và mật khẩu hợp lệ\n*   Đầu ra: Token mới hợp lệ\n\n**Bước 3:** Truy cập API được bảo vệ bằng token mới\n\n*   Đầu vào: Token mới hợp lệ và yêu cầu API\n*   Đầu ra: Trả về dữ liệu từ API\n\n**Kết quả mong muốn:** Xác thực thành công và truy cập vào API được bảo vệ bằng token đã được làm mới."
    },
    {
      "question_id": "EQ3004-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "Để thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token, bạn có thể thực hiện các bước sau:\n\n1. Tạo một ứng dụng khách giả (client) và một dịch vụ chứng thực giả (authorization server) để mô phỏng quá trình đăng nhập.\n2. Khi ứng dụng khách giả gửi yêu cầu đăng nhập đến dịch vụ chứng thực giả, hãy giả lập một nỗ lực đăng nhập không thành công bằng cách trả về mã lỗi hoặc trạng thái không thành công.\n3. Sau khi nỗ lực đăng nhập không thành công, hãy kiểm tra xem dịch vụ chứng thực giả có tạo refresh token hay không. Nếu không, thì bài kiểm tra đã thành công.\n\nVí dụ trong Python:\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n# Mô phỏng ứng dụng khách giả\n@app.post(\"/login\")\nasync def login(username: str, password: str):\n    # Giả lập nỗ lực đăng nhập không thành công\n    if username!= \"tài khoản\" or password!= \"mật khẩu\":\n        raise HTTPException(status_code=401, detail=\"Mật khẩu không đúng\")\n    \n    # Giả lập tạo refresh token\n    refresh_token = \"refresh_token_123\"\n    return {\"refresh_token\": refresh_token}\n\n# Mô phỏng dịch vụ chứng thực giả\n@app.post(\"/refresh-token\")\nasync def refresh_token(refresh_token: str):\n    # Kiểm tra xem refresh token có tồn tại hay không\n    if refresh_token!= \"refresh_token_123\":\n        raise HTTPException(status_code=401, detail=\"Refresh token không tồn tại\")\n    \n    # Tạo mới access token\n    access_token = \"access_token_123\"\n    return {\"access_token\": access_token}\n```\n\nTrong ví dụ trên, khi ứng dụng khách giả gửi yêu cầu đăng nhập đến dịch vụ chứng thực giả, dịch vụ chứng thực giả sẽ trả về mã lỗi 401 nếu nỗ lực đăng nhập không thành công. Sau đó, dịch vụ chứng thực giả sẽ không tạo refresh token, vì vậy ứng dụng khách giả sẽ không thể tạo refresh token."
    },
    {
      "question_id": "EQ3006-VN",
      "question": "Giải thích cách bạn sẽ xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Để xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API, tôi sẽ sử dụng các phương pháp sau:\n\n1. **Tạo một kho dữ liệu mã nghiệp vụ**: Tôi sẽ tạo một kho dữ liệu chứa tất cả các mã nghiệp vụ (ví dụ: ORDER_001, ORDER_002,...) và các mã trạng thái HTTP (ví dụ: 200, 400, 500,...).\n\n2. **Ánh xạ mã nghiệp vụ tới mã trạng thái HTTP**: Tôi sẽ ánh xạ các mã nghiệp vụ tới các mã trạng thái HTTP trong kho dữ liệu, đảm bảo rằng mỗi mã nghiệp vụ chỉ được ánh xạ tới một mã trạng thái HTTP.\n\n3. **Sử dụng kiểm tra mã nghiệp vụ**: Trước khi gửi phản hồi API, tôi sẽ kiểm tra mã nghiệp vụ và ánh xạ nó tới mã trạng thái HTTP tương ứng trong kho dữ liệu để đảm bảo rằng phản hồi API được gửi ra đúng mã trạng thái HTTP.\n\nBằng cách sử dụng các phương pháp này, tôi có thể xác thực việc ánh xạ chính xác các mã nghiệp vụ tới các mã trạng thái HTTP trong các phản hồi API."
    },
    {
      "question_id": "EQ3008-VN",
      "question": "Viết một test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "Dưới đây là một ví dụ về test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền:\n\n**Test Case:** Chuỗi tạo đơn hàng, thanh toán và hoàn tiền\n\n**Mô tả:** Kiểm tra tính toàn diện của hệ thống khi tạo đơn hàng, thanh toán và hoàn tiền.\n\n**Trường hợp sử dụng:**\n\n1. Gọi API tạo đơn hàng với thông tin đơn hàng hợp lệ.\n2. Gọi API xác nhận đơn hàng.\n3. Gọi API thanh toán với thông tin thanh toán hợp lệ.\n4. Gọi API hoàn tiền với thông tin hoàn tiền hợp lệ.\n5. Kiểm tra trạng thái đơn hàng, trạng thái thanh toán và trạng thái hoàn tiền.\n\n**Thử nghiệm:**\n\n| Scenario | Triggers | Expected Result |\n| --- | --- | --- |\n| Tạo đơn hàng thành công | Gọi API tạo đơn hàng | Đơn hàng được tạo thành công |\n| Xác nhận đơn hàng thành công | Gọi API xác nhận đơn hàng | Đơn hàng được xác nhận thành công |\n| Thanh toán thành công | Gọi API thanh toán | Thanh toán được thực hiện thành công |\n| Hoàn tiền thành công | Gọi API hoàn tiền | Hoàn tiền được thực hiện thành công |\n| Đơn hàng bị hủy | Gọi API hủy đơn hàng | Đơn hàng bị hủy thành công |\n\n**Thử nghiệm ngoại lệ:**\n\n| Scenario | Triggers | Expected Result |\n| --- | --- | --- |\n| Thông tin đơn hàng không hợp lệ | Gọi API tạo đơn hàng với thông tin không hợp lệ | Lỗi tạo đơn hàng |\n| Thông tin thanh toán không hợp lệ | Gọi API thanh toán với thông tin không hợp lệ | Lỗi thanh toán |\n| Thông tin hoàn tiền không hợp lệ | Gọi API hoàn tiền với thông tin không hợp lệ | Lỗi hoàn tiền |\n| Đơn hàng đã được hủy | Gọi API xác nhận đơn hàng | Lỗi xác nhận đơn hàng |\n| Thanh toán đã được thực hiện | Gọi API thanh toán | Lỗi thanh toán |\n| Hoàn tiền đã được thực hiện | Gọi API hoàn tiền | Lỗi hoàn tiền |"
    },
    {
      "question_id": "EQ3010-VN",
      "question": "Giải thích một test case xác thực việc làm mới token hoạt động trên nhiều microservice.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case xác thực việc làm mới token hoạt động trên nhiều microservice có thể bao gồm các bước sau:\n\n1. Gọi API tạo token mới trên microservice xác thực.\n2. Gọi API yêu cầu dữ liệu từ microservice dữ liệu người dùng.\n3. Gọi API yêu cầu dữ liệu từ microservice dữ liệu quyền hạn.\n4. Kiểm tra xem token mới có thể được sử dụng để yêu cầu dữ liệu từ các microservice khác hay không.\n\nBằng cách thực hiện các bước này, chúng ta có thể xác thực việc làm mới token hoạt động trên nhiều microservice và đảm bảo rằng token mới có thể được sử dụng để truy cập dữ liệu từ các microservice khác."
    },
    {
      "question_id": "EQ3012-VN",
      "question": "Viết một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "Dưới đây là một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400:\n\n**Kiểm tra xác thực ánh xạ mã lỗi xác thực tới các phản hồi HTTP 400**\n\n**Mã lỗi xác thực** | **Phản hồi HTTP 400**\n---------------------|----------------------\nInvalidUsername      | 400 Bad Request: Tên đăng nhập không hợp lệ\nInvalidPassword      | 400 Bad Request: Mật khẩu không hợp lệ\nInvalidEmail          | 400 Bad Request: Địa chỉ email không hợp lệ\nInvalidPhoneNumber    | 400 Bad Request: Số điện thoại không hợp lệ\n\n**Lưu ý:** Các mã lỗi xác thực và phản hồi HTTP 400 có thể được điều chỉnh tùy theo yêu cầu cụ thể của dự án."
    },
    {
      "question_id": "EQ3014-VN",
      "question": "Thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "Để thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới, chúng ta có thể thực hiện như sau:\n\n**Tên test case:** \"Refresh token đã hết hạn không thể cấp access token mới\"\n\n**Giả sử:** Refresh token đã hết hạn và không được cấp lại\n\n**Thủ tục:**\n\n1. Gửi yêu cầu refresh token đã hết hạn đến server\n2. Xác thực rằng server trả về trạng thái lỗi hoặc thông báo refresh token đã hết hạn\n3. Xác thực rằng access token mới không được cấp\n\n**Kết quả mong muốn:** Refresh token đã hết hạn không thể cấp access token mới."
    },
    {
      "question_id": "EQ3016-VN",
      "question": "Giải thích một bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất là một quá trình kiểm tra nghiêm ngặt bao gồm các bước sau:\n\n- Bước 1: Người dùng thực hiện việc đăng nhập vào hệ thống.\n- Bước 2: Sau khi đăng nhập thành công, người dùng thực hiện việc đăng xuất khỏi hệ thống.\n- Bước 3: Hệ thống xác thực việc hủy bỏ session của người dùng sau khi đăng xuất.\n\nBài kiểm tra này nhằm mục đích đảm bảo rằng hệ thống đã thực sự hủy bỏ session của người dùng sau khi đăng xuất, ngăn chặn khả năng người dùng tiếp tục sử dụng session đã đăng xuất."
    },
    {
      "question_id": "EQ3018-VN",
      "question": "Viết một test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "Dưới đây là một ví dụ về test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập:\n\n**Test Case:** Đăng ký, xác minh email và đăng nhập thành công\n\n**Mô tả:**\n\n1. **Bước 1:** Đăng ký tài khoản mới với thông tin hợp lệ (endpoint: POST /api/register)\n * Dữ liệu yêu cầu: { \"email\": \"test@example.com\", \"password\": \"password123\", \"name\": \"Test User\" }\n * Trả về: Mã xác minh email được gửi đến địa chỉ email đã đăng ký\n2. **Bước 2:** Xác minh email bằng liên kết được gửi đến (endpoint: GET /api/verify-email)\n * Dữ liệu yêu cầu: Mã xác minh email được gửi đến\n * Trả về: Thông báo xác minh email thành công\n3. **Bước 3:** Đăng nhập với tài khoản đã xác minh (endpoint: POST /api/login)\n * Dữ liệu yêu cầu: { \"email\": \"test@example.com\", \"password\": \"password123\" }\n * Trả về: Token truy cập thành công\n\n**Kết quả mong đợi:** Tất cả các bước đều thành công và tài khoản được xác minh thành công."
    },
    {
      "question_id": "EQ3020-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu có thể bao gồm các câu hỏi sau:\n\n1. Câu hỏi dễ: \"Bạn cần thực hiện bước nào để bắt đầu quy trình đặt lại mật khẩu?\"\n (Trả lời: Nhập địa chỉ email hoặc số điện thoại)\n\n2. Câu hỏi trung bình: \"Quy trình đặt lại mật khẩu thường yêu cầu người dùng nhập thông tin gì để xác minh danh tính?\"\n (Trả lời: Mã xác thực được gửi đến email hoặc số điện thoại)\n\n3. Câu hỏi khó: \"Tại sao quy trình đặt lại mật khẩu nên yêu cầu người dùng nhập mật khẩu mới và xác minh lại?\"\n (Trả lời: Để đảm bảo mật khẩu mới không trùng với mật khẩu cũ và để tránh khả năng xảy ra lỗi trong quá trình đặt lại mật khẩu)\n\n4. Câu hỏi khó hơn: \"Một số nền tảng xác thực có yêu cầu người dùng phải chờ một khoảng thời gian trước khi đặt lại mật khẩu. Lợi ích của yêu cầu này là gì?\"\n (Trả lời: Để tránh khả năng xảy ra hành vi giả mạo và đảm bảo tính toàn vẹn của thông tin người dùng)"
    },
    {
      "question_id": "EQ3022-VN",
      "question": "Viết một test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "Dưới đây là một ví dụ về các test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ:\n\n**Test Case 1: Tạo người dùng thành công**\n\n* Đặt tên người dùng: \"test_user\"\n* Đặt mật khẩu: \"test_password\"\n* Xác thực: Người dùng mới được tạo thành công.\n\n**Test Case 2: Cập nhật hồ sơ thành công**\n\n* Tạo người dùng trước đó\n* Cập nhật tên người dùng: \"test_user_update\"\n* Xác thực: Hồ sơ người dùng được cập nhật thành công.\n\n**Test Case 3: Truy xuất hồ sơ thành công**\n\n* Tạo người dùng trước đó\n* Truy xuất hồ sơ người dùng\n* Xác thực: Hồ sơ người dùng được truy xuất thành công.\n\n**Test Case 4: Tạo người dùng thất bại (sử dụng tên người dùng đã tồn tại)**\n\n* Đặt tên người dùng: \"test_user\" (đã tồn tại)\n* Đặt mật khẩu: \"test_password\"\n* Xác thực: Tạo người dùng thất bại do tên người dùng đã tồn tại.\n\n**Test Case 5: Cập nhật hồ sơ thất bại (không có quyền truy cập)**\n\n* Tạo người dùng trước đó\n* Cập nhật tên người dùng mà không có quyền truy cập\n* Xác thực: Cập nhật hồ sơ thất bại do không có quyền truy cập.\n\n**Test Case 6: Truy xuất hồ sơ thất bại (không tìm thấy hồ sơ)**\n\n* Tạo người dùng trước đó\n* Xoá hồ sơ người dùng\n* Truy xuất hồ sơ người dùng\n* Xác thực: Truy xuất hồ sơ thất bại do không tìm thấy hồ sơ."
    },
    {
      "question_id": "EQ3024-VN",
      "question": "Giải thích một bài kiểm tra để xác thực refresh token không thể được sử dụng sau khi đăng xuất.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra này nhằm xác thực refresh token không thể được sử dụng sau khi đăng xuất bởi vì:\n\nKhi người dùng đăng xuất, refresh token cũng được xóa cùng với session của họ. Nếu refresh token vẫn còn hoạt động sau khi đăng xuất, điều đó có nghĩa là kẻ tấn công có thể sử dụng token này để lấy được access token và thực hiện các hành động trên tài khoản của người dùng đã đăng xuất. Vì vậy, việc xác thực refresh token không thể được sử dụng sau khi đăng xuất là một cách để đảm bảo an toàn cho người dùng."
    },
    {
      "question_id": "EQ3026-VN",
      "question": "Viết một test case xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "Để xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP, chúng ta có thể viết một test case như sau:\n\n```python\nimport unittest\nfrom flask import Flask, jsonify\n\nclass TestAuthExpired(unittest.TestCase):\n    def setUp(self):\n        self.app = Flask(__name__)\n        self.app.config['ERROR_MAPPING'] = {\n            'AUTH_EXPIRED': 401\n        }\n\n    def test_auth_expired(self):\n        # Tạo một yêu cầu giả với mã lỗi AUTH_EXPIRED\n        with self.app.test_request_context('/'):\n            self.assertEqual(self.app.config['ERROR_MAPPING']['AUTH_EXPIRED'], 401)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nTrong test case này, chúng ta tạo một ứng dụng Flask và ánh xạ mã lỗi AUTH_EXPIRED tới trạng thái HTTP 401. Sau đó, chúng ta tạo một yêu cầu giả và kiểm tra xem mã lỗi được ánh xạ đúng hay không."
    },
    {
      "question_id": "EQ3028-VN",
      "question": "Giải thích một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ là một quá trình xác minh mà trong đó chuỗi xác thực không được chấp nhận do token không hợp lệ. Trong trường hợp này, hệ thống sẽ yêu cầu người dùng nhập lại email hoặc yêu cầu xác minh lại thông qua một phương thức khác. Điều này nhằm đảm bảo tính bảo mật và ngăn chặn các cuộc tấn công giả mạo."
    },
    {
      "question_id": "EQ3030-VN",
      "question": "Viết một test case cấp độ khó chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "Dưới đây là một ví dụ về test case cấp độ khó cho chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt:\n\n**Test Case:** Chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt\n\n**Mô tả:** Kiểm tra xem chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt hoạt động đúng như mong đợi.\n\n**Bước 1: Nộp đơn vay**\n\n* **Endpoint:** POST /loan-application\n* **Tham số:** Tên, tuổi, thu nhập, nợ vay (ví dụ: {\"name\": \"Nguyễn Văn A\", \"age\": 30, \"income\": 5000, \"debt\": 1000})\n* **Trả về:** ID đơn vay thành công\n\n**Bước 2: Kiểm tra tín dụng**\n\n* **Endpoint:** GET /credit-check\n* **Tham số:** ID đơn vay thành công\n* **Trả về:** Tình trạng tín dụng (ví dụ: \"tín dụng tốt\")\n\n**Bước 3: Phê duyệt vay**\n\n* **Endpoint:** POST /loan-approval\n* **Tham số:** ID đơn vay thành công\n* **Trả về:** Tình trạng phê duyệt (ví dụ: \"phê duyệt thành công\")\n\n**Kịch bản thử nghiệm:**\n\n1. Gửi yêu cầu POST đến endpoint /loan-application với tham số cần thiết.\n2. Lấy ID đơn vay thành công từ trả về của bước 1.\n3. Gửi yêu cầu GET đến endpoint /credit-check với tham số cần thiết.\n4. Lấy tình trạng tín dụng từ trả về của bước 3.\n5. Nếu tình trạng tín dụng tốt, gửi yêu cầu POST đến endpoint /loan-approval với tham số cần thiết.\n6. Lấy tình trạng phê duyệt từ trả về của bước 5.\n\n**Kiểm tra:**\n\n* ID đơn vay thành công được tạo thành công.\n* Tình trạng tín dụng được trả về đúng.\n* Tình trạng phê duyệt được trả về đúng."
    },
    {
      "question_id": "EQ3032-VN",
      "question": "Thiết kế một test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Dưới đây là một thiết kế test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới:\n\n**Test Case 1: Đăng ký thành công**\n\n* Điều kiện tiền đề: Người dùng chưa có tài khoản trên hệ thống.\n* Hoàn cảnh: Người dùng nhập thông tin đăng ký hợp lệ (tên, địa chỉ email, mật khẩu).\n* Thử nghiệm: Người dùng submit form đăng ký.\n* Kết quả mong muốn: Người dùng được tạo thành công tài khoản mới.\n\n**Test Case 2: Đặt lại mật khẩu thành công**\n\n* Điều kiện tiền đề: Người dùng đã có tài khoản trên hệ thống và quên mật khẩu.\n* Hoàn cảnh: Người dùng nhập địa chỉ email và mật khẩu cũ hợp lệ để yêu cầu đặt lại mật khẩu.\n* Thử nghiệm: Người dùng nhận được email chứa liên kết đặt lại mật khẩu và click vào liên kết để đặt lại mật khẩu mới.\n* Kết quả mong muốn: Người dùng được đặt lại mật khẩu thành công.\n\n**Test Case 3: Đăng nhập với thông tin đăng nhập mới**\n\n* Điều kiện tiền đề: Người dùng đã đặt lại mật khẩu thành công trong Test Case 2.\n* Hoàn cảnh: Người dùng nhập thông tin đăng nhập mới (tên, địa chỉ email, mật khẩu mới).\n* Thử nghiệm: Người dùng submit form đăng nhập.\n* Kết quả mong muốn: Người dùng được đăng nhập thành công với thông tin đăng nhập mới."
    },
    {
      "question_id": "EQ3034-VN",
      "question": "Viết một test case chuỗi các endpoint tải lên file, quét virus và tải xuống.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Dưới đây là một ví dụ về các test case cho chuỗi các endpoint tải lên file, quét virus và tải xuống:\n\n**Test Case 1: Tải lên file thành công**\n\n* Mô tả: Tải lên một file hợp lệ (ví dụ: file văn bản) lên server.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để nhận file.\n* Đầu vào: File văn bản (có thể chọn file từ máy tính).\n* Đầu ra: File được tải lên thành công và lưu trữ trên server.\n* Kiểm tra: File được lưu trữ trên server và có thể được tải xuống.\n\n**Test Case 2: Tải lên file không hợp lệ**\n\n* Mô tả: Tải lên một file không hợp lệ (ví dụ: file virus) lên server.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để nhận file.\n* Đầu vào: File virus (có thể chọn file từ máy tính).\n* Đầu ra: Server báo lỗi và không cho phép tải lên file.\n* Kiểm tra: File không được lưu trữ trên server và không có thể được tải xuống.\n\n**Test Case 3: Quét virus thành công**\n\n* Mô tả: Quét một file hợp lệ (ví dụ: file văn bản) trên server để tìm virus.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để quét file.\n* Đầu vào: File văn bản (có thể chọn file từ máy tính).\n* Đầu ra: Server báo rằng file không chứa virus.\n* Kiểm tra: File không chứa virus và có thể được tải xuống.\n\n**Test Case 4: Quét virus không thành công**\n\n* Mô tả: Quét một file không hợp lệ (ví dụ: file virus) trên server để tìm virus.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để quét file.\n* Đầu vào: File virus (có thể chọn file từ máy tính).\n* Đầu ra: Server báo rằng file chứa virus.\n* Kiểm tra: File chứa virus và không thể được tải xuống.\n\n**Test Case 5: Tải xuống file thành công**\n\n* Mô tả: Tải xuống một file hợp lệ (ví dụ: file văn bản) từ server.\n* Điều kiện tiền đề: Server đã được cấu hình và sẵn sàng để tải xuống file.\n* Đầu vào: File văn bản (có thể chọn file từ máy tính).\n* Đầu ra: File được"
    },
    {
      "question_id": "EQ3036-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn việc sử dụng lại refresh token.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Để xác thực việc ngăn chặn việc sử dụng lại refresh token, bạn có thể sử dụng một bài kiểm tra chuỗi (token blacklisting) như sau:\n\n1. Khi một token refresh bị sử dụng lại, bạn gửi yêu cầu đến server để xóa token refresh đó khỏi cơ sở dữ liệu.\n2. Khi một yêu cầu xác thực mới được gửi đến, bạn kiểm tra cơ sở dữ liệu để xem token refresh đã được xóa chưa. Nếu đã được xóa, bạn sẽ không chấp nhận token refresh đó.\n3. Nếu token refresh hợp lệ, bạn sẽ chấp nhận và tạo ra một token mới.\n\nBằng cách thực hiện bài kiểm tra chuỗi này, bạn có thể ngăn chặn việc sử dụng lại token refresh đã bị xóa, đảm bảo tính bảo mật và ngăn chặn việc sử dụng lại token refresh."
    },
    {
      "question_id": "EQ3038-VN",
      "question": "Viết một test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "Dưới đây là một ví dụ về test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán:\n\n**Test Case:** Tìm kiếm sản phẩm, thêm vào giỏ hàng và thanh toán\n\n**Mô tả:** Kiểm tra việc tìm kiếm sản phẩm, thêm vào giỏ hàng và thanh toán sản phẩm thành công.\n\n**Bước 1:** Tìm kiếm sản phẩm\n\n* Gọi API tìm kiếm sản phẩm với từ khóa \"sản phẩm cần tìm kiếm\"\n* Kiểm tra kết quả tìm kiếm có đúng hay không\n\n**Bước 2:** Thêm vào giỏ hàng\n\n* Gọi API thêm sản phẩm vào giỏ hàng\n* Kiểm tra giỏ hàng có chứa sản phẩm vừa thêm hay không\n\n**Bước 3:** Thanh toán\n\n* Gọi API thanh toán sản phẩm\n* Kiểm tra giao dịch thanh toán thành công hay không\n\n**Thử nghiệm:**\n\n* Sử dụng các trường hợp thử nghiệm khác nhau (ví dụ: tìm kiếm sản phẩm không tồn tại, thêm sản phẩm vào giỏ hàng với số lượng không hợp lệ)\n* Kiểm tra các lỗi có thể xảy ra trong quá trình tìm kiếm, thêm vào giỏ hàng và thanh toán."
    },
    {
      "question_id": "EQ3040-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn tấn công chiếm đoạt session API.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Một bài kiểm tra chuỗi (token) là một chuỗi ký tự được tạo ra bởi một hệ thống để xác thực việc ngăn chặn tấn công chiếm đoạt session (tấn công session hijacking). Khi một người dùng đăng nhập vào hệ thống, hệ thống sẽ tạo một chuỗi token và gửi nó đến trình duyệt của người dùng. Mỗi yêu cầu sau đó đến server sẽ bao gồm chuỗi token này để xác thực tính hợp lệ của người dùng và ngăn chặn tấn công chiếm đoạt session."
    },
    {
      "question_id": "EQ3042-VN",
      "question": "Cung cấp chính xác một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "Dưới đây là một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc:\n\n**Test case 1: Cập nhật và đọc**\n\n1. Tạo một tài nguyên mới với một ETag nhất định.\n2. Cập nhật tài nguyên này với một giá trị mới và nhận một ETag mới.\n3. Đọc tài nguyên này và kiểm tra ETag mới.\n4. Cập nhật tài nguyên này với một giá trị mới và nhận một ETag mới.\n5. Đọc tài nguyên này và kiểm tra ETag mới.\n6. Sử dụng If-Match với ETag cũ để cập nhật tài nguyên này.\n7. Kiểm tra nếu cập nhật thành công và ETag mới vẫn còn tồn tại.\n\n**Test case 2: Đồng thời cập nhật**\n\n1. Tạo một tài nguyên mới với một ETag nhất định.\n2. Hai người dùng cập nhật tài nguyên này đồng thời với giá trị mới và nhận ETag mới.\n3. Sử dụng If-Match với ETag cũ để cập nhật tài nguyên này.\n4. Kiểm tra nếu cập nhật thành công và ETag mới vẫn còn tồn tại.\n\n**Test case 3: Cập nhật và đọc với If-Match**\n\n1. Tạo một tài nguyên mới với một ETag nhất định.\n2. Cập nhật tài nguyên này với một giá trị mới và nhận một ETag mới.\n3. Sử dụng If-Match với ETag cũ để cập nhật tài nguyên này.\n4. Đọc tài nguyên này và kiểm tra ETag mới.\n5. Kiểm tra nếu cập nhật thành công và ETag mới vẫn còn tồn tại."
    },
    {
      "question_id": "EQ3044-VN",
      "question": "Thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ: POST /exports -> thăm dò GET /jobs/{id} cho đến khi hoàn thành -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Dưới đây là thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ:\n\n1. **Bước 1: POST /exports**\n * Gửi yêu cầu POST đến endpoint /exports với dữ liệu cần xuất.\n * Kiểm tra trạng thái yêu cầu và chờ đợi cho đến khi trạng thái là \"Đang xuất\" hoặc \"Hoàn thành\".\n\n2. **Bước 2: Lặp lại thăm dò GET /jobs/{id}**\n * Lặp lại việc gửi yêu cầu GET đến endpoint /jobs/{id} với ID công việc được tạo ở bước 1.\n * Kiểm tra trạng thái công việc và chờ đợi cho đến khi trạng thái là \"Hoàn thành\".\n\n3. **Bước 3: GET /exports/{id}**\n * Gửi yêu cầu GET đến endpoint /exports/{id} với ID xuất được tạo ở bước 1.\n * Kiểm tra trạng thái yêu cầu và xác nhận rằng xuất đã hoàn thành thành công.\n\nLưu ý: Các bước trên có thể được thực hiện trong một vòng lặp để đảm bảo rằng xuất đã hoàn thành trước khi kiểm tra trạng thái cuối cùng."
    },
    {
      "question_id": "EQ3046-VN",
      "question": "Cung cấp một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code: /authorize -> /token -> gọi tài nguyên với scope bị thiếu.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "Dưới đây là một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code:\n\n1. **Trường hợp 1: Không cung cấp code authorization**\n * Request đến /authorize mà không cung cấp code authorization.\n * Trả về lỗi 400 Bad Request.\n2. **Trường hợp 2: Không cung cấp client_id**\n * Request đến /authorize mà không cung cấp client_id.\n * Trả về lỗi 400 Bad Request.\n3. **Trường hợp 3: Không cung cấp scope**\n * Request đến /token với scope bị thiếu.\n * Trả về lỗi 400 Bad Request.\n4. **Trường hợp 4: Không cung cấp grant_type**\n * Request đến /token mà không cung cấp grant_type.\n * Trả về lỗi 400 Bad Request.\n\nVí dụ request và response cho trường hợp 3:\n\nRequest:\n```http\nPOST /token HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\n\nclient_id=client1&client_secret=secret1&code=abc123\n```\n\nResponse:\n```http\nHTTP/1.1 400 Bad Request\nContent-Type: application/json\n\n{\n  \"error\": \"invalid_request\",\n  \"error_description\": \"Missing scope parameter\"\n}\n```"
    },
    {
      "question_id": "EQ3048-VN",
      "question": "Viết một bài kiểm tra chuỗi bao gồm việc tạo charge幂等 (idempotent charge creation) với Idempotency-Key trên các endpoint thử lại và hoàn tiền.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "Dưới đây là một bài kiểm tra chuỗi về việc tạo charge idempotent với Idempotency-Key trên các endpoint thử lại và hoàn tiền:\n\n1. **Tạo charge idempotent:**\n   - Gửi yêu cầu tạo charge với Idempotency-Key\n   - Nếu charge đã tồn tại với Idempotency-Key tương ứng, không tạo charge mới\n\n2. **Endpoint thử lại:**\n   - Khi nhận được yêu cầu thử lại, kiểm tra xem charge đã tồn tại với Idempotency-Key tương ứng\n   - Nếu charge đã tồn tại, trả lại kết quả của charge đó\n   - Nếu charge chưa tồn tại, tạo charge mới với Idempotency-Key tương ứng\n\n3. **Endpoint hoàn tiền:**\n   - Khi nhận được yêu cầu hoàn tiền, kiểm tra xem charge đã tồn tại với Idempotency-Key tương ứng\n   - Nếu charge đã tồn tại, hoàn tiền cho charge đó\n   - Nếu charge chưa tồn tại, trả lại lỗi rằng charge chưa tồn tại\n\nLưu ý: Idempotency-Key là một chuỗi ký tự duy nhất cho mỗi charge, giúp xác định xem charge đã tồn tại hay chưa."
    },
    {
      "question_id": "EQ3050-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi cho quy trình xử lý file: tải lên -> POST /process -> thăm dò trạng thái -> tải xuống, bao gồm cả việc xử lý 202.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Dưới đây là một bài kiểm tra chuỗi cho quy trình xử lý file bạn vừa mô tả:\n\n1. **Tải lên**: Gửi yêu cầu HTTP POST đến server với tệp tin cần xử lý.\n2. **POST /process**: Server nhận tệp tin và bắt đầu xử lý nó.\n3. **Trả về trạng thái 202**: Server trả về trạng thái 202 (Tạo hoặc thay đổi đã được chấp nhận) để thông báo cho client rằng tệp tin đã được tiếp nhận và đang được xử lý.\n4. **Thăm dò trạng thái**: Client gửi yêu cầu HTTP GET đến server để hỏi về trạng thái xử lý của tệp tin.\n5. **Trả về trạng thái hiện tại**: Server trả về trạng thái hiện tại của tệp tin, chẳng hạn như \"Đang xử lý\" hoặc \"Xử lý hoàn thành\".\n6. **Tải xuống**: Nếu tệp tin đã được xử lý thành công, client gửi yêu cầu HTTP GET đến server để tải xuống tệp tin đã xử lý."
    },
    {
      "question_id": "EQ3052-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "Để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice, bạn có thể thực hiện các bước sau:\n\n1. **Kiểm tra header**: Kiểm tra header của yêu cầu vào API gateway để xác định có chứa token SSO hay không.\n2. **Kiểm tra token SSO**: Kiểm tra token SSO để xác định đã hết hạn hay chưa. Nếu đã hết hạn, hủy bỏ session SSO.\n3. **Truy cập microservice**: Nếu session SSO còn hiệu lực, truy cập microservice cần thiết và thực hiện các hoạt động phù hợp.\n\nVí dụ về mã Python:\n\n```python\nimport requests\n\ndef kiểm_tra_sso(header):\n    # Kiểm tra header để xác định có chứa token SSO hay không\n    if 'Authorization' not in header:\n        return False\n\n    # Kiểm tra token SSO\n    token = header['Authorization'].split(' ')[1]\n    if not token or token == '':\n        return False\n\n    # Hủy bỏ session SSO nếu đã hết hạn\n    #...\n    return True\n\ndef truy_cap_microservice(header):\n    # Kiểm tra session SSO\n    if not kiểm_tra_sso(header):\n        return False\n\n    # Truy cập microservice cần thiết\n    #...\n    return True\n\n# Sử dụng\nheader = {'Authorization': 'Bearer token_sso'}\nif truy_cap_microservice(header):\n    print('Truy cập microservice thành công')\nelse:\n    print('Truy cập microservice thất bại')\n```"
    },
    {
      "question_id": "EQ3054-VN",
      "question": "Viết một test case chuỗi cho việc thực hiện đơn hàng một phần: tạo đơn hàng -> dự trữ hàng tồn kho -> ship một phần -> hủy phần còn lại và hoàn tiền chênh lệch.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "Dưới đây là một ví dụ về test case chuỗi cho việc thực hiện đơn hàng một phần:\n\n**Test Case 1: Tạo đơn hàng**\n\n- Điều kiện tiền đề: Có hàng tồn kho sẵn có\n- Hoạt động: Tạo đơn hàng với số lượng 10 sản phẩm\n- Kết quả mong muốn: Đơn hàng được tạo thành công\n\n**Test Case 2: Dự trữ hàng tồn kho**\n\n- Điều kiện tiền đề: Đơn hàng đã được tạo thành công\n- Hoạt động: Dự trữ hàng tồn kho cho đơn hàng\n- Kết quả mong muốn: Hàng tồn kho được dự trữ thành công\n\n**Test Case 3: Ship một phần**\n\n- Điều kiện tiền đề: Hàng tồn kho đã được dự trữ thành công\n- Hoạt động: Ship một phần của đơn hàng (5 sản phẩm)\n- Kết quả mong muốn: Hàng hóa được ship thành công\n\n**Test Case 4: Hủy phần còn lại và hoàn tiền chênh lệch**\n\n- Điều kiện tiền đề: Đơn hàng đã được ship một phần\n- Hoạt động: Hủy phần còn lại của đơn hàng và hoàn tiền chênh lệch\n- Kết quả mong muốn: Phần còn lại của đơn hàng được hủy thành công và tiền chênh lệch được hoàn trả cho khách hàng"
    },
    {
      "question_id": "EQ3056-VN",
      "question": "Cung cấp chính xác một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA: POST /login -> POST /2fa/verify với mã sai -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "Dưới đây là một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA:\n\n1. POST /login: Gửi yêu cầu đăng nhập với thông tin tài khoản và mật khẩu hợp lệ.\n2. POST /2fa/verify: Gửi yêu cầu xác minh mã 2FA với mã sai (ví dụ: mã không tồn tại hoặc mã đã hết hạn).\n3. POST /refresh: Gửi yêu cầu refresh token để xem hệ thống có phản hồi lại yêu cầu xác minh mã 2FA hay không, nếu không thì hệ thống sẽ không cho phép truy cập.\n\nĐây là một bài kiểm tra tiêu cực chuỗi để đánh giá khả năng bảo vệ của hệ thống trước các cuộc tấn công giả mạo mã 2FA."
    },
    {
      "question_id": "EQ3058-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê (với các xác nhận tổng số đếm).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Dưới đây là thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê:\n\n**Bài kiểm tra chuỗi xác minh tính nhất quán phân trang**\n\n1. **Tạo dữ liệu**: Tạo một danh sách phân trang với 100 bản ghi, mỗi bản ghi có một trường \"ID\" và một trường \"Tên\".\n2. **Liệt kê dữ liệu**: Liệt kê 10 bản ghi đầu tiên của danh sách phân trang.\n3. **Xóa dữ liệu**: Xóa 5 bản ghi đầu tiên của danh sách phân trang.\n4. **Liệt kê dữ liệu sau xóa**: Liệt kê 10 bản ghi đầu tiên của danh sách phân trang sau khi xóa.\n5. **Xác nhận tổng số đếm**: Xác nhận rằng tổng số bản ghi trong danh sách phân trang sau khi xóa là 95 (100 - 5).\n\n**Thời gian thực hiện**: 5 phút\n\n**Mục tiêu**: Xác minh tính nhất quán phân trang trên các thao tác tạo, liệt kê, xóa và liệt kê."
    },
    {
      "question_id": "EQ3060-VN",
      "question": "Viết một bài kiểm tra chuỗi cho tính dính session (session stickiness): đăng nhập -> các cuộc gọi tiếp theo qua load balancer -> đăng xuất -> xác minh không có node nào chấp nhận token cũ.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "**Bài kiểm tra chuỗi cho tính dính session (session stickiness)**\n\n1. **Đăng nhập**: Client gửi yêu cầu đăng nhập đến Node A trong cụm Load Balancer (LB). Node A xác thực và tạo ra một token session. Client nhận được token này và lưu trữ nó.\n\n2. **Các cuộc gọi tiếp theo qua LB**: Khi Client thực hiện các cuộc gọi tiếp theo đến ứng dụng, LB sẽ phân phối yêu cầu đến các Node khác (Node B hoặc Node C). Vì tính dính session được kích hoạt, LB sẽ sử dụng token session của Client để xác định Node đã xử lý yêu cầu đăng nhập trước đó (Node A). LB sẽ phân phối yêu cầu đến Node A để tiếp tục xử lý.\n\n3. **Đăng xuất**: Khi Client đăng xuất, token session sẽ bị hủy bỏ.\n\n4. **Xác minh không có node nào chấp nhận token cũ**: Sau khi Client đăng xuất, nếu một Node khác (Node B hoặc Node C) nhận được yêu cầu với token session cũ, nó sẽ không chấp nhận token này vì đã bị hủy bỏ. Node sẽ yêu cầu Client đăng nhập lại để tạo ra một token session mới."
    },
    {
      "question_id": "EQ4002-VN",
      "question": "Viết một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản: tạo → kích hoạt → tạm ngừng → kích hoạt lại → xóa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "Dưới đây là một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản:\n```python\nimport unittest\n\nclass TaiKhoan:\n    def __init__(self):\n        self.trang_thai = \"tao\"\n\n    def tao(self):\n        self.trang_thai = \"kich_hoat\"\n        return self.trang_thai\n\n    def kich_hoat(self):\n        if self.trang_thai == \"tao\":\n            self.trang_thai = \"kich_hoat\"\n        elif self.trang_thai == \"tam_ngung\":\n            self.trang_thai = \"kich_hoat_lai\"\n        return self.trang_thai\n\n    def tam_ngung(self):\n        if self.trang_thai == \"kich_hoat\":\n            self.trang_thai = \"tam_ngung\"\n        return self.trang_thai\n\n    def kich_hoat_lai(self):\n        if self.trang_thai == \"tam_ngung\":\n            self.trang_thai = \"kich_hoat\"\n        return self.trang_thai\n\n    def xoa(self):\n        self.trang_thai = \"xoa\"\n        return self.trang_thai\n\nclass TestTaiKhoan(unittest.TestCase):\n    def test_tao_kich_hoat(self):\n        tk = TaiKhoan()\n        self.assertEqual(tk.tao(), \"kich_hoat\")\n\n    def test_kich_hoat_tao(self):\n        tk = TaiKhoan()\n        tk.tao()\n        self.assertEqual(tk.kich_hoat(), \"kich_hoat\")\n\n    def test_kich_hoat_kich_hoat(self):\n        tk = TaiKhoan()\n        tk.tao()\n        tk.kich_hoat()\n        self.assertEqual(tk.kich_hoat(), \"kich_hoat\")\n\n    def test_tam_ngung_tam_ngung(self):\n        tk = TaiKhoan()\n        tk.tao()\n        tk.kich_hoat()\n        tk.tam_ngung()\n        self.assertEqual(tk.tam_ngung(), \"tam_ngung\")\n\n    def test_kich_hoat_lai_tam_ngung(self):\n        tk = TaiKhoan()\n        tk.tao()\n        tk.kich_hoat()\n        tk.tam_ngung()\n        tk.kich_hoat_lai()\n        self.assertEqual(tk.kich_hoat"
    },
    {
      "question_id": "EQ4004-VN",
      "question": "Thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "Dưới đây là thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại:\n\n1. **Bước 1: Tạo tài khoản và tạo giao dịch chuyển tiền**\n * Tạo tài khoản người gửi và người nhận\n * Tạo giao dịch chuyển tiền từ tài khoản người gửi sang tài khoản người nhận\n\n2. **Bước 2: Thực hiện bước 2 của giao dịch chuyển tiền (thất bại)**\n * Gọi phương thức chuyển tiền và giả lập lỗi (ví dụ: lỗi kết nối mạng)\n * Kiểm tra rằng giao dịch chuyển tiền không thành công\n\n3. **Bước 3: Thực hiện bước 3 của giao dịch chuyển tiền (thất bại)**\n * Gọi phương thức chuyển tiền và giả lập lỗi (ví dụ: lỗi kết nối mạng)\n * Kiểm tra rằng giao dịch chuyển tiền không thành công\n\n4. **Bước 4: Xác thực rollback giao dịch**\n * Kiểm tra rằng giao dịch chuyển tiền đã được rollback\n * Kiểm tra rằng tài khoản người gửi và người nhận không bị ảnh hưởng bởi giao dịch chuyển tiền thất bại\n\n5. **Bước 5: Xác thực dữ liệu cơ sở**\n * Kiểm tra rằng dữ liệu cơ sở (ví dụ: số dư tài khoản) được cập nhật đúng theo giao dịch chuyển tiền thất bại."
    },
    {
      "question_id": "EQ4006-VN",
      "question": "Viết một **test** xác thực chuỗi nhiều dịch vụ: đăng nhập → tạo đơn hàng → xử lý thanh toán → hủy đơn hàng sau khi ghi nhận.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Dưới đây là một ví dụ về **test** xác thực chuỗi nhiều dịch vụ:\n\n**Test Case:** Chuỗi tạo đơn hàng và hủy đơn hàng\n\n**Mô tả:** \n1. Đăng nhập vào hệ thống với tư cách người dùng thông thường.\n2. Tạo một đơn hàng mới bằng cách chọn sản phẩm và đặt hàng.\n3. Xử lý thanh toán cho đơn hàng vừa tạo.\n4. Hủy đơn hàng vừa tạo.\n5. Xác minh rằng đơn hàng đã được hủy thành công.\n\n**Thí dụ sử dụng ngôn ngữ đầu cuối (Gherkin):**\n```\nFeature: Chuỗi tạo đơn hàng và hủy đơn hàng\n  Scenario: Tạo đơn hàng và hủy đơn hàng\n    Given Tôi đã đăng nhập vào hệ thống\n    When Tôi tạo một đơn hàng mới\n    And Tôi xử lý thanh toán cho đơn hàng\n    And Tôi hủy đơn hàng vừa tạo\n    Then Đơn hàng đã được hủy thành công\n```"
    },
    {
      "question_id": "EQ4008-VN",
      "question": "Mô tả một **test state-machine** xác thực vòng đời mật khẩu: đặt → hết hạn → đặt lại → ngăn tái sử dụng.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "Test state-machine xác thực vòng đời mật khẩu như sau:\n\n1. **Đặt** (Create): Mật khẩu được tạo và trạng thái là \"đã đặt\".\n2. **Hết hạn** (Expire): Mật khẩu hết hạn và trạng thái chuyển sang \"hết hạn\".\n3. **Đặt lại** (Reset): Mật khẩu được đặt lại và trạng thái chuyển sang \"đã đặt\".\n4. **Ngăn tái sử dụng** (Disallow Reuse): Mật khẩu không được phép tái sử dụng và trạng thái chuyển sang \"ngăn tái sử dụng\".\n\nTest state-machine này đảm bảo vòng đời mật khẩu được quản lý một cách hợp lý."
    },
    {
      "question_id": "EQ4010-VN",
      "question": "Viết một **test chained** phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "Dưới đây là một ví dụ về test chained phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng:\n\n```python\nimport unittest\nfrom unittest.mock import Mock, patch\n\nclass TestDangKyKhoanVay(unittest.TestCase):\n\n    @patch('khoan_vay.check_tin_dung')\n    @patch('khoan_vay.thanh_toan')\n    def test_dang_ky_khoan_vay_thanh_cong(self, mock_thanh_toan, mock_check_tin_dung):\n        # Tạo mock cho kiểm tra tín dụng và thanh toán\n        mock_check_tin_dung.return_value = True\n        mock_thanh_toan.return_value = True\n\n        # Gọi phương thức đăng ký khoản vay\n        khoan_vay.dang_ky_khoan_vay()\n\n        # Kiểm tra xem phương thức thanh toán đã được gọi hay chưa\n        self.assertTrue(mock_thanh_toan.called)\n\n    @patch('khoan_vay.check_tin_dung')\n    def test_dang_ky_khoan_vay_thua(self, mock_check_tin_dung):\n        # Tạo mock cho kiểm tra tín dụng\n        mock_check_tin_dung.return_value = False\n\n        # Gọi phương thức đăng ký khoản vay\n        khoan_vay.dang_ky_khoan_vay()\n\n        # Kiểm tra xem phương thức thanh toán chưa được gọi\n        self.assertFalse(khoan_vay.thanh_toan.called)\n```\n\nTrong ví dụ trên, chúng ta sử dụng các phương thức `patch` và `Mock` để tạo mock cho các phương thức `check_tin_dung` và `thanh_toan`. Sau đó, chúng ta tạo hai test: `test_dang_ky_khoan_vay_thanh_cong` và `test_dang_ky_khoan_vay_thua`. Test đầu tiên kiểm tra xem phương thức thanh toán đã được gọi khi kiểm tra tín dụng thành công. Test thứ hai kiểm tra xem phương thức thanh toán chưa được gọi khi kiểm tra tín dụng thất bại."
    },
    {
      "question_id": "EQ4012-VN",
      "question": "Viết một **test** xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra: cập nhật hồ sơ người dùng với các giá trị xung đột.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "Để xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra, bạn có thể sử dụng cơ chế **Optimistic Locking**. Khi cập nhật hồ sơ người dùng, bạn sẽ kiểm tra xem phiên bản của dữ liệu đã được cập nhật là phiên bản mới nhất hay chưa. Nếu không phải phiên bản mới nhất, bạn sẽ phải cập nhật phiên bản và thử lại."
    },
    {
      "question_id": "EQ4014-VN",
      "question": "Viết một **test chained** rất khó xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Để viết một **test chained** xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo, bạn có thể thực hiện các bước sau:\n\n1. Tạo một tài liệu mẫu (file) với nội dung cần ký.\n2. Sử dụng một thư viện ký số (ví dụ: PKCS#11) để tạo một khóa số và ký số cho file mẫu.\n3. Sử dụng một thư viện xác thực (ví dụ: OpenSSL) để xác minh tính hợp lệ của file ký số.\n4. Sử dụng một thư viện phát hiện giả mạo (ví dụ: SHA-256) để kiểm tra tính toàn vẹn của file ký số.\n5. Viết một chương trình test sử dụng các thư viện trên để thực hiện các bước trên và xác nhận kết quả.\n\nVí dụ, bạn có thể sử dụng Python với các thư viện PyCryptography, cryptography và hashlib để thực hiện các bước trên:\n\n```python\nimport os\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS12\nfrom cryptography.hazes import PKCS"
    },
    {
      "question_id": "EQ4017-VN",
      "question": "Viết một **test state-machine** xác thực vòng đời đăng ký: tạo → nâng cấp → hạ cấp → hủy.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "Dưới đây là một test state-machine xác thực vòng đời đăng ký:\n```python\nimport unittest\n\nclass RegisterState:\n    def __init__(self):\n        self.state = \"tạo\"\n\n    def tạo(self):\n        self.state = \"tạo\"\n        return self\n\n    def nâng_cấp(self):\n        if self.state == \"tạo\":\n            self.state = \"nâng cấp\"\n            return self\n        else:\n            raise ValueError(\"Không thể nâng cấp khi không ở trạng thái 'tạo'\")\n\n    def hạ_cấp(self):\n        if self.state == \"nâng cấp\":\n            self.state = \"hạ cấp\"\n            return self\n        else:\n            raise ValueError(\"Không thể hạ cấp khi không ở trạng thái 'nâng cấp'\")\n\n    def hủy(self):\n        if self.state == \"hạ cấp\":\n            self.state = \"hủy\"\n            return self\n        else:\n            raise ValueError(\"Không thể hủy khi không ở trạng thái 'hạ cấp'\")\n\n\nclass TestRegisterState(unittest.TestCase):\n\n    def test_tạo(self):\n        register_state = RegisterState()\n        self.assertEqual(register_state.state, \"tạo\")\n\n    def test_nâng_cấp(self):\n        register_state = RegisterState()\n        register_state.tạo().nâng_cấp()\n        self.assertEqual(register_state.state, \"nâng cấp\")\n\n    def test_hạ_cấp(self):\n        register_state = RegisterState()\n        register_state.tạo().nâng_cấp().hạ_cấp()\n        self.assertEqual(register_state.state, \"hạ cấp\")\n\n    def test_hủy(self):\n        register_state = RegisterState()\n        register_state.tạo().nâng_cấp().hạ_cấp().hủy()\n        self.assertEqual(register_state.state, \"hủy\")\n\n    def test_nâng_cấp_khi_bị_hủy(self):\n        register_state = RegisterState()\n        register_state.tạo().hủy()\n        with self.assertRaises(ValueError):\n            register_state.nâng_cấp()\n\n    def test_hạ_cấp_khi_bị_hủy(self):\n        register_state = RegisterState()\n        register_state.tạo().hủy()\n        with self.assertRaises(ValueError):\n            register_state.hạ_cấp()\n\n    def test_hủy_khi_bị_hủy(self):\n        register_state = RegisterState()\n        register_state.tạo().hủy()\n        with self.assertRaises(ValueError):\n            register_state.hủy()\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\nTr"
    },
    {
      "question_id": "EQ4019-VN",
      "question": "Viết một **test chained** rất khó xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Một **test chained** có thể không đủ mạnh để xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga** vì các yếu tố sau:\n\n- Nó chỉ kiểm tra một chuỗi các bước cụ thể và có thể không bao quát được tất cả các trường hợp thất bại.\n- Nó không thể mô phỏng được các sự kiện bất ngờ hoặc thất bại ngẫu nhiên trong hệ thống phân phối.\n- Nó không thể xác định được khả năng phục hồi của hệ thống trong trường hợp thất bại một phần.\n\nĐể khắc phục những hạn chế này, chúng ta nên sử dụng các phương pháp kiểm tra khác như **test parallel** hoặc **test stateful** để mô phỏng và kiểm tra khả năng phục hồi sau thất bại một phần trong một **distributed order saga**."
    },
    {
      "question_id": "EQ4021-VN",
      "question": "Viết một **test** rất khó xác minh việc đảo ngược giao dịch tài chính: ghi nợ → ghi có → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "Để viết một **test** khó xác minh việc đảo ngược giao dịch tài chính, chúng ta có thể sử dụng mô hình sau:\n\n1. Ghi nợ: Thực hiện giao dịch ghi nợ (chẳng hạn, giảm số dư tài khoản).\n2. Ghi có: Thực hiện giao dịch ghi có (chẳng hạn, tăng số dư tài khoản).\n3. **Rollback**: Đảo ngược giao dịch ghi có, trở về tình trạng trước khi thực hiện giao dịch ghi có (số dư tài khoản trở về trước khi tăng).\n\nTest này có thể bao gồm các trường hợp như: số dư tài khoản không đủ để thực hiện giao dịch, lỗi trong quá trình thực hiện giao dịch, v.v."
    },
    {
      "question_id": "EQ4023-VN",
      "question": "Thiết kế một **test state-machine** cho kho hàng: thêm hàng → phân bổ → vận chuyển → trả lại → đối chiếu.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Dưới đây là thiết kế một **test state-machine** cho kho hàng:\n\n**Test State-Machine**:\n1. **Thêm hàng** (Add): thêm hàng vào kho hàng\n2. **Phân bổ** (Allocate): phân bổ hàng cho các đơn vị cần thiết\n3. **Vận chuyển** (Transport): vận chuyển hàng đến địa điểm cần thiết\n4. **Trả lại** (Return): trả lại hàng khi đã hoàn thành việc sử dụng\n5. **Đối chiếu** (Verify): đối chiếu số lượng hàng thực tế và số lượng hàng được phân bổ\n\n**Giao diện**:\n- **Add**: thêm hàng vào kho hàng\n- **Allocate**: phân bổ hàng cho các đơn vị cần thiết\n- **Transport**: vận chuyển hàng đến địa điểm cần thiết\n- **Return**: trả lại hàng khi đã hoàn thành việc sử dụng\n- **Verify**: đối chiếu số lượng hàng thực tế và số lượng hàng được phân bổ\n\n**Tính năng**:\n- Theo dõi số lượng hàng trong kho hàng\n- Theo dõi số lượng hàng đã phân bổ\n- Theo dõi số lượng hàng đã vận chuyển\n- Theo dõi số lượng hàng đã trả lại\n- Theo dõi số lượng hàng đã đối chiếu"
    },
    {
      "question_id": "EQ4025-VN",
      "question": "Viết một **test chained** xác thực vòng đời **session mobile**: đăng nhập → làm mới **token** → đăng xuất → làm mới với **token** cũ → thất bại.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "Dưới đây là một **test chained** xác thực vòng đời **session mobile**:\n\n1. **Đăng nhập**: Gửi yêu cầu đăng nhập với thông tin tài khoản hợp lệ và nhận token mới.\n2. **Làm mới token**: Gửi yêu cầu làm mới token với token mới nhận được và nhận token mới.\n3. **Đăng xuất**: Gửi yêu cầu đăng xuất với token mới nhận được.\n4. **Làm mới với token cũ**: Gửi yêu cầu làm mới token với token cũ và kiểm tra kết quả thất bại.\n\nMã test có thể được viết bằng ngôn ngữ lập trình như Python hoặc Java, sử dụng thư viện thử nghiệm như Pytest hoặc JUnit."
    },
    {
      "question_id": "EQ4027-VN",
      "question": "Viết một **test chained** xác thực API gửi email: gửi → theo dõi mở → hủy đăng ký → đảm bảo không gửi thêm email nào nữa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "Để viết một **test chained** xác thực API gửi email, bạn có thể thực hiện các bước sau:\n\n1. **Gửi**: Gửi một yêu cầu gửi email và kiểm tra xem email đã được gửi thành công hay chưa.\n2. **Theo dõi mở**: Theo dõi xem người nhận đã mở email hay chưa, và đảm bảo rằng email đã được mở.\n3. **Hủy đăng ký**: Hủy đăng ký email của người nhận và kiểm tra xem email đã được hủy thành công hay chưa.\n4. **Đảm bảo không gửi thêm email nào nữa**: Kiểm tra xem hệ thống đã ngăn chặn việc gửi email thêm cho người nhận hay chưa.\n\nMã test có thể như sau:\n\n```python\nimport unittest\nfrom unittest.mock import patch\nfrom your_module import send_email, check_email_open, cancel_subscription\n\nclass TestEmailAPI(unittest.TestCase):\n\n    @patch('your_module.send_email')\n    def test_send_email(self, mock_send_email):\n        # Gửi email\n        send_email('nguyenvandat@gmail.com')\n        mock_send_email.assert_called_once_with('nguyenvandat@gmail.com')\n\n    @patch('your_module.check_email_open')\n    def test_check_email_open(self, mock_check_email_open):\n        # Theo dõi mở email\n        check_email_open('nguyenvandat@gmail.com')\n        mock_check_email_open.assert_called_once_with('nguyenvandat@gmail.com')\n\n    @patch('your_module.cancel_subscription')\n    def test_cancel_subscription(self, mock_cancel_subscription):\n        # Hủy đăng ký email\n        cancel_subscription('nguyenvandat@gmail.com')\n        mock_cancel_subscription.assert_called_once_with('nguyenvandat@gmail.com')\n\n    def test_no_more_email(self):\n        # Đảm bảo không gửi thêm email nào nữa\n        self.assertEqual(send_email('nguyenvandat@gmail.com'), None)\n\nif __name__ == '__main__':\n    unittest.main()\n```"
    },
    {
      "question_id": "EQ4029-VN",
      "question": "Viết một **test chained** rất khó cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại: áp dụng phiếu giảm giá → thanh toán → phiếu giảm giá không hợp lệ → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Dưới đây là một ví dụ về **test chained** cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại:\n\n```python\nimport unittest\n\nclass TestLuongMuaHang(unittest.TestCase):\n\n    def test_ap_dung_phi_lieu_giam_gia(self):\n        # Tạo một đơn hàng mới\n        don_hang = DonHang()\n        \n        # Áp dụng phiếu giảm giá\n        phi_lieu_giam_gia = PhiLieuGiamGia(\"phi-lieu-1\")\n        don_hang.ap_dung_phi_lieu_giam_gia(phi_lieu_giam_gia)\n        \n        # Thanh toán\n        don_hang.thanh_toan()\n        \n        # Kiểm tra giá trị đơn hàng sau khi áp dụng phiếu giảm giá\n        self.assertEqual(don_hang.tong_tien(), 100)\n    \n    def test_phi_lieu_giam_gia_khong_hop_le(self):\n        # Tạo một đơn hàng mới\n        don_hang = DonHang()\n        \n        # Áp dụng một phiếu giảm giá không hợp lệ\n        phi_lieu_giam_gia = PhiLieuGiamGia(\"phi-lieu-2\")\n        don_hang.ap_dung_phi_lieu_giam_gia(phi_lieu_giam_gia)\n        \n        # Kiểm tra giá trị đơn hàng sau khi áp dụng phiếu giảm giá không hợp lệ\n        self.assertEqual(don_hang.tong_tien(), 1000)\n    \n    def test_rollback_khi_phi_lieu_giam_gia_khong_hop_le(self):\n        # Tạo một đơn hàng mới\n        don_hang = DonHang()\n        \n        # Áp dụng một phiếu giảm giá không hợp lệ\n        phi_lieu_giam_gia = PhiLieuGiamGia(\"phi-lieu-2\")\n        don_hang.ap_dung_phi_lieu_giam_gia(phi_lieu_giam_gia)\n        \n        # Thanh toán\n        don_hang.thanh_toan()\n        \n        # Kiểm tra giá trị đơn hàng sau khi thanh toán\n        self.assertEqual(don_hang.tong_tien(), 1000)\n        \n        # Rollback\n        don_hang.rollback()\n        \n        # Kiểm tra giá trị đơn hàng sau khi rollback\n        self.assertEqual(don_hang.tong_tien(), 100)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\nTrong ví dụ trên, chúng ta đã"
    }
  ]
}