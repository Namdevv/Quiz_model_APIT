{
  "timestamp": "20250912_155253",
  "model": "Meta-Llama-3.1-8B-Instruct-lora-adapter-v1",
  "summary": {
    "total_questions": 500,
    "mcq_questions": 258,
    "writing_questions": 242,
    "mcq_accuracy": 0.9418604651162791,
    "mcq_correct": 243,
    "mcq_incorrect": 15
  },
  "results": [
    {
      "question_id": "EQ5001",
      "question": "Which HTTP method is commonly used to retrieve data from an API?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is the standard method for retrieving data."
    },
    {
      "question_id": "EQ5002",
      "question": "What does HTTP status code 404 represent?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "OK",
        "B": "Unauthorized",
        "C": "Not Found",
        "D": "Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Not Found",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "404 indicates the requested resource could not be found."
    },
    {
      "question_id": "EQ5003",
      "question": "What is the purpose of the HTTP POST method?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "Retrieve data",
        "B": "Submit data to create resources",
        "C": "Update existing resources",
        "D": "Delete resources"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Submit data to create resources",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST is used to create new resources with data in the request body."
    },
    {
      "question_id": "EQ5004",
      "type": "Writing",
      "gold": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user 'user@example.com' with password 'Password123' exists.\n- **Test Steps:** Send a `POST` request to `/login` with the correct email and password in the body.\n- **Expected Result:** The API returns a `200 OK` status code with a valid authentication token in the response."
    },
    {
      "question_id": "EQ5005",
      "question": "Which of these HTTP status codes means 'Unauthorized'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates missing or invalid credentials."
    },
    {
      "question_id": "EQ5006",
      "type": "Writing",
      "gold": "User must be logged in and have a valid token.",
      "model_answer": "A common precondition is that a user account must exist with a valid profile. This means the API should have a user registration or profile creation endpoint that has been successfully used to generate a user ID or token."
    },
    {
      "question_id": "EQ5007",
      "question": "Which HTTP method is considered idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "PUT",
        "D": "CONNECT"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PUT. A request is idempotent if making the same request repeatedly has the same effect as making it once. For `PUT /resource`, updating a resource that already exists will always result in the same state.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PUT is idempotent because multiple identical requests have the same effect."
    },
    {
      "question_id": "EQ5008",
      "type": "Writing",
      "gold": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Test case: Send a registration request with an email that already exists. Expected result: the API returns a `409 Conflict` status code with an appropriate error message."
    },
    {
      "question_id": "EQ5009",
      "question": "Which HTTP status code means 'OK'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 200",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK is the standard success code."
    },
    {
      "question_id": "EQ5010",
      "type": "Writing",
      "gold": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure and data types expected for API requests and responses. It acts as a contract between the client and server, allowing testers to validate correctness and detect schema violations."
    },
    {
      "question_id": "EQ5011",
      "question": "Which HTTP method is used to delete a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "DELETE removes the resource specified in the URL."
    },
    {
      "question_id": "EQ5012",
      "type": "Writing",
      "gold": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "**Test Step:** Send a `POST /users` request with a valid user payload. **Expected Result:** The API should return a `201 Created` status code. **Additional Verification:** The response body should contain the newly created user's ID or a location header with the user's URL."
    },
    {
      "question_id": "EQ5013",
      "question": "Which HTTP header is typically used for authentication tokens?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "Accept",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Authorization",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Authorization header carries credentials or tokens."
    },
    {
      "question_id": "EQ5014",
      "type": "Writing",
      "gold": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependencies with simulated ones. In API testing, it allows testers to isolate the API under test and simulate the behavior of its downstream services (e.g., databases, other microservices) without needing those services to be running. This makes testing faster, more reliable, and easier to set up."
    },
    {
      "question_id": "EQ5015",
      "question": "Which HTTP status code indicates 'Created'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "403"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 201",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created confirms successful creation of a resource."
    },
    {
      "question_id": "EQ5016",
      "type": "Writing",
      "gold": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "Test Case: 'Fetch Products' Positive. **Preconditions:** API is running. **Steps:** Send GET request to `/products`. **Expected:** Status Code = 200 OK, Response contains at least 3 products."
    },
    {
      "question_id": "EQ5017",
      "question": "Which HTTP status indicates 'Internal Server Error'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "403",
        "D": "500"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 500",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "500 indicates unexpected server-side failure."
    },
    {
      "question_id": "EQ5018",
      "type": "Writing",
      "gold": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "The purpose of a precondition is to ensure that the test environment and system state are stable and consistent before the test execution begins. It defines the required state or setup (e.g., user login, data existence, system configuration) that must be in place for the test to be valid."
    },
    {
      "question_id": "EQ5019",
      "question": "Which HTTP status is appropriate for forbidden access with valid credentials?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden indicates insufficient permissions despite valid login."
    },
    {
      "question_id": "EQ5020",
      "type": "Writing",
      "gold": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Test case: Upload a.txt file. Expected: API rejects the file with a `415 Unsupported Media Type` or `400 Bad Request` error."
    },
    {
      "question_id": "EQ5021",
      "question": "Which HTTP method is typically used for partial updates?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PATCH",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. PATCH",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PATCH is used to modify part of a resource."
    },
    {
      "question_id": "EQ5022",
      "type": "Writing",
      "gold": "To explain the objective and scope of a test scenario.",
      "model_answer": "The purpose of a test case description is to provide a clear and concise summary of what the test case aims to verify, including its functionality and expected outcome."
    },
    {
      "question_id": "EQ5023",
      "question": "Which HTTP header indicates the format of request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Accept-Encoding"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Content-Type",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Type defines the media type of request body."
    },
    {
      "question_id": "EQ5024",
      "type": "Writing",
      "gold": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "Test Step: Send `GET /health` request 10 times. Verify average response time < 1s."
    },
    {
      "question_id": "EQ5025",
      "question": "Which HTTP status code indicates a conflict, such as duplicate resource creation?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict is used when request conflicts with current state."
    },
    {
      "question_id": "EQ5026",
      "question": "Which HTTP status code means 'Bad Request'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 Bad Request indicates invalid syntax or parameters."
    },
    {
      "question_id": "EQ5027",
      "type": "Writing",
      "gold": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "### **Test Case: Health Endpoint**\n- **Test Case Name:** Verify Health Endpoint Returns 200 OK.\n- **Preconditions:** API deployed and running.\n- **Test Steps:** Send a `GET` request to `/health`.\n- **Expected Result:**\n  - The API returns a `200 OK` status code.\n  - The response body should contain a simple success message like `\"healthy\"` or a specific health check status."
    },
    {
      "question_id": "EQ5028",
      "question": "Which HTTP method is used to fully update a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. PUT",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT replaces an existing resource with new data."
    },
    {
      "question_id": "EQ5029",
      "type": "Writing",
      "gold": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management ensures that unique, clean, and consistent data is available for each test case. It prevents data collisions and makes test results reliable."
    },
    {
      "question_id": "EQ5030",
      "question": "Which HTTP status indicates 'Forbidden'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "401",
        "D": "403"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 403",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "403 Forbidden means user is authenticated but not authorized."
    },
    {
      "question_id": "EQ5031",
      "type": "Writing",
      "gold": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "### **Negative Test Case: Invalid JSON Format**\n-   *Test Case Name:* Verify API rejects malformed JSON.\n-   *Test Steps:* Send a `POST` request to `/products` with a raw string instead of JSON (`{\"price\": 9.99}`). \n-   *Expected Result:* The API should return a `400 Bad Request` status code with a clear error message indicating that the request body is invalid."
    },
    {
      "question_id": "EQ5032",
      "question": "Which HTTP status code represents 'Too Many Requests'?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Easy",
      "options": {
        "A": "408",
        "B": "429",
        "C": "503",
        "D": "504"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 429",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "429 Too Many Requests is returned when rate limits are exceeded."
    },
    {
      "question_id": "EQ5033",
      "type": "Writing",
      "gold": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions are the foundation of API testing. They define the expected behavior by verifying that actual values (e.g., status codes, response bodies, headers) match the expected ones. Without strong assertions, tests are meaningless."
    },
    {
      "question_id": "EQ5034",
      "question": "Which HTTP status indicates a timeout from the server?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "400",
        "C": "200",
        "D": "504"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 504",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "504 Gateway Timeout indicates the server did not respond in time."
    },
    {
      "question_id": "EQ5035",
      "type": "Writing",
      "gold": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "### **Test Case: Delete User**\n- **Preconditions:** User ID=123 exists, ID=999 does not.\n- **Steps:**\n  - Request `/users/123` → expect `204 No Content`.\n  - Request `/users/999` → expect `404 Not Found`.\n- **Expected:** User ID=123 is deleted from DB."
    },
    {
      "question_id": "EQ5036",
      "question": "Which HTTP method is safe (does not change server state)?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is safe because it only retrieves data."
    },
    {
      "question_id": "EQ5037",
      "type": "Writing",
      "gold": "A new resource has been successfully created.",
      "model_answer": "It indicates that the request was successful and a new resource has been created as a result."
    },
    {
      "question_id": "EQ5038",
      "question": "Which HTTP status is returned when a client request is well-formed but unauthorized?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "401",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 401 – Unauthorized.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized is used for invalid credentials."
    },
    {
      "question_id": "EQ5039",
      "type": "Writing",
      "gold": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test case: **Get User by ID**\n- **Action:** Send request to `/users/123`.\n- **Expected:** Status `200 OK`, response body contains user data with ID `123`."
    },
    {
      "question_id": "EQ5040",
      "question": "Which HTTP status indicates success but no content is returned?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content is returned on successful deletion or empty responses."
    },
    {
      "question_id": "EQ5041",
      "type": "Writing",
      "gold": "It confirms that the request has succeeded.",
      "model_answer": "A 200 OK response indicates that the request was successful and the data was returned as expected."
    },
    {
      "question_id": "EQ5042",
      "question": "Which header is used to specify accepted response formats?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Accept",
        "C": "Authorization",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Accept",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Accept header tells the server which formats are expected (e.g., application/json)."
    },
    {
      "question_id": "EQ5043",
      "type": "Writing",
      "gold": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "### **Test Case: Invalid Endpoint**\n-   **Test Case Name:** Verify `GET /invalid-path` returns a `404 Not Found` status code.\n-   **Preconditions:** The API is running.\n-   **Test Steps:**\n    - Send a `GET` request to the URL `/invalid-path`.\n-   **Expected Result:**\n    - The API should respond with a `404 Not Found` status code.\n    - The response body should contain an error message indicating the resource was not found."
    },
    {
      "question_id": "EQ5044",
      "question": "Which HTTP status code is used when the client must authenticate to access a resource?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "403",
        "C": "401",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 401",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized requires authentication credentials."
    },
    {
      "question_id": "EQ5045",
      "type": "Writing",
      "gold": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion defines the condition that must be true for a test to pass. It compares the actual outcome with the expected outcome. For example, 'assert user.role == \"admin\"' ensures the user's role is correct."
    },
    {
      "question_id": "EQ5046",
      "question": "Which HTTP status indicates the server cannot handle the request due to overload?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "503 Service Unavailable",
        "B": "200 OK",
        "C": "404 Not Found",
        "D": "201 Created"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 503 Service Unavailable",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "503 indicates temporary overload or maintenance."
    },
    {
      "question_id": "EQ5047",
      "type": "Writing",
      "gold": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "**Test Case: Upload Valid File**\n- **Preconditions:** File `image.jpg` exists on local machine.\n- **Action:** Send `POST` request to `/upload` with file attached.\n- **Expected:** `201 Created` with file stored on server."
    },
    {
      "question_id": "EQ5048",
      "question": "Which HTTP method is safe and idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "GET",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. GET is both safe (does not change state) and idempotent (multiple requests have same effect as one).",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "GET is both safe and idempotent."
    },
    {
      "question_id": "EQ5049",
      "type": "Writing",
      "gold": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "The `415 Unsupported Media Type` status code is used to indicate that the server does not support the media type (e.g., `application/json`) sent in the request's `Content-Type` header. This error typically occurs when a client requests a resource using a format that the server cannot process."
    },
    {
      "question_id": "EQ5050",
      "question": "Which HTTP status code means 'Request Timeout'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "408",
        "C": "500",
        "D": "429"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 408",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout indicates the client took too long to send the request."
    },
    {
      "question_id": "EQ5051",
      "question": "Which HTTP method is typically used to create a new resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. POST",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST is the standard method for creating resources."
    },
    {
      "question_id": "EQ5052",
      "type": "Writing",
      "gold": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "**Test Case: Get Product Details**\n- **Test Case Name:** Verify product details are returned successfully.\n- **Preconditions:** Product ID=123 exists in DB.\n- **Test Steps:**\n  1. Send GET request to `/products/123`.\n- **Expected Result:**\n  - Status Code: `200 OK`.\n  - Response Body contains product name, price, and description."
    },
    {
      "question_id": "EQ5053",
      "question": "Which HTTP status code is returned when a resource is successfully deleted?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content confirms deletion succeeded."
    },
    {
      "question_id": "EQ5054",
      "type": "Writing",
      "gold": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The purpose is to simulate user permissions and restrict access to protected resources. By including valid tokens like OAuth2 or API Keys in the `Authorization` header, testers can validate that only allowed actions are performed."
    },
    {
      "question_id": "EQ5055",
      "question": "Which HTTP status code is used when a client sends an invalid JSON payload?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 indicates the request could not be understood due to invalid syntax."
    },
    {
      "question_id": "EQ5056",
      "type": "Writing",
      "gold": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Unauthorized Access**\n- **Preconditions:** No valid token.\n- **Action:** Send `GET /protected` request.\n- **Expected:** `401 Unauthorized` or `403 Forbidden` response."
    },
    {
      "question_id": "EQ5057",
      "question": "Which HTTP method is generally used to update a resource entirely?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. PUT",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT replaces the full resource with new data."
    },
    {
      "question_id": "EQ5058",
      "type": "Writing",
      "gold": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "The 500 Internal Server Error is used to indicate a generic, unexpected failure on the server. It should be tested as part of negative scenarios to ensure the API handles unexpected conditions gracefully."
    },
    {
      "question_id": "EQ5059",
      "question": "Which HTTP status means 'Conflict'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "409"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict occurs when resource creation/update conflicts with state."
    },
    {
      "question_id": "EQ5060",
      "type": "Writing",
      "gold": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "### **Test Case: Retrieve All Orders**\n-   **Preconditions:** The API is running with a known dataset of orders.\n-   **Action:** Send a `GET` request to the `/orders` endpoint.\n-   **Expected:** The API returns a `200 OK` status code with a JSON response that is an array of order objects. The array should contain at least two orders (e.g., `id: 1`, `id: 2`), with each order having its respective fields (e.g., `customerName`, `total`, `orderDate`)."
    },
    {
      "question_id": "EQ5061",
      "question": "Which HTTP method is used for partial updates to resources?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH modifies only part of a resource."
    },
    {
      "question_id": "EQ5062",
      "type": "Writing",
      "gold": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "Response headers provide metadata about the API response. In testing, they are used to verify security measures (e.g., `Content-Security-Policy`), caching behavior, or authentication tokens."
    },
    {
      "question_id": "EQ5063",
      "question": "Which HTTP status code is returned when authentication is required but missing?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 – Unauthorized.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates missing or invalid credentials."
    },
    {
      "question_id": "EQ5064",
      "type": "Writing",
      "gold": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Test Case: **Create Duplicate User**\n- **Action:** Send `POST /users` with an existing email (`user@example.com`).\n- **Expected:** `409 Conflict` with a message like \"User already exists.\""
    },
    {
      "question_id": "EQ5065",
      "question": "Which HTTP method is most often used for safe read-only operations?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is safe and read-only."
    },
    {
      "question_id": "EQ5066",
      "type": "Writing",
      "gold": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "A `202 Accepted` status code indicates that the request has been received for processing, but it has not been completed yet. It is commonly used for asynchronous operations where the API will continue to process the request in the background."
    },
    {
      "question_id": "EQ5067",
      "question": "Which HTTP status is returned when a resource has been permanently moved?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "302",
        "C": "301",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 301",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "301 Moved Permanently indicates redirection."
    },
    {
      "question_id": "EQ5068",
      "type": "Writing",
      "gold": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "**Test Case: Verify API Response Schema**\n- **Test Case ID:** TC-007\n- **Preconditions:** API service is running.\n- **Test Steps:** Send a valid `GET /products` request.\n- **Expected Result:**\n  - **Status Code:** `200 OK`.\n  - **Response Body:** Verify that the schema conforms to the predefined JSON schema (e.g., all keys present, data types correct)."
    },
    {
      "question_id": "EQ5069",
      "question": "Which HTTP status indicates the request is valid but resource not found?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "404"
      },
      "gold_answer": "D",
      "model_raw_answer": "D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "404 Not Found means the resource does not exist."
    },
    {
      "question_id": "EQ5070",
      "type": "Writing",
      "gold": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body is the main part of an API's response, containing the data requested by the client. Its purpose is to provide the payload of the HTTP request, which the client can parse to understand the outcome of its request."
    },
    {
      "question_id": "EQ5071",
      "question": "Which HTTP status indicates client request timeout?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "500",
        "B": "408",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 408",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout means the client did not finish sending in time."
    },
    {
      "question_id": "EQ5072",
      "type": "Writing",
      "gold": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Logout Verification**\n- **Preconditions:** User authenticated.\n- **Steps:**\n  - Send logout request → expect `200 OK`.\n  - Verify session cookie no longer valid.\n- **Expected:** User cannot access protected routes after logout."
    },
    {
      "question_id": "EQ5073",
      "question": "Which HTTP status indicates a successful request returning JSON data?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 200 OK",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK is the standard code for successful GETs."
    },
    {
      "question_id": "EQ5074",
      "type": "Writing",
      "gold": "That the server rejects unsupported request body formats.",
      "model_answer": "A 415 error validates that the API correctly handles an unsupported request format (e.g., sending JSON in a `Content-Type` header set to `application/xml`)."
    },
    {
      "question_id": "EQ5075",
      "question": "Which HTTP status code indicates server is temporarily down for maintenance?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 is used when service is unavailable due to overload or maintenance."
    },
    {
      "question_id": "EQ5076",
      "question": "Which HTTP method is commonly used for updating only part of a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH is designed for partial updates."
    },
    {
      "question_id": "EQ5077",
      "type": "Writing",
      "gold": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "### **Test Case: Verify Status Endpoint**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Confirm /status API returns 200 OK with 'Healthy' message.\n- **Test Case Description:** Send a GET request to the /status endpoint and verify the HTTP status code and response body.\n- **Preconditions:** The API service must be running.\n- **Test Steps:**\n  1. Send a `GET` request to the URL `/status`.\n- **Expected Result:**\n  - The API returns a `200 OK` status code.\n  - The response body contains the text `'Healthy'`."
    },
    {
      "question_id": "EQ5078",
      "question": "Which HTTP status indicates a successful resource creation?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "B",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created confirms successful creation of resource."
    },
    {
      "question_id": "EQ5079",
      "type": "Writing",
      "gold": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content response indicates that the request was successful, but there is no content to return in the body of the response. It is often used for DELETE requests to confirm deletion."
    },
    {
      "question_id": "EQ5080",
      "question": "Which HTTP status code is used when a request is valid but access is forbidden?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden means valid credentials but insufficient permissions."
    },
    {
      "question_id": "EQ5081",
      "type": "Writing",
      "gold": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "### **Test Case: Invalid Content-Type**\n-   **Test Case Name:** Verify API rejects invalid Content-Type.\n-   **Preconditions:** API is running.\n-   **Test Steps:**\n    1. Send a `POST` request to `/upload`.\n    2. In the request body, attach a file but set `Content-Type` to an unsupported value (e.g., `image/jpeg` for an XML payload).\n-   **Expected Result:**\n    - The API returns a `415 Unsupported Media Type` status code.\n    - The response body indicates that the format is not supported.\n    - The file is not processed or stored."
    },
    {
      "question_id": "EQ5082",
      "question": "Which HTTP status code indicates success but the resource is empty?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "400 Bad Request",
        "D": "204 No Content"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204 No Content.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 is returned when no body content is available."
    },
    {
      "question_id": "EQ5083",
      "type": "Writing",
      "gold": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header indicates to the server which content formats (e.g., application/json, application/xml) the client can understand, allowing the server to respond with the appropriate format."
    },
    {
      "question_id": "EQ5084",
      "question": "Which HTTP status code is appropriate for invalid user credentials?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 Unauthorized",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates invalid login credentials."
    },
    {
      "question_id": "EQ5085",
      "type": "Writing",
      "gold": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Logout**\n- **Preconditions:** User authenticated.\n- **Action:** Send `POST /logout` request.\n- **Expected:** `200 OK`, session expired, subsequent requests return `401 Unauthorized`."
    },
    {
      "question_id": "EQ5086",
      "question": "Which HTTP method is used to retrieve resource details?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is used to retrieve data."
    },
    {
      "question_id": "EQ5087",
      "type": "Writing",
      "gold": "It means the client must provide valid authentication credentials.",
      "model_answer": "A 401 Unauthorized status code means that the client has not provided the correct authentication credentials (e.g., a valid token) or that the authentication has failed."
    },
    {
      "question_id": "EQ5088",
      "question": "Which HTTP status code indicates duplicate resource creation attempt?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict means duplicate or conflicting request."
    },
    {
      "question_id": "EQ5089",
      "type": "Writing",
      "gold": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test Case: Verify Profile Details. **Preconditions:** User ID = 1234 exists. **Action:** Send GET request to /profile/1234. **Expected:** Status = 200 OK, Profile data found in response."
    },
    {
      "question_id": "EQ5090",
      "question": "Which HTTP status code indicates request was valid but the server failed to fulfill it?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "500",
        "D": "201"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "500 Internal Server Error signals server-side failure."
    },
    {
      "question_id": "EQ5091",
      "type": "Writing",
      "gold": "It indicates temporary redirection to another URL.",
      "model_answer": "The purpose of a 302 Found status code is to indicate that the resource has temporarily moved to a different URL. It redirects the client to the new location. This is often used for migration or maintenance of endpoints."
    },
    {
      "question_id": "EQ5092",
      "question": "Which HTTP status is correct for a successfully updated resource using PUT?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 200 OK is the most common status for a successful update (PUT) because it indicates the request was received and understood.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK indicates the resource was updated successfully."
    },
    {
      "question_id": "EQ5093",
      "type": "Writing",
      "gold": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "Test Case: Invalid Login. Preconditions: User exists. Steps: Send login request with correct email and wrong password. Expected: `400 Bad Request` or `401 Unauthorized`."
    },
    {
      "question_id": "EQ5094",
      "question": "Which HTTP method is safe and cacheable?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "GET",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. GET",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "GET is safe, idempotent, and cacheable."
    },
    {
      "question_id": "EQ5095",
      "type": "Writing",
      "gold": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "A 422 Unprocessable Entity status code indicates that the server understands the request but cannot process it due to a semantic error, such as a validation failure or inconsistent state."
    },
    {
      "question_id": "EQ5096",
      "question": "Which HTTP status is appropriate when service is temporarily overloaded?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "201",
        "B": "200",
        "C": "503",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 Service Unavailable indicates overload or maintenance."
    },
    {
      "question_id": "EQ5097",
      "type": "Writing",
      "gold": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "**Test Case: Create New User**\n- **Preconditions:** API available, DB initialized with valid role ID.\n- **Action:** Send `POST /users` with JSON payload `{ \"name\": \"John Doe\", \"email\": \"john@example.com\", \"password\": \"StrongPass123\" }`.\n- **Expected Result:** Response `201 Created` with user ID in header, user data exists in DB."
    },
    {
      "question_id": "EQ5098",
      "question": "Which HTTP header specifies the size of the request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Length",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Cache-Control"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Content-Length",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Length defines body size in bytes."
    },
    {
      "question_id": "EQ5099",
      "type": "Writing",
      "gold": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most straightforward and successful scenario for a feature or API. It includes all required steps and inputs, where everything works as intended, with no errors or failures."
    },
    {
      "question_id": "EQ5100",
      "question": "Which HTTP status code is used when a request method is not allowed on a resource?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "405 Method Not Allowed"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 405 Method Not Allowed.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "405 is used when HTTP method is invalid for the resource."
    },
    {
      "question_id": "EQ2001",
      "question": "When designing API tests, which scenario best represents a boundary condition for a pagination parameter?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sending page=2 when total items=200",
        "B": "Sending page=10 when each page size=10 and total items=100",
        "C": "Sending page=11 when total items=100 with size=10",
        "D": "Sending page=1 when size=20 and total items=300"
      },
      "gold_answer": "C",
      "model_raw_answer": "C Sending page=11 when total items=100 with size=10. This is the boundary condition because it represents the last possible page (page 10 would have all items, so 11 is beyond the valid range).",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Page=11 would exceed the available range (max 10), testing a boundary overflow."
    },
    {
      "question_id": "EQ2002",
      "type": "Writing",
      "gold": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Design a negative test case by sending a request with an invalid or expired token. Expected: the API should return a `401 Unauthorized` or `403 Forbidden` status code, and the response body should indicate that the token is invalid."
    },
    {
      "question_id": "EQ2003",
      "question": "Which of the following is the most effective way to validate an API’s response time under simulated user load?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Manual sequential API calls with stopwatch measurement",
        "B": "Automated load test with concurrent virtual users",
        "C": "Single request execution and measuring response time",
        "D": "Unit testing with mocked responses"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Automated load test with concurrent virtual users.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Load testing with concurrent virtual users mimics real-world conditions."
    },
    {
      "question_id": "EQ2004",
      "type": "Writing",
      "gold": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "*   **Happy Path (Positive):** Test `POST /refund` with valid transaction ID and amount. **Expected:** `201 Created` with refund details, DB updated.\n*   **Error Path (Negative):** Test `POST /refund` with an invalid transaction ID (e.g., 'TRX-99999'). **Expected:** `404 Not Found` with error message 'Transaction not found'."
    },
    {
      "question_id": "EQ2005",
      "question": "Which practice reduces the flakiness of automated API tests running in CI/CD pipelines?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcoding API keys in scripts",
        "B": "Using random sleep delays before assertions",
        "C": "Running tests only once per release",
        "D": "Using stable test data and environment setup hooks"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Using stable test data and environment setup hooks. This ensures tests run consistently across different builds.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Stable test data and environment setup reduce randomness and flakiness."
    },
    {
      "question_id": "EQ2006",
      "type": "Writing",
      "gold": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "Run contract tests with old and new schemas, assert no breaking changes, and monitor production logs for validation errors."
    },
    {
      "question_id": "EQ2007",
      "question": "Which of the following represents a correct negative test for input validation on a date-of-birth field?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sending dateOfBirth=‘2025-13-40’",
        "B": "Sending dateOfBirth=‘1990-05-20’",
        "C": "Leaving dateOfBirth empty when optional",
        "D": "Sending dateOfBirth=‘2000-01-01’"
      },
      "gold_answer": "A",
      "model_raw_answer": "A correct negative test for a date-of-birth field would involve sending an invalid or malformed date. Options B, C, and D all represent valid dates. The correct negative test is sending a date with values that are invalid, such as option A: `dateOfBirth=‘2025-13-40’` because the day of the month is invalid (should be 1–31).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Invalid month/day makes it a correct negative input validation case."
    },
    {
      "question_id": "EQ2008",
      "type": "Writing",
      "gold": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "Mocking replaces the real bank service with a fake one. The test API sends a payment request to the mock, which responds with a predefined status (e.g., 'approved' or 'declined'). This allows testing payment logic without risking real transactions."
    },
    {
      "question_id": "EQ2009",
      "question": "Which monitoring approach helps detect sudden spikes in API error rates?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Code coverage reports",
        "B": "Manual log review every week",
        "C": "Real-time alerting on error rate metrics",
        "D": "Static code analysis"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Real-time alerting on error rate metrics.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Real-time alerting ensures immediate detection of error rate spikes."
    },
    {
      "question_id": "EQ2010",
      "type": "Writing",
      "gold": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "**Boundary Test (Positive):** Send a request with `age=18` (lower bound) and `age=65` (upper bound). Expected: Both `200 OK` with valid user data, as they fall within the defined range.\n  \n**Invalid Test:** Send a request with `age=0`. Expected: `400 Bad Request` with a validation error, as the age is below the minimum allowed."
    },
    {
      "question_id": "EQ2011",
      "question": "Which of these is an example of contract validation in API testing?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking response latency",
        "B": "Validating response JSON matches OpenAPI schema",
        "C": "Measuring server CPU load",
        "D": "Asserting SQL queries from logs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Validating response JSON matches OpenAPI schema.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Contract validation ensures responses match defined schemas."
    },
    {
      "question_id": "EQ2012",
      "type": "Writing",
      "gold": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "To simulate a network timeout, you would use a tool like `curl` or a programming language (e.g., Python with `requests`) to send an HTTP request to the API. You would then configure the request to wait longer than the API's expected timeout (e.g., `timeout=5s` when the API has a 3s timeout). The request will fail with a timeout error."
    },
    {
      "question_id": "EQ2013",
      "question": "Which scenario best represents an intermediate load test?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "10,000 concurrent users for stress testing",
        "B": "Single-user functional check",
        "C": "Unit testing one function",
        "D": "100–200 concurrent users simulating average traffic"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 100–200 concurrent users simulating average traffic.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Intermediate load tests simulate moderate, realistic user traffic."
    },
    {
      "question_id": "EQ2014",
      "type": "Writing",
      "gold": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "*   **Precondition:** The API service must be running and accessible at its base URL (`http://api.example.com`).\n    *   **Action Following Precondition:** A user can send a `GET /products` request to retrieve a list of products."
    },
    {
      "question_id": "EQ2015",
      "question": "Which approach helps detect unauthorized access attempts in an API?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Penetration test using invalid or missing tokens",
        "B": "Unit tests on helper functions",
        "C": "CI pipeline build success",
        "D": "Running API in debug mode"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Penetration test using invalid or missing tokens.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Penetration tests reveal weaknesses in authorization handling."
    },
    {
      "question_id": "EQ2016",
      "type": "Writing",
      "gold": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "**Test Case: Enforce Rate Limit**\n- **Preconditions:** Account configured with 100 requests/minute.\n- **Steps:**\n  1. Send first request → `200 OK`.\n  2. Send second request within 1 minute → `200 OK`.\n  3. Send third request within 1 minute → expect `429 Too Many Requests`.\n- **Expected:** Rate limit enforced exactly."
    },
    {
      "question_id": "EQ2017",
      "question": "Which strategy ensures reproducibility of integration API tests?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Running against random live production data",
        "B": "Using seeded test databases and reset scripts",
        "C": "Hardcoding timestamps in requests",
        "D": "Disabling cleanup steps after tests"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Using seeded test databases and reset scripts.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Seeded test data ensures consistent reproducibility."
    },
    {
      "question_id": "EQ2018",
      "type": "Writing",
      "gold": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "One advantage is that it allows testing of APIs before all dependent systems are available, thus reducing delays in testing."
    },
    {
      "question_id": "EQ2019",
      "question": "Which of these is an appropriate recovery step if API monitoring detects consistent 500 errors?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Ignore them until next release",
        "B": "Add random retry logic to all clients",
        "C": "Alert ops team and trigger rollback of recent deployment",
        "D": "Turn off error logs"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Alert ops team and trigger rollback of recent deployment.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Rollback and alerts ensure quick mitigation."
    },
    {
      "question_id": "EQ2020",
      "type": "Writing",
      "gold": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "*   **Positive Test Case:** Send valid credentials ('user@example.com'/ 'Password123') and expect a `200 OK` with an authentication token.\n    *   **Preconditions:** User account exists with known password.\n    *   **Test Steps:** Send POST request to login endpoint with correct credentials.\n    *   **Expected Result:** Token in response body, status `200 OK`.\n*   **Boundary Test Case (Negative):** Send password with maximum allowed length (e.g., 72 characters) or use 'Password123!@#'."
    },
    {
      "question_id": "EQ2021",
      "question": "Which of the following scenarios is an example of a chained API test case?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Calling GET /status repeatedly",
        "B": "Creating a user, then using that user’s ID in GET /profile",
        "C": "Testing an endpoint with invalid headers",
        "D": "Measuring average latency of one endpoint"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Creating a user, then using that user’s ID in GET /profile. This is an example of a chained API test case because it involves two distinct API calls, where the outcome of the first call (creating a user) is used as input for the second call (getting the user’s profile).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Chained test cases depend on output of one API being input to another."
    },
    {
      "question_id": "EQ2022",
      "type": "Writing",
      "gold": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Test Step: Send a `POST` request to `/upload` with a `Content-Type` header set to an unsupported format like `application/json`."
    },
    {
      "question_id": "EQ2023",
      "question": "Which practice helps detect contract violations early in a CI/CD pipeline?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Load testing in production only",
        "B": "Manual regression testing once a month",
        "C": "Schema validation tests integrated into pipeline",
        "D": "Using mocks for all external dependencies"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Schema validation tests integrated into pipeline.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Automated schema validation in CI/CD detects breaking changes quickly."
    },
    {
      "question_id": "EQ2024",
      "type": "Writing",
      "gold": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Precondition: API connected to mock DB with slow response. Test Step: Send request to API. Expected: API returns 200, but response time > 3s. Verify logs capture slow query warning."
    },
    {
      "question_id": "EQ2025",
      "question": "Which of the following is an example of a negative authorization test?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Calling DELETE /users without admin privileges",
        "B": "Calling GET /users with valid token",
        "C": "Logging in with valid credentials",
        "D": "Refreshing a valid session token"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Calling DELETE /users without admin privileges. This is a negative test as it expects the action to fail, which it should, because the user does not have the necessary role (admin).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Attempting to delete users without privileges tests access restrictions."
    },
    {
      "question_id": "EQ2026",
      "type": "Writing",
      "gold": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Test by sending the same `PUT /orders/{id}` request multiple times. Expected: 1st request → `200 OK` and DB updated. 2nd+ requests → `200 OK` but no further changes. Confirm DB state remains consistent after retries."
    },
    {
      "question_id": "EQ2027",
      "question": "Which method ensures sensitive API keys are not exposed during automated testing?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcoding them in test scripts",
        "B": "Printing them in CI/CD logs",
        "C": "Storing them in public GitHub repos",
        "D": "Using encrypted environment variables"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Using encrypted environment variables.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Encrypted env variables keep secrets secure."
    },
    {
      "question_id": "EQ2028",
      "type": "Writing",
      "gold": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "*   **Boundary Test:** Upload a 5 MB file (e.g., a zip archive) to verify it's successfully processed.\n    *   **Action:** Send a `POST` request with the file attached.\n    *   **Expected:** `200 OK` with the file stored, or the file ID in the response body.\n*   **Invalid Test:** Upload a file larger than 5 MB (e.g., a 10 MB video file).\n    *   **Action:** Send the same `POST` request but with a larger file.\n    *   **Expected:** The API should return a `400 Bad Request` or `413 Payload Too Large` error."
    },
    {
      "question_id": "EQ2029",
      "question": "Which monitoring metric would best indicate a memory leak in an API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Spike in average latency",
        "B": "Steadily increasing memory usage",
        "C": "Decreasing CPU utilization",
        "D": "Random increase in cache hit ratio"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Steadily increasing memory usage.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "A memory leak manifests as continuously rising memory usage."
    },
    {
      "question_id": "EQ2030",
      "type": "Writing",
      "gold": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "### **Test Case: Missing Required Field 'email'**\n- **Test Case ID:** TC-007\n- **Test Case Name:** Verify API rejects request without required 'email' field.\n- **Preconditions:** The API is running.\n- **Test Steps:**\n  1. Send a `POST` request to the user registration endpoint with a JSON body that **does not include the 'email' field**.\n- **Expected Result:**\n  - The API returns a **`400 Bad Request` status code.**\n  - The response body contains an error message that specifically mentions the 'email' field is required."
    },
    {
      "question_id": "EQ2031",
      "question": "Which of the following best describes service virtualization?",
      "type": "MCQ",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Running APIs only in production",
        "B": "Using local database replicas",
        "C": "Simulating unavailable dependencies with virtual services",
        "D": "Replacing backend logic with new microservices"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Simulating unavailable dependencies with virtual services.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Service virtualization allows testing without real dependencies."
    },
    {
      "question_id": "EQ2032",
      "type": "Writing",
      "gold": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "Preconditions: API configured to retry failed requests. Steps: 1) Send request that triggers 503. 2) Verify initial request fails. 3) Verify subsequent retry attempts succeed. 4) Monitor retry count to ensure it doesn't exceed limits."
    },
    {
      "question_id": "EQ2033",
      "question": "Which error scenario best represents a client-side failure?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "HTTP 400 Bad Request",
        "B": "HTTP 500 Internal Server Error",
        "C": "Database timeout",
        "D": "Out-of-memory on server"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. HTTP 400 Bad Request. This is a client-side failure because it indicates the request itself was malformed or incorrect.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "400 Bad Request indicates client-side invalid request."
    },
    {
      "question_id": "EQ2034",
      "type": "Writing",
      "gold": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "### **Test Case: Log Correlation via Trace ID**\n- **Test Case ID:** TC-LOG-CORR-001\n- **Test Case Name:** Verify logs are correlated using a Trace ID header.\n- **Preconditions:**\n  - API configured to propagate Trace ID in headers.\n  - Distributed Tracing enabled.\n- **Test Steps:**\n  1. Send a request to an API (`/process-order`) that generates multiple logs.\n  2. Include a known Trace ID header (`X-Trace-ID: trace-id-123`) in the request.\n- **Expected Result:**\n  - All logs generated for the API request should contain the exact same Trace ID (`trace-id-123`) in their metadata."
    },
    {
      "question_id": "EQ2035",
      "question": "Which of these scenarios requires schema validation during testing?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking average API response time",
        "B": "Ensuring response JSON fields match OpenAPI definition",
        "C": "Measuring throughput under load",
        "D": "Analyzing SQL query logs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Ensuring response JSON fields match OpenAPI definition.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Schema validation ensures structural correctness of responses."
    },
    {
      "question_id": "EQ2036",
      "type": "Writing",
      "gold": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "**Test Case: Multi-Client Rate Limit Enforcement**\n- **Preconditions:** Two API clients (Client A and Client B) with identical rate limits (100 requests/minute).\n- **Steps:**\n  - Client A sends 50 requests in first 30 seconds → expect `200 OK`.\n  - Immediately after, Client B sends 50 requests → expect all `200 OK`.\n  - If Client A exceeds limit, Client B should still receive `200 OK` for remaining allowed requests.\n  - After rate limit is exhausted, both clients should receive `429 Too Many Requests`.\n- **Expected Result:** Both clients must adhere to rate limit, and API must prevent abuse."
    },
    {
      "question_id": "EQ2037",
      "question": "Which of the following improves reproducibility of API tests in multiple environments?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Using hardcoded environment URLs",
        "B": "Randomizing all test data",
        "C": "Executing tests against production data",
        "D": "Parameterizing endpoints and using environment configs"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Parameterizing endpoints and using environment configs. This approach ensures that test steps and data are consistent across different environments.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Parameterization ensures same test logic works across environments."
    },
    {
      "question_id": "EQ2038",
      "type": "Writing",
      "gold": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "**Positive:** Send a valid phone number (+1-202-555-0123) and verify a 200 OK response with an SMS code. **Negative:** Send a phone number with an invalid format (‘999-999-9999’) and verify a 400 Bad Request error."
    },
    {
      "question_id": "EQ2039",
      "question": "Which of these best describes performance baseline testing?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Measuring normal response times under expected load",
        "B": "Testing API with invalid inputs",
        "C": "Validating API against OpenAPI spec",
        "D": "Simulating 10x peak traffic"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Measuring normal response times under expected load.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Baseline testing captures normal expected performance."
    },
    {
      "question_id": "EQ2040",
      "type": "Writing",
      "gold": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "One advantage is that it prevents real-world failures from impacting test stability or reliability. For example, instead of relying on a specific payment gateway to fail, a test can mock the gateway to respond with a known error code, allowing consistent and repeatable test cases."
    },
    {
      "question_id": "EQ2041",
      "question": "Which of these is a correct test case for validating session expiration?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Login with valid credentials, expect 200 OK",
        "B": "Send request with valid token immediately after login",
        "C": "Send request with token after session timeout, expect 401 Unauthorized",
        "D": "Send request without token, expect 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Send request with token after session timeout, expect 401 Unauthorized.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Expired sessions must return 401 Unauthorized."
    },
    {
      "question_id": "EQ2042",
      "type": "Writing",
      "gold": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "**Test Case: Malformed JSON Response**\n- **Preconditions:** API endpoint `/products` is configured to return invalid JSON (e.g., missing quote, syntax error).\n- **Test Steps:**\n  1. Send a `GET` request to `/products`.\n- **Expected Result:**\n  - The API returns a successful status code (e.g., `200 OK`).\n  - The response body is parsed and verified to contain the error message.\n  - The response is not a valid JSON object."
    },
    {
      "question_id": "EQ2043",
      "question": "Which strategy helps validate backward compatibility after adding new optional fields?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Ensure older clients still work without sending new fields",
        "B": "Force clients to update immediately",
        "C": "Remove old fields from responses",
        "D": "Require schema changes to be breaking"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. This strategy ensures that older clients do not break when new optional fields are introduced.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Backward compatibility means old clients should still function without new fields."
    },
    {
      "question_id": "EQ2044",
      "type": "Writing",
      "gold": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "**Test Step:** 1) Send a request to a rate-limited endpoint. 2) Verify the response body or headers contain a rate limit count (e.g., `X-RateLimit-Remaining`). 3) Repeat until the limit is exceeded, then confirm the count is 0."
    },
    {
      "question_id": "EQ2045",
      "question": "Which is the most effective way to test resilience when an API’s downstream service fails?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "options": {
        "A": "Disable retries in client",
        "B": "Stop testing until service recovers",
        "C": "Run unit tests only",
        "D": "Inject failures using chaos testing or mocks"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Inject failures using chaos testing or mocks.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Chaos testing/mocks allow controlled simulation of dependency failures."
    },
    {
      "question_id": "EQ2046",
      "type": "Writing",
      "gold": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic improves reusability and reduces maintenance. With separate data, the same test script can be executed multiple times with different inputs, making it ideal for data-driven testing and ensuring the API handles various valid and invalid data scenarios correctly."
    },
    {
      "question_id": "EQ2047",
      "question": "Which response status code is appropriate for a request blocked due to missing authorization header?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "C. 403 Forbidden",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Missing authorization results in 401 Unauthorized."
    },
    {
      "question_id": "EQ2048",
      "type": "Writing",
      "gold": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "### **Test Case: Cache Unavailability**\n- **Test Case ID:** TC-APIC-008\n- **Test Case Name:** Verify API response when cache service is down.\n- **Preconditions:**\n  - API is deployed.\n  - Cache service is mocked.\n  - API configured to use cache.\n- **Test Steps:**\n  1. Send request for a cached resource.\n  2. Verify API returns `503 Service Unavailable` or `500 Internal Server Error`.\n  3. Confirm database query is executed to return response.\n- **Expected Result:** API gracefully handles cache unavailability by falling back to DB."
    },
    {
      "question_id": "EQ2049",
      "question": "Which of the following represents a proper boundary test for a password length field (min=8, max=20)?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Testing with 7, 8, 20, and 21 characters",
        "B": "Testing with 10 characters only",
        "C": "Testing with 15 characters only",
        "D": "Testing with empty password only"
      },
      "gold_answer": "A",
      "model_raw_answer": "A proper boundary test for a password length field (min=8, max=20) would include testing with the minimum value, the maximum value, and possibly one value in between. \n\nThe correct answer is: A. Testing with 7, 8, 20, and 21 characters.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Boundary testing includes values at, below, and above limits."
    },
    {
      "question_id": "EQ2050",
      "type": "Writing",
      "gold": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "Preconditions: API configured to log requests and responses. Test Case: Send a request with a known password. Verification: Check the log output, assert that the password field is masked or not logged at all."
    },
    {
      "question_id": "EQ2051",
      "question": "Which monitoring method helps identify gradual latency increases over weeks?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Single request stopwatch timing",
        "B": "Manual debugging during incidents",
        "C": "Time-series trend analysis with dashboards",
        "D": "Code coverage metrics"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Time-series trend analysis with dashboards.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Dashboards and time-series monitoring highlight latency trends."
    },
    {
      "question_id": "EQ2052",
      "type": "Writing",
      "gold": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "**Negative:** Test with 'XXX' (invalid code). **Boundary:** Test with 'USD' (common edge) and 'EUR' (another common edge)."
    },
    {
      "question_id": "EQ2053",
      "question": "Which strategy ensures contract tests remain useful when APIs evolve?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Never updating schema tests",
        "B": "Removing optional fields from tests",
        "C": "Running only manual regression tests",
        "D": "Versioning schema contracts and maintaining backward compatibility"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Versioning schema contracts and maintaining backward compatibility ensures that contract tests remain useful when APIs evolve.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Versioning and backward compatibility keep contract tests reliable."
    },
    {
      "question_id": "EQ2054",
      "type": "Writing",
      "gold": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "**Test Case: Network Packet Loss**\n- **Preconditions:** Simulate 10% packet loss between client and server.\n- **Steps:** Send 3 requests: one complete, one with corrupted payload, one with missing header.\n- **Expected:** Server returns `500 Internal Server Error` for corrupted, `400 Bad Request` for missing header. Complete request succeeds."
    },
    {
      "question_id": "EQ2055",
      "question": "Which of these scenarios correctly validates API observability using distributed tracing?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking only HTTP status codes",
        "B": "Following a trace ID across multiple microservices",
        "C": "Checking memory usage in server logs",
        "D": "Using manual testing notes"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Following a trace ID across multiple microservices.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tracing IDs track requests across services."
    },
    {
      "question_id": "EQ2056",
      "type": "Writing",
      "gold": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "One method is to run a 'cleanup verification' test case immediately after the main test. This secondary test queries the database to confirm that all test-created data (e.g., users, orders) has been successfully deleted."
    },
    {
      "question_id": "EQ2057",
      "question": "Which of the following indicates a denial-of-service vulnerability?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "API accepts unlimited requests without throttling",
        "B": "API returns 404 Not Found",
        "C": "API schema missing a description field",
        "D": "Unit test coverage is low"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. API accepts unlimited requests without throttling.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Unrestricted requests can exhaust resources, causing DoS."
    },
    {
      "question_id": "EQ2058",
      "type": "Writing",
      "gold": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "### **Test Case: Partial Transaction Rollback**\n- **Test Case ID:** TC-TRX-007\n- **Test Case Name:** Verify rollback when intermediate step fails in multi-step transaction.\n- **Preconditions:**\n  - API configured for transactions (e.g., SQL transactions, distributed locks).\n  - Initial data: `user_id=999` exists, `product_id=999` exists, `order_id=999` does not exist.\n- **Test Steps:**\n  1. **Transaction Initiation:** Send `POST /orders` request with `user_id=999` and `product_id=999`.\n  2. **Intermediate Failure:** After first step, before final step, manually delete `order_id=999` from DB (simulating failure).\n  3. **Final Attempt:** Send `PUT /orders/{order_id}` (e.g., to set status to'shipped') for the non-existent `order_id=999`.\n- **Expected Result:**\n  - The API responds with a `409 Conflict` or `500 Internal Server Error` for the final step, indicating rollback.\n  - Upon checking the DB, confirm that `order_id=999` was never created, and no partial order state (e.g., `user_id=999` with no products) exists."
    },
    {
      "question_id": "EQ2059",
      "question": "Which HTTP status code should be validated when an API request is well-formed but forbidden due to role restrictions?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden indicates client is authenticated but not authorized."
    },
    {
      "question_id": "EQ2060",
      "type": "Writing",
      "gold": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "1. **Define a JSON Schema for Error Responses:** Establish a base schema (e.g., `{\"error\": string, \"code\": int, \"details\": array}`) that all endpoints must follow.\n2. **Automated Validation:** Use a tool like Postman or Insomnia to send invalid requests to all endpoints.\n3. **Validation Assertion:** For each endpoint, assert that the response body conforms to the defined error schema."
    },
    {
      "question_id": "EQ3001",
      "question": "Which of the following scenarios best represents a multi-hop test involving login and refresh token endpoints?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Send a request to GET /health",
        "B": "Obtain access token via POST /login, then use POST /refresh to extend session",
        "C": "Send request with expired token to protected endpoint",
        "D": "Check status 200 on GET /docs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. This option describes a multi-hop test where two distinct API endpoints are sequentially used: first, to obtain an access token (login), and second, to use that token to extend the session (refresh).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Multi-hop testing means chaining login with subsequent refresh token usage."
    },
    {
      "question_id": "EQ3002",
      "type": "Writing",
      "gold": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "**Test Case: Token Refresh**\n- **Preconditions:** User login generates a short-lived token (TTL=10m).\n- **Steps:**\n  - Request API with expired token → `403 Forbidden`.\n  - Refresh token → expect new valid token.\n  - Use refreshed token to access protected API → `200 OK`.\n- **Expected:** Tokens refreshed successfully."
    },
    {
      "question_id": "EQ3003",
      "question": "Which HTTP status code should a server return when a refresh token is expired?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "401 Unauthorized",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 401 Unauthorized.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Expired refresh token means the client must log in again → 401 Unauthorized."
    },
    {
      "question_id": "EQ3004",
      "type": "Writing",
      "gold": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. **Initial Attempt:** Send a `POST /login` request with an incorrect password. 2. **Assert First Failure:** Confirm the login fails. 3. **Second Attempt:** Immediately send another `POST /login` request. 4. **Assert No Token:** Verify no access token or refresh token is returned. 5. **Assert Session:** Check the session state to confirm it was not inadvertently created."
    },
    {
      "question_id": "EQ3005",
      "question": "Which of the following maps an application-specific error code to the correct HTTP status?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "APP_1001 (User not found) → 404 Not Found",
        "B": "APP_2002 (Invalid password) → 201 Created",
        "C": "APP_3003 (Success) → 500 Internal Server Error",
        "D": "APP_9999 (Database error) → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. APP_1001 (User not found) → 404 Not Found",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Mapping user-not-found to 404 is the correct HTTP translation."
    },
    {
      "question_id": "EQ3006",
      "type": "Writing",
      "gold": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Create a test suite with scenarios covering positive (e.g., successful order creation) and negative paths (e.g., invalid product, duplicate order). For each, assert that the HTTP status code (e.g., `201` Created, `400` Bad Request, `409` Conflict) is correct. Finally, verify that the response body includes the corresponding business-specific error code (e.g., `ORDER_001` for duplicate order)."
    },
    {
      "question_id": "EQ3007",
      "question": "Which scenario demonstrates chained negative testing?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Testing single GET /status request",
        "B": "Valid login followed by accessing /profile",
        "C": "Checking server uptime with GET /health",
        "D": "Logging in with expired password → 401, then retrying refresh token → 401"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Logging in with expired password → 401, then retrying refresh token → 401.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Chained negative tests validate failures across endpoints."
    },
    {
      "question_id": "EQ3008",
      "type": "Writing",
      "gold": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "### **Test Case: Full Order Lifecycle**\n- **Preconditions:** User exists, inventory > 0, test order ID.\n- **Steps:**\n  1. **Create Order:** `/orders` with items → `201 Created`.\n  2. **Process Payment:** `/payments` for order → `201 Created`.\n  3. **Confirm Shipment:** `/ships` for order → `200 OK`.\n  4. **Initiate Refund:** `/refunds` for order → `201 Created`.\n- **Expected:** All steps succeed, order status changes accordingly."
    },
    {
      "question_id": "EQ3009",
      "question": "Which HTTP status code is correct for mapping a custom error ORDER_DUPLICATE to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "404 Not Found",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 409 Conflict",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Duplicate order is a conflict → 409."
    },
    {
      "question_id": "EQ3010",
      "type": "Writing",
      "gold": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "**Test Case: Token Refresh Across Services**\n- **Preconditions:** API Consumer Service (A) and Token Refresh Service (B) both running. User token expired.\n- **Test Steps:**\n  1. Service A → Request protected resource → 403 Forbidden (expired token).\n  2. Service B → Receive refresh request → Obtain new token.\n- **Expected Result:** Service A should be able to retry the request with the new token, succeeding this time."
    },
    {
      "question_id": "EQ3011",
      "question": "Which scenario correctly validates multi-hop error handling in an e-commerce workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Create order → invalid payment details → 402 Payment Required",
        "B": "Check inventory → product exists → 200 OK",
        "C": "Call healthcheck endpoint → 200 OK",
        "D": "Request product catalog → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct scenario. It validates that the API correctly handles an invalid payment scenario by returning a 402 Payment Required status, which is the standard HTTP status code for payment processing errors.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Payment failure after order creation is a multi-hop negative test."
    },
    {
      "question_id": "EQ3012",
      "type": "Writing",
      "gold": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "**Test Case: Validation Error Mapping**\n- **Preconditions:** API configured with custom validation error codes.\n- **Steps:**\n  - Request with invalid field (e.g., `/users` with non-unique username) → 400 Bad Request.\n  - Assert response body contains specific error code (e.g., `{\"error_code\": \"INVALID_INPUT\"}`).\n  - Verify error message is descriptive.\n- **Expected:** API returns correct HTTP status and error details."
    },
    {
      "question_id": "EQ3013",
      "question": "Which of these represents a hard-level chained login test?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Only testing GET /login-docs",
        "B": "Logging in once and stopping",
        "C": "Login → refresh token → logout → confirm refresh fails",
        "D": "Checking GET /health endpoint"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Login → refresh token → logout → confirm refresh fails.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Combines multiple endpoints into a workflow validation."
    },
    {
      "question_id": "EQ3014",
      "type": "Writing",
      "gold": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "### **Test Case: Expired Refresh Token**\n- **Test Case ID:** TC-005\n- **Preconditions:** A refresh token is generated 30 minutes ago and has expired.\n- **Test Steps:**\n  1. Send a `POST /refresh-token` request with the expired refresh token.\n- **Expected Result:** The API returns a `400 Bad Request` or `401 Unauthorized` status with an error message like 'Refresh token has expired' or 'Invalid refresh token'. The response body should not contain an access token."
    },
    {
      "question_id": "EQ3015",
      "question": "Which mapping is correct for business error PAYMENT_DECLINED?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 402 Payment Required – This is the correct HTTP status code for indicating that the payment is required but has not been processed.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Payment declined → 402 Payment Required."
    },
    {
      "question_id": "EQ3016",
      "type": "Writing",
      "gold": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Test case: 1) Login → obtain session token. 2) Send request with token → `200 OK`. 3) Logout endpoint → session invalidated. 4) Repeat request with old token → `401 Unauthorized`."
    },
    {
      "question_id": "EQ3017",
      "question": "Which scenario maps to the correct HTTP code for an internal application error?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "APP_TIMEOUT → 200 OK",
        "B": "APP_TIMEOUT → 504 Gateway Timeout",
        "C": "APP_TIMEOUT → 201 Created",
        "D": "APP_TIMEOUT → 400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. APP_TIMEOUT → 504 Gateway Timeout",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Timeouts should map to 504 Gateway Timeout."
    },
    {
      "question_id": "EQ3018",
      "type": "Writing",
      "gold": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "### **Test Case: Full User Flow**\n- **Preconditions:** API available, mail service mocked.\n- **Steps:**\n  - **Signup:** Send `POST /signup` with valid email/password → `200 OK` with user data and email verification link.\n  - **Email Verification:** Send `POST /verify-email` with link token → `200 OK` with success message.\n  - **Login:** Send `POST /login` with verified user's email/password → `200 OK` with auth token.\n- **Expected:** All steps succeed, user accessible only after email verified."
    },
    {
      "question_id": "EQ3019",
      "question": "Which test validates chained role-based access?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login as user → access /admin → expect 403 Forbidden",
        "B": "Login as admin → access /admin → expect 200 OK",
        "C": "Login as user → view profile → 200 OK",
        "D": "GET /health → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. This test validates role chaining by ensuring a user cannot access an admin-only resource.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Role mismatch leading to 403 is a multi-hop role validation."
    },
    {
      "question_id": "EQ3020",
      "type": "Writing",
      "gold": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "**Test Case: Password Reset Flow**\n1. **Preconditions:** User 'user123' exists, email verified.\n2. **Steps:**\n   - Send password reset request → expect `200 OK`.\n   - Extract reset token from email.\n   - Use token to reset to new password → `200 OK`.\n   - Log in with new password → `200 OK`.\n   - Attempt reset again with same email → expect `400 Bad Request`.\n3. **Expected:** All steps succeed, new password valid, repeated reset fails."
    },
    {
      "question_id": "EQ3021",
      "question": "Which scenario validates a chained login, refresh, and logout sequence?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → use token once",
        "B": "Refresh token immediately after login",
        "C": "Logout only",
        "D": "Login → refresh token → logout → confirm refresh fails"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. This validates full sequence and negative case.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "This full sequence tests the entire authentication lifecycle."
    },
    {
      "question_id": "EQ3022",
      "type": "Writing",
      "gold": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "**Test Case: User Profile Management**\n- **Preconditions:** User API enabled, test user exists.\n- **Test Steps:**\n  - **Create User:** Send `POST /users` with email and password.\n  - **Update Profile:** Send `PUT /users/{id}` with new profile info.\n  - **Retrieve Profile:** Send `GET /users/{id}` to verify updated profile.\n- **Expected Result:** All requests succeed, profile info matches updates."
    },
    {
      "question_id": "EQ3023",
      "question": "Which mapping correctly translates a business error STOCK_OUT to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "201 Created",
        "D": "403 Forbidden"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 409 Conflict",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Stock-out means a conflict with order fulfillment, mapping to 409."
    },
    {
      "question_id": "EQ3024",
      "type": "Writing",
      "gold": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "Test Case: \n1. User logs in, receives access and refresh tokens.\n2. User logs out (invalidate session).\n3. Attempt to use refresh token to get new access token.\n4. Expected: 403 Forbidden or 401 Unauthorized, as logout invalidates refresh token."
    },
    {
      "question_id": "EQ3025",
      "question": "Which scenario validates chained negative testing for a shopping cart workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Add valid item to cart → 200 OK",
        "B": "Checkout with valid payment → 200 OK",
        "C": "Add item → remove item → checkout → expect 400 Bad Request",
        "D": "View cart after login → 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. This validates that the system prevents checkout when the cart is invalid (no items).",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Empty cart checkout is a chained negative scenario."
    },
    {
      "question_id": "EQ3026",
      "type": "Writing",
      "gold": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "### **Test Case: Verify Authentication Expiration**\n-   **Test Case ID:** TC-005\n-   **Test Case Name:** Confirm correct HTTP status returned for expired authentication.\n-   **Preconditions:**\n    -   Authentication service mocked.\n    -   Token expiration configured (e.g., 1 minute).\n-   **Test Steps:**\n    1. Send request to protected endpoint *after* token has expired.\n-   **Expected Result:** The API returns a `401 Unauthorized` HTTP status code."
    },
    {
      "question_id": "EQ3027",
      "question": "Which scenario best validates chained order cancellation?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Hard",
      "options": {
        "A": "Create order → cancel order → GET /orders/{id} shows status=cancelled",
        "B": "Cancel non-existent order → 404",
        "C": "Create order only",
        "D": "Check /status endpoint"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. This scenario validates the entire flow of creating an order and then cancelling it, and finally checking the API response to confirm the status.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Covers lifecycle of order creation → cancellation → verification."
    },
    {
      "question_id": "EQ3028",
      "type": "Writing",
      "gold": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Request email verification with known invalid token. 2) Assert API returns `400 Bad Request` or `401 Unauthorized`. 3) Confirm user remains unverified."
    },
    {
      "question_id": "EQ3029",
      "question": "Which mapping correctly translates FILE_TOO_LARGE to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "404 Not Found",
        "D": "413 Payload Too Large"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 413 Payload Too Large",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "File too large should map to 413."
    },
    {
      "question_id": "EQ3030",
      "type": "Writing",
      "gold": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "**Test Case: Loan Approval Flow**\n- **Preconditions:** User exists, credit score = 700.\n- **Steps:**\n  1. `POST /loans` with $100k, 60 months → 200 OK with loan ID.\n  2. `GET /credit-check` with loan ID → 200 OK with credit score.\n  3. `POST /loans/{id}/approve` → 200 OK with approval message.\n- **Expected:** Loans approved only if valid."
    },
    {
      "question_id": "EQ3031",
      "question": "Which chained sequence validates refresh tokens across multiple sessions?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → logout only",
        "B": "Login → refresh token → logout → login again → confirm old refresh invalid",
        "C": "Refresh token without login",
        "D": "Check GET /status"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Login → refresh token → logout → login again → confirm old refresh invalid.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Ensures session handling across multiple logins."
    },
    {
      "question_id": "EQ3032",
      "type": "Writing",
      "gold": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "**Test Case: Credential Flow**\n- **Scenario:** User signs up (email=user@example.com, password=Strong123).\n- **Action 1:** Request password reset via email.\n- **Action 2:** Change new password → login with new credentials.\n- **Expected:** Successful login with new password."
    },
    {
      "question_id": "EQ3033",
      "question": "Which mapping is correct for mapping business error INVALID_COUPON?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request - Because INVALID_COUPON is an input validation error.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Invalid coupon should map to 400 Bad Request."
    },
    {
      "question_id": "EQ3034",
      "type": "Writing",
      "gold": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "### **Test Case: Secure File Transfer**\n- **Preconditions:** File upload API available, virus scan service integrated, safe file (e.g., PDF) and malicious file (e.g., virus payload) prepared.\n- **Steps:**\n  - **Upload:** Send safe file → `200 OK`, file ID stored.\n  - **Scan:** Call virus scan endpoint with file ID → `202 Accepted` if clean, `400 Bad Request` if infected.\n  - **Download:** Attempt safe file download → `200 OK`, file available.\n  - **Negative:** Try downloading file ID that doesn't exist → `404 Not Found`.\n- **Expected:** Only clean files available for download."
    },
    {
      "question_id": "EQ3035",
      "question": "Which scenario validates correct multi-hop error mapping in payment workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Payment API returns DECLINED → mapped to HTTP 402",
        "B": "Payment API returns APPROVED → mapped to HTTP 404",
        "C": "Payment API returns DECLINED → mapped to HTTP 201",
        "D": "Payment API returns ERROR → mapped to HTTP 200"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is correct. Validating that a declined payment status is correctly mapped to a specific HTTP status code (e.g., `HTTP 402 Payment Required`) is a key part of multi-hop error mapping in a payment workflow.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Payment declined correctly maps to 402 Payment Required."
    },
    {
      "question_id": "EQ3036",
      "type": "Writing",
      "gold": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "Test Case: \"Refresh Token Reuse Attempt.\"\n1. **Action 1:** Obtain a refresh token.\n2. **Action 2:** Attempt to use the same refresh token multiple times.\n3. **Expected Result:** Second and subsequent attempts fail with `409 Conflict` or `403 Forbidden`."
    },
    {
      "question_id": "EQ3037",
      "question": "Which mapping is correct for mapping RATE_LIMIT_EXCEEDED to HTTP?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 429 Too Many Requests.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rate limits exceeded should map to 429."
    },
    {
      "question_id": "EQ3038",
      "type": "Writing",
      "gold": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "### **Test Case: Full E-commerce Flow**\n- **Preconditions:** User authenticated, catalog seeded.\n- **Steps:**\n  - **Search:** Send product name search request → assert results.\n  - **Add to Cart:** Product ID → 201 Created.\n  - **Checkout:** Cart ID → 201 Created.\n- **Expected:** All steps succeed, DB reflects order creation."
    },
    {
      "question_id": "EQ3039",
      "question": "Which scenario validates chained negative testing in ticket booking workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Book valid ticket → 200 OK",
        "B": "Book ticket → cancel ticket → attempt refund → expect 400 Bad Request",
        "C": "View available seats → 200 OK",
        "D": "Check GET /status → 200 OK"
      },
      "gold_answer": "B",
      "model_raw_answer": "B is the correct answer because it validates chained negative testing. The scenario tests a sequence of invalid actions: booking a ticket (valid), then attempting to cancel it (invalid), and finally trying to refund it (invalid). The correct expectation is that the last API call (attempt refund) fails with a 400 Bad Request.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Chained negative: refunding after cancel is invalid."
    },
    {
      "question_id": "EQ3040",
      "type": "Writing",
      "gold": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "Chained Test: 1) Log in as User A → get Session Cookie. 2) Send request with User A's Cookie to protected resource. 3) Assert `401 Unauthorized` or `403 Forbidden`. Preconditions: API must validate session cookie signatures or tokens."
    },
    {
      "question_id": "EQ3041",
      "question": "Which chained flow correctly validates token rotation with refresh token reuse detection?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → call API once → logout",
        "B": "Login → refresh token → attempt reuse of old refresh → expect 401 Unauthorized",
        "C": "Login only",
        "D": "Refresh without login"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Login → refresh token → attempt reuse of old refresh → expect 401 Unauthorized.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Token reuse must be rejected after rotation to prevent replay attacks."
    },
    {
      "question_id": "EQ3042",
      "type": "Writing",
      "gold": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "### **Test Case: Optimistic Concurrency with ETag**\n- **Preconditions:** Item ID=789 exists with ETag='v1'.\n- **Steps:**\n  - **Action 1:** Update Item → new ETag='v2'.\n  - **Action 2:** Send request with old ETag ('v1') → expect `409 Conflict`.\n- **Expected:** DB state unchanged, `v2` ETag used if valid."
    },
    {
      "question_id": "EQ3043",
      "question": "Which HTTP status should be returned when an If-Match precondition fails due to stale ETag during PUT /resource/{id}?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "412 Precondition Failed",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 412 Precondition Failed",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Stale ETag should map to 412 Precondition Failed."
    },
    {
      "question_id": "EQ3044",
      "type": "Writing",
      "gold": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "This test validates asynchronous export processing."
    },
    {
      "question_id": "EQ3045",
      "question": "Which mapping from business code to HTTP is most appropriate for RESOURCE_VERSION_CONFLICT during update?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict is the most appropriate because it indicates a conflict with the current state of the resource (e.g., another user updated it first), which is exactly what happens during a version conflict.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Version conflict maps correctly to 409 Conflict."
    },
    {
      "question_id": "EQ3046",
      "type": "Writing",
      "gold": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Test steps: 1) Client requests authorization with scope'read'. 2) Server grants. 3) Client exchanges code for token. 4) Call resource. Expected: `403 Forbidden` because missing scope 'write'."
    },
    {
      "question_id": "EQ3047",
      "question": "Which status code best represents a refresh token presented to the wrong client_id in a multi-tenant system?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 400 Bad Request",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "OAuth2 specifies invalid_grant (400) for wrong client/refresh usage."
    },
    {
      "question_id": "EQ3048",
      "type": "Writing",
      "gold": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. **Charge Creation**: Send `POST /charge` with $100 amount → `201 Created` with ID and key.\n2. **First Retry**: Send identical `POST /charge` → `200 OK`, DB unchanged.\n3. **Second Request**: Send again → `200 OK`, DB still unchanged.\n4. **Refund**: Send `POST /charge/{id}/refund` with valid key → `200 OK`.\n5. **Second Refund Attempt**: Send identical refund → `200 OK`, DB unchanged.\n6. **Verify DB**: Ensure only one successful transaction."
    },
    {
      "question_id": "EQ3049",
      "question": "Which status mapping is correct for business code INSUFFICIENT_FUNDS from payment gateway?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 402 Payment Required.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Insufficient funds → 402 Payment Required."
    },
    {
      "question_id": "EQ3050",
      "type": "Writing",
      "gold": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "**Test Case: File Processing Pipeline**\n- **Preconditions:** File `input.txt` exists.\n- **Steps:**\n  1. Upload file via `PUT /files` → store ID `file_id`.\n  2. Send `POST /process` with `file_id` → expect `202 Accepted`.\n  3. Poll status until `finished` → verify response.\n  4. Download processed file via `GET /files/{file_id}` → assert contents.\n- **Expected:** File processed successfully, no corrupt data."
    },
    {
      "question_id": "EQ3051",
      "question": "Which scenario correctly validates backoff + retry policy across gateway 429 -> 200 transitions?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "options": {
        "A": "API returns 429 Too Many Requests → client retries with backoff → 200 OK",
        "B": "API returns 401 Unauthorized → retry succeeds",
        "C": "API returns 404 Not Found → retry succeeds",
        "D": "API returns 500 → retry without backoff"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. API returns 429 Too Many Requests → client retries with backoff → 200 OK.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Retry with exponential backoff is required for 429 handling."
    },
    {
      "question_id": "EQ3052",
      "type": "Writing",
      "gold": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "**Test Case: SSO Session Revocation Chained**\n- **Preconditions:** User logged in with valid SSO token. API Gateway and Microservice both configured to use SSO token for authentication.\n- **Action:** Send revocation request to SSO provider (e.g., via logout endpoint).\n- **Verification:**\n  - API Gateway returns `403 Forbidden` or `401 Unauthorized` for subsequent requests from the revoked user.\n  - Microservice API also rejects requests from the same user with a suitable error code (e.g., `403 Forbidden`).\n  - No sensitive data exposed during failed access attempts."
    },
    {
      "question_id": "EQ3053",
      "question": "Which HTTP code should map to BUSINESS_LIMIT_EXCEEDED when per-user quota blocks a valid, authenticated request?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 429 Too Many Requests. This is the standard HTTP status code for rate limit exceeded conditions.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Quota exhaustion maps to 429 Too Many Requests."
    },
    {
      "question_id": "EQ3054",
      "type": "Writing",
      "gold": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "**Test Case: Partial Order with Inventory Management**\n- **Preconditions:** Product stock = 5, initial balance = $100.\n- **Steps:**\n  1. **Create Order:** Place order for 3 units (partial of stock) → `200 OK`.\n  2. **Verify State:** Stock = 2, order status = 'partially shipped'.\n  3. **Partial Ship:** Ship 2 units → `200 OK`.\n  4. **Cancel Remaining:** Cancel 1 unit → `200 OK`.\n  5. **Assert:** Stock = 2, order status = 'cancelled', refund = $50.\n- **Expected:** All transitions valid, correct inventory and balance changes."
    },
    {
      "question_id": "EQ3055",
      "question": "Which mapping is most accurate for error code SIGNATURE_INVALID on webhook delivery verification?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "A. 200 OK\nExplanation: A 'SIGNATURE_INVALID' error means the webhook signature verification failed. This is a request-level validation issue, not a resource or authentication problem. A 200 OK is the most appropriate HTTP status code to indicate that the request was understood, but the specific action (in this case, delivering the webhook event) failed due to validation issues.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Invalid webhook signature should return 401 Unauthorized."
    },
    {
      "question_id": "EQ3056",
      "type": "Writing",
      "gold": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "**Test Case: '2FA Login with Wrong Verification Code'**\n- **Test Case Name:** Attempt to log in with valid credentials but wrong 2FA verification code.\n- **Preconditions:**\n  - A user exists with known email and password.\n  - This user has enabled 2FA (e.g., SMS, email).\n- **Test Steps:**\n  1. Send a `POST` request to `/login` with the user's email and password.\n  2. Extract the `2fa_code` from the response (e.g., `response.data.2fa_code`).\n  3. Send another `POST` request to `/2fa/verify` but this time with a **wrong** verification code (e.g., an incorrect digit or an entirely different code).\n- **Expected Result:**\n  - The `/2fa/verify` request should fail with a `400` or `409` status code (e.g., `Bad Request` or `Conflict`), and the `2fa_status` field in the response should indicate that the verification failed.\n  - The original login attempt should be marked as failed and the user should not be considered logged in.\n  - Any subsequent API call, such as a `POST /refresh` token request, should also fail with an appropriate error message."
    },
    {
      "question_id": "EQ3057",
      "question": "Which HTTP code best represents a soft-deleted resource requested by GET /resource/{id} after DELETE (with recoverable state)?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "204 No Content"
      },
      "gold_answer": "B",
      "model_raw_answer": "A. 200 OK. This is because the resource technically exists in the database, just in a soft-deleted state, so it's not 'not found'.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Soft-deleted resource should be treated as not found."
    },
    {
      "question_id": "EQ3058",
      "type": "Writing",
      "gold": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "**Test Case: Chained Pagination**\n- **Step 1:** Create 20 resources (e.g., `POST /products`).\n- **Step 2:** List first 5 → expect 5 items. List next 5 → expect 5 items. List last 10 → expect 5 items.\n- **Step 3:** Delete last 5 items.\n- **Step 4:** List all → expect only 5 items. List first 10 → 404.\n- **Assertion:** Total count API (`GET /products/count`) → 5."
    },
    {
      "question_id": "EQ3059",
      "question": "Which mapping is correct when dependency outage triggers circuit breaker OPEN, causing gateway to reject requests immediately?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "400 Bad Request"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Circuit breaker OPEN maps to 503 Service Unavailable."
    },
    {
      "question_id": "EQ3060",
      "type": "Writing",
      "gold": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "**Test Case: Session Stickiness**\n1. Login to Node A → obtain session cookie.\n2. LB directs next API call → verify session cookie still valid.\n3. Log out → delete session.\n4. Repeat step 2 → expect `404 Not Found` or `401 Unauthorized` from all nodes."
    },
    {
      "question_id": "EQ4001",
      "question": "Which chained flow correctly validates an order lifecycle with create → capture → refund, ensuring idempotency across retries?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Create order → retry refund twice → refund fails",
        "B": "Capture payment without creating order",
        "C": "Create order → capture payment → retry capture with same idempotency key → single charge → refund succeeds",
        "D": "Refund before order creation"
      },
      "gold_answer": "C",
      "model_raw_answer": "A. Create order → retry refund twice → refund fails. This validates idempotency across retries.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Idempotency must ensure duplicate captures do not create multiple charges."
    },
    {
      "question_id": "EQ4002",
      "type": "Writing",
      "gold": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "**Test Case: Account Lifecycle**\n- **Preconditions:** Admin user exists.\n- **Steps:**\n  - Create account → 201 Created.\n  - Activate → 200 OK.\n  - Suspend → 200 OK.\n  - Reactivate → 200 OK.\n  - Delete → 204 No Content.\n- **Expected:** All transitions valid, DB state matches."
    },
    {
      "question_id": "EQ4003",
      "question": "Which mapping is correct for handling a duplicate transaction detected during a refund request?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 409 Conflict – This is the most appropriate HTTP status code for indicating that the request could not be completed because of a conflict with the current state of the resource. In this case, it means the transaction is already settled or has been refunded before.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Duplicate transaction must map to 409 Conflict."
    },
    {
      "question_id": "EQ4004",
      "type": "Writing",
      "gold": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "**Test Case: Transaction Rollback**\n- **Preconditions:** User A has $100.\n- **Step 1:** Transfer $50 from A to B → `200 OK`.\n- **Step 2:** (Failure) Attempt to transfer $999 from B to C → `400 Invalid Amount`.\n- **Expected:** After Step 2, User A still has $100, no funds moved."
    },
    {
      "question_id": "EQ4005",
      "question": "Which chained scenario validates proper error propagation in a distributed saga transaction?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Start saga → all steps succeed",
        "B": "Start saga → ignore error in step 2",
        "C": "Start saga → rollback ignored",
        "D": "Start saga → step 3 fails → compensating rollback of steps 1 & 2 executed"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. This validates that the system correctly compensates failures in a distributed transaction.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Saga pattern ensures compensating actions on failure."
    },
    {
      "question_id": "EQ4006",
      "type": "Writing",
      "gold": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "This test requires orchestrated API calls across services. **Test Case:** 1. Log in to auth service. 2. Create order → expect `201 Created` from inventory service. 3. Process payment → capture successful. 4. Cancel order → expect `200 OK` with cancelled status. **Validation:** Verify DB consistency post each step."
    },
    {
      "question_id": "EQ4007",
      "question": "Which error handling scenario best validates sanity checks in payment APIs?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Submitting refund > captured amount → 400 Bad Request",
        "B": "Submitting refund = captured amount → 200 OK",
        "C": "Submitting refund < captured amount → 200 OK",
        "D": "Refund without capture → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Sanity checks in payment APIs enforce business rules. Submitting a refund greater than the captured amount violates this rule, so the correct response is a client error (400 Bad Request).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Refunds larger than capture must fail with 400."
    },
    {
      "question_id": "EQ4008",
      "type": "Writing",
      "gold": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "1) **Set:** State 'PasswordSet' transitions to 'Valid' when created. 2) **Expire:** 'Valid' → 'Expired' after 90 days. 3) **Reset:** 'Expired' → 'ResetPending' → 'Valid' after new password. 4) **Reuse:** Prevents 'Valid' → 'Valid' with identical password."
    },
    {
      "question_id": "EQ4009",
      "question": "Which mapping best validates format error handling for malformed JSON payloads?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Malformed JSON must result in 400 Bad Request."
    },
    {
      "question_id": "EQ4010",
      "type": "Writing",
      "gold": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "**Test Case: Loan Approval with Credit Check Failure**\n- **Preconditions:** User exists, loan product active.\n- **Test Steps:**\n  1. Send loan application request.\n  2. Chain with a separate API call to a mock credit service (e.g., `/credit-check`) that returns a `500 Internal Server Error`.\n- **Expected Result:** Loan application API should fail with a `503 Service Unavailable` status code, not `200 OK`. The DB should not be updated with an approved status."
    },
    {
      "question_id": "EQ4011",
      "question": "Which chained flow validates consistent state during distributed booking workflow?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Reserve hotel only",
        "B": "Reserve hotel → book flight → flight fails → hotel reservation auto-cancelled",
        "C": "Book flight only",
        "D": "Book hotel and keep reservation even if payment fails"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. This option validates state consistency when flight booking fails after hotel booking.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Hotel auto-cancellation ensures consistent state across systems."
    },
    {
      "question_id": "EQ4012",
      "type": "Writing",
      "gold": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "**Test Case: Concurrent Profile Updates**\n- **Preconditions:** Two users, Alice and Bob, exist. Both are connected to the API.\n- **Test Steps:**\n  1. **Alice's Request:** Send a `PUT /users/123` request to update Alice's email to `alice@example.com`.\n  2. **Bob's Request (Simultaneous):** Immediately after, Bob sends a `PUT /users/123` request to update the email to `bob@example.com`.\n- **Expected Result:**\n  - The API rejects both requests with a `409 Conflict` status.\n  - The database state remains unchanged, with the original email still `user@example.com`.\n  - A retry after a short interval should succeed, but only with one of the updates being applied."
    },
    {
      "question_id": "EQ4013",
      "question": "Which HTTP code is correct for validating sanity check on withdraw > account balance?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "400 Bad Request"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. 200 OK – This is the correct status code for validating a sanity check (e.g., ensuring withdrawal amount is less than account balance). It indicates the request was successful but may not contain a new resource.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Over-withdrawal must be rejected as 400 Bad Request."
    },
    {
      "question_id": "EQ4014",
      "type": "Writing",
      "gold": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "**Test Case: Chained Document Signing**\n- **Preconditions:** API configured for document signing (e.g., AWS Signature Version 4).\n- **Steps:**\n  1. Upload a document → get its hash.\n  2. Sign the hash → attach signature to document.\n  3. Verify signature → ensure document integrity.\n  4. Attempt tampering (alter bytes) → expect verification to fail.\n- **Expected:** Signature verification passes only for original document."
    },
    {
      "question_id": "EQ4015",
      "question": "Which scenario validates state rollback when an API partially updates user info and DB transaction fails?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Update fails mid-way → no partial changes persist",
        "B": "Update fails mid-way → partial changes remain",
        "C": "Update fails mid-way → system crashes",
        "D": "Update succeeds despite DB rollback"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Update fails mid-way → no partial changes persist. This ensures data consistency by rolling back changes.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Proper rollback prevents partial/inconsistent data."
    },
    {
      "question_id": "EQ4016",
      "question": "Which chained scenario best validates the idempotency of a payment capture endpoint?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "POST /capture twice with different Idempotency-Key values → two charges",
        "B": "POST /capture twice with the same Idempotency-Key → single charge recorded",
        "C": "POST /refund without capture → success",
        "D": "GET /capture-status once"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. POST /capture twice with the same Idempotency-Key → single charge recorded.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Idempotency ensures duplicate requests with same key do not create multiple charges."
    },
    {
      "question_id": "EQ4017",
      "type": "Writing",
      "gold": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "1. **Create:** Send `POST` to `/subscriptions` with plan='basic'. Assert `200 OK`, DB shows `status='active'`.\n2. **Upgrade:** Send `PUT` to `/subscriptions/ID` with plan='premium'. Assert `200 OK`, DB shows new plan.\n3. **Downgrade:** Send `PUT` to `/subscriptions/ID` with plan='basic'. Assert `200 OK`, DB updated.\n4. **Cancel:** Send `DELETE` to `/subscriptions/ID`. Assert `200 OK`, DB shows `status='cancelled'`."
    },
    {
      "question_id": "EQ4018",
      "question": "Which mapping correctly handles application error LIMIT_EXCEEDED for per-account API quota?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 429 Too Many Requests",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rate/limit exceeded maps to 429 Too Many Requests."
    },
    {
      "question_id": "EQ4019",
      "type": "Writing",
      "gold": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "**Test Case: Distributed Order Saga Recovery**\n- **Preconditions:** 3 microservices (Order, Inventory, Shipping) deployed across regions, event bus mocked.\n- **Steps:**\n  1. Send `CreateOrder` → `Commit` event → `ReserveInventory` → `PrepareShipping`.\n  2. Inject failure after `PrepareShipping`: shipping service returns 500.\n  3. Expected: Order service reverts to `Created` state, no inventory reserved.\n  4. Repeat with different failures in chain.\n- **Expected:** All services recover cleanly, no stale data."
    },
    {
      "question_id": "EQ4020",
      "question": "Which chained flow validates OAuth2 token misuse detection across services?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "options": {
        "A": "Login once",
        "B": "Refresh token immediately",
        "C": "Login → get token → attempt to use token in another client → 403 Forbidden",
        "D": "Logout only"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Login → get token → attempt to use token in another client → 403 Forbidden.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Cross-client token misuse should be forbidden."
    },
    {
      "question_id": "EQ4021",
      "type": "Writing",
      "gold": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "This test requires complex state management. Preconditions: account balance $100. Action: debit $50 → credit $20 → rollback. Expected: no changes, balance remains $100."
    },
    {
      "question_id": "EQ4022",
      "question": "Which scenario best validates format error handling for XML vs JSON input mismatch?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "Send XML body with Content-Type: application/json → 415 Unsupported Media Type",
        "B": "Send JSON body with application/json → 200 OK",
        "C": "Send XML body with application/xml → 200 OK",
        "D": "Send YAML → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "Answer: A. This validates that the API rejects an XML body with a JSON Content-Type, ensuring strict format enforcement.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Mismatch in body vs header must result in 415."
    },
    {
      "question_id": "EQ4023",
      "type": "Writing",
      "gold": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Test steps: 1) Add 100 units → 2) Allocate 50 → 3) Ship 30 → 4) Return 20 → 5) Reconcile DB → Expected: stock=70, all transactions logged."
    },
    {
      "question_id": "EQ4024",
      "question": "Which HTTP status is correct when a schema validation error occurs for a nested field?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Schema validation errors must return 400."
    },
    {
      "question_id": "EQ4025",
      "type": "Writing",
      "gold": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "**Test Case: Mobile Session Lifecycle**\n- **Test Case Name:** Verify session lifecycle with refresh and invalidation.\n- **Preconditions:** Mobile app connected to API with short-lived sessions (15 minutes).\n- **Test Steps:**\n  1. **Login & Initial Token:** Send `POST /login` with valid credentials.\n  2. **Token Refresh:** Wait for session to be half-life. Send `POST /refresh-token` with existing refresh token. Assert `200 OK` and new refresh token.\n  3. **Logout:** Send `DELETE /logout` with user ID. Assert `204 No Content`.\n  4. **Invalid Refresh:** Send `POST /refresh-token` with old refresh token after logout. Assert `401 Unauthorized`.\n- **Expected Results:** All refresh steps succeed only before logout."
    },
    {
      "question_id": "EQ4026",
      "question": "Which chained scenario validates proper rollback after multi-step booking (flight + hotel) when payment fails?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Book flight → 200 OK",
        "B": "Book hotel → 200 OK",
        "C": "Book flight + hotel → payment succeeds",
        "D": "Book flight + hotel → payment fails → rollback both bookings"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rollback ensures no inconsistent bookings remain."
    },
    {
      "question_id": "EQ4027",
      "type": "Writing",
      "gold": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. **Send Email:** Send a test email with unique tracking and unsubscribe links. 2. **Open Tracking:** Use a tracking pixel to confirm email opened. 3. **Unsubscribe:** Send a request to the unsubscribe endpoint for that email's user. 4. **Verify No More Emails:** Monitor the user's inbox for the next scheduled email and confirm it does not arrive."
    },
    {
      "question_id": "EQ4028",
      "question": "Which mapping is correct for application code TOKEN_REPLAY_DETECTED?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "A. 200 OK. This status code indicates the request was successful, which is the case when a replay attempt is detected and blocked.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Token replay must be treated as 401 Unauthorized."
    },
    {
      "question_id": "EQ4029",
      "type": "Writing",
      "gold": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "This test requires multiple steps: 1) Apply a valid coupon during checkout. 2) Proceed to payment. 3) Programmatically invalidate the coupon on the server. 4) The API should return a `400` error. 5) The DB should show the order was rolled back to 'pending' state."
    },
    {
      "question_id": "EQ4030",
      "question": "Which chained workflow validates asynchronous payment settlement with reconciliation?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Create order only",
        "B": "Create order → capture payment → async settlement → reconcile → final status=settled",
        "C": "Refund without settlement",
        "D": "Check API health"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. This option includes steps for asynchronous payment processing and reconciliation.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Asynchronous settlement must reconcile correctly."
    },
    {
      "question_id": "EQ5001-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để truy xuất dữ liệu từ một API?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là phương thức chuẩn để truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5002-VN",
      "question": "Mã trạng thái HTTP 404 đại diện cho điều gì?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "OK",
        "B": "Unauthorized",
        "C": "Not Found",
        "D": "Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Not Found",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "404 cho biết tài nguyên được yêu cầu không thể tìm thấy."
    },
    {
      "question_id": "EQ5003-VN",
      "question": "Mục đích của phương thức HTTP POST là gì?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "Truy xuất dữ liệu",
        "B": "Gửi dữ liệu để tạo tài nguyên",
        "C": "Cập nhật tài nguyên hiện có",
        "D": "Xóa tài nguyên"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Gửi dữ liệu để tạo tài nguyên.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST được sử dụng để tạo tài nguyên mới với dữ liệu trong request body."
    },
    {
      "question_id": "EQ5004-VN",
      "type": "Writing",
      "gold": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "### **Test Case: Đăng Nhập với Tài Khoản Valid**\n- **Test Case Name:** Đăng nhập thành công với email và mật khẩu đúng.\n- **Test Case ID:** TC-LOGIN-001.\n- **Test Case Description:** Đăng nhập vào hệ thống với một tài khoản đã tồn tại và đúng thông tin.\n- **Preconditions:**\n  - Hệ thống API đang hoạt động.\n  - Có một tài khoản `user@example.com` với mật khẩu `Password123!` đã đăng ký.\n- **Test Steps:**\n  1. Gửi yêu cầu `POST` đến endpoint đăng nhập (ví dụ `/login`).\n  2. Thư viện test sẽ sử dụng các công cụ như `requests` (Python) hoặc `axios` (JavaScript) để gửi yêu cầu.\n  3. Trong cơ thể yêu cầu, bạn cần gửi một `JSON` body với trường `email` và `password`.\n  4. Sử dụng các giá trị xác định từ precondition (ví dụ `{\"email\": \"user@example.com\", \"password\": \"Password123!\"}`).\n- **Expected Result:**\n  - **Status Code:** HTTP Status `200 OK` hoặc `201 Created` (tùy thuộc vào API).\n  - **Response Body:** Trả về một `JSON` chứa thông tin về token truy cập hoặc user được xác thực. Ví dụ, `{\"token\": \"eyJhb...\", \"user\": {\"id\": 1, \"name\": \"User Name\"}}`.\n  - **Header:** Có một tiêu đề `Authorization` hoặc `X-Token` với giá trị token được trả về.\n  - **Database:** Một bản ghi về session hoặc token liên quan đến yêu cầu đăng nhập này có thể được tạo."
    },
    {
      "question_id": "EQ5005-VN",
      "question": "Mã trạng thái HTTP nào trong số này có nghĩa là 'Unauthorized'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
    },
    {
      "question_id": "EQ5006-VN",
      "type": "Writing",
      "gold": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "Điều kiện tiên quyết phổ biến là một tài khoản người dùng đã được đăng ký và có quyền truy cập vào profile của họ."
    },
    {
      "question_id": "EQ5007-VN",
      "question": "Phương thức HTTP nào được coi là idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "PUT",
        "D": "CONNECT"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PUT – Vì thực hiện PUT nhiều lần vẫn có thể dẫn đến kết quả giống như thực hiện một lần.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PUT là idempotent vì nhiều request giống hệt nhau có cùng một hiệu ứng."
    },
    {
      "question_id": "EQ5008-VN",
      "type": "Writing",
      "gold": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Test trường email không hợp lệ: Request với `email=invalid` và kiểm tra trạng thái HTTP và nội dung trả về."
    },
    {
      "question_id": "EQ5009-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'OK'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 200",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK là mã thành công chuẩn."
    },
    {
      "question_id": "EQ5010-VN",
      "type": "Writing",
      "gold": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "Một schema xác định cấu trúc và quy tắc của dữ liệu được gửi hoặc nhận. Trong testing, nó giúp xác minh dữ liệu API đáp ứng các yêu cầu cấu trúc và loại dữ liệu (int, string, array, etc.)."
    },
    {
      "question_id": "EQ5011-VN",
      "question": "Phương thức HTTP nào được sử dụng để xóa một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "D",
      "model_raw_answer": "D",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "DELETE xóa tài nguyên được chỉ định trong URL."
    },
    {
      "question_id": "EQ5012-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "Test Step: Đăng một tài khoản mới và xác minh status code tạo là 201 Created."
    },
    {
      "question_id": "EQ5013-VN",
      "question": "HTTP header nào thường được sử dụng cho các authentication token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "Accept",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Authorization",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Authorization header mang thông tin xác thực hoặc token."
    },
    {
      "question_id": "EQ5014-VN",
      "type": "Writing",
      "gold": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking giúp tạo giả lập các dịch vụ phụ thuộc để thực hiện kiểm tra độc lập, giảm phụ thuộc vào các dịch vụ khác."
    },
    {
      "question_id": "EQ5015-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Created'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "403"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 201",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created xác nhận tạo tài nguyên thành công."
    },
    {
      "question_id": "EQ5016-VN",
      "type": "Writing",
      "gold": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "**Test Case: Lấy Danh Sách Sản Phẩm**\n- **Test Case ID:** TC-GET-PRODUCTS-001\n- **Test Case Name:** Xác minh API trả về danh sách sản phẩm.\n- **Test Case Description:** Lấy danh sách sản phẩm từ API.\n- **Preconditions:** Có ít nhất 5 sản phẩm trong cơ sở dữ liệu.\n- **Test Steps:**\n  1. Gửi yêu cầu GET đến endpoint `/products`.\n- **Expected Results:**\n  - Status Code: `200 OK`.\n  - Trả về danh sách JSON chứa ít nhất 5 sản phẩm.\n  - Mỗi sản phẩm có các trường cơ bản (id, tên, giá)."
    },
    {
      "question_id": "EQ5017-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Internal Server Error'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "403",
        "D": "500"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 500",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "500 cho biết lỗi không mong muốn phía server."
    },
    {
      "question_id": "EQ5018-VN",
      "type": "Writing",
      "gold": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Mục đích của một precondition trong một test case là đảm bảo rằng tất cả các yêu cầu và trạng thái cần thiết để thực hiện và đánh giá hiệu quả của một yêu cầu chức năng được đáp ứng trước khi test được thực thi."
    },
    {
      "question_id": "EQ5019-VN",
      "question": "Trạng thái HTTP nào phù hợp cho quyền truy cập bị cấm với thông tin đăng nhập hợp lệ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden cho biết không đủ quyền hạn mặc dù đăng nhập hợp lệ."
    },
    {
      "question_id": "EQ5020-VN",
      "type": "Writing",
      "gold": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test case: Đặt file có định dạng `.exe`. Lệnh test: `POST /upload` với file attachment. Expected: Trả về `415 Unsupported File Type` hoặc `400 Bad Request`."
    },
    {
      "question_id": "EQ5021-VN",
      "question": "Phương thức HTTP nào thường được sử dụng cho các partial update?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PATCH",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. PATCH",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PATCH được sử dụng để sửa đổi một phần của tài nguyên."
    },
    {
      "question_id": "EQ5022-VN",
      "type": "Writing",
      "gold": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "Mục đích của một test case description là cung cấp một bản mô tả ngắn gọn và rõ ràng về chức năng hoặc yêu cầu mà test case đó đang kiểm tra."
    },
    {
      "question_id": "EQ5023-VN",
      "question": "HTTP header nào cho biết định dạng của request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Accept-Encoding"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Content-Type",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Type định nghĩa kiểu media của request body."
    },
    {
      "question_id": "EQ5024-VN",
      "type": "Writing",
      "gold": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "Test step: Gọi API `GET /health` và xác minh thời gian phản hồi `< 1000 ms`."
    },
    {
      "question_id": "EQ5025-VN",
      "question": "Mã trạng thái HTTP nào cho biết conflict, chẳng hạn như tạo tài nguyên trùng lặp?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict được sử dụng khi request conflict với trạng thái hiện tại."
    },
    {
      "question_id": "EQ5026-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'Bad Request'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 Bad Request cho biết cú pháp hoặc tham số không hợp lệ."
    },
    {
      "question_id": "EQ5027-VN",
      "type": "Writing",
      "gold": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "**Test Case: Health Check**\n- **Test Case Name:** Verify healthy API response.\n- **Preconditions:** API đang chạy.\n- **Test Steps:** Gửi yêu cầu GET đến /health.\n- **Expected Result:** HTTP Status Code = 200 OK, Response Body chứa 'healthy' = true."
    },
    {
      "question_id": "EQ5028-VN",
      "question": "Phương thức HTTP nào được sử dụng để cập nhật hoàn toàn một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. PUT",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT thay thế một tài nguyên hiện có bằng dữ liệu mới."
    },
    {
      "question_id": "EQ5029-VN",
      "type": "Writing",
      "gold": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "Sử dụng test data management giúp cung cấp dữ liệu thử nghiệm linh hoạt, bảo mật, và khả năng tái tạo được."
    },
    {
      "question_id": "EQ5030-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Forbidden'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "401",
        "D": "403"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 403",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "403 Forbidden có nghĩa là người dùng đã được xác thực nhưng không được authorization."
    },
    {
      "question_id": "EQ5031-VN",
      "type": "Writing",
      "gold": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test trường hợp yêu cầu resource không tồn tại (ID không hợp lệ). Ví dụ, thử GET /products/999. Expected: `404 Not Found` hoặc JSON có trường `error`."
    },
    {
      "question_id": "EQ5032-VN",
      "question": "Mã trạng thái HTTP nào đại diện cho 'Too Many Requests'?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Easy",
      "options": {
        "A": "408",
        "B": "429",
        "C": "503",
        "D": "504"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 429.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "429 Too Many Requests được trả về khi rate limit bị vượt quá."
    },
    {
      "question_id": "EQ5033-VN",
      "type": "Writing",
      "gold": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion là công cụ kiểm tra giúp xác định xem API đáp ứng yêu cầu hay không. Nó so sánh kết quả thực tế với kết quả mong đợi và báo cáo kết quả kiểm tra."
    },
    {
      "question_id": "EQ5034-VN",
      "question": "Mã trạng thái HTTP nào cho biết một timeout từ server?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "400",
        "C": "200",
        "D": "504"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 504",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "504 Gateway Timeout cho biết server không phản hồi kịp thời."
    },
    {
      "question_id": "EQ5035-VN",
      "type": "Writing",
      "gold": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "**Test Case: Xoá User**\n- **Test Case ID:** TC-DELETE-USER\n- **Test Case Name:** Xác nhận xoá user thành công.\n- **Preconditions:** User ID=1234 tồn tại.\n- **Test Steps:**\n  1. Request DELETE /users/1234.\n- **Expected Result:**\n  - Status Code = 204 No Content.\n  - Dữ liệu trong DB không tồn tại ID=1234."
    },
    {
      "question_id": "EQ5036-VN",
      "question": "Phương thức HTTP nào là safe (không thay đổi trạng thái server)?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là safe vì nó chỉ truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5037-VN",
      "type": "Writing",
      "gold": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "Mã trạng thái HTTP 201 Created cho biết yêu cầu tạo mới tài nguyên thành công."
    },
    {
      "question_id": "EQ5038-VN",
      "question": "Trạng thái HTTP nào được trả về khi một client request được định dạng tốt nhưng bị unauthorized?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "401",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 401",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized được sử dụng cho thông tin đăng nhập không hợp lệ."
    },
    {
      "question_id": "EQ5039-VN",
      "type": "Writing",
      "gold": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "Test trường hợp ID tồn tại và ID không tồn tại."
    },
    {
      "question_id": "EQ5040-VN",
      "question": "Mã trạng thái HTTP nào cho biết thành công nhưng không có content nào được trả về?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204 – No Content.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content được trả về khi xóa thành công hoặc response rỗng."
    },
    {
      "question_id": "EQ5041-VN",
      "type": "Writing",
      "gold": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "Một response 200 OK cho biết yêu cầu của client đã được thực hiện thành công."
    },
    {
      "question_id": "EQ5042-VN",
      "question": "Header nào được sử dụng để chỉ định các định dạng response được chấp nhận?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Accept",
        "C": "Authorization",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Accept – Header này được sử dụng bởi client để chỉ định các định dạng response được chấp nhận. Ví dụ, `Accept: application/json` sẽ chỉ định client mong muốn nhận dạng JSON.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Accept header cho server biết những định dạng nào được mong đợi (ví dụ: application/json)."
    },
    {
      "question_id": "EQ5043-VN",
      "type": "Writing",
      "gold": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "**Test Case:** Validate Negative Authentication\n- **Test Case Name:** Attempt Login with Invalid Credentials.\n- **Preconditions:** API đang chạy.\n- **Test Steps:**\n  - Send `POST` request đến endpoint `/login` với payload `{\"username\": \"invaliduser\", \"password\": \"wrongpassword\"}`.\n- **Expected Result:**\n  - Status Code: `401 Unauthorized` hoặc `400 Bad Request`.\n  - Response Body không chứa token hoặc chứa thông báo lỗi như \"Invalid credentials\"."
    },
    {
      "question_id": "EQ5044-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi client phải authenticate để truy cập một tài nguyên?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "403",
        "C": "401",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 401 – Unauthorized. Mã trạng thái này được sử dụng khi server xác định rằng yêu cầu đã được gửi, nhưng server không thể thực hiện yêu cầu vì thiếu quyền truy cập.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized yêu cầu thông tin xác thực."
    },
    {
      "question_id": "EQ5045-VN",
      "type": "Writing",
      "gold": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Một test case assertion xác định điều kiện thành công của một thử nghiệm. Ví dụ, nếu yêu cầu là 'API trả về HTTP 200 khi tạo user thành công', thì assertion sẽ kiểm tra xem trạng thái HTTP trả về là 200 hay không."
    },
    {
      "question_id": "EQ5046-VN",
      "question": "Trạng thái HTTP nào cho biết server không thể xử lý request do quá tải?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "503 Service Unavailable",
        "B": "200 OK",
        "C": "404 Not Found",
        "D": "201 Created"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 503 Service Unavailable.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "503 cho biết quá tải tạm thời hoặc đang bảo trì."
    },
    {
      "question_id": "EQ5047-VN",
      "type": "Writing",
      "gold": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "Test case: `POST /upload` with valid image file (e.g., `image.jpg`). Expected: `201 Created`, file saved successfully in server."
    },
    {
      "question_id": "EQ5048-VN",
      "question": "Phương thức HTTP nào là safe và idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "GET",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. GET",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "GET vừa là safe vừa là idempotent."
    },
    {
      "question_id": "EQ5049-VN",
      "type": "Writing",
      "gold": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "415 Unsupported Media Type được sử dụng khi client gửi yêu cầu với định dạng nội dung (Content-Type) mà server không hỗ trợ. Ví dụ, nếu client yêu cầu dữ liệu JSON nhưng server chỉ hiểu dạng XML, nó sẽ trả về trạng thái 415."
    },
    {
      "question_id": "EQ5050-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'Request Timeout'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "408",
        "C": "500",
        "D": "429"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 408",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout cho biết client mất quá nhiều thời gian để gửi request."
    },
    {
      "question_id": "EQ5051-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để tạo một tài nguyên mới?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. POST",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST là phương thức chuẩn để tạo tài nguyên."
    },
    {
      "question_id": "EQ5052-VN",
      "type": "Writing",
      "gold": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "**Test Case:** Lấy Chi Tiết Sản Phẩm\n- **Test Scenario:** Đăng nhập và yêu cầu chi tiết sản phẩm ID=123.\n- **Action:** Gọi `GET /products/123`.\n- **Expected:** Trả về mã `200 OK` với dữ liệu chi tiết sản phẩm."
    },
    {
      "question_id": "EQ5053-VN",
      "question": "Mã trạng thái HTTP nào được trả về khi một tài nguyên được xóa thành công?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content xác nhận việc xóa thành công."
    },
    {
      "question_id": "EQ5054-VN",
      "type": "Writing",
      "gold": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "Là để xác thực và cấp quyền cho yêu cầu gửi đến server. Ví dụ, `Authorization: Bearer <token>` sẽ yêu cầu server kiểm tra token và xác định xem người dùng nào được thực hiện hành động đó."
    },
    {
      "question_id": "EQ5055-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một client gửi một JSON payload không hợp lệ?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 cho biết request không thể hiểu được do cú pháp không hợp lệ."
    },
    {
      "question_id": "EQ5056-VN",
      "type": "Writing",
      "gold": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Test trường hợp không gửi token hoặc gửi token hết hạn. Expected: `403 Forbidden` hoặc `401 Unauthorized`."
    },
    {
      "question_id": "EQ5057-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để cập nhật hoàn toàn một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. PUT",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT thay thế hoàn toàn tài nguyên bằng dữ liệu mới."
    },
    {
      "question_id": "EQ5058-VN",
      "type": "Writing",
      "gold": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "500 Internal Server Error là một mã lỗi chung được sử dụng khi xảy ra lỗi trên server mà không thể xác định lỗi cụ thể. Trong testing, mục đích là kiểm tra khả năng xử lý lỗi của API, chẳng hạn khi gặp vấn đề cơ bản với cơ sở dữ liệu hoặc khi xảy ra lỗi bất ngờ trong mã nguồn."
    },
    {
      "question_id": "EQ5059-VN",
      "question": "Trạng thái HTTP nào có nghĩa là 'Conflict'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "409"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict xảy ra khi việc tạo/cập nhật tài nguyên conflict với trạng thái."
    },
    {
      "question_id": "EQ5060-VN",
      "type": "Writing",
      "gold": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "**Test Case: Lấy Danh Sách Đơn Hàng**\n- **Test Case ID:** TC_001\n- **Test Case Name:** Kiểm tra việc lấy danh sách đơn hàng thành công.\n- **Test Case Description:** Gửi yêu cầu GET đến endpoint `/orders` và xác thực trạng thái và dữ liệu trả về.\n- **Test Case Preconditions:** Có ít nhất một đơn hàng đã được tạo trong cơ sở dữ liệu.\n- **Test Case Steps:**\n  1. Gửi yêu cầu GET đến `/orders`.\n  2. Xác định xem HTTP Status Code trả về là `200 OK` hay không.\n  3. Xác thực xem danh sách đơn hàng được trả về và có phải là danh sách không trống hay không.\n- **Test Case Expected Result:**\n  - HTTP Status Code: `200 OK`.\n  - Trả về danh sách các đơn hàng được tạo trước đó."
    },
    {
      "question_id": "EQ5061-VN",
      "question": "Phương thức HTTP nào được sử dụng cho các partial update tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH chỉ sửa đổi một phần của tài nguyên."
    },
    {
      "question_id": "EQ5062-VN",
      "type": "Writing",
      "gold": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "Chức năng của response header là cung cấp thông tin metadata về nội dung trả về. Ví dụ, `Content-Type` xác định định dạng dữ liệu, `Cache-Control` chỉ định hành vi caching."
    },
    {
      "question_id": "EQ5063-VN",
      "question": "Mã trạng thái HTTP nào được trả về khi authentication là bắt buộc nhưng bị thiếu?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
    },
    {
      "question_id": "EQ5064-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "Test Negative: Bước 1: Gọi API tạo tài nguyên với đường dẫn `/products/ABC123`. Bước 2: Thay vì gửi một payload hợp lệ, hãy gửi một payload bất kỳ (vd: `{\"name\": \"Test\"}`) và yêu cầu HTTP. Bước 3: Đảm bảo API trả về một trạng thái không thành công như `404 Not Found` hoặc `409 Conflict`, và trong trường hợp đó, đảm bảo cơ sở dữ liệu không bị thay đổi."
    },
    {
      "question_id": "EQ5065-VN",
      "question": "Phương thức HTTP nào thường được sử dụng cho các read-only operation an toàn?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là safe và read-only."
    },
    {
      "question_id": "EQ5066-VN",
      "type": "Writing",
      "gold": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "202 Accepted được sử dụng khi API nhận được yêu cầu nhưng sẽ xử lý sau. Ví dụ, khi gửi file lớn, API sẽ trả 202 Accepted và tiếp tục xử lý ở hậu kỳ."
    },
    {
      "question_id": "EQ5067-VN",
      "question": "Trạng thái HTTP nào được trả về khi một tài nguyên đã được di chuyển vĩnh viễn?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "302",
        "C": "301",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 301 – Permanent Redirect.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "301 Moved Permanently cho biết redirection."
    },
    {
      "question_id": "EQ5068-VN",
      "type": "Writing",
      "gold": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Test case: **Test Positive - Valid Data**. **Action:** Send request với dữ liệu hợp lệ (ví dụ: đăng ký user với email và password valid). **Expected:** API trả về trạng thái HTTP 200 OK và response body phải chứa các trường dữ liệu chính (ví dụ: `id`, `email`, `password`) với các giá trị phù hợp."
    },
    {
      "question_id": "EQ5069-VN",
      "question": "Trạng thái HTTP nào cho biết request hợp lệ nhưng không tìm thấy tài nguyên?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "404"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 404",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "404 Not Found có nghĩa là tài nguyên không tồn tại."
    },
    {
      "question_id": "EQ5070-VN",
      "type": "Writing",
      "gold": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Response body chứa dữ liệu trả về cho client. Mục đích là kiểm tra tính chính xác, đầy đủ, và hợp lệ của dữ liệu này."
    },
    {
      "question_id": "EQ5071-VN",
      "question": "Trạng thái HTTP nào cho biết client request timeout?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "500",
        "B": "408",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 408",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout có nghĩa là client không gửi xong kịp thời."
    },
    {
      "question_id": "EQ5072-VN",
      "type": "Writing",
      "gold": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Logout**\n- **Preconditions:** User logged in.\n- **Action:** Send logout request.\n- **Expected:** User session expired, subsequent requests to protected endpoints return 403 Forbidden."
    },
    {
      "question_id": "EQ5073-VN",
      "question": "Trạng thái HTTP nào cho biết một request thành công trả về dữ liệu JSON?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 200 OK",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK là mã chuẩn cho các GET thành công."
    },
    {
      "question_id": "EQ5074-VN",
      "type": "Writing",
      "gold": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "Lỗi 415 Unsupported Media Type xảy ra khi client gửi dữ liệu theo định dạng mà server không hỗ trợ. Ví dụ, nếu API yêu cầu dữ liệu dạng JSON nhưng client gửi XML, thì server sẽ trả về lỗi này."
    },
    {
      "question_id": "EQ5075-VN",
      "question": "Mã trạng thái HTTP nào cho biết server tạm thời ngừng hoạt động để bảo trì?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 được sử dụng khi dịch vụ không khả dụng do quá tải hoặc bảo trì."
    },
    {
      "question_id": "EQ5076-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để cập nhật chỉ một phần của tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH được thiết kế cho các partial update."
    },
    {
      "question_id": "EQ5077-VN",
      "type": "Writing",
      "gold": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Test trường hợp: **Test Case: Status Endpoint**\n- **Preconditions:** API đang chạy.\n- **Test Steps:** Gửi yêu cầu GET đến `/status`.\n- **Expected Result:** HTTP Status Code `200 OK` và trả về JSON với trạng thái như 'running' hoặc 'healthy'."
    },
    {
      "question_id": "EQ5078-VN",
      "question": "Trạng thái HTTP nào cho biết việc tạo tài nguyên thành công?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 201 Created",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created xác nhận việc tạo tài nguyên thành công."
    },
    {
      "question_id": "EQ5079-VN",
      "type": "Writing",
      "gold": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "Một response 204 No Content xác nhận rằng yêu cầu đã được thực hiện thành công, nhưng server không có nội dung nào để gửi lại."
    },
    {
      "question_id": "EQ5080-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một request hợp lệ nhưng quyền truy cập bị cấm?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden có nghĩa là thông tin đăng nhập hợp lệ nhưng không đủ quyền."
    },
    {
      "question_id": "EQ5081-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test Case: Gửi yêu cầu POST với header `Content-Type: application/xml`. Expected: Server trả về `415 Unsupported Media Type`."
    },
    {
      "question_id": "EQ5082-VN",
      "question": "Mã trạng thái HTTP nào cho biết thành công nhưng tài nguyên rỗng?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "400 Bad Request",
        "D": "204 No Content"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204 No Content",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 được trả về khi không có body content."
    },
    {
      "question_id": "EQ5083-VN",
      "type": "Writing",
      "gold": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "Accept header được sử dụng để chỉ định format dữ liệu trả về mà client hỗ trợ. Ví dụ, `Accept: application/json` yêu cầu server trả về dữ liệu JSON."
    },
    {
      "question_id": "EQ5084-VN",
      "question": "Mã trạng thái HTTP nào phù hợp cho thông tin đăng nhập không hợp lệ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 Unauthorized.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thông tin đăng nhập không hợp lệ."
    },
    {
      "question_id": "EQ5085-VN",
      "type": "Writing",
      "gold": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "### **Test Case: Logout Successful**\n- **Test Case ID:** TC-LOGOUT-001\n- **Test Case Name:** Verify successful logout.\n- **Preconditions:** User authenticated with valid token.\n- **Test Steps:**\n  1. Send `POST` request to `/logout`.\n  2. Verify response status code is `200 OK`.\n- **Post-conditions:**\n  - Token should not be valid after logout.\n  - Subsequent protected endpoint should return `401 Unauthorized`.\n- **Expected Result:** Logout confirmed by invalid token."
    },
    {
      "question_id": "EQ5086-VN",
      "question": "Phương thức HTTP nào được sử dụng để truy xuất chi tiết tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET được sử dụng để truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5087-VN",
      "type": "Writing",
      "gold": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "Một 401 Unauthorized nghĩa là yêu cầu được gửi nhưng không được xác thực hoặc xác thực không hợp lệ. Ví dụ, người dùng chưa đăng nhập hoặc mật khẩu không đúng."
    },
    {
      "question_id": "EQ5088-VN",
      "question": "Mã trạng thái HTTP nào cho biết nỗ lực tạo tài nguyên trùng lặp?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict có nghĩa là request trùng lặp hoặc conflict."
    },
    {
      "question_id": "EQ5089-VN",
      "type": "Writing",
      "gold": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "Test Case: Tính năng Profile chi tiết.\n- **Test Case Name:** Verify Profile Details.\n- **Test Case Description:** Đảm bảo API trả về thông tin người dùng đầy đủ khi yêu cầu profile riêng.\n- **Preconditions:** User 'John Doe' có profile sẵn.\n- **Test Steps:**\n  1. Request Profile với ID User.\n- **Expected Result:**\n  - Status Code: `200 OK`.\n  - Body chứa tên, email, địa chỉ, hình ảnh profile."
    },
    {
      "question_id": "EQ5090-VN",
      "question": "Mã trạng thái HTTP nào cho biết request hợp lệ nhưng server không thể hoàn thành nó?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "500",
        "D": "201"
      },
      "gold_answer": "C",
      "model_raw_answer": "D. 201.",
      "model_normalized_answer": "D",
      "correct": false,
      "explanation": "500 Internal Server Error báo hiệu lỗi phía server."
    },
    {
      "question_id": "EQ5091-VN",
      "type": "Writing",
      "gold": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "Mục đích của 302 Found là chuyển hướng tạm thời một yêu cầu đến một URL khác. Ví dụ, khi một API được di chuyển sang một URL mới, nó sẽ trả về trạng thái 302 với địa chỉ mới để client biết."
    },
    {
      "question_id": "EQ5092-VN",
      "question": "Trạng thái HTTP nào là chính xác cho một tài nguyên được cập nhật thành công bằng PUT?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK cho biết tài nguyên đã được cập nhật thành công."
    },
    {
      "question_id": "EQ5093-VN",
      "type": "Writing",
      "gold": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Đăng nhập với mật khẩu sai**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Đăng nhập với mật khẩu sai.\n- **Test Case Description:** Đăng nhập với một mật khẩu sai để kiểm tra lỗi.\n- **Preconditions:** Đăng nhập.\n- **Test Steps:**\n  - **Test Step 1:** Gửi yêu cầu đăng nhập với trường password = 'wrongpassword'.\n- **Expected Result:**\n  - Status Code = 401 Unauthorized.\n  - Response Body chứa thông báo lỗi như 'Sai mật khẩu'."
    },
    {
      "question_id": "EQ5094-VN",
      "question": "Phương thức HTTP nào là safe và cacheable?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "GET",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. GET",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "GET vừa là safe, idempotent, và cacheable."
    },
    {
      "question_id": "EQ5095-VN",
      "type": "Writing",
      "gold": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "Cú pháp yêu cầu không đúng."
    },
    {
      "question_id": "EQ5096-VN",
      "question": "Trạng thái HTTP nào phù hợp khi dịch vụ tạm thời quá tải?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "201",
        "B": "200",
        "C": "503",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 Service Unavailable cho biết quá tải hoặc bảo trì."
    },
    {
      "question_id": "EQ5097-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Test Positive: Gửi một yêu cầu đăng ký với các thông tin hợp lệ (email, password, name) và kiểm tra HTTP Status Code là `201 Created`."
    },
    {
      "question_id": "EQ5098-VN",
      "question": "HTTP header nào chỉ định kích thước của request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Length",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Cache-Control"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Content-Length",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Length định nghĩa kích thước body theo byte."
    },
    {
      "question_id": "EQ5099-VN",
      "type": "Writing",
      "gold": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "'Happy path' trong testing là hành trình sử dụng hệ thống mà không xảy ra lỗi hoặc vấn đề. Ví dụ, đăng ký tài khoản thành công mà không bị trùng email."
    },
    {
      "question_id": "EQ5100-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một request method không được phép trên một tài nguyên?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "405 Method Not Allowed"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 405 Method Not Allowed",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "405 được sử dụng khi phương thức HTTP không hợp lệ cho tài nguyên."
    },
    {
      "question_id": "EQ2001-VN",
      "question": "Khi thiết kế các bài kiểm tra API, kịch bản nào thể hiện rõ nhất một **điều kiện biên** cho tham số phân trang?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gửi page=2 khi total items=200",
        "B": "Gửi page=10 khi size=10 mỗi trang và total items=100",
        "C": "Gửi page=11 khi total items=100 với size=10",
        "D": "Gửi page=1 khi size=20 và total items=300"
      },
      "gold_answer": "C",
      "model_raw_answer": "Câu trả lời đúng: **C. Gửi page=11 khi total items=100 với size=10**. Điều kiện biên cho tham số phân trang là khi trang yêu cầu vượt quá tổng số trang có thể. Ví dụ, nếu có 10 trang, thì trang 11 không thể tồn tại. Kịch bản này sẽ giúp kiểm tra xem API có trả về một trạng thái không hợp lệ (e.g., `400 Bad Request`, `404 Not Found`), hoặc có trả về một trang dữ liệu trống (mảng rỗng, đối tượng rỗng) không.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Page=11 sẽ vượt quá phạm vi có sẵn (tối đa 10), kiểm tra một sự tràn **điều kiện biên**."
    },
    {
      "question_id": "EQ2002-VN",
      "type": "Writing",
      "gold": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "Một test case âm tính cho endpoint yêu cầu OAuth2 là test khi không đưa token hoặc đưa token hết hạn. Cú pháp request: `GET /protected-resource` không thêm `Authorization` header. Expected Result: `403 Forbidden` hoặc `401 Unauthorized`."
    },
    {
      "question_id": "EQ2003-VN",
      "question": "Cách nào sau đây là hiệu quả nhất để xác thực thời gian phản hồi của API dưới **tải người dùng** mô phỏng?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi API tuần tự thủ công bằng đồng hồ bấm giờ",
        "B": "**Load test** tự động với **người dùng ảo** đồng thời",
        "C": "Thực hiện một yêu cầu duy nhất và đo thời gian phản hồi",
        "D": "**Unit testing** với các phản hồi được **mock**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. **Load test** tự động với **người dùng ảo** đồng thời.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Load testing** với **người dùng ảo** đồng thời mô phỏng điều kiện thực tế."
    },
    {
      "question_id": "EQ2004-VN",
      "type": "Writing",
      "gold": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path:**\n- **Test Case ID:** TC-009 (Refund Successful).\n- **Test Case Name:** Verify full refund processed successfully.\n- **Preconditions:** User account has sufficient balance, refund request is valid.\n- **Test Steps:**\n  1. Send `POST /refunds` request with valid payload.\n- **Expected Result:**\n  - API returns `201 Created`.\n  - Database confirmed refund amount deducted from user's balance.\n  - Email notification for successful refund sent to user.\n- **Post-conditions:** Refund record exists in DB.\n\n**Test Case Error-Path:**\n- **Test Case ID:** TC-010 (Refund Failed).\n- **Test Case Name:** Verify refund fails when insufficient balance.\n- **Preconditions:** User account has zero balance.\n- **Test Steps:**\n  1. Send `POST /refunds` request with same payload as happy path.\n- **Expected Result:**\n  - API returns `400 Bad Request` or `409 Conflict` with appropriate error message.\n  - No refund record created in DB.\n  - Email notification for failed refund not sent.\n- **Post-conditions:** No changes in user's balance."
    },
    {
      "question_id": "EQ2005-VN",
      "question": "Thực hành nào giúp giảm **sự flaky** của **automated API tests** chạy trong các **CI/CD pipelines**?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcode **API keys** trong các script",
        "B": "Sử dụng độ trễ ngủ ngẫu nhiên trước các **assertion**",
        "C": "Chỉ chạy **test** một lần mỗi bản phát hành",
        "D": "Sử dụng dữ liệu **test** ổn định và các **hook** thiết lập môi trường"
      },
      "gold_answer": "D",
      "model_raw_answer": "Đáp án: D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Dữ liệu **test** và thiết lập môi trường ổn định giúp giảm tính ngẫu nhiên và **sự flaky**."
    },
    {
      "question_id": "EQ2006-VN",
      "type": "Writing",
      "gold": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "Cơ chế tương thích ngược (backward compatibility) đảm bảo API cũ vẫn hoạt động khi schema mới được triển khai. Xác thực thay đổi schema liên quan đến việc kiểm tra các trường hợp test cũ với các phiên bản mới của API."
    },
    {
      "question_id": "EQ2007-VN",
      "question": "Điều nào sau đây thể hiện một **test case âm tính** chính xác cho việc xác thực đầu vào trên trường ngày sinh?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gửi **dateOfBirth**=‘2025-13-40’",
        "B": "Gửi **dateOfBirth**=‘1990-05-20’",
        "C": "Để trống **dateOfBirth** khi nó là tùy chọn",
        "D": "Gửi **dateOfBirth**=‘2000-01-01’"
      },
      "gold_answer": "A",
      "model_raw_answer": "C. Để trống **dateOfBirth** khi nó là tùy chọn.",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Tháng/ngày không hợp lệ làm cho nó trở thành một trường hợp xác thực đầu vào **âm tính** chính xác."
    },
    {
      "question_id": "EQ2008-VN",
      "type": "Writing",
      "gold": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Mocking tạo một bản sao giả của API ngân hàng. Trong kiểm tra, API thanh toán sẽ gọi mock này thay vì dịch vụ thật. Ví dụ, mock được cấu hình để luôn trả `200 OK` và chứa dữ liệu giả cho đơn hàng."
    },
    {
      "question_id": "EQ2009-VN",
      "question": "Cách tiếp cận giám sát nào giúp phát hiện các đợt tăng đột biến về tỷ lệ lỗi API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Báo cáo **code coverage**",
        "B": "Kiểm tra **log** thủ công mỗi tuần",
        "C": "Cảnh báo thời gian thực trên các chỉ số tỷ lệ lỗi",
        "D": "Phân tích **code** tĩnh"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Cảnh báo thời gian thực trên các chỉ số tỷ lệ lỗi.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Cảnh báo thời gian thực đảm bảo phát hiện ngay lập tức các đợt tăng đột biến tỷ lệ lỗi."
    },
    {
      "question_id": "EQ2010-VN",
      "type": "Writing",
      "gold": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "- **Boundary Test (Valid):** Là khi nhập giá trị `18` hoặc `65`.  Ví dụ: `POST /users` với `age=18`.\n- **Invalid Test (Hết Phạm Vi):** Là khi nhập giá trị `0` hoặc `70`. Ví dụ: `POST /users` với `age=0`."
    },
    {
      "question_id": "EQ2011-VN",
      "question": "Điều nào sau đây là một ví dụ về **contract validation** trong **API testing**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra độ trễ phản hồi",
        "B": "Xác thực **JSON** phản hồi khớp với **OpenAPI schema**",
        "C": "Đo tải **CPU** của máy chủ",
        "D": "**Assert** các truy vấn **SQL** từ **log**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Xác thực **JSON** phản hồi khớp với **OpenAPI schema**.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Contract validation** đảm bảo các phản hồi khớp với **schema** đã xác định."
    },
    {
      "question_id": "EQ2012-VN",
      "type": "Writing",
      "gold": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "Mô phỏng lỗi mạng timeout bằng cách thêm delay giả lập vào yêu cầu gửi đến server. Ví dụ, sử dụng tool như `curl` hoặc `Postman` và thêm parameter `--timeout` hoặc `headers` với giá trị thời gian chờ cao. Sau đó, kiểm tra hành động của API khi nhận yêu cầu (ví dụ: trả về trạng thái lỗi 504, retry sau một thời gian)."
    },
    {
      "question_id": "EQ2013-VN",
      "question": "Kịch bản nào thể hiện rõ nhất một **load test** trung gian?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "10.000 **người dùng ảo** đồng thời cho **stress testing**",
        "B": "Kiểm tra chức năng một người dùng",
        "C": "**Unit testing** một chức năng",
        "D": "100–200 **người dùng ảo** đồng thời mô phỏng lưu lượng truy cập trung bình"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 100–200 **người dùng ảo** đồng thời mô phỏng lưu lượng truy cập trung bình.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Các **load test** trung gian mô phỏng lưu lượng truy cập người dùng vừa phải, thực tế."
    },
    {
      "question_id": "EQ2014-VN",
      "type": "Writing",
      "gold": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "**Ví dụ về Precondition:** Một API yêu cầu phải có một tài khoản khách hàng được tạo (`user_id = 123`) và một đơn hàng tồn tại (`order_id = 456`) để thực hiện hành động \"Xác nhận đơn hàng\" (confirm order).\n\n**Step sau Precondition:** Sau khi đảm bảo `user_id = 123` và `order_id = 456` tồn tại trong cơ sở dữ liệu, **Bước tiếp theo** là gửi một yêu cầu `POST` tới `/orders/{order_id}/confirm` với payload xác nhận đơn hàng."
    },
    {
      "question_id": "EQ2015-VN",
      "question": "Cách tiếp cận nào giúp phát hiện các nỗ lực truy cập trái phép trong một API?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "**Penetration test** sử dụng **token** không hợp lệ hoặc thiếu",
        "B": "**Unit test** trên các chức năng hỗ trợ",
        "C": "Thành công **build** **CI pipeline**",
        "D": "Chạy API ở chế độ **debug**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Answer: A. **Penetration test** sử dụng **token** không hợp lệ hoặc thiếu.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Penetration test** tiết lộ điểm yếu trong việc xử lý ủy quyền."
    },
    {
      "question_id": "EQ2016-VN",
      "type": "Writing",
      "gold": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "Test case sẽ bao gồm các bước sau:\n- Gửi yêu cầu hợp lệ nhiều lần liên tiếp (ví dụ 10 requests trong 5s).\n- Xác minh số lượng yêu cầu cho phép (rate limit) được lưu trữ đúng.\n- Challenging: gửi yêu cầu thứ 11 và xác minh API trả về trạng thái `403 Forbidden` hoặc `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2017-VN",
      "question": "Chiến lược nào đảm bảo khả năng tái tạo của các **integration API tests**?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chạy với dữ liệu sản phẩm ngẫu nhiên",
        "B": "Sử dụng các cơ sở dữ liệu **test** được **seed** và các **script reset**",
        "C": "Hardcode **timestamp** trong các yêu cầu",
        "D": "Vô hiệu hóa các **cleanup step** sau khi **test**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Sử dụng các cơ sở dữ liệu **test** được **seed** và các **script reset**.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Dữ liệu **test** được **seed** đảm bảo khả năng tái tạo nhất quán."
    },
    {
      "question_id": "EQ2018-VN",
      "type": "Writing",
      "gold": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "**Lợi thế:** Dịch vụ giả (service virtualization) cho phép thực hiện **testing** mà không cần tất cả các **service** thực tế sẵn có. Điều này giảm chi phí, tăng tốc độ thử nghiệm và cho phép bắt đầu **testing** sớm."
    },
    {
      "question_id": "EQ2019-VN",
      "question": "Điều nào trong số này là một **recovery step** thích hợp nếu giám sát API phát hiện lỗi **500** nhất quán?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Bỏ qua chúng cho đến bản phát hành tiếp theo",
        "B": "Thêm logic **retry** ngẫu nhiên cho tất cả các máy khách",
        "C": "Cảnh báo đội ngũ vận hành và kích hoạt **rollback** của **deployment** gần đây",
        "D": "Tắt **log** lỗi"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Cảnh báo đội ngũ vận hành và kích hoạt **rollback** của **deployment** gần đây.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Rollback** và cảnh báo đảm bảo giảm thiểu nhanh chóng."
    },
    {
      "question_id": "EQ2020-VN",
      "type": "Writing",
      "gold": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "**Test Case Tích Cực:** Gửi một yêu cầu đăng nhập với một tên người dùng và mật khẩu hợp lệ, kiểm tra HTTP status code (`200 OK`) và đảm bảo trả về một token truy cập hợp lệ. **Boundary Test Case:** 1. **Tên người dùng Boundary:** Gửi tên người dùng là chuỗi rỗng. 2. **Mật khẩu Boundary:** Gửi mật khẩu là chuỗi rỗng hoặc quá dài vượt quá giới hạn của API. 3. **Thử sai lệch:** Gửi tên người dùng không tồn tại hoặc mật khẩu sai."
    },
    {
      "question_id": "EQ2021-VN",
      "question": "Kịch bản nào sau đây là một ví dụ về một **chained API test case**?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi GET /status lặp đi lặp lại",
        "B": "Tạo một người dùng, sau đó sử dụng ID của người dùng đó trong GET /profile",
        "C": "Kiểm tra một endpoint với các **header** không hợp lệ",
        "D": "Đo độ trễ trung bình của một endpoint"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Tạo một người dùng, sau đó sử dụng ID của người dùng đó trong GET /profile. Ví dụ: 1. **Test Case 1:** Tạo một người dùng mới → `POST /users` với các thông tin hợp lệ. 2. **Test Case 2:** Sử dụng ID người dùng từ Test Case 1 để thực hiện một yêu cầu `GET /users/{id}` và xác minh thông tin người dùng được trả về đúng. 3. **Test Case 3:** Xoá người dùng khỏi hệ thống và thực hiện lại yêu cầu `GET /users/{id}` để xác minh người dùng đã bị xóa.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Chained test case** phụ thuộc vào đầu ra của một API là đầu vào cho API khác."
    },
    {
      "question_id": "EQ2022-VN",
      "type": "Writing",
      "gold": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "**Test Step:** Gửi một yêu cầu `POST` tới endpoint `/upload` nhưng thay vì gửi một file, bạn gửi một chuỗi văn bản như `{\"content\": \"Hello, World!\"}` trong phần body của request. **Expected Result:** API phải trả về một trạng thái HTTP `415 Unsupported Media Type` và trong body của response, bạn mong đợi một thông điệp lỗi như `\"The server cannot process the request, because the entity body of the request contains data in a format that the server does not know how to parse.\"`."
    },
    {
      "question_id": "EQ2023-VN",
      "question": "Thực hành nào giúp phát hiện vi phạm **contract** sớm trong **CI/CD pipeline**?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "**Load testing** trong **production** thôi",
        "B": "Kiểm tra **regression** thủ công mỗi tháng một lần",
        "C": "**Schema validation tests** được tích hợp vào **pipeline**",
        "D": "Sử dụng **mock** cho tất cả các phụ thuộc bên ngoài"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. **Schema validation tests** được tích hợp vào **pipeline**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Automated schema validation** trong **CI/CD** phát hiện các thay đổi gây lỗi nhanh chóng."
    },
    {
      "question_id": "EQ2024-VN",
      "type": "Writing",
      "gold": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "**Cách test:** 1. Đăng ký một trường hợp sử dụng API với yêu cầu DB chậm (tạo một bảng lớn, sử dụng một truy vấn phức tạp). 2. Sử dụng công cụ monitor như Prometheus hoặc Datadog để theo dõi thời gian thực hiện của truy vấn đó. 3. Lặp lại yêu cầu API nhiều lần và kiểm tra xem dữ liệu monitor có thể phản ánh đúng tình trạng chậm của DB hay không."
    },
    {
      "question_id": "EQ2025-VN",
      "question": "Điều nào sau đây là một ví dụ về một **negative authorization test**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi **DELETE /users** mà không có đặc quyền quản trị",
        "B": "Gọi **GET /users** với **token** hợp lệ",
        "C": "Đăng nhập với thông tin đăng nhập hợp lệ",
        "D": "Làm mới một **session token** hợp lệ"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Gọi **DELETE /users** mà không có đặc quyền quản trị.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Cố gắng xóa người dùng mà không có đặc quyền kiểm tra các hạn chế truy cập."
    },
    {
      "question_id": "EQ2026-VN",
      "type": "Writing",
      "gold": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Trường hợp: API tạo tài khoản. Kiểm tra bằng cách gửi request tạo một lần, sau đó gửi lại request cùng tham số. Đáp ứng: DB chỉ có 1 bản ghi, HTTP Status `201` duy nhất."
    },
    {
      "question_id": "EQ2027-VN",
      "question": "Phương pháp nào đảm bảo các **API keys** nhạy cảm không bị lộ trong quá trình **automated testing**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcode chúng trong các **test script**",
        "B": "In chúng trong các **log CI/CD**",
        "C": "Lưu trữ chúng trong các **repo GitHub** công khai",
        "D": "Sử dụng các biến môi trường được mã hóa"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Sử dụng các biến môi trường được mã hóa",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Các biến môi trường được mã hóa giữ bí mật an toàn."
    },
    {
      "question_id": "EQ2028-VN",
      "type": "Writing",
      "gold": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "- **Boundary Test (Valid Edge):** Tải file kích thước 5 MB (theo yêu cầu) -> 100% dự kiến trả `200 OK` và lưu file thành công.\n- **Invalid Test:** Tải file kích thước > 10 MB -> 100% dự kiến trả `415 Unsupported Media Type` hoặc `413 Payload Too Large`."
    },
    {
      "question_id": "EQ2029-VN",
      "question": "Chỉ số giám sát nào sẽ tốt nhất để chỉ ra rò rỉ bộ nhớ trong một API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Tăng đột biến độ trễ trung bình",
        "B": "Sử dụng bộ nhớ tăng dần",
        "C": "Sử dụng CPU giảm",
        "D": "Tăng ngẫu nhiên tỷ lệ **cache hit**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Sử dụng bộ nhớ tăng dần.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Rò rỉ bộ nhớ biểu hiện dưới dạng sử dụng bộ nhớ liên tục tăng."
    },
    {
      "question_id": "EQ2030-VN",
      "type": "Writing",
      "gold": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "Test Case: **Xử lý lỗi khi email bị thiếu**\n- **Test Scenario:** Gửi yêu cầu đăng ký với body `{ \"username\": \"user123\", \"password\": \"password123\" }` (bỏ campo `email`).\n- **Test Steps:**\n  1. Gửi yêu cầu qua API.\n- **Expected Result:**\n  - Trả về trạng thái HTTP `400 Bad Request`.\n  - Nội dung response chứa thông báo lỗi cho trường `email` (ví dụ: `{\"error\": {\"email\": [\"Email is required.\"]}}`).\n  - Không tạo được tài khoản mới."
    },
    {
      "question_id": "EQ2031-VN",
      "question": "Điều nào sau đây mô tả rõ nhất **service virtualization**?",
      "type": "MCQ",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chỉ chạy API trong **production**",
        "B": "Sử dụng bản sao cơ sở dữ liệu cục bộ",
        "C": "Mô phỏng các phụ thuộc không có sẵn với các dịch vụ ảo",
        "D": "Thay thế logic **backend** bằng các **microservice** mới"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Mô phỏng các phụ thuộc không có sẵn với các dịch vụ ảo",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Service virtualization** cho phép kiểm tra mà không có các phụ thuộc thực."
    },
    {
      "question_id": "EQ2032-VN",
      "type": "Writing",
      "gold": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "1. **Cài đặt:** Sử dụng một công cụ như **Locust** hoặc **K6** để tạo ra một đợt yêu cầu (ramp-up) lên API.\n2. **Thi hành:** Trong đợt thử nghiệm, giả lập một số yêu cầu bị **timeout** (để API trả về **503 Service Unavailable**).\n3. **Xác thực:** Sau khi đợt thử nghiệm hoàn thành, kiểm tra **log** hoặc **database** để xác định xem các yêu cầu bị **timeout** đã được **retry** thành công hay không.\n4. **Đường thử nghiệm:** Đảm bảo hệ thống **retry** được kích hoạt và có cơ chế giới hạn số lần **retry** để tránh **infinite loop**.\n\n**Lợi ích:** Giúp đảm bảo API có khả năng tự phục hồi (self-healing) khi gặp lỗi tạm thời."
    },
    {
      "question_id": "EQ2033-VN",
      "question": "Kịch bản lỗi nào thể hiện rõ nhất một lỗi phía máy khách?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "HTTP 400 Bad Request",
        "B": "HTTP 500 Internal Server Error",
        "C": "Lỗi **timeout** cơ sở dữ liệu",
        "D": "**Out-of-memory** trên máy chủ"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. HTTP 400 Bad Request – Là lỗi phía máy khách vì nó xảy ra khi dữ liệu yêu cầu không hợp lệ (ví dụ: một trường yêu cầu không được nhập).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**400 Bad Request** chỉ ra yêu cầu không hợp lệ từ phía máy khách."
    },
    {
      "question_id": "EQ2034-VN",
      "type": "Writing",
      "gold": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "**Test Case:** Log Correlation via Trace ID.\n- **Test Case ID:** TC-LOG-001.\n- **Test Case Name:** Verify logs linked to trace ID header.\n- **Preconditions:** API configured with tracing enabled, trace ID 'TRACE-123' available.\n- **Test Steps:**\n  1. Send request to `/process` with `X-Trace-ID: TRACE-123` header.\n  2. In logs, search for `trace_id: TRACE-123`.\n- **Expected Result:** Log entries found with matching trace ID."
    },
    {
      "question_id": "EQ2035-VN",
      "question": "Kịch bản nào trong số này yêu cầu **schema validation** trong quá trình **testing**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra thời gian phản hồi API trung bình",
        "B": "Đảm bảo các trường **JSON** phản hồi khớp với định nghĩa **OpenAPI**",
        "C": "Đo **throughput** dưới **tải**",
        "D": "Phân tích **log** truy vấn **SQL**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đảm bảo các trường **JSON** phản hồi khớp với định nghĩa **OpenAPI**.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Schema validation** đảm bảo tính chính xác về cấu trúc của các phản hồi."
    },
    {
      "question_id": "EQ2036-VN",
      "type": "Writing",
      "gold": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "**Test Case:** `Verify Rate Limit Enforcement - Bursty Requests`.\n\n- **Preconditions:** Máy khách A được cấu hình với giới hạn 100 req/min.\n- **Test Steps:**\n  1. Gửi 50 yêu cầu liên tục trong 1 phút.\n  2. Sau khi vượt qua giới hạn, tiếp tục gửi yêu cầu trong 5 phút.\n- **Expected Result:**\n  - Trước khi vượt qua giới hạn: `200 OK` cho tất cả yêu cầu.\n  - Sau khi vượt qua giới hạn: Yêu cầu thứ 51 và sauwards bị chặn với `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2037-VN",
      "question": "Điều nào sau đây cải thiện khả năng tái tạo của các **API tests** trong nhiều môi trường?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sử dụng các **URL** môi trường được **hardcode**",
        "B": "Ngẫu nhiên hóa tất cả dữ liệu **test**",
        "C": "Thực hiện **test** trên dữ liệu **production**",
        "D": "Tham số hóa các **endpoint** và sử dụng cấu hình môi trường"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Tham số hóa các **endpoint** và sử dụng cấu hình môi trường.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Parameterization** đảm bảo cùng một logic **test** hoạt động trên các môi trường."
    },
    {
      "question_id": "EQ2038-VN",
      "type": "Writing",
      "gold": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "*   **Test Case Tích Cực (Positive):** Gửi yêu cầu `POST /send-sms` với số điện thoại hợp lệ (`+8498765432`) và mã SMS ngắn bất kỳ (e.g., `12345`). Đợi xác nhận, kiểm tra trạng thái HTTP (e.g., `200 OK`), và nội dung phản hồi để xác nhận mã đã được gửi thành công.\n*   **Test Case Âm Tính (Negative):** Gửi yêu cầu `POST /send-sms` với số điện thoại trống hoặc không hợp lệ (e.g., `1234567`). Đợi xác nhận, kiểm tra trạng thái HTTP (e.g., `400 Bad Request` hoặc `500 Internal Server Error`), và nội dung phản hồi để xác nhận API đã xử lý lỗi phù hợp."
    },
    {
      "question_id": "EQ2039-VN",
      "question": "Điều nào trong số này mô tả rõ nhất **performance baseline testing**?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đo thời gian phản hồi bình thường dưới **tải** dự kiến",
        "B": "Kiểm tra API với các đầu vào không hợp lệ",
        "C": "Xác thực API so với **OpenAPI spec**",
        "D": "Mô phỏng lưu lượng truy cập **peak** gấp 10 lần"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Đo thời gian phản hồi bình thường dưới **tải** dự kiến.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Baseline testing** nắm bắt hiệu suất bình thường dự kiến."
    },
    {
      "question_id": "EQ2040-VN",
      "type": "Writing",
      "gold": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Lợi thế là **mock** cho phép chạy các test về lỗi mạng (timeout, 500 error) mà không phụ thuộc vào kết nối internet ổn định, giúp tăng độ tin cậy và tốc độ của pipeline test."
    },
    {
      "question_id": "EQ2041-VN",
      "question": "Điều nào trong số này là một **test case** chính xác để xác thực hết hạn **session**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đăng nhập với thông tin đăng nhập hợp lệ, mong đợi **200 OK**",
        "B": "Gửi yêu cầu với **token** hợp lệ ngay sau khi đăng nhập",
        "C": "Gửi yêu cầu với **token** sau khi hết **timeout session**, mong đợi **401 Unauthorized**",
        "D": "Gửi yêu cầu không có **token**, mong đợi **200 OK**"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Gửi yêu cầu với **token** sau khi hết **timeout session**, mong đợi **401 Unauthorized**",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Session** đã hết hạn phải trả về **401 Unauthorized**."
    },
    {
      "question_id": "EQ2042-VN",
      "type": "Writing",
      "gold": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "**Test Case:** `Verify Invalid JSON Response`\n\n- **Preconditions:** API đang chạy.\n- **Test Steps:**\n  1. Gửi yêu cầu GET bình thường.\n  2. Gửi yêu cầu với JSON Response bị định dạng sai (thiếu dấu ngoặc kép, từ khóa sai).\n- **Expected Result:**\n  - API phải trả về **HTTP Status Code 400 Bad Request**.\n  - Response Body phải chứa thông báo lỗi rõ ràng về vấn đề định dạng JSON."
    },
    {
      "question_id": "EQ2043-VN",
      "question": "Chiến lược nào giúp xác thực **tương thích ngược** sau khi thêm các trường tùy chọn mới?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đảm bảo các máy khách cũ vẫn hoạt động mà không cần gửi các trường mới",
        "B": "Buộc các máy khách cập nhật ngay lập tức",
        "C": "Xóa các trường cũ khỏi phản hồi",
        "D": "Yêu cầu các thay đổi **schema** phải gây lỗi"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Đảm bảo các máy khách cũ vẫn hoạt động mà không cần gửi các trường mới.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Tương thích ngược** có nghĩa là các máy khách cũ vẫn phải hoạt động mà không cần các trường mới."
    },
    {
      "question_id": "EQ2044-VN",
      "type": "Writing",
      "gold": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "**Test Step:**\n1. **Action:** Gửi một yêu cầu hợp lệ đến API.\n2. **Expected:**\n   - **Status Code:** `200 OK` hoặc mã trạng thái tương ứng.\n   - **Header:** `X-RateLimit-Remaining` phải có trong phản hồi HTTP.\n   - **Value:** Giá trị của `X-RateLimit-Remaining` phải chính xác (ví dụ: `10` nếu giới hạn là 10 yêu cầu/phút)."
    },
    {
      "question_id": "EQ2045-VN",
      "question": "Cách hiệu quả nhất để kiểm tra khả năng phục hồi khi một dịch vụ **downstream** của API bị lỗi là gì?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "options": {
        "A": "Vô hiệu hóa **retry** ở máy khách",
        "B": "Ngừng **testing** cho đến khi dịch vụ phục hồi",
        "C": "Chỉ chạy **unit tests**",
        "D": "Chèn lỗi bằng cách sử dụng **chaos testing** hoặc **mock**"
      },
      "gold_answer": "D",
      "model_raw_answer": "Đáp án: D. Chèn lỗi bằng cách sử dụng **chaos testing** hoặc **mock**.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Chaos testing/mocks** cho phép mô phỏng có kiểm soát các lỗi phụ thuộc."
    },
    {
      "question_id": "EQ2046-VN",
      "type": "Writing",
      "gold": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Lợi thế là dữ liệu **test** không bị ảnh hưởng bởi kết quả của các trường hợp **test** khác, đảm bảo tính độc lập và khả năng tái tạo kết quả **test** chính xác."
    },
    {
      "question_id": "EQ2047-VN",
      "question": "**Response status code** nào thích hợp cho một yêu cầu bị chặn do thiếu **authorization header**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 Unauthorized",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Thiếu ủy quyền dẫn đến **401 Unauthorized**."
    },
    {
      "question_id": "EQ2048-VN",
      "type": "Writing",
      "gold": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "### **Test Case: Cache Unavailable**\n- **Test Case ID:** TC-007\n- **Test Case Name:** Verify graceful degradation when cache service is unavailable.\n- **Preconditions:**\n  - Cache API (e.g., Redis, Memcached) is not reachable from API gateway.\n- **Test Steps:**\n  1. Send `GET /products` request to API.\n  2. Confirm API returns `200 OK` or an acceptable status code.\n- **Post-conditions/Expected Results:**\n  - Verify data is not served from cache. Instead, API should hit the backend database.\n  - Check logs to confirm graceful degradation without errors."
    },
    {
      "question_id": "EQ2049-VN",
      "question": "Điều nào sau đây thể hiện một **boundary test** thích hợp cho trường độ dài mật khẩu (**min**=8, **max**=20)?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra với 7, 8, 20, và 21 ký tự",
        "B": "Chỉ kiểm tra với 10 ký tự",
        "C": "Chỉ kiểm tra với 15 ký tự",
        "D": "Chỉ kiểm tra với mật khẩu trống"
      },
      "gold_answer": "A",
      "model_raw_answer": "A là câu trả lời đúng vì nó kiểm tra cả các trường hợp ở biên giới của yêu cầu (7 ký tự < min, 8 ký tự = min, 20 ký tự = max, 21 ký tự > max).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Boundary testing** bao gồm các giá trị ở, dưới và trên giới hạn."
    },
    {
      "question_id": "EQ2050-VN",
      "type": "Writing",
      "gold": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Xác thực logging: 1) Sử dụng các filter bảo mật trên logstash/kafka. 2) Đánh dấu các trường nhạy cảm bằng prefix như \"*****\". 3) Lưu trữ logs riêng biệt cho dữ liệu bảo mật."
    },
    {
      "question_id": "EQ2051-VN",
      "question": "Phương pháp giám sát nào giúp xác định sự gia tăng độ trễ dần dần qua các tuần?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đo thời gian bằng đồng hồ bấm giờ cho một yêu cầu duy nhất",
        "B": "Gỡ lỗi thủ công trong các sự cố",
        "C": "Phân tích xu hướng chuỗi thời gian bằng **dashboard**",
        "D": "Các chỉ số **code coverage**"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Phân tích xu hướng chuỗi thời gian bằng **dashboard**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Dashboard** và giám sát chuỗi thời gian làm nổi bật các xu hướng độ trễ."
    },
    {
      "question_id": "EQ2052-VN",
      "type": "Writing",
      "gold": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case Âm Tính:** Đặt trường tiền tệ với giá trị `USD` và thực hiện thanh toán. Đảm bảo hệ thống không báo lỗi và chuyển đổi tiền tệ thành USD.\n- **Boundary Test Case:** Đặt trường tiền tệ ở biên giới (ví dụ: `EUR` và `USD`), thực hiện thanh toán và kiểm tra kết quả."
    },
    {
      "question_id": "EQ2053-VN",
      "question": "Chiến lược nào đảm bảo các **contract test** vẫn hữu ích khi API phát triển?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Không bao giờ cập nhật **schema tests**",
        "B": "Xóa các trường tùy chọn khỏi **test**",
        "C": "Chỉ chạy các **regression test** thủ công",
        "D": "Phiên bản hóa các **schema contract** và duy trì **tương thích ngược**"
      },
      "gold_answer": "D",
      "model_raw_answer": "Đáp án D. Phiên bản hóa các **schema contract** và duy trì **tương thích ngược**.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Versioning** và **tương thích ngược** giữ cho các **contract test** đáng tin cậy."
    },
    {
      "question_id": "EQ2054-VN",
      "type": "Writing",
      "gold": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "**Test Case:** Kiểm tra tính ổn định khi mạng bị gián đoạn.\n- **Preconditions:** API đang chạy, giả lập mất gói mạng.\n- **Steps:**\n  - Gửi yêu cầu → mong đợi `503 Service Unavailable`.\n  - Đợi 10s → phục hồi kết nối → tiếp tục xử lý yêu cầu.\n- **Expected:** API phải phục hồi tự động."
    },
    {
      "question_id": "EQ2055-VN",
      "question": "Kịch bản nào trong số này xác thực chính xác **observability** API bằng cách sử dụng **distributed tracing**?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chỉ kiểm tra các **HTTP status codes**",
        "B": "Theo dõi một **trace ID** trên nhiều **microservice**",
        "C": "Kiểm tra việc sử dụng bộ nhớ trong các **log** máy chủ",
        "D": "Sử dụng các ghi chú **test** thủ công"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Theo dõi một **trace ID** trên nhiều **microservice**.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Trace ID** theo dõi các yêu cầu trên các dịch vụ."
    },
    {
      "question_id": "EQ2056-VN",
      "type": "Writing",
      "gold": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Phương pháp: 1) Sử dụng **ID test** cố định để tạo dữ liệu **test**. 2) Thực hiện **API test** tạo và sau đó xóa dữ liệu đó. 3) Kiểm tra DB trước và sau test để xác nhận dữ liệu đã bị xóa hoàn toàn."
    },
    {
      "question_id": "EQ2057-VN",
      "question": "Điều nào sau đây chỉ ra một lỗ hổng **denial-of-service**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "API chấp nhận yêu cầu không giới hạn mà không cần **throttling**",
        "B": "API trả về **404 Not Found**",
        "C": "**API schema** thiếu trường mô tả",
        "D": "**Unit test coverage** thấp"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. API chấp nhận yêu cầu không giới hạn mà không cần **throttling**. Lỗ hổng này cho phép tấn công **DoS** bằng cách gửi nhiều yêu cầu vô hạn.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Các yêu cầu không bị hạn chế có thể làm cạn kiệt tài nguyên, gây ra **DoS**."
    },
    {
      "question_id": "EQ2058-VN",
      "type": "Writing",
      "gold": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "**Test Case: Rollback Multi-Step Transaction**\n- **Preconditions:** DB sẵn sàng, thử nghiệm được thiết lập.\n- **Test Steps:**\n  1. Thực hiện giao dịch nhiều bước (A -> B -> C).\n  2. Thừa hưởng bước bất kỳ (đặt giá trị DB).\n  3. Thử nghiệm: Đặt bước C thất bại (gán giá trị không hợp lệ).\n- **Expected Result:** DB được rollback hoàn toàn, trạng thái trước khi bắt đầu giao dịch được bảo tồn. Không có bước nào bị lưu ngoài cơ chế rollback."
    },
    {
      "question_id": "EQ2059-VN",
      "question": "**HTTP status code** nào nên được xác thực khi một yêu cầu API được định dạng tốt nhưng bị cấm do hạn chế vai trò?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**403 Forbidden** chỉ ra máy khách đã được xác thực nhưng không được ủy quyền."
    },
    {
      "question_id": "EQ2060-VN",
      "type": "Writing",
      "gold": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "1. **Thiết lập cơ sở dữ liệu**: Đảm bảo các trường lỗi tồn tại trong schema JSON và được ánh xạ với các lỗi cơ bản (e.g., `400-BAD_REQUEST`, `404-NOT_FOUND`, `500-INTERNAL_SERVER_ERROR`).\n2. **Tạo yêu cầu lỗi**: Sử dụng công cụ như Postman hoặc Insomnia để gửi yêu cầu bất hợp lệ lên từng endpoint. Ví dụ: gửi request `GET` cho một resource không tồn tại, hoặc gửi request với trường dữ liệu không hợp lệ.\n3. **Xác thực phản hồi lỗi**: Sử dụng công cụ kiểm tra JSON như `jq` hoặc trực tiếp trong script để xác minh:\n   - **Mã trạng thái HTTP**: Là một trong các mã lỗi cơ bản (400, 404, 500).\n   - **Thân phản hồi (Body)**: Phải tuân theo **JSON schema** đã định nghĩa. Ví dụ, một lỗi `400` phải có trường `error` với thông tin lỗi cụ thể, dạng `string`.\n   - **Header**: Có thể cần kiểm tra các thông số như `Content-Type` hoặc các thông báo đặc biệt như `Retry-After`.\n4. **Thẻ nghiệm và báo cáo lỗi**: Nếu phản hồi lỗi không đúng, báo cáo lỗi với thông tin chi tiết về lỗi cơ bản nào không được đáp ứng.\n5. **Lặp lại với các trường hợp lỗi khác nhau**: Để đảm bảo schema JSON có thể xác thực được mọi loại lỗi có thể xảy ra trên các endpoint khác nhau."
    },
    {
      "question_id": "EQ3001-VN",
      "question": "Kịch bản nào sau đây thể hiện rõ nhất một bài kiểm tra multi-hop (đa bước) liên quan đến các endpoint đăng nhập và làm mới token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Gửi yêu cầu tới GET /health",
        "B": "Nhận access token qua POST /login, sau đó sử dụng POST /refresh để gia hạn session",
        "C": "Gửi yêu cầu với token đã hết hạn tới một endpoint được bảo vệ",
        "D": "Kiểm tra trạng thái 200 trên GET /docs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Nhận access token qua POST /login, sau đó sử dụng POST /refresh để gia hạn session.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Kiểm tra multi-hop có nghĩa là nối chuỗi đăng nhập với việc sử dụng refresh token sau đó."
    },
    {
      "question_id": "EQ3002-VN",
      "type": "Writing",
      "gold": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "### **Test Case: Đăng Nhập, Làm Mới Token, Truy Cập Bảo Vệ**\n- **Test Case ID:** TC-002\n- **Test Case Name:** Xác thực đăng nhập, làm mới token, truy cập API được bảo vệ.\n- **Preconditions:**\n  - Hệ thống API đã được bật và sẵn sàng.\n  - Có một user có quyền đủ để truy cập API được bảo vệ.\n- **Test Steps:**\n  1. **Đăng Nhập:** Gửi yêu cầu `POST /login` với email/password hợp lệ. Verify response có `token_access` và `token_refresh`.\n  2. **Làm Mới Token:** Sử dụng `token_refresh` gửi yêu cầu `POST /refresh-token` để nhận token mới. Verify token mới được trả về và có giá trị.\n  3. **Truy Cập Bảo Vệ:** Sử dụng `token_access` mới để gửi yêu cầu `GET /protected-resource`. Verify API trả về trạng thái `200 OK` và dữ liệu yêu cầu.\n- **Expected Results:**\n  - Yêu cầu đăng nhập và làm mới token đều phải thành công.\n  - Yêu cầu truy cập API được bảo vệ phải thành công khi sử dụng token mới.\n  - Token cũ không thể sử dụng để truy cập API bảo vệ."
    },
    {
      "question_id": "EQ3003-VN",
      "question": "Một server nên trả về mã trạng thái HTTP nào khi một refresh token đã hết hạn?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "401 Unauthorized",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 401 Unauthorized",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Refresh token đã hết hạn có nghĩa là client phải đăng nhập lại → 401 Unauthorized."
    },
    {
      "question_id": "EQ3004-VN",
      "type": "Writing",
      "gold": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Prevent Token Issuance on Failed Login**\n- **Preconditions:** API hỗ trợ refresh token và đăng nhập đã bật.\n- **Action:**\n  - Gửi yêu cầu đăng nhập với thông tin sai.\n- **Expected:** 403 Forbidden hoặc 401 Unauthorized, không có refresh token được phát hành trong trường hợp đó."
    },
    {
      "question_id": "EQ3005-VN",
      "question": "Cái nào sau đây ánh xạ một mã lỗi cụ thể của ứng dụng tới mã trạng thái HTTP chính xác?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "APP_1001 (User not found) → 404 Not Found",
        "B": "APP_2002 (Invalid password) → 201 Created",
        "C": "APP_3003 (Success) → 500 Internal Server Error",
        "D": "APP_9999 (Database error) → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. APP_1001 (User not found) → 404 Not Found.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Ánh xạ lỗi người dùng không tìm thấy tới 404 là một bản dịch HTTP chính xác."
    },
    {
      "question_id": "EQ3006-VN",
      "type": "Writing",
      "gold": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Tôi sẽ tạo một cơ sở dữ liệu chứa thông tin về mã nghiệp vụ và trạng thái HTTP. Sau đó, tôi sẽ tạo các trường hợp kiểm tra bằng cách gọi API với các mã nghiệp vụ khác nhau và xác minh rằng API trả về đúng mã trạng thái HTTP tương ứng (ví dụ: `201` cho tạo đơn hàng thành công, `409` cho đơn hàng tồn tại)."
    },
    {
      "question_id": "EQ3007-VN",
      "question": "Kịch bản nào thể hiện việc kiểm tra tiêu cực chuỗi (chained negative testing)?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Kiểm tra yêu cầu GET /status đơn lẻ",
        "B": "Đăng nhập hợp lệ sau đó truy cập /profile",
        "C": "Kiểm tra thời gian hoạt động của server với GET /health",
        "D": "Đăng nhập với mật khẩu hết hạn → 401, sau đó thử lại refresh token → 401"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Đăng nhập với mật khẩu hết hạn → 401, sau đó thử lại refresh token → 401",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Các bài kiểm tra tiêu cực chuỗi xác thực các thất bại trên nhiều endpoint."
    },
    {
      "question_id": "EQ3008-VN",
      "type": "Writing",
      "gold": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "### **Test Case: Tạo Đơn Hàng → Thanh Toán → Hoàn Tiền**\n- **Preconditions:**\n  - Tài khoản khách hàng sẵn tiền.\n  - Sản phẩm tồn kho.\n- **Test Steps:**\n  1. **Tạo ĐH:** `POST /orders` với sản phẩm A, B.\n  2. **Thanh Toán:** `POST /payments` cho đơn hàng vừa tạo.\n  3. **Hoàn Tiền:** `POST /refund` cho đơn hàng ID biết.\n- **Expected:** ĐH hoàn thành, trạng thái DB → DB → DB."
    },
    {
      "question_id": "EQ3009-VN",
      "question": "Mã trạng thái HTTP nào là chính xác để ánh xạ một lỗi tùy chỉnh ORDER_DUPLICATE tới HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "404 Not Found",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 409 Conflict",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Đơn hàng trùng lặp là một xung đột → 409."
    },
    {
      "question_id": "EQ3010-VN",
      "type": "Writing",
      "gold": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case xác thực: 1) Gửi yêu cầu đăng nhập → nhận token từ Service Authentication. 2) Sử dụng token gọi API protected trên Service A → 200 OK. 3) Service A gọi API khác trên Service B → Service B xác thực token → 200 OK. 4) Test token hết hạn → 401 Unauthorized."
    },
    {
      "question_id": "EQ3011-VN",
      "question": "Kịch bản nào xác thực việc xử lý lỗi đa bước (multi-hop) chính xác trong một quy trình thương mại điện tử?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Tạo đơn hàng → chi tiết thanh toán không hợp lệ → 402 Payment Required",
        "B": "Kiểm tra kho hàng → sản phẩm tồn tại → 200 OK",
        "C": "Gọi endpoint healthcheck → 200 OK",
        "D": "Yêu cầu danh mục sản phẩm → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Tạo đơn hàng → chi tiết thanh toán không hợp lệ → 402 Payment Required.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thanh toán thất bại sau khi tạo đơn hàng là một bài kiểm tra tiêu cực multi-hop."
    },
    {
      "question_id": "EQ3012-VN",
      "type": "Writing",
      "gold": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "### **Test Case: Xác Thực và Mã Lỗi**\n- **Test Case Name:** Valid + Invalid Authentication (Token).\n- **Test Case ID:** TC-007.\n- **Preconditions:** API đang hoạt động, có 1 user biết password và 1 token expired.\n\n- **Test Steps:**\n  - **Valid:** Gửi request với token hợp lệ → `200 OK` với response user data.\n  - **Invalid Token:** Gửi request với token hết hạn → `400 Bad Request` với message lỗi.\n  - **Invalid Payload:** Gửi request với payload không đúng format → `400 Bad Request` với message lỗi.\n\n- **Expected Results:**\n  - Response `200 OK` chỉ khi token hợp lệ.\n  - Mã lỗi `400` phải được trả về khi token hoặc payload không hợp lệ."
    },
    {
      "question_id": "EQ3013-VN",
      "question": "Cái nào trong số này thể hiện một bài kiểm tra đăng nhập chuỗi cấp độ khó?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Chỉ kiểm tra GET /login-docs",
        "B": "Chỉ đăng nhập một lần và dừng lại",
        "C": "Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại",
        "D": "Kiểm tra endpoint GET /health"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Kết hợp nhiều endpoint vào một quy trình xác thực."
    },
    {
      "question_id": "EQ3014-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Test Case:** `Test Refresh Token Expiry`.\n2. **Preconditions:**\n   - Có một refresh token đã hết hạn (ví dụ đã quá thời hạn 1 giờ).\n   - Access token liên quan đã hết hạn.\n3. **Test Steps:**\n   - Gửi yêu cầu refresh token đã hết hạn đến endpoint token refresh.\n4. **Expected Result:**\n   - API trả về trạng thái HTTP `403 Forbidden` hoặc `401 Unauthorized`.\n   - Không cấp được access token mới."
    },
    {
      "question_id": "EQ3015-VN",
      "question": "Ánh xạ nào là chính xác cho lỗi nghiệp vụ PAYMENT_DECLINED?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 402 Payment Required – vì đây là mã trạng thái HTTP dành cho yêu cầu bị từ chối vì lý do thanh toán.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Thanh toán bị từ chối → 402 Payment Required."
    },
    {
      "question_id": "EQ3016-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Bước 1:** Đăng nhập với một tài khoản xác thực và lưu trữ cookie của session được tạo ra. 2. **Bước 2:** Sử dụng cookie này gửi một yêu cầu GET đến một endpoint được bảo vệ (VD: `/protected/data`). 3. **Bước 3:** Sau khi yêu cầu được xử lý, yêu cầu hủy bỏ session được gửi đến server. 4. **Bước 4:** Một yêu cầu khác được gửi đến endpoint bảo vệ sử dụng cookie cũ. 5. **Bước 5:** Kiểm tra trạng thái HTTP và nội dung đáp ứng (VD: mã trạng thái `403 Forbidden` hoặc `404 Not Found`, nội dung JSON trả về không chứa dữ liệu)."
    },
    {
      "question_id": "EQ3017-VN",
      "question": "Kịch bản nào ánh xạ tới mã HTTP chính xác cho một lỗi ứng dụng nội bộ?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "APP_TIMEOUT → 200 OK",
        "B": "APP_TIMEOUT → 504 Gateway Timeout",
        "C": "APP_TIMEOUT → 201 Created",
        "D": "APP_TIMEOUT → 400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. APP_TIMEOUT → 504 Gateway Timeout",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Các lỗi timeout nên ánh xạ tới 504 Gateway Timeout."
    },
    {
      "question_id": "EQ3018-VN",
      "type": "Writing",
      "gold": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "### **Test Case: Đăng ký và Đăng nhập**\n- **Test Case ID:** TC-001\n- **Test Case Name:** Đăng ký mới -> Xác minh email -> Đăng nhập thành công.\n- **Preconditions:** Server API đang hoạt động.\n- **Test Steps:**\n  1. **Đăng ký:** Gửi yêu cầu POST tới `/users` với thông tin tên, email, password. Ví dụ: `POST /users` với body `{ \"name\": \"John Doe\", \"email\": \"john@example.com\", \"password\": \"Password123\" }`.\n  2. **Xác minh Email:** Không có endpoint trực tiếp xác minh email, nhưng giả sử hệ thống sẽ gửi email đến địa chỉ đăng ký. Vì test tự động, không thể chờ email, nên giả sử email đã được xác minh trước khi chạy test này.\n  3. **Đăng nhập:** Gửi yêu cầu POST tới `/login` với email và password được đăng ký. Ví dụ: `POST /login` với body `{ \"email\": \"john@example.com\", \"password\": \"Password123\" }`.\n- **Expected Results:**\n  - **Đăng ký:** Trả về `201 Created` và một chuỗi ID người dùng (ví dụ `{\"id\": \"user-123\"}`).\n  - **Đăng nhập:** Trả về `200 OK` với một chuỗi token xác thực (ví dụ `{\"token\": \"eyJhbGciOiJIUzI1NiJ9\"}`) và một chuỗi ID người dùng."
    },
    {
      "question_id": "EQ3019-VN",
      "question": "Bài kiểm tra nào xác thực quyền truy cập dựa trên vai trò chuỗi?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập với vai trò user → truy cập /admin → mong đợi 403 Forbidden",
        "B": "Đăng nhập với vai trò admin → truy cập /admin → mong đợi 200 OK",
        "C": "Đăng nhập với vai trò user → xem hồ sơ → 200 OK",
        "D": "GET /health → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "Câu trả lời đúng: A. Đăng nhập với vai trò user → truy cập /admin → mong đợi 403 Forbidden\nVấn đề: Kiểm tra xem một người dùng có thể truy cập vào một endpoint được bảo vệ bằng quyền hạn nào không. Ví dụ, endpoint /admin chỉ được phép truy cập bởi người dùng có vai trò là admin.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Vai trò không khớp dẫn đến 403 là một xác thực vai trò multi-hop."
    },
    {
      "question_id": "EQ3020-VN",
      "type": "Writing",
      "gold": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Bước 1:** Đăng nhập không đúng lần đầu → hệ thống gửi email hoặc SMS xác thực.\n2. **Bước 2:** Người dùng nhập mã xác thực → hệ thống yêu cầu đáp ứng (CAPTCHA).\n3. **Bước 3:** Sau khi thành công, yêu cầu nhập mật khẩu mới và xác nhận lại.\n4. **Bước 4:** Kiểm tra: mật khẩu cũ không thể dùng lại, mới đủ độ phức tạp và không trùng với trước đó."
    },
    {
      "question_id": "EQ3021-VN",
      "question": "Kịch bản nào xác thực một chuỗi đăng nhập, làm mới và đăng xuất?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập → sử dụng token một lần",
        "B": "Làm mới token ngay sau khi đăng nhập",
        "C": "Chỉ đăng xuất",
        "D": "Đăng nhập → làm mới token → đăng xuất → xác nhận làm mới thất bại"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Chuỗi này xác thực toàn bộ quy trình token trong API.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Chuỗi đầy đủ này kiểm tra toàn bộ vòng đời xác thực."
    },
    {
      "question_id": "EQ3022-VN",
      "type": "Writing",
      "gold": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "**Test Case: Quản lý Người dùng**\n- **Test Case ID:** TC-USER-001\n- **Test Case Name:** Xác thực tạo, cập nhật và xem hồ sơ người dùng.\n- **Test Case Description:** Kiểm tra các chức năng cơ bản của người dùng (tạo, cập nhật, xem hồ sơ).\n\n### **Test Case Steps:**\n- **Test Case 1: Tạo Người dùng**\n  - **Preconditions:** Đăng nhập với quyền quản trị.\n  - **Test Steps:**\n    - Gọi API `/users` với request body chứa thông tin người dùng (username, email, full_name).\n    - Verify: `200 OK`, dữ liệu được tạo thành công trong cơ sở dữ liệu.\n  - **Expected Result:**\n    - Người dùng mới được tạo và có thể tìm thấy trong hệ thống.\n\n- **Test Case 2: Cập nhật Hồ sơ**\n  - **Preconditions:** Người dùng tồn tại.\n  - **Test Steps:**\n    - Gọi API `/users/{id}` với phương thức `PUT`.\n    - Verify: `200 OK` nếu cập nhật thành công.\n  - **Expected Result:**\n    - Thông tin được cập nhật trong cơ sở dữ liệu.\n\n- **Test Case 3: Truy xuất Hồ sơ**\n  - **Preconditions:** Người dùng tồn tại.\n  - **Test Steps:**\n    - Gọi API `/users/{id}` với phương thức `GET`.\n    - Verify: `200 OK` nếu tìm thấy, nội dung chính xác.\n  - **Expected Result:**\n    - Dữ liệu về người dùng được trả về trong phản hồi API."
    },
    {
      "question_id": "EQ3023-VN",
      "question": "Ánh xạ nào dịch chính xác một lỗi nghiệp vụ STOCK_OUT sang HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "201 Created",
        "D": "403 Forbidden"
      },
      "gold_answer": "B",
      "model_raw_answer": "A. 200 OK",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Hết hàng có nghĩa là một xung đột với việc thực hiện đơn hàng, ánh xạ tới 409."
    },
    {
      "question_id": "EQ3024-VN",
      "type": "Writing",
      "gold": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập và nhận token**: Đăng nhập và nhận token access và refresh token.\n2. **Đăng xuất**: Gọi API đăng xuất và lưu lại refresh token.\n3. **Thử refresh**: Sử dụng refresh token vừa nhận để gửi yêu cầu refresh token.\n4. **Kiểm tra trạng thái**: Đảm bảo API trả về `403 Forbidden` hoặc `401 Unauthorized` vì đã đăng xuất."
    },
    {
      "question_id": "EQ3025-VN",
      "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi cho một quy trình giỏ hàng?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Thêm mặt hàng hợp lệ vào giỏ hàng → 200 OK",
        "B": "Thanh toán với thanh toán hợp lệ → 200 OK",
        "C": "Thêm mặt hàng → xóa mặt hàng → thanh toán → mong đợi 400 Bad Request",
        "D": "Xem giỏ hàng sau khi đăng nhập → 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Thêm mặt hàng → xóa mặt hàng → thanh toán → mong đợi 400 Bad Request.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Thanh toán giỏ hàng trống là một kịch bản tiêu cực chuỗi."
    },
    {
      "question_id": "EQ3026-VN",
      "type": "Writing",
      "gold": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "### **Test Case: Mã Lỗi Hợp Lệ**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Xác thực ánh xạ mã lỗi `AUTH_EXPIRED` → trạng thái HTTP.\n- **Preconditions:** API được cấu hình với module xác thực token.\n- **Test Steps:**\n  - **Scenario 1 (Positive):** Gửi yêu cầu với token hợp lệ → `200 OK`.\n  - **Scenario 2 (Negative):** Sử dụng token đã hết hạn → **Expected:** `HTTP 401 Unauthorized`.\n- **Post-conditions:** DB không bị ảnh hưởng.\n- **Test Case Owner:** [Tên người thực hiện].\n- **Test Case Status:** [Đã thực thi hoặc cần thực thi]."
    },
    {
      "question_id": "EQ3027-VN",
      "question": "Kịch bản nào thể hiện rõ nhất việc xác thực việc hủy đơn hàng chuỗi?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Hard",
      "options": {
        "A": "Tạo đơn hàng → hủy đơn hàng → GET /orders/{id} hiển thị status=cancelled",
        "B": "Hủy đơn hàng không tồn tại → 404",
        "C": "Chỉ tạo đơn hàng",
        "D": "Kiểm tra endpoint /status"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Kịch bản này thể hiện rõ việc xác thực việc hủy đơn hàng chuỗi bằng việc tạo một đơn hàng, thực hiện hành động hủy, và sau đó yêu cầu trạng thái đơn hàng đó.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Bao gồm vòng đời của việc tạo đơn hàng → hủy bỏ → xác minh."
    },
    {
      "question_id": "EQ3028-VN",
      "type": "Writing",
      "gold": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Một bài kiểm tra thất bại xác minh email: Gửi yêu cầu xác thực với token hết hạn hoặc không tồn tại. Thì trả lời 401 Unauthorized hoặc 400 Bad Request."
    },
    {
      "question_id": "EQ3029-VN",
      "question": "Ánh xạ nào dịch chính xác FILE_TOO_LARGE sang HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "404 Not Found",
        "D": "413 Payload Too Large"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 413 Payload Too Large",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "File quá lớn nên ánh xạ tới 413."
    },
    {
      "question_id": "EQ3030-VN",
      "type": "Writing",
      "gold": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "### **Test Case: Loan Approval Flow**\n- **Test Case ID:** TC-LOAN-001\n- **Test Case Name:** Chuỗi yêu cầu vay tiền với tín dụng chấp nhận và từ chối.\n- **Preconditions:**\n  - Có tài khoản khách hàng với ID `KH-123`.\n  - Hệ thống có sẵn dữ liệu về các khách hàng (tín dụng tốt, xấu, chưa có).\n- **Test Steps:**\n  1. **Đăng ký vay:** Gửi `POST /loans` với số tiền và kỳ hạn hợp lý, thuộc về `KH-123`. Expected: `201 Created` với ID đơn vay.\n  2. **Tín dụng kiểm tra:** Gửi `POST /credit-check` với ID khách hàng từ bước 1. Expected: `200 OK` với kết quả tín dụng.\n  3. **Phê duyệt vay:** Với tín dụng tốt, gửi `PUT /loans/{id}` với trạng thái `approved`. Expected: `200 OK`. Với tín dụng xấu, trạng thái `rejected`. Expected: `200 OK`.\n- **Post-condition:** Dữ liệu cơ sở dữ liệu cập nhật phản ánh trạng thái vay của khách hàng."
    },
    {
      "question_id": "EQ3031-VN",
      "question": "Chuỗi nào xác thực các refresh token trên nhiều session?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Chỉ đăng nhập → đăng xuất",
        "B": "Đăng nhập → làm mới token → đăng xuất → đăng nhập lại → xác nhận refresh token cũ không hợp lệ",
        "C": "Làm mới token mà không đăng nhập",
        "D": "Kiểm tra GET /status"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Chuỗi này đảm bảo refresh token chỉ được sử dụng một lần trên mỗi session.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Đảm bảo xử lý session trên nhiều lần đăng nhập."
    },
    {
      "question_id": "EQ3032-VN",
      "type": "Writing",
      "gold": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "**Test Case: Quản lý Mật khẩu**\n- **Bước 1: Đăng ký**\n  - **Test Scenario 1:** Đăng ký thành công với email và password hợp lệ.\n  - **Test Scenario 2:** Đăng ký với email đã tồn tại.\n  - **Test Scenario 3:** Đăng ký thiếu thông tin bắt buộc.\n- **Bước 2: Đặt lại mật khẩu**\n  - **Test Scenario 4:** Đặt lại mật khẩu thành công với email và câu hỏi bảo vệ hợp lệ.\n  - **Test Scenario 5:** Đặt lại mật khẩu với email không tồn tại.\n- **Bước 3: Đăng nhập**\n  - **Test Scenario 6:** Đăng nhập thành công với email và password đúng.\n  - **Test Scenario 7:** Đăng nhập sai password.\n  - **Test Scenario 8:** Đăng nhập với tài khoản bị khóa."
    },
    {
      "question_id": "EQ3033-VN",
      "question": "Ánh xạ nào là chính xác để ánh xạ lỗi nghiệp vụ INVALID_COUPON?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Coupon không hợp lệ nên ánh xạ tới 400 Bad Request."
    },
    {
      "question_id": "EQ3034-VN",
      "type": "Writing",
      "gold": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "**Test Case: Upload & Virus Scan**\n- **Test Case ID:** TC-FILE-001\n- **Test Case Name:** Chuỗi upload file, quét virus và tải xuống.\n- **Preconditions:** File mẫu sẵn, dịch vụ virus scan online accessible.\n- **Test Steps:**\n  1. **Upload File:** Request POST đến `/files` với file mẫu.\n  2. **Quét Virus:** Sử dụng dịch vụ virus scan online (API) để quét ID file vừa tải lên.\n  3. **Tải Xuống:** Request GET đến `/files/<ID_FILE>` để tải xuống file gốc.\n- **Expected Results:**\n  - File tải lên thành công.\n  - Quét virus trả về kết quả `Positive` (file an toàn) hoặc `Negative` (file bị nhiễm).\n  - File tải xuống trùng với bản gốc."
    },
    {
      "question_id": "EQ3035-VN",
      "question": "Kịch bản nào xác thực ánh xạ lỗi đa bước (multi-hop) chính xác trong quy trình thanh toán?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 402",
        "B": "API thanh toán trả về APPROVED → được ánh xạ tới HTTP 404",
        "C": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 201",
        "D": "API thanh toán trả về ERROR → được ánh xạ tới HTTP 200"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. API thanh toán trả về DECLINED → được ánh xạ tới HTTP 402 (Payment Required).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thanh toán bị từ chối ánh xạ chính xác tới 402 Payment Required."
    },
    {
      "question_id": "EQ3036-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Một bài kiểm tra chuỗi cần thực hiện các bước: 1) Mua token refresh. 2) Sử dụng token refresh để nhận token mới. 3) Cố gắng sử dụng token refresh đã cũ trong yêu cầu tiếp theo. Nếu API từ chối với mã lỗi 403 hoặc 401, và token mới vẫn hoạt động, thì bài kiểm tra đã thành công."
    },
    {
      "question_id": "EQ3037-VN",
      "question": "Ánh xạ nào là chính xác để ánh xạ RATE_LIMIT_EXCEEDED sang HTTP?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 429 Too Many Requests",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Vượt quá giới hạn tốc độ nên ánh xạ tới 429."
    },
    {
      "question_id": "EQ3038-VN",
      "type": "Writing",
      "gold": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Mua Hàng Online**\n- **Preconditions:** Sản phẩm sẵn, User có tài khoản và đủ tiền.\n- **Test Steps:**\n  - **Search:** API tìm kiếm sản phẩm với từ khóa \"Laptop\".\n  - **Add to Cart:** Sử dụng ID sản phẩm tìm được để thêm vào giỏ.\n  - **Checkout:** Tạo đơn hàng từ giỏ, nhập địa chỉ và thanh toán.\n- **Expected Result:** Đơn hàng được tạo thành công, trạng thái payment là'success'."
    },
    {
      "question_id": "EQ3039-VN",
      "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi trong quy trình đặt vé?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Đặt vé hợp lệ → 200 OK",
        "B": "Đặt vé → hủy vé → thử hoàn tiền → mong đợi 400 Bad Request",
        "C": "Xem các ghế có sẵn → 200 OK",
        "D": "Kiểm tra GET /status → 200 OK"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đặt vé → hủy vé → thử hoàn tiền → mong đợi 400 Bad Request.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tiêu cực chuỗi: hoàn tiền sau khi hủy là không hợp lệ."
    },
    {
      "question_id": "EQ3040-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Một bài kiểm tra chuỗi xác thực việc ngăn chặn tấn công chiếm đoạt session API bằng cách tạo ra các yêu cầu gửi token session khác nhau. \n- **Test Case 1:** Gửi yêu cầu xác thực với token session hợp lệ và kiểm tra phản hồi 200 OK. \n- **Test Case 2:** Gửi yêu cầu xác thực với token session đã bị hỏng (expired hoặc không tồn tại). Kiểm tra phản hồi 401 Unauthorized hoặc 403 Forbidden. \n- **Test Case 3 (Chuẩn hóa):** Sử dụng công cụ như Insomnia hoặc Postman tạo ra 100-200 yêu cầu gửi token session khác nhau. \n- **Test Case 4 (Tấn công):** Sử dụng công cụ như Burp hoặc Postman để gửi yêu cầu chiếm đoạt token session từ request khác. \n- **Expected Result:** Tất cả các yêu cầu gửi token session hợp lệ phải được chấp nhận. Tất cả các yêu cầu gửi token session đã bị hỏng phải bị từ chối. Không có yêu cầu chiếm đoạt session nào phải được chấp nhận."
    },
    {
      "question_id": "EQ3041-VN",
      "question": "Chuỗi nào xác thực chính xác việc xoay vòng token với phát hiện việc sử dụng lại refresh token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập → gọi API một lần → đăng xuất",
        "B": "Đăng nhập → làm mới token → thử sử dụng lại refresh token cũ → mong đợi 401 Unauthorized",
        "C": "Chỉ đăng nhập",
        "D": "Làm mới mà không đăng nhập"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Chuỗi này xác thực rằng hệ thống đang kiểm soát việc sử dụng lại refresh token.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Việc sử dụng lại token phải bị từ chối sau khi xoay vòng để ngăn chặn các cuộc tấn công replay."
    },
    {
      "question_id": "EQ3042-VN",
      "type": "Writing",
      "gold": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "**Test Case: Đồng Thời Lạc Quan với ETag**\n- **Test Scenario:** Sửa đổi một tài liệu → Lấy ETag → Cập nhật khác → Thử lại với ETag cũ → Đợi optimistic concurrency phát sinh.\n- **Expected:** Cập nhật thất bại với `409 Conflict` nếu ETag cũ không khớp."
    },
    {
      "question_id": "EQ3043-VN",
      "question": "Mã trạng thái HTTP nào nên được trả về khi một điều kiện tiên quyết If-Match thất bại do ETag cũ trong quá trình PUT /resource/{id}?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "412 Precondition Failed",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 412 Precondition Failed.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "ETag cũ nên ánh xạ tới 412 Precondition Failed."
    },
    {
      "question_id": "EQ3044-VN",
      "type": "Writing",
      "gold": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Bài kiểm tra phải mô phỏng quá trình xuất file lâu, theo dõi trạng thái job, và chỉ yêu cầu tải file khi job hoàn thành."
    },
    {
      "question_id": "EQ3045-VN",
      "question": "Ánh xạ nào từ mã nghiệp vụ tới HTTP là phù hợp nhất cho RESOURCE_VERSION_CONFLICT trong quá trình cập nhật?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Xung đột phiên bản ánh xạ chính xác tới 409 Conflict."
    },
    {
      "question_id": "EQ3046-VN",
      "type": "Writing",
      "gold": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "**Test Case: OAuth2 Authorization Code - Tiêu cực**\n- **Test Case Name:** Đăng ký quyền không tồn tại.\n- **Test Case ID:** TC-OAUTH-008.\n- **Test Case Version:** 1.0.\n- **Test Case Status:** Chưa thực hiện.\n\n- **Test Case Description:**\n  1. Người dùng xác thực qua /authorize với scope=\"read:messages\".\n 2. Sau khi nhận authorization code, thực hiện trao đổi mã lấy access token qua /token endpoint.\n- **Test Case Steps:**\n  - **Bước 1:** Gửi yêu cầu POST đến /token với grant_type=\"authorization_code\" và kèm theo authorization code.\n  - **Bước 2:** Trong cơ sở dữ liệu mock, giả lập trường yêu cầu quyền bị thiếu (ví dụ: không có quyền \"write:messages\").\n- **Test Case Expected Result:**\n  - **Kết quả Thử nghiệm:** HTTP Status Code 400 Bad Request hoặc 403 Forbidden được trả về.\n  - **Kết quả Hậu kiểm:** Lỗi xảy ra khi kiểm tra nội dung response."
    },
    {
      "question_id": "EQ3047-VN",
      "question": "Mã trạng thái nào thể hiện rõ nhất một refresh token được trình bày cho một client_id sai trong một hệ thống đa người thuê (multi-tenant)?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "C. 401 Unauthorized. Mã trạng thái này được sử dụng để chỉ định rằng một yêu cầu đã không được chứng thực hợp lệ. Trong trường hợp một refresh token được trình bày cho một client_id sai, server sẽ không thể xác minh tính hợp lệ của client, vì vậy trạng thái 401 Unauthorized là phù hợp nhất.",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "OAuth2 chỉ định invalid_grant (400) cho việc sử dụng client/refresh sai."
    },
    {
      "question_id": "EQ3048-VN",
      "type": "Writing",
      "gold": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. **Charge Creation (idempotent):**\n    * **Action:** `POST /charges` với dữ liệu charge.\n    * **Expected:** Charge được tạo một lần duy nhất với cùng Idempotency-Key. Thử lặp nhiều lần vẫn chỉ tạo 1 charge.\n    * **Negative:** Dữ liệu không hợp lệ (e.g., thiếu card token) → `400 Bad Request`.\n\n2. **Charge Update (idempotent):**\n    * **Action:** `PUT /charges/{chargeId}` với trạng thái mới (e.g., từ `pending` → `captured`).\n    * **Expected:** Trạng thái của charge được cập nhật một lần duy nhất. Thử update trạng thái đã tồn tại → `200 OK` nhưng không thay đổi trạng thái.\n\n3. **Charge Cancel (idempotent):**\n    * **Action:** `DELETE /charges/{chargeId}` hoặc `POST /charges/{chargeId}/cancel`.\n    * **Expected:** Charge bị hủy một lần duy nhất. Thử hủy charge đã hủy → `200 OK` nhưng không thay đổi trạng thái.\n\n4. **Refund (idempotent):**\n    * **Action:** `POST /charges/{chargeId}/refunds` với số tiền hoàn tiền.\n    * **Expected:** Refund được tạo một lần duy nhất với cùng Idempotency-Key. Thử lặp nhiều lần vẫn chỉ tạo 1 refund."
    },
    {
      "question_id": "EQ3049-VN",
      "question": "Ánh xạ trạng thái nào là chính xác cho mã nghiệp vụ INSUFFICIENT_FUNDS từ cổng thanh toán?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 402 Payment Required – mã trạng thái này được định nghĩa cho trường hợp thanh toán không thành công vì lý do về tiền bạc.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Không đủ tiền → 402 Payment Required."
    },
    {
      "question_id": "EQ3050-VN",
      "type": "Writing",
      "gold": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "### **Bài kiểm tra chuỗi xử lý file**\n- **Đầu tiên: Tải file lên**\n  - **Bước 1:** Sử dụng tool như `curl` hoặc `requests` thực hiện yêu cầu `POST` lên endpoint như `/upload`.\n  - **Đầu vào:** Chia sẻ một tệp tin cụ thể (ví dụ, một ảnh nhỏ) trong dự án.\n  - **Lời giải:** Yêu cầu phải được chấp nhận với trạng thái `201 Created` hoặc `200 OK` kèm theo ID file.\n\n- **Tiếp theo: Xử lý file**\n  - **Bước 2:** Sử dụng ID file từ bước trước, gửi yêu cầu `POST` tới endpoint xử lý như `/process/{file_id}`.\n  - **Đầu vào:** ID file từ bước trước.\n  - **Lời giải:** Endpoint này sẽ thực hiện các tác vụ như chuyển đổi định dạng, thêm watermark, hoặc bất kỳ logic nào liên quan đến file. Yêu cầu này phải được chấp nhận với trạng thái `202 Accepted` (nếu cần thời gian xử lý sau) hoặc `200 OK`.\n\n- **Cuối cùng: Tải trạng thái xuống**\n  - **Bước 3:** Sử dụng ID file, gửi yêu cầu `GET` tới endpoint như `/status/{file_id}` hoặc `/process/{file_id}/status`.\n  - **Lời giải:** Yêu cầu này sẽ trả về trạng thái hiện tại của file sau khi xử lý, bao gồm cả thông tin về việc đã hoàn thành hay chưa. Yêu cầu này phải được chấp nhận với trạng thái phù hợp (ví dụ, `200 OK` nếu đã hoàn thành, `202 Accepted` nếu đang xử lý).\n\n- **Cục diện cuối:** Tải file xử lý ra**\n  - **Bước 4:** Sử dụng ID file từ bước trước, gửi yêu cầu `GET` tới endpoint như `/processed/{file_id}`.\n  - **Lời giải:** Yêu cầu này sẽ tải về tệp tin đã được xử lý. Yêu cầu này phải được chấp nhận với trạng thái `200 OK` và nội dung tải về phải là bản xử lý thành công của file gốc."
    },
    {
      "question_id": "EQ3051-VN",
      "question": "Kịch bản nào xác thực chính xác chính sách backoff + thử lại trên các chuyển đổi 429 -> 200 của gateway?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "options": {
        "A": "API trả về 429 Too Many Requests → client thử lại với backoff → 200 OK",
        "B": "API trả về 401 Unauthorized → thử lại thành công",
        "C": "API trả về 404 Not Found → thử lại thành công",
        "D": "API trả về 500 → thử lại mà không có backoff"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. API trả về 429 Too Many Requests → client thử lại với backoff → 200 OK",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thử lại với backoff lũy thừa là cần thiết để xử lý 429."
    },
    {
      "question_id": "EQ3052-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "### **Bài Kiểm Tra: Hủy Bỏ Session SSO**\n- **Test Case:** Đăng nhập SSO → Truy cập API → Hủy Bỏ Session → Thử Lại API.\n- **Expected:** API phải trả `403 Forbidden` hoặc yêu cầu xác thực lại cho yêu cầu tiếp theo."
    },
    {
      "question_id": "EQ3053-VN",
      "question": "Mã HTTP nào nên ánh xạ tới BUSINESS_LIMIT_EXCEEDED khi hạn ngạch (quota) trên mỗi người dùng chặn một yêu cầu hợp lệ, đã xác thực?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 429 Too Many Requests",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Hạn ngạch cạn kiệt ánh xạ tới 429 Too Many Requests."
    },
    {
      "question_id": "EQ3054-VN",
      "type": "Writing",
      "gold": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "**Test Case: Tạo Đơn Hàng Một Phần**\n- **Test Case ID:** TC_SHIP_PARTIAL\n- **Test Case Name:** Tạo đơn hàng, ship một phần và hủy phần còn lại.\n- **Preconditions:**\n  - Có sẵn hàng tồn kho cho sản phẩm A và B.\n  - Tạo một đơn hàng có 3 sản phẩm (2A, 1B).\n- **Test Steps:**\n  1. Tạo đơn hàng.\n  2. Ghi nhận ID đơn hàng và trạng thái.\n  3. Ship 2 sản phẩm A.\n  4. Kiểm tra trạng thái đơn hàng và hàng tồn kho.\n  5. Hủy phần còn lại của đơn hàng (sản phẩm B).\n  6. Kiểm tra trạng thái đơn hàng và hàng tồn kho sau khi hủy.\n  7. Xác minh tiền chênh lệch được hoàn lại cho khách hàng.\n- **Post-conditions:** Xóa đơn hàng khỏi cơ sở dữ liệu."
    },
    {
      "question_id": "EQ3055-VN",
      "question": "Ánh xạ nào là chính xác nhất cho mã lỗi SIGNATURE_INVALID trên xác minh giao hàng webhook?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 401 Unauthorized",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Chữ ký webhook không hợp lệ nên trả về 401 Unauthorized."
    },
    {
      "question_id": "EQ3056-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Test Case:** `Verify 2FA Failure`.\n2. **Action:** Send `POST /login` with valid credentials, then `POST /2fa/verify` with an invalid 2FA code.\n3. **Expected:** `400 Bad Request` or `401 Unauthorized`."
    },
    {
      "question_id": "EQ3057-VN",
      "question": "Mã HTTP nào thể hiện rõ nhất một tài nguyên đã bị xóa mềm (soft-deleted) được yêu cầu bởi GET /resource/{id} sau DELETE (với trạng thái có thể khôi phục)?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "204 No Content"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 404 Not Found. Mã HTTP này được sử dụng khi một tài nguyên không thể được tìm thấy. Trong trường hợp một tài nguyên đã bị xóa mềm, mặc dù nó vẫn tồn tại trong cơ sở dữ liệu, yêu cầu GET cho ID đó nên trả về trạng thái 404 Not Found để thể hiện rằng tài nguyên đó không còn tồn tại theo cách thông thường.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tài nguyên đã bị xóa mềm nên được coi là không tìm thấy."
    },
    {
      "question_id": "EQ3058-VN",
      "type": "Writing",
      "gold": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Test Case: 1) Tạo trang 10 bản ghi. 2) Liệt kê → kiểm tra tổng số = 10. 3) Xóa 3 bản ghi. 4) Liệt kê → kiểm tra tổng số = 7. 5) Kiểm tra từng bản ghi đã xóa không còn trong danh sách."
    },
    {
      "question_id": "EQ3059-VN",
      "question": "Ánh xạ nào là chính xác khi sự cố phụ thuộc kích hoạt mạch ngắt (circuit breaker) MỞ, khiến gateway từ chối yêu cầu ngay lập tức?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "400 Bad Request"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable – Ánh xạ này chính xác khi gateway phát hiện sự cố hệ thống, chẳng hạn như máy chủ không phản hồi.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Mạch ngắt MỞ ánh xạ tới 503 Service Unavailable."
    },
    {
      "question_id": "EQ3060-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "**Test Case: Session Stickiness**\n- **Test Case:** Đăng nhập → Gọi API → Load Balancer → Node 1 → Node 2 → Node 3 → Đăng xuất.\n- **Expected:** Token chỉ được chấp nhận trên Node 1. Node 2/3 phải trả 403 Forbidden."
    },
    {
      "question_id": "EQ4001-VN",
      "question": "Luồng **chained** nào xác thực chính xác vòng đời đơn hàng với tạo → ghi nhận → hoàn tiền, đảm bảo **idempotency** trên các lần **retry**?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Tạo đơn hàng → **retry** hoàn tiền hai lần → hoàn tiền thất bại",
        "B": "Ghi nhận thanh toán mà không tạo đơn hàng",
        "C": "Tạo đơn hàng → ghi nhận thanh toán → **retry** ghi nhận với cùng **idempotency key** → một lần ghi nhận duy nhất → hoàn tiền thành công",
        "D": "Hoàn tiền trước khi tạo đơn hàng"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Tạo đơn hàng → ghi nhận thanh toán → **retry** ghi nhận với cùng **idempotency key** → một lần ghi nhận duy nhất → hoàn tiền thành công.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Idempotency** phải đảm bảo các lần ghi nhận trùng lặp không tạo ra nhiều lần ghi nhận."
    },
    {
      "question_id": "EQ4002-VN",
      "type": "Writing",
      "gold": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "Test Case: Quản lý trạng thái tài khoản.\n- **Test Case 1 (Tạo & Kích hoạt):** Gửi yêu cầu tạo tài khoản → xác nhận trạng thái là `active`.\n- **Test Case 2 (Tạm ngừng & Kích hoạt lại):** Đổi trạng thái → gửi yêu cầu kích hoạt lại → trạng thái trở lại `active`.\n- **Test Case 3 (Xóa):** Xoá tài khoản → trạng thái DB → `deleted`.\n- **Test Case 4 (Trạng thái bất hợp lệ):** Gửi yêu cầu với trạng thái không tồn tại → API trả lỗi `400`."
    },
    {
      "question_id": "EQ4003-VN",
      "question": "Ánh xạ nào là đúng để xử lý một giao dịch trùng lặp được phát hiện trong quá trình yêu cầu hoàn tiền?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 409 Conflict. Vì giao dịch đã tồn tại và không thể được tạo lại.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Giao dịch trùng lặp phải ánh xạ tới **409 Conflict**."
    },
    {
      "question_id": "EQ4004-VN",
      "type": "Writing",
      "gold": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Test Case 1: Success** (giao dịch thành công): Tích hợp các API chuyển tiền (Step 1), xác minh tiền chuyển đến.\n2. **Test Case 2: Fail tại bước 2** (giao dịch thất bại khi chuyển tiền): API bước 2 (chuyển tiền) giả lập lỗi cơ bản, xác minh giao dịch được **rollback** hoàn toàn.\n3. **Test Case 3: Fail tại bước 3** (giao dịch thất bại khi xác nhận giao dịch): API bước 3 (xác nhận giao dịch) giả lập lỗi cơ bản, xác minh giao dịch được **rollback** hoàn toàn.\n4. **Test Case 4: Fail ở bước 2 nhưng bước 3 được gọi trước khi rollback** (giao dịch thất bại khi chuyển tiền nhưng bước 3 đã được gọi): API bước 2 (chuyển tiền) giả lập lỗi cơ bản, bước 3 được gọi trước khi rollback, xác minh giao dịch được **rollback** hoàn toàn.\n5. **Test Case 5: Fail ở bước 3 nhưng bước 2 được gọi trước khi rollback** (giao dịch thất bại khi xác nhận giao dịch nhưng bước 2 đã được gọi): API bước 3 (xác nhận giao dịch) giả lập lỗi cơ bản, bước 2 được gọi trước khi rollback, xác minh giao dịch được **rollback** hoàn toàn."
    },
    {
      "question_id": "EQ4005-VN",
      "question": "Kịch bản **chained** nào xác thực đúng việc truyền lỗi trong một giao dịch **distributed saga**?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Bắt đầu saga → tất cả các bước thành công",
        "B": "Bắt đầu saga → bỏ qua lỗi ở bước 2",
        "C": "Bắt đầu saga → **rollback** bị bỏ qua",
        "D": "Bắt đầu saga → bước 3 thất bại → **rollback** bù trừ của các bước 1 & 2 được thực thi"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Bắt đầu saga → bước 3 thất bại → **rollback** bù trừ của các bước 1 & 2 được thực thi.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Mô hình **saga** đảm bảo các hành động bù trừ khi thất bại."
    },
    {
      "question_id": "EQ4006-VN",
      "type": "Writing",
      "gold": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "**Test Case:** * **Test Scenario:** Đăng nhập thành công, tạo đơn hàng, xử lý thanh toán, hủy đơn hàng. * **Test Steps:**\n    1. Đăng nhập với tài khoản admin.\n    2. Tạo đơn hàng với sản phẩm bất kỳ.\n    3. Xử lý thanh toán thành công.\n    4. Hủy đơn hàng.\n    5. Validate trạng thái đơn hàng cuối cùng là 'Hủy' và không có lỗi xảy ra. * **Expected Result:** Trạng thái cuối cùng là 'Hủy', không lỗi."
    },
    {
      "question_id": "EQ4007-VN",
      "question": "Kịch bản xử lý lỗi nào tốt nhất để xác thực các kiểm tra hợp lý trong **payment APIs**?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Gửi hoàn tiền > số tiền đã ghi nhận → **400 Bad Request**",
        "B": "Gửi hoàn tiền = số tiền đã ghi nhận → **200 OK**",
        "C": "Gửi hoàn tiền < số tiền đã ghi nhận → **200 OK**",
        "D": "Hoàn tiền mà không ghi nhận → **200 OK**"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Gửi hoàn tiền > số tiền đã ghi nhận → **400 Bad Request**\nLý do: Khi yêu cầu hoàn tiền lớn hơn số tiền đã ghi nhận, API nên trả **400 Bad Request** vì yêu cầu không hợp lệ.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Số tiền hoàn tiền lớn hơn số tiền đã ghi nhận phải thất bại với **400**."
    },
    {
      "question_id": "EQ4008-VN",
      "type": "Writing",
      "gold": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "**Test Case:** \"Mật khẩu vòng đời\".\n\n- **Test Step 1:** Đăng nhập với mật khẩu mới → **Expected:** `200 OK`.\n- **Test Step 2:** Lỗi khi sử dụng mật khẩu cũ sau khi hết hạn → **Expected:** `403 Forbidden`.\n- **Test Step 3:** Đăng nhập → Đổi mật khẩu → Sử dụng lại → **Expected:** `400 Bad Request`."
    },
    {
      "question_id": "EQ4009-VN",
      "question": "Ánh xạ nào tốt nhất để xác thực xử lý lỗi định dạng cho các tải trọng **JSON** bị định dạng sai?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**JSON** bị định dạng sai phải dẫn đến **400 Bad Request**."
    },
    {
      "question_id": "EQ4010-VN",
      "type": "Writing",
      "gold": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "Test Case: `POST /apply-loan`\n- **Step 1:** Gửi yêu cầu đăng ký với thông tin hợp lệ.\n- **Step 2:** Tương tự, nhưng trong **branch** thất bại, thêm một trường thông tin cá nhân (e.g., `borrower.occupation = ''`) **không hợp lệ**.\n- **Expected:** Trong trường hợp **thanh công** (tín dụng được chấp nhận), API trả mã xác nhận `201 Created` và email xác nhận. Đối với **thất bại** (do thông tin không hợp lệ), API phản hồi `400 Bad Request` với lỗi cụ thể."
    },
    {
      "question_id": "EQ4011-VN",
      "question": "Luồng **chained** nào xác thực trạng thái nhất quán trong quy trình đặt phòng phân tán?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Chỉ đặt khách sạn",
        "B": "Đặt khách sạn → đặt chuyến bay → chuyến bay thất bại → đặt phòng khách sạn tự động bị hủy",
        "C": "Chỉ đặt chuyến bay",
        "D": "Đặt khách sạn và giữ đặt phòng ngay cả khi thanh toán thất bại"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đặt khách sạn → đặt chuyến bay → chuyến bay thất bại → đặt phòng khách sạn tự động bị hủy.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Việc tự động hủy khách sạn đảm bảo trạng thái nhất quán trên các hệ thống."
    },
    {
      "question_id": "EQ4012-VN",
      "type": "Writing",
      "gold": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "Test Scenario: Gửi hai yêu cầu update hồ sơ với trường tên khác nhau vào cùng một lúc. Expected: Chỉ yêu cầu đầu tiên được chấp nhận, còn lại bị từ chối với mã lỗi duy nhất (e.g., `409 Conflict`)."
    },
    {
      "question_id": "EQ4013-VN",
      "question": "**HTTP code** nào là đúng để xác thực kiểm tra hợp lý khi rút tiền > số dư tài khoản?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "400 Bad Request"
      },
      "gold_answer": "D",
      "model_raw_answer": "C. 403 Forbidden.",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Rút tiền quá số dư phải bị từ chối với **400 Bad Request**."
    },
    {
      "question_id": "EQ4014-VN",
      "type": "Writing",
      "gold": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Chuỗi các test case như tải lên file bất hợp pháp → ký → xác minh → file hợp lệ → giả mạo → file bị từ chối."
    },
    {
      "question_id": "EQ4015-VN",
      "question": "Kịch bản nào xác thực **rollback** trạng thái khi một API cập nhật thông tin người dùng một phần và giao dịch **DB** thất bại?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Cập nhật thất bại giữa chừng → không có thay đổi một phần nào tồn tại",
        "B": "Cập nhật thất bại giữa chừng → thay đổi một phần vẫn còn",
        "C": "Cập nhật thất bại giữa chừng → hệ thống bị lỗi",
        "D": "Cập nhật thành công mặc dù **DB rollback**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Lời giải: Kịch bản phải xác thực xem sau khi **rollback**, trạng thái cuối cùng có phải là nguyên trạng ban đầu (tính bất biến) hay không. Ví dụ, nếu trước khi gọi API, tên người dùng là \"John Doe\" và email là \"john.doe@example.com\", sau khi API cập nhật một phần (chẳng hạn chỉ đổi tên) và thất bại, thì **rollback** phải đảm bảo tên vẫn là \"John Doe\" và email vẫn là \"john.doe@example.com\".",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "**Rollback** thích hợp ngăn ngừa dữ liệu một phần/không nhất quán."
    },
    {
      "question_id": "EQ4016-VN",
      "question": "Kịch bản **chained** nào tốt nhất để xác thực **idempotency** của một **endpoint** ghi nhận thanh toán?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "POST /capture hai lần với các giá trị **Idempotency-Key** khác nhau → hai lần ghi nhận",
        "B": "POST /capture hai lần với cùng một **Idempotency-Key** → một lần ghi nhận duy nhất được ghi lại",
        "C": "POST /refund mà không ghi nhận → thành công",
        "D": "GET /capture-status một lần"
      },
      "gold_answer": "B",
      "model_raw_answer": "Câu trả lời đúng: B. POST /capture hai lần với cùng một **Idempotency-Key** → một lần ghi nhận duy nhất được ghi lại.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Idempotency** đảm bảo các yêu cầu trùng lặp với cùng một khóa không tạo ra nhiều lần ghi nhận."
    },
    {
      "question_id": "EQ4017-VN",
      "type": "Writing",
      "gold": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Test Case:** Tạo User (expected: `200 OK` và tồn tại trong DB). 2. **Test Case:** Nâng cấp User → thêm quyền admin (expected: chỉ `200 OK` nếu user tồn tại và quyền được cập nhật). 3. **Test Case:** Hạ cấp User → xóa quyền admin (expected: `200 OK` nếu user tồn tại, quyền bị xóa). 4. **Test Case:** Hủy đăng ký User → xóa tài khoản (expected: `200 OK`, DB không chứa record)."
    },
    {
      "question_id": "EQ4018-VN",
      "question": "Ánh xạ nào là đúng để xử lý mã lỗi ứng dụng **LIMIT_EXCEEDED** cho hạn ngạch API mỗi tài khoản?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 429 Too Many Requests – được sử dụng cho các trường hợp quá trình hoặc hạn ngạch bị vượt quá.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Vượt quá giới hạn/hạn ngạch ánh xạ tới **429 Too Many Requests**."
    },
    {
      "question_id": "EQ4019-VN",
      "type": "Writing",
      "gold": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Chaining các hoạt động trong saga phân tán đòi hỏi các trường hợp kiểm tra toàn diện và khả năng hồi phục phức tạp."
    },
    {
      "question_id": "EQ4020-VN",
      "question": "Luồng **chained** nào xác thực việc phát hiện lạm dụng **OAuth2 token** trên các dịch vụ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "options": {
        "A": "Đăng nhập một lần",
        "B": "Làm mới **token** ngay lập tức",
        "C": "Đăng nhập → lấy **token** → cố gắng sử dụng **token** trong một máy khách khác → **403 Forbidden**",
        "D": "Chỉ đăng xuất"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. **Chained** xác thực: Đăng nhập → lấy **token** → cố gắng sử dụng **token** trong một máy khách khác → **403 Forbidden**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Việc lạm dụng **token** chéo máy khách phải bị cấm."
    },
    {
      "question_id": "EQ4021-VN",
      "type": "Writing",
      "gold": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "Test khó vì phụ thuộc vào chu trình nghiệp vụ phức tạp, các trạng thái tài khoản phải được kiểm soát chặt chẽ."
    },
    {
      "question_id": "EQ4022-VN",
      "question": "Kịch bản nào tốt nhất để xác thực xử lý lỗi định dạng cho sự không khớp đầu vào **XML vs JSON**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "Gửi thân **XML** với **Content-Type: application/json** → **415 Unsupported Media Type**",
        "B": "Gửi thân **JSON** với **application/json** → **200 OK**",
        "C": "Gửi thân **XML** với **application/xml** → **200 OK**",
        "D": "Gửi **YAML** → **200 OK**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Câu trả lời đúng: C. Gửi thân **XML** với **application/xml** → **200 OK**. \n\nGiải thích: Để xác thực xử lý lỗi định dạng cho sự không khớp đầu vào **XML vs JSON**, ta cần gửi yêu cầu với thân **XML** và header **Content-Type: application/xml**. Nếu API xử lý lỗi tốt, khi nhận được một định dạng không phù hợp, nó sẽ trả về một mã trạng thái lỗi (ví dụ như **415 Unsupported Media Type** nếu API chỉ hỗ trợ **JSON**).",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Sự không khớp trong thân so với **header** phải dẫn đến **415**."
    },
    {
      "question_id": "EQ4023-VN",
      "type": "Writing",
      "gold": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Thêm hàng mới → trạng thái 'Đã Nhập'. 2) Phân bổ cho đơn hàng → trạng thái 'Đã Phân'. 3) Vận chuyển → trạng thái 'Đã Giao'. 4) Trả lại hàng → trạng thái 'Đã Trả'. 5) Đối chiếu số lượng → trạng thái 'Đã Kiểm Tra'."
    },
    {
      "question_id": "EQ4024-VN",
      "question": "**HTTP status** nào là đúng khi xảy ra lỗi xác thực **schema** cho một trường lồng nhau?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Lỗi xác thực **schema** phải trả về **400**."
    },
    {
      "question_id": "EQ4025-VN",
      "type": "Writing",
      "gold": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "Test Chain: 1) Đăng nhập → lưu **token**. 2) Lần sau làm mới **token** → vẫn hoạt động. 3) Đăng xuất → token hết hạn. 4) Sử dụng **token** cũ → bị từ chối."
    },
    {
      "question_id": "EQ4026-VN",
      "question": "Kịch bản **chained** nào xác thực **rollback** thích hợp sau khi đặt phòng nhiều bước (chuyến bay + khách sạn) khi thanh toán thất bại?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Đặt chuyến bay → **200 OK**",
        "B": "Đặt khách sạn → **200 OK**",
        "C": "Đặt chuyến bay + khách sạn → thanh toán thành công",
        "D": "Đặt chuyến bay + khách sạn → thanh toán thất bại → **rollback** cả hai đặt phòng"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Đặt chuyến bay + khách sạn → thanh toán thất bại → **rollback** cả hai đặt phòng.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Rollback** đảm bảo không còn đặt phòng không nhất quán."
    },
    {
      "question_id": "EQ4027-VN",
      "type": "Writing",
      "gold": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "1. **Test Case 1: Gửi Email**\n   - **Action:** API gửi email cho user mới (e.g., `POST /users`).\n   - **Expected:** Email được gửi thành công, DB có thông tin email.\n\n2. **Test Case 2: Theo dõi Mở Email**\n   - **Action:** API yêu cầu hệ thống theo dõi mở email (e.g., `GET /emails/{id}/status`).\n   - **Expected:** API trả về trạng thái email (e.g., `open`).\n\n3. **Test Case 3: Hủy Đăng Ký**\n   - **Action:** API thực hiện hủy đăng ký user liên quan đến email (e.g., `DELETE /users/{id}`).\n   - **Expected:** Email không thể mở được nữa, DB cập nhật trạng thái email.\n\n4. **Test Case 4: Đảm Bảo Không Gửi Lại**\n   - **Action:** Lặp lại `Test Case 1` sau khi email đã được theo dõi mở và hủy.\n   - **Expected:** API không gửi email mới, hệ thống đảm bảo không lặp lại hành động gửi email cho user đã xóa."
    },
    {
      "question_id": "EQ4028-VN",
      "question": "Ánh xạ nào là đúng cho mã ứng dụng **TOKEN_REPLAY_DETECTED**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "A. 200 OK",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Tái sử dụng **token** phải được xử lý như **401 Unauthorized**."
    },
    {
      "question_id": "EQ4029-VN",
      "type": "Writing",
      "gold": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chain phức tạp vì cần các bước logic và rollback đảm bảo hệ thống ổn định sau thất bại."
    },
    {
      "question_id": "EQ4030-VN",
      "question": "Luồng **chained** nào xác thực việc thanh toán không đồng bộ với đối chiếu?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Chỉ tạo đơn hàng",
        "B": "Tạo đơn hàng → ghi nhận thanh toán → đối chiếu không đồng bộ → trạng thái cuối cùng=đã đối chiếu",
        "C": "Hoàn tiền mà không đối chiếu",
        "D": "Kiểm tra tình trạng API"
      },
      "gold_answer": "B",
      "model_raw_answer": "C. Hoàn tiền mà không đối chiếu.",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Thanh toán không đồng bộ phải đối chiếu chính xác."
    }
  ],
  "writing_for_review": [
    {
      "question_id": "EQ5004",
      "question": "Write one simple positive test case for a login API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user 'user@example.com' with password 'Password123' exists.\n- **Test Steps:** Send a `POST` request to `/login` with the correct email and password in the body.\n- **Expected Result:** The API returns a `200 OK` status code with a valid authentication token in the response."
    },
    {
      "question_id": "EQ5006",
      "question": "What is a common precondition for testing a user profile endpoint?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "User must be logged in and have a valid token.",
      "model_answer": "A common precondition is that a user account must exist with a valid profile. This means the API should have a user registration or profile creation endpoint that has been successfully used to generate a user ID or token."
    },
    {
      "question_id": "EQ5008",
      "question": "Write a simple negative test for a register API.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Test case: Send a registration request with an email that already exists. Expected result: the API returns a `409 Conflict` status code with an appropriate error message."
    },
    {
      "question_id": "EQ5010",
      "question": "What is the role of a schema in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure and data types expected for API requests and responses. It acts as a contract between the client and server, allowing testers to validate correctness and detect schema violations."
    },
    {
      "question_id": "EQ5012",
      "question": "Write a simple test step for validating a 201 Created response.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "**Test Step:** Send a `POST /users` request with a valid user payload. **Expected Result:** The API should return a `201 Created` status code. **Additional Verification:** The response body should contain the newly created user's ID or a location header with the user's URL."
    },
    {
      "question_id": "EQ5014",
      "question": "What is the purpose of mocking in API testing?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependencies with simulated ones. In API testing, it allows testers to isolate the API under test and simulate the behavior of its downstream services (e.g., databases, other microservices) without needing those services to be running. This makes testing faster, more reliable, and easier to set up."
    },
    {
      "question_id": "EQ5016",
      "question": "Write one easy test case for an API that fetches product list.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "Test Case: 'Fetch Products' Positive. **Preconditions:** API is running. **Steps:** Send GET request to `/products`. **Expected:** Status Code = 200 OK, Response contains at least 3 products."
    },
    {
      "question_id": "EQ5018",
      "question": "What is the purpose of a precondition in a test case?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "The purpose of a precondition is to ensure that the test environment and system state are stable and consistent before the test execution begins. It defines the required state or setup (e.g., user login, data existence, system configuration) that must be in place for the test to be valid."
    },
    {
      "question_id": "EQ5020",
      "question": "Write one negative test for file upload with an unsupported format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Test case: Upload a.txt file. Expected: API rejects the file with a `415 Unsupported Media Type` or `400 Bad Request` error."
    },
    {
      "question_id": "EQ5022",
      "question": "What is the purpose of a test case description?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "To explain the objective and scope of a test scenario.",
      "model_answer": "The purpose of a test case description is to provide a clear and concise summary of what the test case aims to verify, including its functionality and expected outcome."
    },
    {
      "question_id": "EQ5024",
      "question": "Write a test step to validate response time under 1 second.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "Test Step: Send `GET /health` request 10 times. Verify average response time < 1s."
    },
    {
      "question_id": "EQ5027",
      "question": "Write one simple positive test for GET /health endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "### **Test Case: Health Endpoint**\n- **Test Case Name:** Verify Health Endpoint Returns 200 OK.\n- **Preconditions:** API deployed and running.\n- **Test Steps:** Send a `GET` request to `/health`.\n- **Expected Result:**\n  - The API returns a `200 OK` status code.\n  - The response body should contain a simple success message like `\"healthy\"` or a specific health check status."
    },
    {
      "question_id": "EQ5029",
      "question": "What is the purpose of using test data management in API testing?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management ensures that unique, clean, and consistent data is available for each test case. It prevents data collisions and makes test results reliable."
    },
    {
      "question_id": "EQ5031",
      "question": "Write one easy negative test case for an API expecting JSON format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "### **Negative Test Case: Invalid JSON Format**\n-   *Test Case Name:* Verify API rejects malformed JSON.\n-   *Test Steps:* Send a `POST` request to `/products` with a raw string instead of JSON (`{\"price\": 9.99}`). \n-   *Expected Result:* The API should return a `400 Bad Request` status code with a clear error message indicating that the request body is invalid."
    },
    {
      "question_id": "EQ5033",
      "question": "What is the role of assertions in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions are the foundation of API testing. They define the expected behavior by verifying that actual values (e.g., status codes, response bodies, headers) match the expected ones. Without strong assertions, tests are meaningless."
    },
    {
      "question_id": "EQ5035",
      "question": "Write a test case to check DELETE /users/{id} works correctly.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "### **Test Case: Delete User**\n- **Preconditions:** User ID=123 exists, ID=999 does not.\n- **Steps:**\n  - Request `/users/123` → expect `204 No Content`.\n  - Request `/users/999` → expect `404 Not Found`.\n- **Expected:** User ID=123 is deleted from DB."
    },
    {
      "question_id": "EQ5037",
      "question": "What does HTTP status 201 Created indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "A new resource has been successfully created.",
      "model_answer": "It indicates that the request was successful and a new resource has been created as a result."
    },
    {
      "question_id": "EQ5039",
      "question": "Write one simple test for GET /users/{id} returning correct response.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test case: **Get User by ID**\n- **Action:** Send request to `/users/123`.\n- **Expected:** Status `200 OK`, response body contains user data with ID `123`."
    },
    {
      "question_id": "EQ5041",
      "question": "What is the purpose of a 200 OK response?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It confirms that the request has succeeded.",
      "model_answer": "A 200 OK response indicates that the request was successful and the data was returned as expected."
    },
    {
      "question_id": "EQ5043",
      "question": "Write one negative test to validate response for an invalid endpoint.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "### **Test Case: Invalid Endpoint**\n-   **Test Case Name:** Verify `GET /invalid-path` returns a `404 Not Found` status code.\n-   **Preconditions:** The API is running.\n-   **Test Steps:**\n    - Send a `GET` request to the URL `/invalid-path`.\n-   **Expected Result:**\n    - The API should respond with a `404 Not Found` status code.\n    - The response body should contain an error message indicating the resource was not found."
    },
    {
      "question_id": "EQ5045",
      "question": "What does a test case assertion do?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion defines the condition that must be true for a test to pass. It compares the actual outcome with the expected outcome. For example, 'assert user.role == \"admin\"' ensures the user's role is correct."
    },
    {
      "question_id": "EQ5047",
      "question": "Write one positive test for file upload endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "**Test Case: Upload Valid File**\n- **Preconditions:** File `image.jpg` exists on local machine.\n- **Action:** Send `POST` request to `/upload` with file attached.\n- **Expected:** `201 Created` with file stored on server."
    },
    {
      "question_id": "EQ5049",
      "question": "What is the role of 415 Unsupported Media Type?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "The `415 Unsupported Media Type` status code is used to indicate that the server does not support the media type (e.g., `application/json`) sent in the request's `Content-Type` header. This error typically occurs when a client requests a resource using a format that the server cannot process."
    },
    {
      "question_id": "EQ5052",
      "question": "Write a simple positive test for checking product details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "**Test Case: Get Product Details**\n- **Test Case Name:** Verify product details are returned successfully.\n- **Preconditions:** Product ID=123 exists in DB.\n- **Test Steps:**\n  1. Send GET request to `/products/123`.\n- **Expected Result:**\n  - Status Code: `200 OK`.\n  - Response Body contains product name, price, and description."
    },
    {
      "question_id": "EQ5054",
      "question": "What is the purpose of using Authorization headers in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The purpose is to simulate user permissions and restrict access to protected resources. By including valid tokens like OAuth2 or API Keys in the `Authorization` header, testers can validate that only allowed actions are performed."
    },
    {
      "question_id": "EQ5056",
      "question": "Write a negative test case for an API requiring authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Unauthorized Access**\n- **Preconditions:** No valid token.\n- **Action:** Send `GET /protected` request.\n- **Expected:** `401 Unauthorized` or `403 Forbidden` response."
    },
    {
      "question_id": "EQ5058",
      "question": "What is the role of 500 Internal Server Error in API testing?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "The 500 Internal Server Error is used to indicate a generic, unexpected failure on the server. It should be tested as part of negative scenarios to ensure the API handles unexpected conditions gracefully."
    },
    {
      "question_id": "EQ5060",
      "question": "Write one positive test case for an API returning list of orders.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "### **Test Case: Retrieve All Orders**\n-   **Preconditions:** The API is running with a known dataset of orders.\n-   **Action:** Send a `GET` request to the `/orders` endpoint.\n-   **Expected:** The API returns a `200 OK` status code with a JSON response that is an array of order objects. The array should contain at least two orders (e.g., `id: 1`, `id: 2`), with each order having its respective fields (e.g., `customerName`, `total`, `orderDate`)."
    },
    {
      "question_id": "EQ5062",
      "question": "What is the function of response headers in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "Response headers provide metadata about the API response. In testing, they are used to verify security measures (e.g., `Content-Security-Policy`), caching behavior, or authentication tokens."
    },
    {
      "question_id": "EQ5064",
      "question": "Write one negative test for creating a duplicate resource.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Test Case: **Create Duplicate User**\n- **Action:** Send `POST /users` with an existing email (`user@example.com`).\n- **Expected:** `409 Conflict` with a message like \"User already exists.\""
    },
    {
      "question_id": "EQ5066",
      "question": "What is the role of 202 Accepted in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "A `202 Accepted` status code indicates that the request has been received for processing, but it has not been completed yet. It is commonly used for asynchronous operations where the API will continue to process the request in the background."
    },
    {
      "question_id": "EQ5068",
      "question": "Write one easy positive test for checking API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "**Test Case: Verify API Response Schema**\n- **Test Case ID:** TC-007\n- **Preconditions:** API service is running.\n- **Test Steps:** Send a valid `GET /products` request.\n- **Expected Result:**\n  - **Status Code:** `200 OK`.\n  - **Response Body:** Verify that the schema conforms to the predefined JSON schema (e.g., all keys present, data types correct)."
    },
    {
      "question_id": "EQ5070",
      "question": "What is the purpose of response body in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body is the main part of an API's response, containing the data requested by the client. Its purpose is to provide the payload of the HTTP request, which the client can parse to understand the outcome of its request."
    },
    {
      "question_id": "EQ5072",
      "question": "Write one test case for verifying logout functionality.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "**Test Case: Logout Verification**\n- **Preconditions:** User authenticated.\n- **Steps:**\n  - Send logout request → expect `200 OK`.\n  - Verify session cookie no longer valid.\n- **Expected:** User cannot access protected routes after logout."
    },
    {
      "question_id": "EQ5074",
      "question": "What does a 415 Unsupported Media Type error validate?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "That the server rejects unsupported request body formats.",
      "model_answer": "A 415 error validates that the API correctly handles an unsupported request format (e.g., sending JSON in a `Content-Type` header set to `application/xml`)."
    },
    {
      "question_id": "EQ5077",
      "question": "Write one simple positive test for GET /status endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "### **Test Case: Verify Status Endpoint**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Confirm /status API returns 200 OK with 'Healthy' message.\n- **Test Case Description:** Send a GET request to the /status endpoint and verify the HTTP status code and response body.\n- **Preconditions:** The API service must be running.\n- **Test Steps:**\n  1. Send a `GET` request to the URL `/status`.\n- **Expected Result:**\n  - The API returns a `200 OK` status code.\n  - The response body contains the text `'Healthy'`."
    },
    {
      "question_id": "EQ5079",
      "question": "What does a 204 No Content response mean?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content response indicates that the request was successful, but there is no content to return in the body of the response. It is often used for DELETE requests to confirm deletion."
    },
    {
      "question_id": "EQ5081",
      "question": "Write a negative test case for sending an invalid Content-Type header.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "### **Test Case: Invalid Content-Type**\n-   **Test Case Name:** Verify API rejects invalid Content-Type.\n-   **Preconditions:** API is running.\n-   **Test Steps:**\n    1. Send a `POST` request to `/upload`.\n    2. In the request body, attach a file but set `Content-Type` to an unsupported value (e.g., `image/jpeg` for an XML payload).\n-   **Expected Result:**\n    - The API returns a `415 Unsupported Media Type` status code.\n    - The response body indicates that the format is not supported.\n    - The file is not processed or stored."
    },
    {
      "question_id": "EQ5083",
      "question": "What is the purpose of the Accept header in API requests?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header indicates to the server which content formats (e.g., application/json, application/xml) the client can understand, allowing the server to respond with the appropriate format."
    },
    {
      "question_id": "EQ5085",
      "question": "Write a simple test case for a successful logout API call.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Logout**\n- **Preconditions:** User authenticated.\n- **Action:** Send `POST /logout` request.\n- **Expected:** `200 OK`, session expired, subsequent requests return `401 Unauthorized`."
    },
    {
      "question_id": "EQ5087",
      "question": "What is the meaning of 401 Unauthorized in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "It means the client must provide valid authentication credentials.",
      "model_answer": "A 401 Unauthorized status code means that the client has not provided the correct authentication credentials (e.g., a valid token) or that the authentication has failed."
    },
    {
      "question_id": "EQ5089",
      "question": "Write one easy positive test case for checking profile details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test Case: Verify Profile Details. **Preconditions:** User ID = 1234 exists. **Action:** Send GET request to /profile/1234. **Expected:** Status = 200 OK, Profile data found in response."
    },
    {
      "question_id": "EQ5091",
      "question": "What is the purpose of 302 Found in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates temporary redirection to another URL.",
      "model_answer": "The purpose of a 302 Found status code is to indicate that the resource has temporarily moved to a different URL. It redirects the client to the new location. This is often used for migration or maintenance of endpoints."
    },
    {
      "question_id": "EQ5093",
      "question": "Write a test case for negative login attempt with wrong password.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "Test Case: Invalid Login. Preconditions: User exists. Steps: Send login request with correct email and wrong password. Expected: `400 Bad Request` or `401 Unauthorized`."
    },
    {
      "question_id": "EQ5095",
      "question": "What does 422 Unprocessable Entity indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "A 422 Unprocessable Entity status code indicates that the server understands the request but cannot process it due to a semantic error, such as a validation failure or inconsistent state."
    },
    {
      "question_id": "EQ5097",
      "question": "Write a positive test for POST /users endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "**Test Case: Create New User**\n- **Preconditions:** API available, DB initialized with valid role ID.\n- **Action:** Send `POST /users` with JSON payload `{ \"name\": \"John Doe\", \"email\": \"john@example.com\", \"password\": \"StrongPass123\" }`.\n- **Expected Result:** Response `201 Created` with user ID in header, user data exists in DB."
    },
    {
      "question_id": "EQ5099",
      "question": "What does the term 'happy path' mean in testing?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most straightforward and successful scenario for a feature or API. It includes all required steps and inputs, where everything works as intended, with no errors or failures."
    },
    {
      "question_id": "EQ2002",
      "question": "Explain how you would design a negative test case for an API endpoint that requires OAuth2 Bearer tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Design a negative test case by sending a request with an invalid or expired token. Expected: the API should return a `401 Unauthorized` or `403 Forbidden` status code, and the response body should indicate that the token is invalid."
    },
    {
      "question_id": "EQ2004",
      "question": "Provide one happy-path and one error-path test case for a payment refund API endpoint.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "*   **Happy Path (Positive):** Test `POST /refund` with valid transaction ID and amount. **Expected:** `201 Created` with refund details, DB updated.\n*   **Error Path (Negative):** Test `POST /refund` with an invalid transaction ID (e.g., 'TRX-99999'). **Expected:** `404 Not Found` with error message 'Transaction not found'."
    },
    {
      "question_id": "EQ2006",
      "question": "How would you validate schema changes in a backward-compatible API upgrade?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "Run contract tests with old and new schemas, assert no breaking changes, and monitor production logs for validation errors."
    },
    {
      "question_id": "EQ2008",
      "question": "Explain how mocking can be used to test a payment API without calling the real bank service.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "Mocking replaces the real bank service with a fake one. The test API sends a payment request to the mock, which responds with a predefined status (e.g., 'approved' or 'declined'). This allows testing payment logic without risking real transactions."
    },
    {
      "question_id": "EQ2010",
      "question": "Design one boundary test and one invalid test for an API field `age` (range 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "**Boundary Test (Positive):** Send a request with `age=18` (lower bound) and `age=65` (upper bound). Expected: Both `200 OK` with valid user data, as they fall within the defined range.\n  \n**Invalid Test:** Send a request with `age=0`. Expected: `400 Bad Request` with a validation error, as the age is below the minimum allowed."
    },
    {
      "question_id": "EQ2012",
      "question": "Explain how you would simulate a network timeout error in API testing.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "To simulate a network timeout, you would use a tool like `curl` or a programming language (e.g., Python with `requests`) to send an HTTP request to the API. You would then configure the request to wait longer than the API's expected timeout (e.g., `timeout=5s` when the API has a 3s timeout). The request will fail with a timeout error."
    },
    {
      "question_id": "EQ2014",
      "question": "Give one example of an API precondition and one step that follows it.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "*   **Precondition:** The API service must be running and accessible at its base URL (`http://api.example.com`).\n    *   **Action Following Precondition:** A user can send a `GET /products` request to retrieve a list of products."
    },
    {
      "question_id": "EQ2016",
      "question": "Write one test case to validate that API rate limiting is enforced correctly.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "**Test Case: Enforce Rate Limit**\n- **Preconditions:** Account configured with 100 requests/minute.\n- **Steps:**\n  1. Send first request → `200 OK`.\n  2. Send second request within 1 minute → `200 OK`.\n  3. Send third request within 1 minute → expect `429 Too Many Requests`.\n- **Expected:** Rate limit enforced exactly."
    },
    {
      "question_id": "EQ2018",
      "question": "Explain one advantage of using service virtualization in API testing.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "One advantage is that it allows testing of APIs before all dependent systems are available, thus reducing delays in testing."
    },
    {
      "question_id": "EQ2020",
      "question": "Describe how to design one positive and one boundary test case for a login API requiring username and password.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "*   **Positive Test Case:** Send valid credentials ('user@example.com'/ 'Password123') and expect a `200 OK` with an authentication token.\n    *   **Preconditions:** User account exists with known password.\n    *   **Test Steps:** Send POST request to login endpoint with correct credentials.\n    *   **Expected Result:** Token in response body, status `200 OK`.\n*   **Boundary Test Case (Negative):** Send password with maximum allowed length (e.g., 72 characters) or use 'Password123!@#'."
    },
    {
      "question_id": "EQ2022",
      "question": "Write one test step to validate that an API correctly returns 415 Unsupported Media Type.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Test Step: Send a `POST` request to `/upload` with a `Content-Type` header set to an unsupported format like `application/json`."
    },
    {
      "question_id": "EQ2024",
      "question": "Describe one way to test observability when an API experiences a slow database query.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Precondition: API connected to mock DB with slow response. Test Step: Send request to API. Expected: API returns 200, but response time > 3s. Verify logs capture slow query warning."
    },
    {
      "question_id": "EQ2026",
      "question": "Explain how you would test API idempotency for a retry scenario.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Test by sending the same `PUT /orders/{id}` request multiple times. Expected: 1st request → `200 OK` and DB updated. 2nd+ requests → `200 OK` but no further changes. Confirm DB state remains consistent after retries."
    },
    {
      "question_id": "EQ2028",
      "question": "Give one boundary and one invalid test for a file upload API accepting max 5 MB files.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "*   **Boundary Test:** Upload a 5 MB file (e.g., a zip archive) to verify it's successfully processed.\n    *   **Action:** Send a `POST` request with the file attached.\n    *   **Expected:** `200 OK` with the file stored, or the file ID in the response body.\n*   **Invalid Test:** Upload a file larger than 5 MB (e.g., a 10 MB video file).\n    *   **Action:** Send the same `POST` request but with a larger file.\n    *   **Expected:** The API should return a `400 Bad Request` or `413 Payload Too Large` error."
    },
    {
      "question_id": "EQ2030",
      "question": "Write a test case to validate proper error handling when an API is called with a missing required field `email`.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "### **Test Case: Missing Required Field 'email'**\n- **Test Case ID:** TC-007\n- **Test Case Name:** Verify API rejects request without required 'email' field.\n- **Preconditions:** The API is running.\n- **Test Steps:**\n  1. Send a `POST` request to the user registration endpoint with a JSON body that **does not include the 'email' field**.\n- **Expected Result:**\n  - The API returns a **`400 Bad Request` status code.**\n  - The response body contains an error message that specifically mentions the 'email' field is required."
    },
    {
      "question_id": "EQ2032",
      "question": "How would you design a test to validate retry logic when an API occasionally returns 503?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "Preconditions: API configured to retry failed requests. Steps: 1) Send request that triggers 503. 2) Verify initial request fails. 3) Verify subsequent retry attempts succeed. 4) Monitor retry count to ensure it doesn't exceed limits."
    },
    {
      "question_id": "EQ2034",
      "question": "Write a test case that validates log correlation using a trace ID header.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "### **Test Case: Log Correlation via Trace ID**\n- **Test Case ID:** TC-LOG-CORR-001\n- **Test Case Name:** Verify logs are correlated using a Trace ID header.\n- **Preconditions:**\n  - API configured to propagate Trace ID in headers.\n  - Distributed Tracing enabled.\n- **Test Steps:**\n  1. Send a request to an API (`/process-order`) that generates multiple logs.\n  2. Include a known Trace ID header (`X-Trace-ID: trace-id-123`) in the request.\n- **Expected Result:**\n  - All logs generated for the API request should contain the exact same Trace ID (`trace-id-123`) in their metadata."
    },
    {
      "question_id": "EQ2036",
      "question": "Design one intermediate-level test case for validating API rate limiting when multiple clients are involved.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "**Test Case: Multi-Client Rate Limit Enforcement**\n- **Preconditions:** Two API clients (Client A and Client B) with identical rate limits (100 requests/minute).\n- **Steps:**\n  - Client A sends 50 requests in first 30 seconds → expect `200 OK`.\n  - Immediately after, Client B sends 50 requests → expect all `200 OK`.\n  - If Client A exceeds limit, Client B should still receive `200 OK` for remaining allowed requests.\n  - After rate limit is exhausted, both clients should receive `429 Too Many Requests`.\n- **Expected Result:** Both clients must adhere to rate limit, and API must prevent abuse."
    },
    {
      "question_id": "EQ2038",
      "question": "Describe one positive and one negative test case for an API endpoint that sends SMS codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "**Positive:** Send a valid phone number (+1-202-555-0123) and verify a 200 OK response with an SMS code. **Negative:** Send a phone number with an invalid format (‘999-999-9999’) and verify a 400 Bad Request error."
    },
    {
      "question_id": "EQ2040",
      "question": "Explain one advantage of mocking external APIs when testing failure scenarios.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "One advantage is that it prevents real-world failures from impacting test stability or reliability. For example, instead of relying on a specific payment gateway to fail, a test can mock the gateway to respond with a known error code, allowing consistent and repeatable test cases."
    },
    {
      "question_id": "EQ2042",
      "question": "Write one test case to validate error handling when API returns malformed JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "**Test Case: Malformed JSON Response**\n- **Preconditions:** API endpoint `/products` is configured to return invalid JSON (e.g., missing quote, syntax error).\n- **Test Steps:**\n  1. Send a `GET` request to `/products`.\n- **Expected Result:**\n  - The API returns a successful status code (e.g., `200 OK`).\n  - The response body is parsed and verified to contain the error message.\n  - The response is not a valid JSON object."
    },
    {
      "question_id": "EQ2044",
      "question": "Design one test step to confirm rate limiting headers (e.g., X-RateLimit-Remaining) are present.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "**Test Step:** 1) Send a request to a rate-limited endpoint. 2) Verify the response body or headers contain a rate limit count (e.g., `X-RateLimit-Remaining`). 3) Repeat until the limit is exceeded, then confirm the count is 0."
    },
    {
      "question_id": "EQ2046",
      "question": "Describe one advantage of separating test data from test logic in API testing.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic improves reusability and reduces maintenance. With separate data, the same test script can be executed multiple times with different inputs, making it ideal for data-driven testing and ensuring the API handles various valid and invalid data scenarios correctly."
    },
    {
      "question_id": "EQ2048",
      "question": "Write a test case for validating graceful degradation when API cache is unavailable.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "### **Test Case: Cache Unavailability**\n- **Test Case ID:** TC-APIC-008\n- **Test Case Name:** Verify API response when cache service is down.\n- **Preconditions:**\n  - API is deployed.\n  - Cache service is mocked.\n  - API configured to use cache.\n- **Test Steps:**\n  1. Send request for a cached resource.\n  2. Verify API returns `503 Service Unavailable` or `500 Internal Server Error`.\n  3. Confirm database query is executed to return response.\n- **Expected Result:** API gracefully handles cache unavailability by falling back to DB."
    },
    {
      "question_id": "EQ2050",
      "question": "Explain one way to validate logging for sensitive fields such as passwords.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "Preconditions: API configured to log requests and responses. Test Case: Send a request with a known password. Verification: Check the log output, assert that the password field is masked or not logged at all."
    },
    {
      "question_id": "EQ2052",
      "question": "Provide one negative and one boundary test case for a currency field that must match ISO 4217 codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "**Negative:** Test with 'XXX' (invalid code). **Boundary:** Test with 'USD' (common edge) and 'EUR' (another common edge)."
    },
    {
      "question_id": "EQ2054",
      "question": "Write one test case to validate API behavior under network packet loss.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "**Test Case: Network Packet Loss**\n- **Preconditions:** Simulate 10% packet loss between client and server.\n- **Steps:** Send 3 requests: one complete, one with corrupted payload, one with missing header.\n- **Expected:** Server returns `500 Internal Server Error` for corrupted, `400 Bad Request` for missing header. Complete request succeeds."
    },
    {
      "question_id": "EQ2056",
      "question": "Describe one method to verify test data cleanup after API test execution.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "One method is to run a 'cleanup verification' test case immediately after the main test. This secondary test queries the database to confirm that all test-created data (e.g., users, orders) has been successfully deleted."
    },
    {
      "question_id": "EQ2058",
      "question": "Write a test case to verify proper rollback when a multi-step transaction partially fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "### **Test Case: Partial Transaction Rollback**\n- **Test Case ID:** TC-TRX-007\n- **Test Case Name:** Verify rollback when intermediate step fails in multi-step transaction.\n- **Preconditions:**\n  - API configured for transactions (e.g., SQL transactions, distributed locks).\n  - Initial data: `user_id=999` exists, `product_id=999` exists, `order_id=999` does not exist.\n- **Test Steps:**\n  1. **Transaction Initiation:** Send `POST /orders` request with `user_id=999` and `product_id=999`.\n  2. **Intermediate Failure:** After first step, before final step, manually delete `order_id=999` from DB (simulating failure).\n  3. **Final Attempt:** Send `PUT /orders/{order_id}` (e.g., to set status to'shipped') for the non-existent `order_id=999`.\n- **Expected Result:**\n  - The API responds with a `409 Conflict` or `500 Internal Server Error` for the final step, indicating rollback.\n  - Upon checking the DB, confirm that `order_id=999` was never created, and no partial order state (e.g., `user_id=999` with no products) exists."
    },
    {
      "question_id": "EQ2060",
      "question": "Explain one approach to validating error messages follow a consistent JSON schema across all endpoints.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "1. **Define a JSON Schema for Error Responses:** Establish a base schema (e.g., `{\"error\": string, \"code\": int, \"details\": array}`) that all endpoints must follow.\n2. **Automated Validation:** Use a tool like Postman or Insomnia to send invalid requests to all endpoints.\n3. **Validation Assertion:** For each endpoint, assert that the response body conforms to the defined error schema."
    },
    {
      "question_id": "EQ3002",
      "question": "Write a test case that validates login, token refresh, and accessing a protected API using the refreshed token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "**Test Case: Token Refresh**\n- **Preconditions:** User login generates a short-lived token (TTL=10m).\n- **Steps:**\n  - Request API with expired token → `403 Forbidden`.\n  - Refresh token → expect new valid token.\n  - Use refreshed token to access protected API → `200 OK`.\n- **Expected:** Tokens refreshed successfully."
    },
    {
      "question_id": "EQ3004",
      "question": "Design a chained test validating that a failed login attempt still prevents refresh token generation.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. **Initial Attempt:** Send a `POST /login` request with an incorrect password. 2. **Assert First Failure:** Confirm the login fails. 3. **Second Attempt:** Immediately send another `POST /login` request. 4. **Assert No Token:** Verify no access token or refresh token is returned. 5. **Assert Session:** Check the session state to confirm it was not inadvertently created."
    },
    {
      "question_id": "EQ3006",
      "question": "Explain how you would validate correct mapping of business codes (e.g., ORDER_001) to HTTP status codes in API responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Create a test suite with scenarios covering positive (e.g., successful order creation) and negative paths (e.g., invalid product, duplicate order). For each, assert that the HTTP status code (e.g., `201` Created, `400` Bad Request, `409` Conflict) is correct. Finally, verify that the response body includes the corresponding business-specific error code (e.g., `ORDER_001` for duplicate order)."
    },
    {
      "question_id": "EQ3008",
      "question": "Write one hard-level test case chaining order creation, payment, and refund APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "### **Test Case: Full Order Lifecycle**\n- **Preconditions:** User exists, inventory > 0, test order ID.\n- **Steps:**\n  1. **Create Order:** `/orders` with items → `201 Created`.\n  2. **Process Payment:** `/payments` for order → `201 Created`.\n  3. **Confirm Shipment:** `/ships` for order → `200 OK`.\n  4. **Initiate Refund:** `/refunds` for order → `201 Created`.\n- **Expected:** All steps succeed, order status changes accordingly."
    },
    {
      "question_id": "EQ3010",
      "question": "Explain one test case that validates token refresh works across multiple microservices.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "**Test Case: Token Refresh Across Services**\n- **Preconditions:** API Consumer Service (A) and Token Refresh Service (B) both running. User token expired.\n- **Test Steps:**\n  1. Service A → Request protected resource → 403 Forbidden (expired token).\n  2. Service B → Receive refresh request → Obtain new token.\n- **Expected Result:** Service A should be able to retry the request with the new token, succeeding this time."
    },
    {
      "question_id": "EQ3012",
      "question": "Write a test that validates mapping of validation error codes to HTTP 400 responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "**Test Case: Validation Error Mapping**\n- **Preconditions:** API configured with custom validation error codes.\n- **Steps:**\n  - Request with invalid field (e.g., `/users` with non-unique username) → 400 Bad Request.\n  - Assert response body contains specific error code (e.g., `{\"error_code\": \"INVALID_INPUT\"}`).\n  - Verify error message is descriptive.\n- **Expected:** API returns correct HTTP status and error details."
    },
    {
      "question_id": "EQ3014",
      "question": "Design a test case validating expired refresh tokens cannot issue new access tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "### **Test Case: Expired Refresh Token**\n- **Test Case ID:** TC-005\n- **Preconditions:** A refresh token is generated 30 minutes ago and has expired.\n- **Test Steps:**\n  1. Send a `POST /refresh-token` request with the expired refresh token.\n- **Expected Result:** The API returns a `400 Bad Request` or `401 Unauthorized` status with an error message like 'Refresh token has expired' or 'Invalid refresh token'. The response body should not contain an access token."
    },
    {
      "question_id": "EQ3016",
      "question": "Explain one multi-hop chained test that validates session invalidation after logout.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Test case: 1) Login → obtain session token. 2) Send request with token → `200 OK`. 3) Logout endpoint → session invalidated. 4) Repeat request with old token → `401 Unauthorized`."
    },
    {
      "question_id": "EQ3018",
      "question": "Write a test case chaining signup, email verification, and login endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "### **Test Case: Full User Flow**\n- **Preconditions:** API available, mail service mocked.\n- **Steps:**\n  - **Signup:** Send `POST /signup` with valid email/password → `200 OK` with user data and email verification link.\n  - **Email Verification:** Send `POST /verify-email` with link token → `200 OK` with success message.\n  - **Login:** Send `POST /login` with verified user's email/password → `200 OK` with auth token.\n- **Expected:** All steps succeed, user accessible only after email verified."
    },
    {
      "question_id": "EQ3020",
      "question": "Design one hard-level chained test validating a password reset flow.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "**Test Case: Password Reset Flow**\n1. **Preconditions:** User 'user123' exists, email verified.\n2. **Steps:**\n   - Send password reset request → expect `200 OK`.\n   - Extract reset token from email.\n   - Use token to reset to new password → `200 OK`.\n   - Log in with new password → `200 OK`.\n   - Attempt reset again with same email → expect `400 Bad Request`.\n3. **Expected:** All steps succeed, new password valid, repeated reset fails."
    },
    {
      "question_id": "EQ3022",
      "question": "Write a chained test case for validating user creation, profile update, and profile retrieval.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "**Test Case: User Profile Management**\n- **Preconditions:** User API enabled, test user exists.\n- **Test Steps:**\n  - **Create User:** Send `POST /users` with email and password.\n  - **Update Profile:** Send `PUT /users/{id}` with new profile info.\n  - **Retrieve Profile:** Send `GET /users/{id}` to verify updated profile.\n- **Expected Result:** All requests succeed, profile info matches updates."
    },
    {
      "question_id": "EQ3024",
      "question": "Explain one test to validate refresh token cannot be used after logout.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "Test Case: \n1. User logs in, receives access and refresh tokens.\n2. User logs out (invalidate session).\n3. Attempt to use refresh token to get new access token.\n4. Expected: 403 Forbidden or 401 Unauthorized, as logout invalidates refresh token."
    },
    {
      "question_id": "EQ3026",
      "question": "Write a test case validating correct mapping of internal error code AUTH_EXPIRED to HTTP status.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "### **Test Case: Verify Authentication Expiration**\n-   **Test Case ID:** TC-005\n-   **Test Case Name:** Confirm correct HTTP status returned for expired authentication.\n-   **Preconditions:**\n    -   Authentication service mocked.\n    -   Token expiration configured (e.g., 1 minute).\n-   **Test Steps:**\n    1. Send request to protected endpoint *after* token has expired.\n-   **Expected Result:** The API returns a `401 Unauthorized` HTTP status code."
    },
    {
      "question_id": "EQ3028",
      "question": "Explain a chained test validating email verification failure if token is invalid.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Request email verification with known invalid token. 2) Assert API returns `400 Bad Request` or `401 Unauthorized`. 3) Confirm user remains unverified."
    },
    {
      "question_id": "EQ3030",
      "question": "Write a hard-level test case chaining loan application, credit check, and approval endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "**Test Case: Loan Approval Flow**\n- **Preconditions:** User exists, credit score = 700.\n- **Steps:**\n  1. `POST /loans` with $100k, 60 months → 200 OK with loan ID.\n  2. `GET /credit-check` with loan ID → 200 OK with credit score.\n  3. `POST /loans/{id}/approve` → 200 OK with approval message.\n- **Expected:** Loans approved only if valid."
    },
    {
      "question_id": "EQ3032",
      "question": "Design a test case chaining signup, password reset, and login with new credentials.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "**Test Case: Credential Flow**\n- **Scenario:** User signs up (email=user@example.com, password=Strong123).\n- **Action 1:** Request password reset via email.\n- **Action 2:** Change new password → login with new credentials.\n- **Expected:** Successful login with new password."
    },
    {
      "question_id": "EQ3034",
      "question": "Write a test case chaining file upload, virus scan, and download endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "### **Test Case: Secure File Transfer**\n- **Preconditions:** File upload API available, virus scan service integrated, safe file (e.g., PDF) and malicious file (e.g., virus payload) prepared.\n- **Steps:**\n  - **Upload:** Send safe file → `200 OK`, file ID stored.\n  - **Scan:** Call virus scan endpoint with file ID → `202 Accepted` if clean, `400 Bad Request` if infected.\n  - **Download:** Attempt safe file download → `200 OK`, file available.\n  - **Negative:** Try downloading file ID that doesn't exist → `404 Not Found`.\n- **Expected:** Only clean files available for download."
    },
    {
      "question_id": "EQ3036",
      "question": "Explain one chained test for validating refresh token reuse prevention.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "Test Case: \"Refresh Token Reuse Attempt.\"\n1. **Action 1:** Obtain a refresh token.\n2. **Action 2:** Attempt to use the same refresh token multiple times.\n3. **Expected Result:** Second and subsequent attempts fail with `409 Conflict` or `403 Forbidden`."
    },
    {
      "question_id": "EQ3038",
      "question": "Write a test case chaining search, add-to-cart, and checkout APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "### **Test Case: Full E-commerce Flow**\n- **Preconditions:** User authenticated, catalog seeded.\n- **Steps:**\n  - **Search:** Send product name search request → assert results.\n  - **Add to Cart:** Product ID → 201 Created.\n  - **Checkout:** Cart ID → 201 Created.\n- **Expected:** All steps succeed, DB reflects order creation."
    },
    {
      "question_id": "EQ3040",
      "question": "Explain one chained test for validating API session hijacking prevention.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "Chained Test: 1) Log in as User A → get Session Cookie. 2) Send request with User A's Cookie to protected resource. 3) Assert `401 Unauthorized` or `403 Forbidden`. Preconditions: API must validate session cookie signatures or tokens."
    },
    {
      "question_id": "EQ3042",
      "question": "Provide exactly one chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "### **Test Case: Optimistic Concurrency with ETag**\n- **Preconditions:** Item ID=789 exists with ETag='v1'.\n- **Steps:**\n  - **Action 1:** Update Item → new ETag='v2'.\n  - **Action 2:** Send request with old ETag ('v1') → expect `409 Conflict`.\n- **Expected:** DB state unchanged, `v2` ETag used if valid."
    },
    {
      "question_id": "EQ3044",
      "question": "Design a multi-hop test verifying async export job: POST /exports -> poll GET /jobs/{id} until complete -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "This test validates asynchronous export processing."
    },
    {
      "question_id": "EQ3046",
      "question": "Give one chained negative test for OAuth2 Authorization Code: /authorize -> /token -> resource call with missing scope.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Test steps: 1) Client requests authorization with scope'read'. 2) Server grants. 3) Client exchanges code for token. 4) Call resource. Expected: `403 Forbidden` because missing scope 'write'."
    },
    {
      "question_id": "EQ3048",
      "question": "Write one chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. **Charge Creation**: Send `POST /charge` with $100 amount → `201 Created` with ID and key.\n2. **First Retry**: Send identical `POST /charge` → `200 OK`, DB unchanged.\n3. **Second Request**: Send again → `200 OK`, DB still unchanged.\n4. **Refund**: Send `POST /charge/{id}/refund` with valid key → `200 OK`.\n5. **Second Refund Attempt**: Send identical refund → `200 OK`, DB unchanged.\n6. **Verify DB**: Ensure only one successful transaction."
    },
    {
      "question_id": "EQ3050",
      "question": "Provide one chained test for file processing pipeline: upload -> POST /process -> poll status -> download, including 202 handling.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "**Test Case: File Processing Pipeline**\n- **Preconditions:** File `input.txt` exists.\n- **Steps:**\n  1. Upload file via `PUT /files` → store ID `file_id`.\n  2. Send `POST /process` with `file_id` → expect `202 Accepted`.\n  3. Poll status until `finished` → verify response.\n  4. Download processed file via `GET /files/{file_id}` → assert contents.\n- **Expected:** File processed successfully, no corrupt data."
    },
    {
      "question_id": "EQ3052",
      "question": "Give one chained test to validate SSO session revocation propagates to API gateway and microservice access.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "**Test Case: SSO Session Revocation Chained**\n- **Preconditions:** User logged in with valid SSO token. API Gateway and Microservice both configured to use SSO token for authentication.\n- **Action:** Send revocation request to SSO provider (e.g., via logout endpoint).\n- **Verification:**\n  - API Gateway returns `403 Forbidden` or `401 Unauthorized` for subsequent requests from the revoked user.\n  - Microservice API also rejects requests from the same user with a suitable error code (e.g., `403 Forbidden`).\n  - No sensitive data exposed during failed access attempts."
    },
    {
      "question_id": "EQ3054",
      "question": "Write one chained test for partial order fulfillment: create order -> reserve inventory -> partial ship -> cancel remaining and refund delta.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "**Test Case: Partial Order with Inventory Management**\n- **Preconditions:** Product stock = 5, initial balance = $100.\n- **Steps:**\n  1. **Create Order:** Place order for 3 units (partial of stock) → `200 OK`.\n  2. **Verify State:** Stock = 2, order status = 'partially shipped'.\n  3. **Partial Ship:** Ship 2 units → `200 OK`.\n  4. **Cancel Remaining:** Cancel 1 unit → `200 OK`.\n  5. **Assert:** Stock = 2, order status = 'cancelled', refund = $50.\n- **Expected:** All transitions valid, correct inventory and balance changes."
    },
    {
      "question_id": "EQ3056",
      "question": "Provide exactly one chained negative test for 2FA login: POST /login -> POST /2fa/verify with wrong code -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "**Test Case: '2FA Login with Wrong Verification Code'**\n- **Test Case Name:** Attempt to log in with valid credentials but wrong 2FA verification code.\n- **Preconditions:**\n  - A user exists with known email and password.\n  - This user has enabled 2FA (e.g., SMS, email).\n- **Test Steps:**\n  1. Send a `POST` request to `/login` with the user's email and password.\n  2. Extract the `2fa_code` from the response (e.g., `response.data.2fa_code`).\n  3. Send another `POST` request to `/2fa/verify` but this time with a **wrong** verification code (e.g., an incorrect digit or an entirely different code).\n- **Expected Result:**\n  - The `/2fa/verify` request should fail with a `400` or `409` status code (e.g., `Bad Request` or `Conflict`), and the `2fa_status` field in the response should indicate that the verification failed.\n  - The original login attempt should be marked as failed and the user should not be considered logged in.\n  - Any subsequent API call, such as a `POST /refresh` token request, should also fail with an appropriate error message."
    },
    {
      "question_id": "EQ3058",
      "question": "Design a chained test verifying pagination consistency across create -> list -> delete -> list (with total count assertions).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "**Test Case: Chained Pagination**\n- **Step 1:** Create 20 resources (e.g., `POST /products`).\n- **Step 2:** List first 5 → expect 5 items. List next 5 → expect 5 items. List last 10 → expect 5 items.\n- **Step 3:** Delete last 5 items.\n- **Step 4:** List all → expect only 5 items. List first 10 → 404.\n- **Assertion:** Total count API (`GET /products/count`) → 5."
    },
    {
      "question_id": "EQ3060",
      "question": "Write one chained test for session stickiness: login -> subsequent calls via load balancer -> logout -> verify no node accepts old token.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "**Test Case: Session Stickiness**\n1. Login to Node A → obtain session cookie.\n2. LB directs next API call → verify session cookie still valid.\n3. Log out → delete session.\n4. Repeat step 2 → expect `404 Not Found` or `401 Unauthorized` from all nodes."
    },
    {
      "question_id": "EQ4002",
      "question": "Write a state-machine style test validating account lifecycle: create → activate → suspend → reactivate → delete.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "**Test Case: Account Lifecycle**\n- **Preconditions:** Admin user exists.\n- **Steps:**\n  - Create account → 201 Created.\n  - Activate → 200 OK.\n  - Suspend → 200 OK.\n  - Reactivate → 200 OK.\n  - Delete → 204 No Content.\n- **Expected:** All transitions valid, DB state matches."
    },
    {
      "question_id": "EQ4004",
      "question": "Design a chained test that validates transaction rollback when step 2 of a 3-step money transfer fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "**Test Case: Transaction Rollback**\n- **Preconditions:** User A has $100.\n- **Step 1:** Transfer $50 from A to B → `200 OK`.\n- **Step 2:** (Failure) Attempt to transfer $999 from B to C → `400 Invalid Amount`.\n- **Expected:** After Step 2, User A still has $100, no funds moved."
    },
    {
      "question_id": "EQ4006",
      "question": "Write one test validating a multi-service chain: login → create order → process payment → cancel order after capture.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "This test requires orchestrated API calls across services. **Test Case:** 1. Log in to auth service. 2. Create order → expect `201 Created` from inventory service. 3. Process payment → capture successful. 4. Cancel order → expect `200 OK` with cancelled status. **Validation:** Verify DB consistency post each step."
    },
    {
      "question_id": "EQ4008",
      "question": "Describe one state-machine test validating password lifecycle: set → expire → reset → reuse prevention.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "1) **Set:** State 'PasswordSet' transitions to 'Valid' when created. 2) **Expire:** 'Valid' → 'Expired' after 90 days. 3) **Reset:** 'Expired' → 'ResetPending' → 'Valid' after new password. 4) **Reuse:** Prevents 'Valid' → 'Valid' with identical password."
    },
    {
      "question_id": "EQ4010",
      "question": "Write one complex chained test covering a loan application flow with branch failure in credit check.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "**Test Case: Loan Approval with Credit Check Failure**\n- **Preconditions:** User exists, loan product active.\n- **Test Steps:**\n  1. Send loan application request.\n  2. Chain with a separate API call to a mock credit service (e.g., `/credit-check`) that returns a `500 Internal Server Error`.\n- **Expected Result:** Loan application API should fail with a `503 Service Unavailable` status code, not `200 OK`. The DB should not be updated with an approved status."
    },
    {
      "question_id": "EQ4012",
      "question": "Write a test validating data integrity when concurrent writes occur: update user profile with conflicting values.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "**Test Case: Concurrent Profile Updates**\n- **Preconditions:** Two users, Alice and Bob, exist. Both are connected to the API.\n- **Test Steps:**\n  1. **Alice's Request:** Send a `PUT /users/123` request to update Alice's email to `alice@example.com`.\n  2. **Bob's Request (Simultaneous):** Immediately after, Bob sends a `PUT /users/123` request to update the email to `bob@example.com`.\n- **Expected Result:**\n  - The API rejects both requests with a `409 Conflict` status.\n  - The database state remains unchanged, with the original email still `user@example.com`.\n  - A retry after a short interval should succeed, but only with one of the updates being applied."
    },
    {
      "question_id": "EQ4014",
      "question": "Write one very hard test validating chained document signing: upload → sign → verify → tamper detection.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "**Test Case: Chained Document Signing**\n- **Preconditions:** API configured for document signing (e.g., AWS Signature Version 4).\n- **Steps:**\n  1. Upload a document → get its hash.\n  2. Sign the hash → attach signature to document.\n  3. Verify signature → ensure document integrity.\n  4. Attempt tampering (alter bytes) → expect verification to fail.\n- **Expected:** Signature verification passes only for original document."
    },
    {
      "question_id": "EQ4017",
      "question": "Write one state-machine test validating subscription lifecycle: create → upgrade → downgrade → cancel.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "1. **Create:** Send `POST` to `/subscriptions` with plan='basic'. Assert `200 OK`, DB shows `status='active'`.\n2. **Upgrade:** Send `PUT` to `/subscriptions/ID` with plan='premium'. Assert `200 OK`, DB shows new plan.\n3. **Downgrade:** Send `PUT` to `/subscriptions/ID` with plan='basic'. Assert `200 OK`, DB updated.\n4. **Cancel:** Send `DELETE` to `/subscriptions/ID`. Assert `200 OK`, DB shows `status='cancelled'`."
    },
    {
      "question_id": "EQ4019",
      "question": "Write a very hard chained test validating recovery after partial failure in a distributed order saga.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "**Test Case: Distributed Order Saga Recovery**\n- **Preconditions:** 3 microservices (Order, Inventory, Shipping) deployed across regions, event bus mocked.\n- **Steps:**\n  1. Send `CreateOrder` → `Commit` event → `ReserveInventory` → `PrepareShipping`.\n  2. Inject failure after `PrepareShipping`: shipping service returns 500.\n  3. Expected: Order service reverts to `Created` state, no inventory reserved.\n  4. Repeat with different failures in chain.\n- **Expected:** All services recover cleanly, no stale data."
    },
    {
      "question_id": "EQ4021",
      "question": "Write one very hard test verifying financial transaction reversals: debit → credit → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "This test requires complex state management. Preconditions: account balance $100. Action: debit $50 → credit $20 → rollback. Expected: no changes, balance remains $100."
    },
    {
      "question_id": "EQ4023",
      "question": "Design a state-machine test for warehouse inventory: add stock → allocate → ship → return → reconcile.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Test steps: 1) Add 100 units → 2) Allocate 50 → 3) Ship 30 → 4) Return 20 → 5) Reconcile DB → Expected: stock=70, all transactions logged."
    },
    {
      "question_id": "EQ4025",
      "question": "Write one chained test validating mobile session lifecycle: login → token refresh → logout → refresh with old token → fail.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "**Test Case: Mobile Session Lifecycle**\n- **Test Case Name:** Verify session lifecycle with refresh and invalidation.\n- **Preconditions:** Mobile app connected to API with short-lived sessions (15 minutes).\n- **Test Steps:**\n  1. **Login & Initial Token:** Send `POST /login` with valid credentials.\n  2. **Token Refresh:** Wait for session to be half-life. Send `POST /refresh-token` with existing refresh token. Assert `200 OK` and new refresh token.\n  3. **Logout:** Send `DELETE /logout` with user ID. Assert `204 No Content`.\n  4. **Invalid Refresh:** Send `POST /refresh-token` with old refresh token after logout. Assert `401 Unauthorized`.\n- **Expected Results:** All refresh steps succeed only before logout."
    },
    {
      "question_id": "EQ4027",
      "question": "Write one chained test validating email delivery API: send → open-tracking → unsubscribe → ensure no further emails sent.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. **Send Email:** Send a test email with unique tracking and unsubscribe links. 2. **Open Tracking:** Use a tracking pixel to confirm email opened. 3. **Unsubscribe:** Send a request to the unsubscribe endpoint for that email's user. 4. **Verify No More Emails:** Monitor the user's inbox for the next scheduled email and confirm it does not arrive."
    },
    {
      "question_id": "EQ4029",
      "question": "Write one very hard chained test for purchase flow with coupon application and failure branch: apply coupon → checkout → coupon invalid → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "This test requires multiple steps: 1) Apply a valid coupon during checkout. 2) Proceed to payment. 3) Programmatically invalidate the coupon on the server. 4) The API should return a `400` error. 5) The DB should show the order was rolled back to 'pending' state."
    },
    {
      "question_id": "EQ5004-VN",
      "question": "Viết một test case positive đơn giản cho một API đăng nhập.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "### **Test Case: Đăng Nhập với Tài Khoản Valid**\n- **Test Case Name:** Đăng nhập thành công với email và mật khẩu đúng.\n- **Test Case ID:** TC-LOGIN-001.\n- **Test Case Description:** Đăng nhập vào hệ thống với một tài khoản đã tồn tại và đúng thông tin.\n- **Preconditions:**\n  - Hệ thống API đang hoạt động.\n  - Có một tài khoản `user@example.com` với mật khẩu `Password123!` đã đăng ký.\n- **Test Steps:**\n  1. Gửi yêu cầu `POST` đến endpoint đăng nhập (ví dụ `/login`).\n  2. Thư viện test sẽ sử dụng các công cụ như `requests` (Python) hoặc `axios` (JavaScript) để gửi yêu cầu.\n  3. Trong cơ thể yêu cầu, bạn cần gửi một `JSON` body với trường `email` và `password`.\n  4. Sử dụng các giá trị xác định từ precondition (ví dụ `{\"email\": \"user@example.com\", \"password\": \"Password123!\"}`).\n- **Expected Result:**\n  - **Status Code:** HTTP Status `200 OK` hoặc `201 Created` (tùy thuộc vào API).\n  - **Response Body:** Trả về một `JSON` chứa thông tin về token truy cập hoặc user được xác thực. Ví dụ, `{\"token\": \"eyJhb...\", \"user\": {\"id\": 1, \"name\": \"User Name\"}}`.\n  - **Header:** Có một tiêu đề `Authorization` hoặc `X-Token` với giá trị token được trả về.\n  - **Database:** Một bản ghi về session hoặc token liên quan đến yêu cầu đăng nhập này có thể được tạo."
    },
    {
      "question_id": "EQ5006-VN",
      "question": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "Điều kiện tiên quyết phổ biến là một tài khoản người dùng đã được đăng ký và có quyền truy cập vào profile của họ."
    },
    {
      "question_id": "EQ5008-VN",
      "question": "Viết một test negative đơn giản cho một API đăng ký.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Test trường email không hợp lệ: Request với `email=invalid` và kiểm tra trạng thái HTTP và nội dung trả về."
    },
    {
      "question_id": "EQ5010-VN",
      "question": "Vai trò của một schema trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "Một schema xác định cấu trúc và quy tắc của dữ liệu được gửi hoặc nhận. Trong testing, nó giúp xác minh dữ liệu API đáp ứng các yêu cầu cấu trúc và loại dữ liệu (int, string, array, etc.)."
    },
    {
      "question_id": "EQ5012-VN",
      "question": "Viết một test step đơn giản để validate một response 201 Created.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "Test Step: Đăng một tài khoản mới và xác minh status code tạo là 201 Created."
    },
    {
      "question_id": "EQ5014-VN",
      "question": "Mục đích của mocking trong API testing là gì?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking giúp tạo giả lập các dịch vụ phụ thuộc để thực hiện kiểm tra độc lập, giảm phụ thuộc vào các dịch vụ khác."
    },
    {
      "question_id": "EQ5016-VN",
      "question": "Viết một test case dễ dàng cho một API lấy danh sách sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "**Test Case: Lấy Danh Sách Sản Phẩm**\n- **Test Case ID:** TC-GET-PRODUCTS-001\n- **Test Case Name:** Xác minh API trả về danh sách sản phẩm.\n- **Test Case Description:** Lấy danh sách sản phẩm từ API.\n- **Preconditions:** Có ít nhất 5 sản phẩm trong cơ sở dữ liệu.\n- **Test Steps:**\n  1. Gửi yêu cầu GET đến endpoint `/products`.\n- **Expected Results:**\n  - Status Code: `200 OK`.\n  - Trả về danh sách JSON chứa ít nhất 5 sản phẩm.\n  - Mỗi sản phẩm có các trường cơ bản (id, tên, giá)."
    },
    {
      "question_id": "EQ5018-VN",
      "question": "Mục đích của một precondition trong một test case là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Mục đích của một precondition trong một test case là đảm bảo rằng tất cả các yêu cầu và trạng thái cần thiết để thực hiện và đánh giá hiệu quả của một yêu cầu chức năng được đáp ứng trước khi test được thực thi."
    },
    {
      "question_id": "EQ5020-VN",
      "question": "Viết một test negative cho việc upload file với định dạng không được hỗ trợ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test case: Đặt file có định dạng `.exe`. Lệnh test: `POST /upload` với file attachment. Expected: Trả về `415 Unsupported File Type` hoặc `400 Bad Request`."
    },
    {
      "question_id": "EQ5022-VN",
      "question": "Mục đích của một test case description là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "Mục đích của một test case description là cung cấp một bản mô tả ngắn gọn và rõ ràng về chức năng hoặc yêu cầu mà test case đó đang kiểm tra."
    },
    {
      "question_id": "EQ5024-VN",
      "question": "Viết một test step để validate thời gian response dưới 1 giây.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "Test step: Gọi API `GET /health` và xác minh thời gian phản hồi `< 1000 ms`."
    },
    {
      "question_id": "EQ5027-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /health.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "**Test Case: Health Check**\n- **Test Case Name:** Verify healthy API response.\n- **Preconditions:** API đang chạy.\n- **Test Steps:** Gửi yêu cầu GET đến /health.\n- **Expected Result:** HTTP Status Code = 200 OK, Response Body chứa 'healthy' = true."
    },
    {
      "question_id": "EQ5029-VN",
      "question": "Mục đích của việc sử dụng test data management trong API testing là gì?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "Sử dụng test data management giúp cung cấp dữ liệu thử nghiệm linh hoạt, bảo mật, và khả năng tái tạo được."
    },
    {
      "question_id": "EQ5031-VN",
      "question": "Viết một test negative dễ dàng cho một API mong đợi định dạng JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test trường hợp yêu cầu resource không tồn tại (ID không hợp lệ). Ví dụ, thử GET /products/999. Expected: `404 Not Found` hoặc JSON có trường `error`."
    },
    {
      "question_id": "EQ5033-VN",
      "question": "Vai trò của assertion trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "Assertion là công cụ kiểm tra giúp xác định xem API đáp ứng yêu cầu hay không. Nó so sánh kết quả thực tế với kết quả mong đợi và báo cáo kết quả kiểm tra."
    },
    {
      "question_id": "EQ5035-VN",
      "question": "Viết một test case để kiểm tra DELETE /users/{id} hoạt động đúng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "**Test Case: Xoá User**\n- **Test Case ID:** TC-DELETE-USER\n- **Test Case Name:** Xác nhận xoá user thành công.\n- **Preconditions:** User ID=1234 tồn tại.\n- **Test Steps:**\n  1. Request DELETE /users/1234.\n- **Expected Result:**\n  - Status Code = 204 No Content.\n  - Dữ liệu trong DB không tồn tại ID=1234."
    },
    {
      "question_id": "EQ5037-VN",
      "question": "Mã trạng thái HTTP 201 Created cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "Mã trạng thái HTTP 201 Created cho biết yêu cầu tạo mới tài nguyên thành công."
    },
    {
      "question_id": "EQ5039-VN",
      "question": "Viết một test đơn giản cho GET /users/{id} trả về response chính xác.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "Test trường hợp ID tồn tại và ID không tồn tại."
    },
    {
      "question_id": "EQ5041-VN",
      "question": "Mục đích của một response 200 OK là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "Một response 200 OK cho biết yêu cầu của client đã được thực hiện thành công."
    },
    {
      "question_id": "EQ5043-VN",
      "question": "Viết một test negative để validate response cho một endpoint không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "**Test Case:** Validate Negative Authentication\n- **Test Case Name:** Attempt Login with Invalid Credentials.\n- **Preconditions:** API đang chạy.\n- **Test Steps:**\n  - Send `POST` request đến endpoint `/login` với payload `{\"username\": \"invaliduser\", \"password\": \"wrongpassword\"}`.\n- **Expected Result:**\n  - Status Code: `401 Unauthorized` hoặc `400 Bad Request`.\n  - Response Body không chứa token hoặc chứa thông báo lỗi như \"Invalid credentials\"."
    },
    {
      "question_id": "EQ5045-VN",
      "question": "Một test case assertion làm gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Một test case assertion xác định điều kiện thành công của một thử nghiệm. Ví dụ, nếu yêu cầu là 'API trả về HTTP 200 khi tạo user thành công', thì assertion sẽ kiểm tra xem trạng thái HTTP trả về là 200 hay không."
    },
    {
      "question_id": "EQ5047-VN",
      "question": "Viết một test positive cho endpoint upload file.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "Test case: `POST /upload` with valid image file (e.g., `image.jpg`). Expected: `201 Created`, file saved successfully in server."
    },
    {
      "question_id": "EQ5049-VN",
      "question": "Vai trò của 415 Unsupported Media Type là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "415 Unsupported Media Type được sử dụng khi client gửi yêu cầu với định dạng nội dung (Content-Type) mà server không hỗ trợ. Ví dụ, nếu client yêu cầu dữ liệu JSON nhưng server chỉ hiểu dạng XML, nó sẽ trả về trạng thái 415."
    },
    {
      "question_id": "EQ5052-VN",
      "question": "Viết một test positive đơn giản để kiểm tra API chi tiết sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "**Test Case:** Lấy Chi Tiết Sản Phẩm\n- **Test Scenario:** Đăng nhập và yêu cầu chi tiết sản phẩm ID=123.\n- **Action:** Gọi `GET /products/123`.\n- **Expected:** Trả về mã `200 OK` với dữ liệu chi tiết sản phẩm."
    },
    {
      "question_id": "EQ5054-VN",
      "question": "Mục đích của việc sử dụng Authorization headers trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "Là để xác thực và cấp quyền cho yêu cầu gửi đến server. Ví dụ, `Authorization: Bearer <token>` sẽ yêu cầu server kiểm tra token và xác định xem người dùng nào được thực hiện hành động đó."
    },
    {
      "question_id": "EQ5056-VN",
      "question": "Viết một test negative case cho một API yêu cầu authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Test trường hợp không gửi token hoặc gửi token hết hạn. Expected: `403 Forbidden` hoặc `401 Unauthorized`."
    },
    {
      "question_id": "EQ5058-VN",
      "question": "Vai trò của 500 Internal Server Error trong API testing là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "500 Internal Server Error là một mã lỗi chung được sử dụng khi xảy ra lỗi trên server mà không thể xác định lỗi cụ thể. Trong testing, mục đích là kiểm tra khả năng xử lý lỗi của API, chẳng hạn khi gặp vấn đề cơ bản với cơ sở dữ liệu hoặc khi xảy ra lỗi bất ngờ trong mã nguồn."
    },
    {
      "question_id": "EQ5060-VN",
      "question": "Viết một test case positive cho một API trả về danh sách đơn hàng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "**Test Case: Lấy Danh Sách Đơn Hàng**\n- **Test Case ID:** TC_001\n- **Test Case Name:** Kiểm tra việc lấy danh sách đơn hàng thành công.\n- **Test Case Description:** Gửi yêu cầu GET đến endpoint `/orders` và xác thực trạng thái và dữ liệu trả về.\n- **Test Case Preconditions:** Có ít nhất một đơn hàng đã được tạo trong cơ sở dữ liệu.\n- **Test Case Steps:**\n  1. Gửi yêu cầu GET đến `/orders`.\n  2. Xác định xem HTTP Status Code trả về là `200 OK` hay không.\n  3. Xác thực xem danh sách đơn hàng được trả về và có phải là danh sách không trống hay không.\n- **Test Case Expected Result:**\n  - HTTP Status Code: `200 OK`.\n  - Trả về danh sách các đơn hàng được tạo trước đó."
    },
    {
      "question_id": "EQ5062-VN",
      "question": "Chức năng của response header trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "Chức năng của response header là cung cấp thông tin metadata về nội dung trả về. Ví dụ, `Content-Type` xác định định dạng dữ liệu, `Cache-Control` chỉ định hành vi caching."
    },
    {
      "question_id": "EQ5064-VN",
      "question": "Viết một test negative cho việc tạo một tài nguyên trùng lặp.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "Test Negative: Bước 1: Gọi API tạo tài nguyên với đường dẫn `/products/ABC123`. Bước 2: Thay vì gửi một payload hợp lệ, hãy gửi một payload bất kỳ (vd: `{\"name\": \"Test\"}`) và yêu cầu HTTP. Bước 3: Đảm bảo API trả về một trạng thái không thành công như `404 Not Found` hoặc `409 Conflict`, và trong trường hợp đó, đảm bảo cơ sở dữ liệu không bị thay đổi."
    },
    {
      "question_id": "EQ5066-VN",
      "question": "Vai trò của 202 Accepted trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "202 Accepted được sử dụng khi API nhận được yêu cầu nhưng sẽ xử lý sau. Ví dụ, khi gửi file lớn, API sẽ trả 202 Accepted và tiếp tục xử lý ở hậu kỳ."
    },
    {
      "question_id": "EQ5068-VN",
      "question": "Viết một test positive dễ dàng để kiểm tra API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Test case: **Test Positive - Valid Data**. **Action:** Send request với dữ liệu hợp lệ (ví dụ: đăng ký user với email và password valid). **Expected:** API trả về trạng thái HTTP 200 OK và response body phải chứa các trường dữ liệu chính (ví dụ: `id`, `email`, `password`) với các giá trị phù hợp."
    },
    {
      "question_id": "EQ5070-VN",
      "question": "Mục đích của response body trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Response body chứa dữ liệu trả về cho client. Mục đích là kiểm tra tính chính xác, đầy đủ, và hợp lệ của dữ liệu này."
    },
    {
      "question_id": "EQ5072-VN",
      "question": "Viết một test case để verify chức năng logout.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Logout**\n- **Preconditions:** User logged in.\n- **Action:** Send logout request.\n- **Expected:** User session expired, subsequent requests to protected endpoints return 403 Forbidden."
    },
    {
      "question_id": "EQ5074-VN",
      "question": "Lỗi 415 Unsupported Media Type validate điều gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "Lỗi 415 Unsupported Media Type xảy ra khi client gửi dữ liệu theo định dạng mà server không hỗ trợ. Ví dụ, nếu API yêu cầu dữ liệu dạng JSON nhưng client gửi XML, thì server sẽ trả về lỗi này."
    },
    {
      "question_id": "EQ5077-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /status.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Test trường hợp: **Test Case: Status Endpoint**\n- **Preconditions:** API đang chạy.\n- **Test Steps:** Gửi yêu cầu GET đến `/status`.\n- **Expected Result:** HTTP Status Code `200 OK` và trả về JSON với trạng thái như 'running' hoặc 'healthy'."
    },
    {
      "question_id": "EQ5079-VN",
      "question": "Một response 204 No Content có nghĩa là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "Một response 204 No Content xác nhận rằng yêu cầu đã được thực hiện thành công, nhưng server không có nội dung nào để gửi lại."
    },
    {
      "question_id": "EQ5081-VN",
      "question": "Viết một test negative case cho việc gửi một Content-Type header không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Test Case: Gửi yêu cầu POST với header `Content-Type: application/xml`. Expected: Server trả về `415 Unsupported Media Type`."
    },
    {
      "question_id": "EQ5083-VN",
      "question": "Mục đích của Accept header trong các API request là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "Accept header được sử dụng để chỉ định format dữ liệu trả về mà client hỗ trợ. Ví dụ, `Accept: application/json` yêu cầu server trả về dữ liệu JSON."
    },
    {
      "question_id": "EQ5085-VN",
      "question": "Viết một test case đơn giản cho một API logout thành công.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "### **Test Case: Logout Successful**\n- **Test Case ID:** TC-LOGOUT-001\n- **Test Case Name:** Verify successful logout.\n- **Preconditions:** User authenticated with valid token.\n- **Test Steps:**\n  1. Send `POST` request to `/logout`.\n  2. Verify response status code is `200 OK`.\n- **Post-conditions:**\n  - Token should not be valid after logout.\n  - Subsequent protected endpoint should return `401 Unauthorized`.\n- **Expected Result:** Logout confirmed by invalid token."
    },
    {
      "question_id": "EQ5087-VN",
      "question": "Ý nghĩa của 401 Unauthorized trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "Một 401 Unauthorized nghĩa là yêu cầu được gửi nhưng không được xác thực hoặc xác thực không hợp lệ. Ví dụ, người dùng chưa đăng nhập hoặc mật khẩu không đúng."
    },
    {
      "question_id": "EQ5089-VN",
      "question": "Viết một test case positive dễ dàng để kiểm tra API chi tiết profile.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "Test Case: Tính năng Profile chi tiết.\n- **Test Case Name:** Verify Profile Details.\n- **Test Case Description:** Đảm bảo API trả về thông tin người dùng đầy đủ khi yêu cầu profile riêng.\n- **Preconditions:** User 'John Doe' có profile sẵn.\n- **Test Steps:**\n  1. Request Profile với ID User.\n- **Expected Result:**\n  - Status Code: `200 OK`.\n  - Body chứa tên, email, địa chỉ, hình ảnh profile."
    },
    {
      "question_id": "EQ5091-VN",
      "question": "Mục đích của 302 Found trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "Mục đích của 302 Found là chuyển hướng tạm thời một yêu cầu đến một URL khác. Ví dụ, khi một API được di chuyển sang một URL mới, nó sẽ trả về trạng thái 302 với địa chỉ mới để client biết."
    },
    {
      "question_id": "EQ5093-VN",
      "question": "Viết một test case cho nỗ lực đăng nhập negative với mật khẩu sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Đăng nhập với mật khẩu sai**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Đăng nhập với mật khẩu sai.\n- **Test Case Description:** Đăng nhập với một mật khẩu sai để kiểm tra lỗi.\n- **Preconditions:** Đăng nhập.\n- **Test Steps:**\n  - **Test Step 1:** Gửi yêu cầu đăng nhập với trường password = 'wrongpassword'.\n- **Expected Result:**\n  - Status Code = 401 Unauthorized.\n  - Response Body chứa thông báo lỗi như 'Sai mật khẩu'."
    },
    {
      "question_id": "EQ5095-VN",
      "question": "422 Unprocessable Entity cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "Cú pháp yêu cầu không đúng."
    },
    {
      "question_id": "EQ5097-VN",
      "question": "Viết một test positive cho endpoint POST /users.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Test Positive: Gửi một yêu cầu đăng ký với các thông tin hợp lệ (email, password, name) và kiểm tra HTTP Status Code là `201 Created`."
    },
    {
      "question_id": "EQ5099-VN",
      "question": "Thuật ngữ 'happy path' trong testing có nghĩa là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "'Happy path' trong testing là hành trình sử dụng hệ thống mà không xảy ra lỗi hoặc vấn đề. Ví dụ, đăng ký tài khoản thành công mà không bị trùng email."
    },
    {
      "question_id": "EQ2002-VN",
      "question": "Hãy giải thích cách bạn thiết kế một **test case âm tính** cho một endpoint API yêu cầu **OAuth2 Bearer token**.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "Một test case âm tính cho endpoint yêu cầu OAuth2 là test khi không đưa token hoặc đưa token hết hạn. Cú pháp request: `GET /protected-resource` không thêm `Authorization` header. Expected Result: `403 Forbidden` hoặc `401 Unauthorized`."
    },
    {
      "question_id": "EQ2004-VN",
      "question": "Cung cấp một **test case happy-path** và một **test case error-path** cho một endpoint API hoàn tiền thanh toán.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path:**\n- **Test Case ID:** TC-009 (Refund Successful).\n- **Test Case Name:** Verify full refund processed successfully.\n- **Preconditions:** User account has sufficient balance, refund request is valid.\n- **Test Steps:**\n  1. Send `POST /refunds` request with valid payload.\n- **Expected Result:**\n  - API returns `201 Created`.\n  - Database confirmed refund amount deducted from user's balance.\n  - Email notification for successful refund sent to user.\n- **Post-conditions:** Refund record exists in DB.\n\n**Test Case Error-Path:**\n- **Test Case ID:** TC-010 (Refund Failed).\n- **Test Case Name:** Verify refund fails when insufficient balance.\n- **Preconditions:** User account has zero balance.\n- **Test Steps:**\n  1. Send `POST /refunds` request with same payload as happy path.\n- **Expected Result:**\n  - API returns `400 Bad Request` or `409 Conflict` with appropriate error message.\n  - No refund record created in DB.\n  - Email notification for failed refund not sent.\n- **Post-conditions:** No changes in user's balance."
    },
    {
      "question_id": "EQ2006-VN",
      "question": "Bạn sẽ xác thực các thay đổi **schema** trong một nâng cấp API **tương thích ngược** như thế nào?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "Cơ chế tương thích ngược (backward compatibility) đảm bảo API cũ vẫn hoạt động khi schema mới được triển khai. Xác thực thay đổi schema liên quan đến việc kiểm tra các trường hợp test cũ với các phiên bản mới của API."
    },
    {
      "question_id": "EQ2008-VN",
      "question": "Giải thích cách **mocking** có thể được sử dụng để kiểm tra một API thanh toán mà không gọi dịch vụ ngân hàng thực.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Mocking tạo một bản sao giả của API ngân hàng. Trong kiểm tra, API thanh toán sẽ gọi mock này thay vì dịch vụ thật. Ví dụ, mock được cấu hình để luôn trả `200 OK` và chứa dữ liệu giả cho đơn hàng."
    },
    {
      "question_id": "EQ2010-VN",
      "question": "Thiết kế một **boundary test** và một **invalid test** cho trường API `age` (phạm vi 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "- **Boundary Test (Valid):** Là khi nhập giá trị `18` hoặc `65`.  Ví dụ: `POST /users` với `age=18`.\n- **Invalid Test (Hết Phạm Vi):** Là khi nhập giá trị `0` hoặc `70`. Ví dụ: `POST /users` với `age=0`."
    },
    {
      "question_id": "EQ2012-VN",
      "question": "Giải thích cách bạn mô phỏng lỗi **network timeout** trong **API testing**.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "Mô phỏng lỗi mạng timeout bằng cách thêm delay giả lập vào yêu cầu gửi đến server. Ví dụ, sử dụng tool như `curl` hoặc `Postman` và thêm parameter `--timeout` hoặc `headers` với giá trị thời gian chờ cao. Sau đó, kiểm tra hành động của API khi nhận yêu cầu (ví dụ: trả về trạng thái lỗi 504, retry sau một thời gian)."
    },
    {
      "question_id": "EQ2014-VN",
      "question": "Đưa ra một ví dụ về một **precondition** API và một **step** theo sau nó.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "**Ví dụ về Precondition:** Một API yêu cầu phải có một tài khoản khách hàng được tạo (`user_id = 123`) và một đơn hàng tồn tại (`order_id = 456`) để thực hiện hành động \"Xác nhận đơn hàng\" (confirm order).\n\n**Step sau Precondition:** Sau khi đảm bảo `user_id = 123` và `order_id = 456` tồn tại trong cơ sở dữ liệu, **Bước tiếp theo** là gửi một yêu cầu `POST` tới `/orders/{order_id}/confirm` với payload xác nhận đơn hàng."
    },
    {
      "question_id": "EQ2016-VN",
      "question": "Viết một **test case** để xác thực rằng **API rate limiting** được thực thi đúng.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "Test case sẽ bao gồm các bước sau:\n- Gửi yêu cầu hợp lệ nhiều lần liên tiếp (ví dụ 10 requests trong 5s).\n- Xác minh số lượng yêu cầu cho phép (rate limit) được lưu trữ đúng.\n- Challenging: gửi yêu cầu thứ 11 và xác minh API trả về trạng thái `403 Forbidden` hoặc `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2018-VN",
      "question": "Giải thích một lợi thế của việc sử dụng **service virtualization** trong **API testing**.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "**Lợi thế:** Dịch vụ giả (service virtualization) cho phép thực hiện **testing** mà không cần tất cả các **service** thực tế sẵn có. Điều này giảm chi phí, tăng tốc độ thử nghiệm và cho phép bắt đầu **testing** sớm."
    },
    {
      "question_id": "EQ2020-VN",
      "question": "Mô tả cách thiết kế một **test case tích cực** và một **boundary test case** cho một API đăng nhập yêu cầu tên người dùng và mật khẩu.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "**Test Case Tích Cực:** Gửi một yêu cầu đăng nhập với một tên người dùng và mật khẩu hợp lệ, kiểm tra HTTP status code (`200 OK`) và đảm bảo trả về một token truy cập hợp lệ. **Boundary Test Case:** 1. **Tên người dùng Boundary:** Gửi tên người dùng là chuỗi rỗng. 2. **Mật khẩu Boundary:** Gửi mật khẩu là chuỗi rỗng hoặc quá dài vượt quá giới hạn của API. 3. **Thử sai lệch:** Gửi tên người dùng không tồn tại hoặc mật khẩu sai."
    },
    {
      "question_id": "EQ2022-VN",
      "question": "Viết một **test step** để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "**Test Step:** Gửi một yêu cầu `POST` tới endpoint `/upload` nhưng thay vì gửi một file, bạn gửi một chuỗi văn bản như `{\"content\": \"Hello, World!\"}` trong phần body của request. **Expected Result:** API phải trả về một trạng thái HTTP `415 Unsupported Media Type` và trong body của response, bạn mong đợi một thông điệp lỗi như `\"The server cannot process the request, because the entity body of the request contains data in a format that the server does not know how to parse.\"`."
    },
    {
      "question_id": "EQ2024-VN",
      "question": "Mô tả một cách để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "**Cách test:** 1. Đăng ký một trường hợp sử dụng API với yêu cầu DB chậm (tạo một bảng lớn, sử dụng một truy vấn phức tạp). 2. Sử dụng công cụ monitor như Prometheus hoặc Datadog để theo dõi thời gian thực hiện của truy vấn đó. 3. Lặp lại yêu cầu API nhiều lần và kiểm tra xem dữ liệu monitor có thể phản ánh đúng tình trạng chậm của DB hay không."
    },
    {
      "question_id": "EQ2026-VN",
      "question": "Giải thích cách bạn sẽ kiểm tra **API idempotency** cho một kịch bản **retry**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Trường hợp: API tạo tài khoản. Kiểm tra bằng cách gửi request tạo một lần, sau đó gửi lại request cùng tham số. Đáp ứng: DB chỉ có 1 bản ghi, HTTP Status `201` duy nhất."
    },
    {
      "question_id": "EQ2028-VN",
      "question": "Đưa ra một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "- **Boundary Test (Valid Edge):** Tải file kích thước 5 MB (theo yêu cầu) -> 100% dự kiến trả `200 OK` và lưu file thành công.\n- **Invalid Test:** Tải file kích thước > 10 MB -> 100% dự kiến trả `415 Unsupported Media Type` hoặc `413 Payload Too Large`."
    },
    {
      "question_id": "EQ2030-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "Test Case: **Xử lý lỗi khi email bị thiếu**\n- **Test Scenario:** Gửi yêu cầu đăng ký với body `{ \"username\": \"user123\", \"password\": \"password123\" }` (bỏ campo `email`).\n- **Test Steps:**\n  1. Gửi yêu cầu qua API.\n- **Expected Result:**\n  - Trả về trạng thái HTTP `400 Bad Request`.\n  - Nội dung response chứa thông báo lỗi cho trường `email` (ví dụ: `{\"error\": {\"email\": [\"Email is required.\"]}}`).\n  - Không tạo được tài khoản mới."
    },
    {
      "question_id": "EQ2032-VN",
      "question": "Bạn sẽ thiết kế một **test** để xác thực logic **retry** như thế nào khi một API thỉnh thoảng trả về **503**?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "1. **Cài đặt:** Sử dụng một công cụ như **Locust** hoặc **K6** để tạo ra một đợt yêu cầu (ramp-up) lên API.\n2. **Thi hành:** Trong đợt thử nghiệm, giả lập một số yêu cầu bị **timeout** (để API trả về **503 Service Unavailable**).\n3. **Xác thực:** Sau khi đợt thử nghiệm hoàn thành, kiểm tra **log** hoặc **database** để xác định xem các yêu cầu bị **timeout** đã được **retry** thành công hay không.\n4. **Đường thử nghiệm:** Đảm bảo hệ thống **retry** được kích hoạt và có cơ chế giới hạn số lần **retry** để tránh **infinite loop**.\n\n**Lợi ích:** Giúp đảm bảo API có khả năng tự phục hồi (self-healing) khi gặp lỗi tạm thời."
    },
    {
      "question_id": "EQ2034-VN",
      "question": "Viết một **test case** xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "**Test Case:** Log Correlation via Trace ID.\n- **Test Case ID:** TC-LOG-001.\n- **Test Case Name:** Verify logs linked to trace ID header.\n- **Preconditions:** API configured with tracing enabled, trace ID 'TRACE-123' available.\n- **Test Steps:**\n  1. Send request to `/process` with `X-Trace-ID: TRACE-123` header.\n  2. In logs, search for `trace_id: TRACE-123`.\n- **Expected Result:** Log entries found with matching trace ID."
    },
    {
      "question_id": "EQ2036-VN",
      "question": "Thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting** khi có nhiều máy khách tham gia.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "**Test Case:** `Verify Rate Limit Enforcement - Bursty Requests`.\n\n- **Preconditions:** Máy khách A được cấu hình với giới hạn 100 req/min.\n- **Test Steps:**\n  1. Gửi 50 yêu cầu liên tục trong 1 phút.\n  2. Sau khi vượt qua giới hạn, tiếp tục gửi yêu cầu trong 5 phút.\n- **Expected Result:**\n  - Trước khi vượt qua giới hạn: `200 OK` cho tất cả yêu cầu.\n  - Sau khi vượt qua giới hạn: Yêu cầu thứ 51 và sauwards bị chặn với `429 Too Many Requests`."
    },
    {
      "question_id": "EQ2038-VN",
      "question": "Mô tả một **test case tích cực** và một **test case âm tính** cho một endpoint API gửi mã **SMS**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "*   **Test Case Tích Cực (Positive):** Gửi yêu cầu `POST /send-sms` với số điện thoại hợp lệ (`+8498765432`) và mã SMS ngắn bất kỳ (e.g., `12345`). Đợi xác nhận, kiểm tra trạng thái HTTP (e.g., `200 OK`), và nội dung phản hồi để xác nhận mã đã được gửi thành công.\n*   **Test Case Âm Tính (Negative):** Gửi yêu cầu `POST /send-sms` với số điện thoại trống hoặc không hợp lệ (e.g., `1234567`). Đợi xác nhận, kiểm tra trạng thái HTTP (e.g., `400 Bad Request` hoặc `500 Internal Server Error`), và nội dung phản hồi để xác nhận API đã xử lý lỗi phù hợp."
    },
    {
      "question_id": "EQ2040-VN",
      "question": "Giải thích một lợi thế của việc **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Lợi thế là **mock** cho phép chạy các test về lỗi mạng (timeout, 500 error) mà không phụ thuộc vào kết nối internet ổn định, giúp tăng độ tin cậy và tốc độ của pipeline test."
    },
    {
      "question_id": "EQ2042-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi khi API trả về **JSON** bị định dạng sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "**Test Case:** `Verify Invalid JSON Response`\n\n- **Preconditions:** API đang chạy.\n- **Test Steps:**\n  1. Gửi yêu cầu GET bình thường.\n  2. Gửi yêu cầu với JSON Response bị định dạng sai (thiếu dấu ngoặc kép, từ khóa sai).\n- **Expected Result:**\n  - API phải trả về **HTTP Status Code 400 Bad Request**.\n  - Response Body phải chứa thông báo lỗi rõ ràng về vấn đề định dạng JSON."
    },
    {
      "question_id": "EQ2044-VN",
      "question": "Thiết kế một **test step** để xác nhận các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "**Test Step:**\n1. **Action:** Gửi một yêu cầu hợp lệ đến API.\n2. **Expected:**\n   - **Status Code:** `200 OK` hoặc mã trạng thái tương ứng.\n   - **Header:** `X-RateLimit-Remaining` phải có trong phản hồi HTTP.\n   - **Value:** Giá trị của `X-RateLimit-Remaining` phải chính xác (ví dụ: `10` nếu giới hạn là 10 yêu cầu/phút)."
    },
    {
      "question_id": "EQ2046-VN",
      "question": "Mô tả một lợi thế của việc tách dữ liệu **test** khỏi logic **test** trong **API testing**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Lợi thế là dữ liệu **test** không bị ảnh hưởng bởi kết quả của các trường hợp **test** khác, đảm bảo tính độc lập và khả năng tái tạo kết quả **test** chính xác."
    },
    {
      "question_id": "EQ2048-VN",
      "question": "Viết một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "### **Test Case: Cache Unavailable**\n- **Test Case ID:** TC-007\n- **Test Case Name:** Verify graceful degradation when cache service is unavailable.\n- **Preconditions:**\n  - Cache API (e.g., Redis, Memcached) is not reachable from API gateway.\n- **Test Steps:**\n  1. Send `GET /products` request to API.\n  2. Confirm API returns `200 OK` or an acceptable status code.\n- **Post-conditions/Expected Results:**\n  - Verify data is not served from cache. Instead, API should hit the backend database.\n  - Check logs to confirm graceful degradation without errors."
    },
    {
      "question_id": "EQ2050-VN",
      "question": "Giải thích một cách để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Xác thực logging: 1) Sử dụng các filter bảo mật trên logstash/kafka. 2) Đánh dấu các trường nhạy cảm bằng prefix như \"*****\". 3) Lưu trữ logs riêng biệt cho dữ liệu bảo mật."
    },
    {
      "question_id": "EQ2052-VN",
      "question": "Cung cấp một **test case âm tính** và một **boundary test case** cho một trường tiền tệ phải khớp với mã **ISO 4217**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test Case Âm Tính:** Đặt trường tiền tệ với giá trị `USD` và thực hiện thanh toán. Đảm bảo hệ thống không báo lỗi và chuyển đổi tiền tệ thành USD.\n- **Boundary Test Case:** Đặt trường tiền tệ ở biên giới (ví dụ: `EUR` và `USD`), thực hiện thanh toán và kiểm tra kết quả."
    },
    {
      "question_id": "EQ2054-VN",
      "question": "Viết một **test case** để xác thực hành vi API dưới tình trạng mất gói mạng.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "**Test Case:** Kiểm tra tính ổn định khi mạng bị gián đoạn.\n- **Preconditions:** API đang chạy, giả lập mất gói mạng.\n- **Steps:**\n  - Gửi yêu cầu → mong đợi `503 Service Unavailable`.\n  - Đợi 10s → phục hồi kết nối → tiếp tục xử lý yêu cầu.\n- **Expected:** API phải phục hồi tự động."
    },
    {
      "question_id": "EQ2056-VN",
      "question": "Mô tả một phương pháp để xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Phương pháp: 1) Sử dụng **ID test** cố định để tạo dữ liệu **test**. 2) Thực hiện **API test** tạo và sau đó xóa dữ liệu đó. 3) Kiểm tra DB trước và sau test để xác nhận dữ liệu đã bị xóa hoàn toàn."
    },
    {
      "question_id": "EQ2058-VN",
      "question": "Viết một **test case** để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "**Test Case: Rollback Multi-Step Transaction**\n- **Preconditions:** DB sẵn sàng, thử nghiệm được thiết lập.\n- **Test Steps:**\n  1. Thực hiện giao dịch nhiều bước (A -> B -> C).\n  2. Thừa hưởng bước bất kỳ (đặt giá trị DB).\n  3. Thử nghiệm: Đặt bước C thất bại (gán giá trị không hợp lệ).\n- **Expected Result:** DB được rollback hoàn toàn, trạng thái trước khi bắt đầu giao dịch được bảo tồn. Không có bước nào bị lưu ngoài cơ chế rollback."
    },
    {
      "question_id": "EQ2060-VN",
      "question": "Giải thích một cách tiếp cận để xác thực các thông báo lỗi tuân theo một **JSON schema** nhất quán trên tất cả các **endpoint**.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "1. **Thiết lập cơ sở dữ liệu**: Đảm bảo các trường lỗi tồn tại trong schema JSON và được ánh xạ với các lỗi cơ bản (e.g., `400-BAD_REQUEST`, `404-NOT_FOUND`, `500-INTERNAL_SERVER_ERROR`).\n2. **Tạo yêu cầu lỗi**: Sử dụng công cụ như Postman hoặc Insomnia để gửi yêu cầu bất hợp lệ lên từng endpoint. Ví dụ: gửi request `GET` cho một resource không tồn tại, hoặc gửi request với trường dữ liệu không hợp lệ.\n3. **Xác thực phản hồi lỗi**: Sử dụng công cụ kiểm tra JSON như `jq` hoặc trực tiếp trong script để xác minh:\n   - **Mã trạng thái HTTP**: Là một trong các mã lỗi cơ bản (400, 404, 500).\n   - **Thân phản hồi (Body)**: Phải tuân theo **JSON schema** đã định nghĩa. Ví dụ, một lỗi `400` phải có trường `error` với thông tin lỗi cụ thể, dạng `string`.\n   - **Header**: Có thể cần kiểm tra các thông số như `Content-Type` hoặc các thông báo đặc biệt như `Retry-After`.\n4. **Thẻ nghiệm và báo cáo lỗi**: Nếu phản hồi lỗi không đúng, báo cáo lỗi với thông tin chi tiết về lỗi cơ bản nào không được đáp ứng.\n5. **Lặp lại với các trường hợp lỗi khác nhau**: Để đảm bảo schema JSON có thể xác thực được mọi loại lỗi có thể xảy ra trên các endpoint khác nhau."
    },
    {
      "question_id": "EQ3002-VN",
      "question": "Viết một test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "### **Test Case: Đăng Nhập, Làm Mới Token, Truy Cập Bảo Vệ**\n- **Test Case ID:** TC-002\n- **Test Case Name:** Xác thực đăng nhập, làm mới token, truy cập API được bảo vệ.\n- **Preconditions:**\n  - Hệ thống API đã được bật và sẵn sàng.\n  - Có một user có quyền đủ để truy cập API được bảo vệ.\n- **Test Steps:**\n  1. **Đăng Nhập:** Gửi yêu cầu `POST /login` với email/password hợp lệ. Verify response có `token_access` và `token_refresh`.\n  2. **Làm Mới Token:** Sử dụng `token_refresh` gửi yêu cầu `POST /refresh-token` để nhận token mới. Verify token mới được trả về và có giá trị.\n  3. **Truy Cập Bảo Vệ:** Sử dụng `token_access` mới để gửi yêu cầu `GET /protected-resource`. Verify API trả về trạng thái `200 OK` và dữ liệu yêu cầu.\n- **Expected Results:**\n  - Yêu cầu đăng nhập và làm mới token đều phải thành công.\n  - Yêu cầu truy cập API được bảo vệ phải thành công khi sử dụng token mới.\n  - Token cũ không thể sử dụng để truy cập API bảo vệ."
    },
    {
      "question_id": "EQ3004-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "**Test Case: Prevent Token Issuance on Failed Login**\n- **Preconditions:** API hỗ trợ refresh token và đăng nhập đã bật.\n- **Action:**\n  - Gửi yêu cầu đăng nhập với thông tin sai.\n- **Expected:** 403 Forbidden hoặc 401 Unauthorized, không có refresh token được phát hành trong trường hợp đó."
    },
    {
      "question_id": "EQ3006-VN",
      "question": "Giải thích cách bạn sẽ xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Tôi sẽ tạo một cơ sở dữ liệu chứa thông tin về mã nghiệp vụ và trạng thái HTTP. Sau đó, tôi sẽ tạo các trường hợp kiểm tra bằng cách gọi API với các mã nghiệp vụ khác nhau và xác minh rằng API trả về đúng mã trạng thái HTTP tương ứng (ví dụ: `201` cho tạo đơn hàng thành công, `409` cho đơn hàng tồn tại)."
    },
    {
      "question_id": "EQ3008-VN",
      "question": "Viết một test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "### **Test Case: Tạo Đơn Hàng → Thanh Toán → Hoàn Tiền**\n- **Preconditions:**\n  - Tài khoản khách hàng sẵn tiền.\n  - Sản phẩm tồn kho.\n- **Test Steps:**\n  1. **Tạo ĐH:** `POST /orders` với sản phẩm A, B.\n  2. **Thanh Toán:** `POST /payments` cho đơn hàng vừa tạo.\n  3. **Hoàn Tiền:** `POST /refund` cho đơn hàng ID biết.\n- **Expected:** ĐH hoàn thành, trạng thái DB → DB → DB."
    },
    {
      "question_id": "EQ3010-VN",
      "question": "Giải thích một test case xác thực việc làm mới token hoạt động trên nhiều microservice.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case xác thực: 1) Gửi yêu cầu đăng nhập → nhận token từ Service Authentication. 2) Sử dụng token gọi API protected trên Service A → 200 OK. 3) Service A gọi API khác trên Service B → Service B xác thực token → 200 OK. 4) Test token hết hạn → 401 Unauthorized."
    },
    {
      "question_id": "EQ3012-VN",
      "question": "Viết một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "### **Test Case: Xác Thực và Mã Lỗi**\n- **Test Case Name:** Valid + Invalid Authentication (Token).\n- **Test Case ID:** TC-007.\n- **Preconditions:** API đang hoạt động, có 1 user biết password và 1 token expired.\n\n- **Test Steps:**\n  - **Valid:** Gửi request với token hợp lệ → `200 OK` với response user data.\n  - **Invalid Token:** Gửi request với token hết hạn → `400 Bad Request` với message lỗi.\n  - **Invalid Payload:** Gửi request với payload không đúng format → `400 Bad Request` với message lỗi.\n\n- **Expected Results:**\n  - Response `200 OK` chỉ khi token hợp lệ.\n  - Mã lỗi `400` phải được trả về khi token hoặc payload không hợp lệ."
    },
    {
      "question_id": "EQ3014-VN",
      "question": "Thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Test Case:** `Test Refresh Token Expiry`.\n2. **Preconditions:**\n   - Có một refresh token đã hết hạn (ví dụ đã quá thời hạn 1 giờ).\n   - Access token liên quan đã hết hạn.\n3. **Test Steps:**\n   - Gửi yêu cầu refresh token đã hết hạn đến endpoint token refresh.\n4. **Expected Result:**\n   - API trả về trạng thái HTTP `403 Forbidden` hoặc `401 Unauthorized`.\n   - Không cấp được access token mới."
    },
    {
      "question_id": "EQ3016-VN",
      "question": "Giải thích một bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Bước 1:** Đăng nhập với một tài khoản xác thực và lưu trữ cookie của session được tạo ra. 2. **Bước 2:** Sử dụng cookie này gửi một yêu cầu GET đến một endpoint được bảo vệ (VD: `/protected/data`). 3. **Bước 3:** Sau khi yêu cầu được xử lý, yêu cầu hủy bỏ session được gửi đến server. 4. **Bước 4:** Một yêu cầu khác được gửi đến endpoint bảo vệ sử dụng cookie cũ. 5. **Bước 5:** Kiểm tra trạng thái HTTP và nội dung đáp ứng (VD: mã trạng thái `403 Forbidden` hoặc `404 Not Found`, nội dung JSON trả về không chứa dữ liệu)."
    },
    {
      "question_id": "EQ3018-VN",
      "question": "Viết một test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "### **Test Case: Đăng ký và Đăng nhập**\n- **Test Case ID:** TC-001\n- **Test Case Name:** Đăng ký mới -> Xác minh email -> Đăng nhập thành công.\n- **Preconditions:** Server API đang hoạt động.\n- **Test Steps:**\n  1. **Đăng ký:** Gửi yêu cầu POST tới `/users` với thông tin tên, email, password. Ví dụ: `POST /users` với body `{ \"name\": \"John Doe\", \"email\": \"john@example.com\", \"password\": \"Password123\" }`.\n  2. **Xác minh Email:** Không có endpoint trực tiếp xác minh email, nhưng giả sử hệ thống sẽ gửi email đến địa chỉ đăng ký. Vì test tự động, không thể chờ email, nên giả sử email đã được xác minh trước khi chạy test này.\n  3. **Đăng nhập:** Gửi yêu cầu POST tới `/login` với email và password được đăng ký. Ví dụ: `POST /login` với body `{ \"email\": \"john@example.com\", \"password\": \"Password123\" }`.\n- **Expected Results:**\n  - **Đăng ký:** Trả về `201 Created` và một chuỗi ID người dùng (ví dụ `{\"id\": \"user-123\"}`).\n  - **Đăng nhập:** Trả về `200 OK` với một chuỗi token xác thực (ví dụ `{\"token\": \"eyJhbGciOiJIUzI1NiJ9\"}`) và một chuỗi ID người dùng."
    },
    {
      "question_id": "EQ3020-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Bước 1:** Đăng nhập không đúng lần đầu → hệ thống gửi email hoặc SMS xác thực.\n2. **Bước 2:** Người dùng nhập mã xác thực → hệ thống yêu cầu đáp ứng (CAPTCHA).\n3. **Bước 3:** Sau khi thành công, yêu cầu nhập mật khẩu mới và xác nhận lại.\n4. **Bước 4:** Kiểm tra: mật khẩu cũ không thể dùng lại, mới đủ độ phức tạp và không trùng với trước đó."
    },
    {
      "question_id": "EQ3022-VN",
      "question": "Viết một test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "**Test Case: Quản lý Người dùng**\n- **Test Case ID:** TC-USER-001\n- **Test Case Name:** Xác thực tạo, cập nhật và xem hồ sơ người dùng.\n- **Test Case Description:** Kiểm tra các chức năng cơ bản của người dùng (tạo, cập nhật, xem hồ sơ).\n\n### **Test Case Steps:**\n- **Test Case 1: Tạo Người dùng**\n  - **Preconditions:** Đăng nhập với quyền quản trị.\n  - **Test Steps:**\n    - Gọi API `/users` với request body chứa thông tin người dùng (username, email, full_name).\n    - Verify: `200 OK`, dữ liệu được tạo thành công trong cơ sở dữ liệu.\n  - **Expected Result:**\n    - Người dùng mới được tạo và có thể tìm thấy trong hệ thống.\n\n- **Test Case 2: Cập nhật Hồ sơ**\n  - **Preconditions:** Người dùng tồn tại.\n  - **Test Steps:**\n    - Gọi API `/users/{id}` với phương thức `PUT`.\n    - Verify: `200 OK` nếu cập nhật thành công.\n  - **Expected Result:**\n    - Thông tin được cập nhật trong cơ sở dữ liệu.\n\n- **Test Case 3: Truy xuất Hồ sơ**\n  - **Preconditions:** Người dùng tồn tại.\n  - **Test Steps:**\n    - Gọi API `/users/{id}` với phương thức `GET`.\n    - Verify: `200 OK` nếu tìm thấy, nội dung chính xác.\n  - **Expected Result:**\n    - Dữ liệu về người dùng được trả về trong phản hồi API."
    },
    {
      "question_id": "EQ3024-VN",
      "question": "Giải thích một bài kiểm tra để xác thực refresh token không thể được sử dụng sau khi đăng xuất.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập và nhận token**: Đăng nhập và nhận token access và refresh token.\n2. **Đăng xuất**: Gọi API đăng xuất và lưu lại refresh token.\n3. **Thử refresh**: Sử dụng refresh token vừa nhận để gửi yêu cầu refresh token.\n4. **Kiểm tra trạng thái**: Đảm bảo API trả về `403 Forbidden` hoặc `401 Unauthorized` vì đã đăng xuất."
    },
    {
      "question_id": "EQ3026-VN",
      "question": "Viết một test case xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "### **Test Case: Mã Lỗi Hợp Lệ**\n- **Test Case ID:** TC-008\n- **Test Case Name:** Xác thực ánh xạ mã lỗi `AUTH_EXPIRED` → trạng thái HTTP.\n- **Preconditions:** API được cấu hình với module xác thực token.\n- **Test Steps:**\n  - **Scenario 1 (Positive):** Gửi yêu cầu với token hợp lệ → `200 OK`.\n  - **Scenario 2 (Negative):** Sử dụng token đã hết hạn → **Expected:** `HTTP 401 Unauthorized`.\n- **Post-conditions:** DB không bị ảnh hưởng.\n- **Test Case Owner:** [Tên người thực hiện].\n- **Test Case Status:** [Đã thực thi hoặc cần thực thi]."
    },
    {
      "question_id": "EQ3028-VN",
      "question": "Giải thích một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Một bài kiểm tra thất bại xác minh email: Gửi yêu cầu xác thực với token hết hạn hoặc không tồn tại. Thì trả lời 401 Unauthorized hoặc 400 Bad Request."
    },
    {
      "question_id": "EQ3030-VN",
      "question": "Viết một test case cấp độ khó chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "### **Test Case: Loan Approval Flow**\n- **Test Case ID:** TC-LOAN-001\n- **Test Case Name:** Chuỗi yêu cầu vay tiền với tín dụng chấp nhận và từ chối.\n- **Preconditions:**\n  - Có tài khoản khách hàng với ID `KH-123`.\n  - Hệ thống có sẵn dữ liệu về các khách hàng (tín dụng tốt, xấu, chưa có).\n- **Test Steps:**\n  1. **Đăng ký vay:** Gửi `POST /loans` với số tiền và kỳ hạn hợp lý, thuộc về `KH-123`. Expected: `201 Created` với ID đơn vay.\n  2. **Tín dụng kiểm tra:** Gửi `POST /credit-check` với ID khách hàng từ bước 1. Expected: `200 OK` với kết quả tín dụng.\n  3. **Phê duyệt vay:** Với tín dụng tốt, gửi `PUT /loans/{id}` với trạng thái `approved`. Expected: `200 OK`. Với tín dụng xấu, trạng thái `rejected`. Expected: `200 OK`.\n- **Post-condition:** Dữ liệu cơ sở dữ liệu cập nhật phản ánh trạng thái vay của khách hàng."
    },
    {
      "question_id": "EQ3032-VN",
      "question": "Thiết kế một test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "**Test Case: Quản lý Mật khẩu**\n- **Bước 1: Đăng ký**\n  - **Test Scenario 1:** Đăng ký thành công với email và password hợp lệ.\n  - **Test Scenario 2:** Đăng ký với email đã tồn tại.\n  - **Test Scenario 3:** Đăng ký thiếu thông tin bắt buộc.\n- **Bước 2: Đặt lại mật khẩu**\n  - **Test Scenario 4:** Đặt lại mật khẩu thành công với email và câu hỏi bảo vệ hợp lệ.\n  - **Test Scenario 5:** Đặt lại mật khẩu với email không tồn tại.\n- **Bước 3: Đăng nhập**\n  - **Test Scenario 6:** Đăng nhập thành công với email và password đúng.\n  - **Test Scenario 7:** Đăng nhập sai password.\n  - **Test Scenario 8:** Đăng nhập với tài khoản bị khóa."
    },
    {
      "question_id": "EQ3034-VN",
      "question": "Viết một test case chuỗi các endpoint tải lên file, quét virus và tải xuống.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "**Test Case: Upload & Virus Scan**\n- **Test Case ID:** TC-FILE-001\n- **Test Case Name:** Chuỗi upload file, quét virus và tải xuống.\n- **Preconditions:** File mẫu sẵn, dịch vụ virus scan online accessible.\n- **Test Steps:**\n  1. **Upload File:** Request POST đến `/files` với file mẫu.\n  2. **Quét Virus:** Sử dụng dịch vụ virus scan online (API) để quét ID file vừa tải lên.\n  3. **Tải Xuống:** Request GET đến `/files/<ID_FILE>` để tải xuống file gốc.\n- **Expected Results:**\n  - File tải lên thành công.\n  - Quét virus trả về kết quả `Positive` (file an toàn) hoặc `Negative` (file bị nhiễm).\n  - File tải xuống trùng với bản gốc."
    },
    {
      "question_id": "EQ3036-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn việc sử dụng lại refresh token.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Một bài kiểm tra chuỗi cần thực hiện các bước: 1) Mua token refresh. 2) Sử dụng token refresh để nhận token mới. 3) Cố gắng sử dụng token refresh đã cũ trong yêu cầu tiếp theo. Nếu API từ chối với mã lỗi 403 hoặc 401, và token mới vẫn hoạt động, thì bài kiểm tra đã thành công."
    },
    {
      "question_id": "EQ3038-VN",
      "question": "Viết một test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Mua Hàng Online**\n- **Preconditions:** Sản phẩm sẵn, User có tài khoản và đủ tiền.\n- **Test Steps:**\n  - **Search:** API tìm kiếm sản phẩm với từ khóa \"Laptop\".\n  - **Add to Cart:** Sử dụng ID sản phẩm tìm được để thêm vào giỏ.\n  - **Checkout:** Tạo đơn hàng từ giỏ, nhập địa chỉ và thanh toán.\n- **Expected Result:** Đơn hàng được tạo thành công, trạng thái payment là'success'."
    },
    {
      "question_id": "EQ3040-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn tấn công chiếm đoạt session API.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Một bài kiểm tra chuỗi xác thực việc ngăn chặn tấn công chiếm đoạt session API bằng cách tạo ra các yêu cầu gửi token session khác nhau. \n- **Test Case 1:** Gửi yêu cầu xác thực với token session hợp lệ và kiểm tra phản hồi 200 OK. \n- **Test Case 2:** Gửi yêu cầu xác thực với token session đã bị hỏng (expired hoặc không tồn tại). Kiểm tra phản hồi 401 Unauthorized hoặc 403 Forbidden. \n- **Test Case 3 (Chuẩn hóa):** Sử dụng công cụ như Insomnia hoặc Postman tạo ra 100-200 yêu cầu gửi token session khác nhau. \n- **Test Case 4 (Tấn công):** Sử dụng công cụ như Burp hoặc Postman để gửi yêu cầu chiếm đoạt token session từ request khác. \n- **Expected Result:** Tất cả các yêu cầu gửi token session hợp lệ phải được chấp nhận. Tất cả các yêu cầu gửi token session đã bị hỏng phải bị từ chối. Không có yêu cầu chiếm đoạt session nào phải được chấp nhận."
    },
    {
      "question_id": "EQ3042-VN",
      "question": "Cung cấp chính xác một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "**Test Case: Đồng Thời Lạc Quan với ETag**\n- **Test Scenario:** Sửa đổi một tài liệu → Lấy ETag → Cập nhật khác → Thử lại với ETag cũ → Đợi optimistic concurrency phát sinh.\n- **Expected:** Cập nhật thất bại với `409 Conflict` nếu ETag cũ không khớp."
    },
    {
      "question_id": "EQ3044-VN",
      "question": "Thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ: POST /exports -> thăm dò GET /jobs/{id} cho đến khi hoàn thành -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Bài kiểm tra phải mô phỏng quá trình xuất file lâu, theo dõi trạng thái job, và chỉ yêu cầu tải file khi job hoàn thành."
    },
    {
      "question_id": "EQ3046-VN",
      "question": "Cung cấp một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code: /authorize -> /token -> gọi tài nguyên với scope bị thiếu.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "**Test Case: OAuth2 Authorization Code - Tiêu cực**\n- **Test Case Name:** Đăng ký quyền không tồn tại.\n- **Test Case ID:** TC-OAUTH-008.\n- **Test Case Version:** 1.0.\n- **Test Case Status:** Chưa thực hiện.\n\n- **Test Case Description:**\n  1. Người dùng xác thực qua /authorize với scope=\"read:messages\".\n 2. Sau khi nhận authorization code, thực hiện trao đổi mã lấy access token qua /token endpoint.\n- **Test Case Steps:**\n  - **Bước 1:** Gửi yêu cầu POST đến /token với grant_type=\"authorization_code\" và kèm theo authorization code.\n  - **Bước 2:** Trong cơ sở dữ liệu mock, giả lập trường yêu cầu quyền bị thiếu (ví dụ: không có quyền \"write:messages\").\n- **Test Case Expected Result:**\n  - **Kết quả Thử nghiệm:** HTTP Status Code 400 Bad Request hoặc 403 Forbidden được trả về.\n  - **Kết quả Hậu kiểm:** Lỗi xảy ra khi kiểm tra nội dung response."
    },
    {
      "question_id": "EQ3048-VN",
      "question": "Viết một bài kiểm tra chuỗi bao gồm việc tạo charge幂等 (idempotent charge creation) với Idempotency-Key trên các endpoint thử lại và hoàn tiền.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. **Charge Creation (idempotent):**\n    * **Action:** `POST /charges` với dữ liệu charge.\n    * **Expected:** Charge được tạo một lần duy nhất với cùng Idempotency-Key. Thử lặp nhiều lần vẫn chỉ tạo 1 charge.\n    * **Negative:** Dữ liệu không hợp lệ (e.g., thiếu card token) → `400 Bad Request`.\n\n2. **Charge Update (idempotent):**\n    * **Action:** `PUT /charges/{chargeId}` với trạng thái mới (e.g., từ `pending` → `captured`).\n    * **Expected:** Trạng thái của charge được cập nhật một lần duy nhất. Thử update trạng thái đã tồn tại → `200 OK` nhưng không thay đổi trạng thái.\n\n3. **Charge Cancel (idempotent):**\n    * **Action:** `DELETE /charges/{chargeId}` hoặc `POST /charges/{chargeId}/cancel`.\n    * **Expected:** Charge bị hủy một lần duy nhất. Thử hủy charge đã hủy → `200 OK` nhưng không thay đổi trạng thái.\n\n4. **Refund (idempotent):**\n    * **Action:** `POST /charges/{chargeId}/refunds` với số tiền hoàn tiền.\n    * **Expected:** Refund được tạo một lần duy nhất với cùng Idempotency-Key. Thử lặp nhiều lần vẫn chỉ tạo 1 refund."
    },
    {
      "question_id": "EQ3050-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi cho quy trình xử lý file: tải lên -> POST /process -> thăm dò trạng thái -> tải xuống, bao gồm cả việc xử lý 202.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "### **Bài kiểm tra chuỗi xử lý file**\n- **Đầu tiên: Tải file lên**\n  - **Bước 1:** Sử dụng tool như `curl` hoặc `requests` thực hiện yêu cầu `POST` lên endpoint như `/upload`.\n  - **Đầu vào:** Chia sẻ một tệp tin cụ thể (ví dụ, một ảnh nhỏ) trong dự án.\n  - **Lời giải:** Yêu cầu phải được chấp nhận với trạng thái `201 Created` hoặc `200 OK` kèm theo ID file.\n\n- **Tiếp theo: Xử lý file**\n  - **Bước 2:** Sử dụng ID file từ bước trước, gửi yêu cầu `POST` tới endpoint xử lý như `/process/{file_id}`.\n  - **Đầu vào:** ID file từ bước trước.\n  - **Lời giải:** Endpoint này sẽ thực hiện các tác vụ như chuyển đổi định dạng, thêm watermark, hoặc bất kỳ logic nào liên quan đến file. Yêu cầu này phải được chấp nhận với trạng thái `202 Accepted` (nếu cần thời gian xử lý sau) hoặc `200 OK`.\n\n- **Cuối cùng: Tải trạng thái xuống**\n  - **Bước 3:** Sử dụng ID file, gửi yêu cầu `GET` tới endpoint như `/status/{file_id}` hoặc `/process/{file_id}/status`.\n  - **Lời giải:** Yêu cầu này sẽ trả về trạng thái hiện tại của file sau khi xử lý, bao gồm cả thông tin về việc đã hoàn thành hay chưa. Yêu cầu này phải được chấp nhận với trạng thái phù hợp (ví dụ, `200 OK` nếu đã hoàn thành, `202 Accepted` nếu đang xử lý).\n\n- **Cục diện cuối:** Tải file xử lý ra**\n  - **Bước 4:** Sử dụng ID file từ bước trước, gửi yêu cầu `GET` tới endpoint như `/processed/{file_id}`.\n  - **Lời giải:** Yêu cầu này sẽ tải về tệp tin đã được xử lý. Yêu cầu này phải được chấp nhận với trạng thái `200 OK` và nội dung tải về phải là bản xử lý thành công của file gốc."
    },
    {
      "question_id": "EQ3052-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "### **Bài Kiểm Tra: Hủy Bỏ Session SSO**\n- **Test Case:** Đăng nhập SSO → Truy cập API → Hủy Bỏ Session → Thử Lại API.\n- **Expected:** API phải trả `403 Forbidden` hoặc yêu cầu xác thực lại cho yêu cầu tiếp theo."
    },
    {
      "question_id": "EQ3054-VN",
      "question": "Viết một test case chuỗi cho việc thực hiện đơn hàng một phần: tạo đơn hàng -> dự trữ hàng tồn kho -> ship một phần -> hủy phần còn lại và hoàn tiền chênh lệch.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "**Test Case: Tạo Đơn Hàng Một Phần**\n- **Test Case ID:** TC_SHIP_PARTIAL\n- **Test Case Name:** Tạo đơn hàng, ship một phần và hủy phần còn lại.\n- **Preconditions:**\n  - Có sẵn hàng tồn kho cho sản phẩm A và B.\n  - Tạo một đơn hàng có 3 sản phẩm (2A, 1B).\n- **Test Steps:**\n  1. Tạo đơn hàng.\n  2. Ghi nhận ID đơn hàng và trạng thái.\n  3. Ship 2 sản phẩm A.\n  4. Kiểm tra trạng thái đơn hàng và hàng tồn kho.\n  5. Hủy phần còn lại của đơn hàng (sản phẩm B).\n  6. Kiểm tra trạng thái đơn hàng và hàng tồn kho sau khi hủy.\n  7. Xác minh tiền chênh lệch được hoàn lại cho khách hàng.\n- **Post-conditions:** Xóa đơn hàng khỏi cơ sở dữ liệu."
    },
    {
      "question_id": "EQ3056-VN",
      "question": "Cung cấp chính xác một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA: POST /login -> POST /2fa/verify với mã sai -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Test Case:** `Verify 2FA Failure`.\n2. **Action:** Send `POST /login` with valid credentials, then `POST /2fa/verify` with an invalid 2FA code.\n3. **Expected:** `400 Bad Request` or `401 Unauthorized`."
    },
    {
      "question_id": "EQ3058-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê (với các xác nhận tổng số đếm).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Test Case: 1) Tạo trang 10 bản ghi. 2) Liệt kê → kiểm tra tổng số = 10. 3) Xóa 3 bản ghi. 4) Liệt kê → kiểm tra tổng số = 7. 5) Kiểm tra từng bản ghi đã xóa không còn trong danh sách."
    },
    {
      "question_id": "EQ3060-VN",
      "question": "Viết một bài kiểm tra chuỗi cho tính dính session (session stickiness): đăng nhập -> các cuộc gọi tiếp theo qua load balancer -> đăng xuất -> xác minh không có node nào chấp nhận token cũ.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "**Test Case: Session Stickiness**\n- **Test Case:** Đăng nhập → Gọi API → Load Balancer → Node 1 → Node 2 → Node 3 → Đăng xuất.\n- **Expected:** Token chỉ được chấp nhận trên Node 1. Node 2/3 phải trả 403 Forbidden."
    },
    {
      "question_id": "EQ4002-VN",
      "question": "Viết một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản: tạo → kích hoạt → tạm ngừng → kích hoạt lại → xóa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "Test Case: Quản lý trạng thái tài khoản.\n- **Test Case 1 (Tạo & Kích hoạt):** Gửi yêu cầu tạo tài khoản → xác nhận trạng thái là `active`.\n- **Test Case 2 (Tạm ngừng & Kích hoạt lại):** Đổi trạng thái → gửi yêu cầu kích hoạt lại → trạng thái trở lại `active`.\n- **Test Case 3 (Xóa):** Xoá tài khoản → trạng thái DB → `deleted`.\n- **Test Case 4 (Trạng thái bất hợp lệ):** Gửi yêu cầu với trạng thái không tồn tại → API trả lỗi `400`."
    },
    {
      "question_id": "EQ4004-VN",
      "question": "Thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Test Case 1: Success** (giao dịch thành công): Tích hợp các API chuyển tiền (Step 1), xác minh tiền chuyển đến.\n2. **Test Case 2: Fail tại bước 2** (giao dịch thất bại khi chuyển tiền): API bước 2 (chuyển tiền) giả lập lỗi cơ bản, xác minh giao dịch được **rollback** hoàn toàn.\n3. **Test Case 3: Fail tại bước 3** (giao dịch thất bại khi xác nhận giao dịch): API bước 3 (xác nhận giao dịch) giả lập lỗi cơ bản, xác minh giao dịch được **rollback** hoàn toàn.\n4. **Test Case 4: Fail ở bước 2 nhưng bước 3 được gọi trước khi rollback** (giao dịch thất bại khi chuyển tiền nhưng bước 3 đã được gọi): API bước 2 (chuyển tiền) giả lập lỗi cơ bản, bước 3 được gọi trước khi rollback, xác minh giao dịch được **rollback** hoàn toàn.\n5. **Test Case 5: Fail ở bước 3 nhưng bước 2 được gọi trước khi rollback** (giao dịch thất bại khi xác nhận giao dịch nhưng bước 2 đã được gọi): API bước 3 (xác nhận giao dịch) giả lập lỗi cơ bản, bước 2 được gọi trước khi rollback, xác minh giao dịch được **rollback** hoàn toàn."
    },
    {
      "question_id": "EQ4006-VN",
      "question": "Viết một **test** xác thực chuỗi nhiều dịch vụ: đăng nhập → tạo đơn hàng → xử lý thanh toán → hủy đơn hàng sau khi ghi nhận.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "**Test Case:** * **Test Scenario:** Đăng nhập thành công, tạo đơn hàng, xử lý thanh toán, hủy đơn hàng. * **Test Steps:**\n    1. Đăng nhập với tài khoản admin.\n    2. Tạo đơn hàng với sản phẩm bất kỳ.\n    3. Xử lý thanh toán thành công.\n    4. Hủy đơn hàng.\n    5. Validate trạng thái đơn hàng cuối cùng là 'Hủy' và không có lỗi xảy ra. * **Expected Result:** Trạng thái cuối cùng là 'Hủy', không lỗi."
    },
    {
      "question_id": "EQ4008-VN",
      "question": "Mô tả một **test state-machine** xác thực vòng đời mật khẩu: đặt → hết hạn → đặt lại → ngăn tái sử dụng.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "**Test Case:** \"Mật khẩu vòng đời\".\n\n- **Test Step 1:** Đăng nhập với mật khẩu mới → **Expected:** `200 OK`.\n- **Test Step 2:** Lỗi khi sử dụng mật khẩu cũ sau khi hết hạn → **Expected:** `403 Forbidden`.\n- **Test Step 3:** Đăng nhập → Đổi mật khẩu → Sử dụng lại → **Expected:** `400 Bad Request`."
    },
    {
      "question_id": "EQ4010-VN",
      "question": "Viết một **test chained** phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "Test Case: `POST /apply-loan`\n- **Step 1:** Gửi yêu cầu đăng ký với thông tin hợp lệ.\n- **Step 2:** Tương tự, nhưng trong **branch** thất bại, thêm một trường thông tin cá nhân (e.g., `borrower.occupation = ''`) **không hợp lệ**.\n- **Expected:** Trong trường hợp **thanh công** (tín dụng được chấp nhận), API trả mã xác nhận `201 Created` và email xác nhận. Đối với **thất bại** (do thông tin không hợp lệ), API phản hồi `400 Bad Request` với lỗi cụ thể."
    },
    {
      "question_id": "EQ4012-VN",
      "question": "Viết một **test** xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra: cập nhật hồ sơ người dùng với các giá trị xung đột.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "Test Scenario: Gửi hai yêu cầu update hồ sơ với trường tên khác nhau vào cùng một lúc. Expected: Chỉ yêu cầu đầu tiên được chấp nhận, còn lại bị từ chối với mã lỗi duy nhất (e.g., `409 Conflict`)."
    },
    {
      "question_id": "EQ4014-VN",
      "question": "Viết một **test chained** rất khó xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Chuỗi các test case như tải lên file bất hợp pháp → ký → xác minh → file hợp lệ → giả mạo → file bị từ chối."
    },
    {
      "question_id": "EQ4017-VN",
      "question": "Viết một **test state-machine** xác thực vòng đời đăng ký: tạo → nâng cấp → hạ cấp → hủy.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Test Case:** Tạo User (expected: `200 OK` và tồn tại trong DB). 2. **Test Case:** Nâng cấp User → thêm quyền admin (expected: chỉ `200 OK` nếu user tồn tại và quyền được cập nhật). 3. **Test Case:** Hạ cấp User → xóa quyền admin (expected: `200 OK` nếu user tồn tại, quyền bị xóa). 4. **Test Case:** Hủy đăng ký User → xóa tài khoản (expected: `200 OK`, DB không chứa record)."
    },
    {
      "question_id": "EQ4019-VN",
      "question": "Viết một **test chained** rất khó xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Chaining các hoạt động trong saga phân tán đòi hỏi các trường hợp kiểm tra toàn diện và khả năng hồi phục phức tạp."
    },
    {
      "question_id": "EQ4021-VN",
      "question": "Viết một **test** rất khó xác minh việc đảo ngược giao dịch tài chính: ghi nợ → ghi có → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "Test khó vì phụ thuộc vào chu trình nghiệp vụ phức tạp, các trạng thái tài khoản phải được kiểm soát chặt chẽ."
    },
    {
      "question_id": "EQ4023-VN",
      "question": "Thiết kế một **test state-machine** cho kho hàng: thêm hàng → phân bổ → vận chuyển → trả lại → đối chiếu.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Thêm hàng mới → trạng thái 'Đã Nhập'. 2) Phân bổ cho đơn hàng → trạng thái 'Đã Phân'. 3) Vận chuyển → trạng thái 'Đã Giao'. 4) Trả lại hàng → trạng thái 'Đã Trả'. 5) Đối chiếu số lượng → trạng thái 'Đã Kiểm Tra'."
    },
    {
      "question_id": "EQ4025-VN",
      "question": "Viết một **test chained** xác thực vòng đời **session mobile**: đăng nhập → làm mới **token** → đăng xuất → làm mới với **token** cũ → thất bại.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "Test Chain: 1) Đăng nhập → lưu **token**. 2) Lần sau làm mới **token** → vẫn hoạt động. 3) Đăng xuất → token hết hạn. 4) Sử dụng **token** cũ → bị từ chối."
    },
    {
      "question_id": "EQ4027-VN",
      "question": "Viết một **test chained** xác thực API gửi email: gửi → theo dõi mở → hủy đăng ký → đảm bảo không gửi thêm email nào nữa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "1. **Test Case 1: Gửi Email**\n   - **Action:** API gửi email cho user mới (e.g., `POST /users`).\n   - **Expected:** Email được gửi thành công, DB có thông tin email.\n\n2. **Test Case 2: Theo dõi Mở Email**\n   - **Action:** API yêu cầu hệ thống theo dõi mở email (e.g., `GET /emails/{id}/status`).\n   - **Expected:** API trả về trạng thái email (e.g., `open`).\n\n3. **Test Case 3: Hủy Đăng Ký**\n   - **Action:** API thực hiện hủy đăng ký user liên quan đến email (e.g., `DELETE /users/{id}`).\n   - **Expected:** Email không thể mở được nữa, DB cập nhật trạng thái email.\n\n4. **Test Case 4: Đảm Bảo Không Gửi Lại**\n   - **Action:** Lặp lại `Test Case 1` sau khi email đã được theo dõi mở và hủy.\n   - **Expected:** API không gửi email mới, hệ thống đảm bảo không lặp lại hành động gửi email cho user đã xóa."
    },
    {
      "question_id": "EQ4029-VN",
      "question": "Viết một **test chained** rất khó cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại: áp dụng phiếu giảm giá → thanh toán → phiếu giảm giá không hợp lệ → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chain phức tạp vì cần các bước logic và rollback đảm bảo hệ thống ổn định sau thất bại."
    }
  ]
}