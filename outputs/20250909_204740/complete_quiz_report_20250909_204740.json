{
  "timestamp": "20250909_204740",
  "summary": {
    "total_questions": 500,
    "mcq_questions": 258,
    "writing_questions": 242,
    "mcq_accuracy": 0.7054263565891473,
    "mcq_correct": 182,
    "mcq_incorrect": 76
  },
  "results": [
    {
      "question_id": "EQ5001",
      "question": "Which HTTP method is commonly used to retrieve data from an API?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. GET. The HTTP GET method is used to retrieve or read data from a specific resource.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is the standard method for retrieving data."
    },
    {
      "question_id": "EQ5002",
      "question": "What does HTTP status code 404 represent?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "OK",
        "B": "Unauthorized",
        "C": "Not Found",
        "D": "Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. Not Found. This status code is used to indicate that the server could not find a specific resource (e.g., a user with ID 1234) on the server.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "404 indicates the requested resource could not be found."
    },
    {
      "question_id": "EQ5003",
      "question": "What is the purpose of the HTTP POST method?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "Retrieve data",
        "B": "Submit data to create resources",
        "C": "Update existing resources",
        "D": "Delete resources"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Submit data to create resources.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST is used to create new resources with data in the request body."
    },
    {
      "question_id": "EQ5004",
      "type": "Writing",
      "gold": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user exists with a valid password.\n- **Test Steps:** Send a `POST /login` request with a valid username and password (e.g., `{\"username\": \"testuser\", \"password\": \"TestPassword123\"}`).\n- **Expected Result:** The API returns a `200 OK` status code with a login token in the response."
    },
    {
      "question_id": "EQ5005",
      "question": "Which of these HTTP status codes means 'Unauthorized'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 is the status code for 'Unauthorized'.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates missing or invalid credentials."
    },
    {
      "question_id": "EQ5006",
      "type": "Writing",
      "gold": "User must be logged in and have a valid token.",
      "model_answer": "A valid user account and appropriate permissions (e.g., admin or regular user) are necessary. Additionally, the user's profile should already exist in the database."
    },
    {
      "question_id": "EQ5007",
      "question": "Which HTTP method is considered idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "PUT",
        "D": "CONNECT"
      },
      "gold_answer": "C",
      "model_raw_answer": "Idempotent methods do not change the state of the server after the first request. The correct options are: A. POST – creates a new resource but can be called multiple times without changing the state of that specific request. D. CONNECT – a tunneling method, not state-changing.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "PUT is idempotent because multiple identical requests have the same effect."
    },
    {
      "question_id": "EQ5008",
      "type": "Writing",
      "gold": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Send a `POST` request with an invalid user ID (e.g., 999) and assert that the response status is `404 Not Found`."
    },
    {
      "question_id": "EQ5009",
      "question": "Which HTTP status code means 'OK'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. 200. This status code indicates that the request was successful.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK is the standard success code."
    },
    {
      "question_id": "EQ5010",
      "type": "Writing",
      "gold": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure of the API request body, headers, and query parameters. It ensures consistent data formatting across tests."
    },
    {
      "question_id": "EQ5011",
      "question": "Which HTTP method is used to delete a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. GET — Used for retrieving resources. \nB. POST — Used for creating new resources.\nC. PUT — Used for updating or replacing existing resources.\nD. DELETE — Used for removing existing resources.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "DELETE removes the resource specified in the URL."
    },
    {
      "question_id": "EQ5012",
      "type": "Writing",
      "gold": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "Send a `POST` request with valid data. Expected: The response status code should be `201 Created`."
    },
    {
      "question_id": "EQ5013",
      "question": "Which HTTP header is typically used for authentication tokens?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "Accept",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Authorization. The `Authorization` header is used to include credentials in requests, such as an API key or an access token.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Authorization header carries credentials or tokens."
    },
    {
      "question_id": "EQ5014",
      "type": "Writing",
      "gold": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependent systems (like databases or other microservices) with simulated versions during testing. This allows tests to be run independently of the full infrastructure, making them faster and more reliable. It ensures the API behaves as expected without relying on external systems."
    },
    {
      "question_id": "EQ5015",
      "question": "Which HTTP status code indicates 'Created'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "403"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 201.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created confirms successful creation of a resource."
    },
    {
      "question_id": "EQ5016",
      "type": "Writing",
      "gold": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "**Test Case: Get Product List**\n- **Preconditions:** API is running, product with ID=123 exists.\n- **Test Step:** Call `GET /products` endpoint.\n- **Expected Result:** API returns `200 OK` with a valid JSON array of products."
    },
    {
      "question_id": "EQ5017",
      "question": "Which HTTP status indicates 'Internal Server Error'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "403",
        "D": "500"
      },
      "gold_answer": "D",
      "model_raw_answer": "Internal Server Error is a generic status code for severe server errors. It is defined by the IETF as a 'Server Error' category, and the specific status code 500 (Internal Server Error) is the one universally accepted for this purpose.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "500 indicates unexpected server-side failure."
    },
    {
      "question_id": "EQ5018",
      "type": "Writing",
      "gold": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "A precondition is a state that must be true before a test case can be executed. It ensures that the test runs under controlled conditions."
    },
    {
      "question_id": "EQ5019",
      "question": "Which HTTP status is appropriate for forbidden access with valid credentials?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "Answer: C. 403 Forbidden indicates that the request was valid but access is denied.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden indicates insufficient permissions despite valid login."
    },
    {
      "question_id": "EQ5020",
      "type": "Writing",
      "gold": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Negative Test: Upload a file in a format unsupported by the server (e.g., an executable or a proprietary format). Expected Result: The upload fails with an appropriate error message (e.g., 'File type not allowed')."
    },
    {
      "question_id": "EQ5021",
      "question": "Which HTTP method is typically used for partial updates?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PATCH",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. PATCH.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PATCH is used to modify part of a resource."
    },
    {
      "question_id": "EQ5022",
      "type": "Writing",
      "gold": "To explain the objective and scope of a test scenario.",
      "model_answer": "The purpose of a test case description is to provide a clear and concise explanation of what the test case aims to verify. It serves as a summary of the test's objectives, preconditions, and expected results."
    },
    {
      "question_id": "EQ5023",
      "question": "Which HTTP header indicates the format of request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Accept-Encoding"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. Content-Type. The Content-Type header is used to indicate the format of the request body, such as JSON, XML, or a custom format.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Type defines the media type of request body."
    },
    {
      "question_id": "EQ5024",
      "type": "Writing",
      "gold": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "1. Send request and record timestamp.\n2. Compare with threshold (e.g., 500ms).\n3. Verify response status code."
    },
    {
      "question_id": "EQ5025",
      "question": "Which HTTP status code indicates a conflict, such as duplicate resource creation?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 409 Conflict. This status code is used to indicate that the request could not be completed because of a conflict, such as a resource already being used.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict is used when request conflicts with current state."
    },
    {
      "question_id": "EQ5026",
      "question": "Which HTTP status code means 'Bad Request'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 Bad Request indicates invalid syntax or parameters."
    },
    {
      "question_id": "EQ5027",
      "type": "Writing",
      "gold": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "1. **Test:** Send a `GET` request to `/health`. \n2.  **Expected:** The API returns a successful `200 OK` status code with a simple response like 'healthy'."
    },
    {
      "question_id": "EQ5028",
      "question": "Which HTTP method is used to fully update a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. PUT. A PUT request is used to fully replace the existing resource with the data provided in the request body.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT replaces an existing resource with new data."
    },
    {
      "question_id": "EQ5029",
      "type": "Writing",
      "gold": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management provides consistent and reliable data for API testing, eliminating the need to hardcode sensitive information. It improves test repeatability, reduces manual data creation efforts, and enhances overall test efficiency."
    },
    {
      "question_id": "EQ5030",
      "question": "Which HTTP status indicates 'Forbidden'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "401",
        "D": "403"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 403. This status code indicates that the client does not have access to the specified resource; however, authentication with a 401 status is required.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "403 Forbidden means user is authenticated but not authorized."
    },
    {
      "question_id": "EQ5031",
      "type": "Writing",
      "gold": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "Send a `GET` request to a non-existent resource and assert that the response body does not contain the expected `{\"id\": 1}` JSON key."
    },
    {
      "question_id": "EQ5032",
      "question": "Which HTTP status code represents 'Too Many Requests'?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Easy",
      "options": {
        "A": "408",
        "B": "429",
        "C": "503",
        "D": "504"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 429 is the status code for 'Too Many Requests', indicating the client exceeded rate limits.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "429 Too Many Requests is returned when rate limits are exceeded."
    },
    {
      "question_id": "EQ5033",
      "type": "Writing",
      "gold": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions verify conditions in API responses. They validate status codes, error messages, and data consistency, helping detect bugs early in testing."
    },
    {
      "question_id": "EQ5034",
      "question": "Which HTTP status indicates a timeout from the server?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "400",
        "C": "200",
        "D": "504"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 504, which indicates a timeout from the server.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "504 Gateway Timeout indicates the server did not respond in time."
    },
    {
      "question_id": "EQ5035",
      "type": "Writing",
      "gold": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "Create a user, send a DELETE request, and verify the user is now gone from the database."
    },
    {
      "question_id": "EQ5036",
      "question": "Which HTTP method is safe (does not change server state)?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. GET – It is used for retrieving data and does not change the server state.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is safe because it only retrieves data."
    },
    {
      "question_id": "EQ5037",
      "type": "Writing",
      "gold": "A new resource has been successfully created.",
      "model_answer": "That the resource was successfully created."
    },
    {
      "question_id": "EQ5038",
      "question": "Which HTTP status is returned when a client request is well-formed but unauthorized?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "401",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. 401. This status code indicates that the authentication credentials (username/password) provided in the request are invalid or missing.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized is used for invalid credentials."
    },
    {
      "question_id": "EQ5039",
      "type": "Writing",
      "gold": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test involves sending a GET request to `/users/123` and asserting the HTTP status code is `200 OK`."
    },
    {
      "question_id": "EQ5040",
      "question": "Which HTTP status indicates success but no content is returned?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204 (No Content) is the correct answer. It indicates the request was successful, but the server chose not to provide a response body.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content is returned on successful deletion or empty responses."
    },
    {
      "question_id": "EQ5041",
      "type": "Writing",
      "gold": "It confirms that the request has succeeded.",
      "model_answer": "It indicates the request was successful and the resource exists."
    },
    {
      "question_id": "EQ5042",
      "question": "Which header is used to specify accepted response formats?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Accept",
        "C": "Authorization",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct header is 'Accept'. It is used to specify the client's preferred response formats. In a 'Accept' header, the client sends an `Accept: application/json, application/xml` request, indicating it can handle both formats.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Accept header tells the server which formats are expected (e.g., application/json)."
    },
    {
      "question_id": "EQ5043",
      "type": "Writing",
      "gold": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "Send a request to an endpoint with a missing or invalid parameter (e.g., `/users/123` without a `page` parameter). The server response should not be `200 OK`, but instead a `404 Not Found` or a custom error with a clear message."
    },
    {
      "question_id": "EQ5044",
      "question": "Which HTTP status code is used when the client must authenticate to access a resource?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "403",
        "C": "401",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "Answer: C. 401 is the status code used for authentication required.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized requires authentication credentials."
    },
    {
      "question_id": "EQ5045",
      "type": "Writing",
      "gold": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion is a statement (e.g., 'assert that the total is 100') that defines what the correct outcome should be. It is the 'what' part of what the test case is verifying."
    },
    {
      "question_id": "EQ5046",
      "question": "Which HTTP status indicates the server cannot handle the request due to overload?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "503 Service Unavailable",
        "B": "200 OK",
        "C": "404 Not Found",
        "D": "201 Created"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. 503 Service Unavailable. This status code indicates that the server is temporarily unable to handle the request due to an overload of work.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "503 indicates temporary overload or maintenance."
    },
    {
      "question_id": "EQ5047",
      "type": "Writing",
      "gold": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "**Positive Test: File Upload**\n1. **Action:** Send a `POST` request to the file upload endpoint.\n2. **Condition:** The API should accept a valid file (e.g., `image.jpg`) and return a successful `201 Created` response with a specific upload ID."
    },
    {
      "question_id": "EQ5048",
      "question": "Which HTTP method is safe and idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "GET",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "Both safe (no side effects, returns original state) and idempotent (calling multiple times has same effect as one) are key characteristics. \n\n- **GET** is both: It's used to retrieve data and calling it multiple times with the same parameters in a row won't change the state (e.g., a user's account). It's also safe because it doesn't modify the server state directly.\n- **POST** is not safe because it creates a new resource and can modify the server state in various ways.\n- **PATCH** is idempotent but not safe. It modifies an existing resource, but calling it multiple times with the same patch will have the same effect as once.\n- **DELETE** is neither safe nor idempotent because it modifies the server state and can have irreversible effects.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "GET is both safe and idempotent."
    },
    {
      "question_id": "EQ5049",
      "type": "Writing",
      "gold": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "415 is an unsupported media type. Its role is to indicate that the client understands the format but the server cannot validate it. It's commonly used in POST requests for payloads not defined by the resource's URI."
    },
    {
      "question_id": "EQ5050",
      "question": "Which HTTP status code means 'Request Timeout'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "408",
        "C": "500",
        "D": "429"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 408. This status code is used for 'Request Timeout' because the client timed out waiting for a response.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout indicates the client took too long to send the request."
    },
    {
      "question_id": "EQ5051",
      "question": "Which HTTP method is typically used to create a new resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "POST is the HTTP method used to create a new resource.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "POST is the standard method for creating resources."
    },
    {
      "question_id": "EQ5052",
      "type": "Writing",
      "gold": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "Send a `GET` request to `/products/123` with a valid ID. Expected result: `200 OK` with a JSON object containing product name, price, and description."
    },
    {
      "question_id": "EQ5053",
      "question": "Which HTTP status code is returned when a resource is successfully deleted?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. 200",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "204 No Content confirms deletion succeeded."
    },
    {
      "question_id": "EQ5054",
      "type": "Writing",
      "gold": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The Authorization header is used to include a valid token or credential in requests, allowing clients to access protected resources. In testing, it simulates a valid session or permission level."
    },
    {
      "question_id": "EQ5055",
      "question": "Which HTTP status code is used when a client sends an invalid JSON payload?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct HTTP status code for an invalid JSON payload is 400 Bad Request.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 indicates the request could not be understood due to invalid syntax."
    },
    {
      "question_id": "EQ5056",
      "type": "Writing",
      "gold": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "Send a request without a valid authentication token. Expected result: `401 Unauthorized` status code."
    },
    {
      "question_id": "EQ5057",
      "question": "Which HTTP method is generally used to update a resource entirely?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. PUT.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT replaces the full resource with new data."
    },
    {
      "question_id": "EQ5058",
      "type": "Writing",
      "gold": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "It indicates an unexpected condition that occurred on the server."
    },
    {
      "question_id": "EQ5059",
      "question": "Which HTTP status means 'Conflict'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "409"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 409. This status code indicates that the request could not be completed because of a conflict with the current state of the resource.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict occurs when resource creation/update conflicts with state."
    },
    {
      "question_id": "EQ5060",
      "type": "Writing",
      "gold": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "**Test Case: Get Orders**\n- **Preconditions:** User authenticated, 3 orders existing.\n- **Test Steps:** Call `/orders` endpoint → expect `200 OK`, array of valid orders with IDs, `200` indicates successful retrieval of multiple resources.\n- **Expected Result:** No errors, correct data format."
    },
    {
      "question_id": "EQ5061",
      "question": "Which HTTP method is used for partial updates to resources?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. PATCH. PATCH is used for making partial updates to a resource.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH modifies only part of a resource."
    },
    {
      "question_id": "EQ5062",
      "type": "Writing",
      "gold": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "They provide metadata about responses, such as `Location` for redirects or `ETag` for caching validation."
    },
    {
      "question_id": "EQ5063",
      "question": "Which HTTP status code is returned when authentication is required but missing?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 Unauthorized – indicates that the client must authenticate itself.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates missing or invalid credentials."
    },
    {
      "question_id": "EQ5064",
      "type": "Writing",
      "gold": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Create Resource A with ID=1. Send `POST /resources` again with the same data as Resource A. Expected Result: `201 Created` is not returned, and Resource B should not exist."
    },
    {
      "question_id": "EQ5065",
      "question": "Which HTTP method is most often used for safe read-only operations?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "The most common HTTP method for safe read-only operations is GET. It is used to retrieve data from a specific resource without changing its state. Other methods like PUT, POST, and DELETE are generally used for creating, updating, or deleting data, which can have side effects.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is safe and read-only."
    },
    {
      "question_id": "EQ5066",
      "type": "Writing",
      "gold": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "202 Accepted is a status code indicating the request was successful but resulted in one or more unintended changes. It's often used for `PUT` or `PATCH` operations that modify the resource."
    },
    {
      "question_id": "EQ5067",
      "question": "Which HTTP status is returned when a resource has been permanently moved?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "302",
        "C": "301",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "Correct answer: C. 301 (Moved Permanently).",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "301 Moved Permanently indicates redirection."
    },
    {
      "question_id": "EQ5068",
      "type": "Writing",
      "gold": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "A simple positive test is to call an endpoint with a known valid parameter (e.g., `id=123`) and assert that the response body contains the expected `status` field with value `200` (or `201`, etc.)."
    },
    {
      "question_id": "EQ5069",
      "question": "Which HTTP status indicates the request is valid but resource not found?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "404"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 404",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "404 Not Found means the resource does not exist."
    },
    {
      "question_id": "EQ5070",
      "type": "Writing",
      "gold": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body is the main data section returned by an API in an HTTP response. In API testing, it's used to verify that the API returns the expected data format, content, and structure (e.g., JSON, XML, text) for specific endpoints and under various conditions."
    },
    {
      "question_id": "EQ5071",
      "question": "Which HTTP status indicates client request timeout?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "500",
        "B": "408",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 408. This status code indicates that the server timed out waiting for a client response, which is a common client timeout scenario.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout means the client did not finish sending in time."
    },
    {
      "question_id": "EQ5072",
      "type": "Writing",
      "gold": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "Test Case: Logout Functionality\n- Log in successfully.\n- Perform logout action (e.g., click logout button).\n- Expected Result: The user session should be cleared, and access to protected pages should be denied."
    },
    {
      "question_id": "EQ5073",
      "question": "Which HTTP status indicates a successful request returning JSON data?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. 200 OK. This status code indicates that the request was successful. Since the request is successful, the appropriate response body format would typically be the default, which is usually `*text/*` (like `text/plain`), but in the case of a JSON response, it's often implicit in the client's expectations for a successful request. However, according to the HTTP specification, the response body format (e.g., `application/json`) is not explicitly defined by a single status code. In practice, most successful requests (like `GET /users`) return a `200 OK` with a `Content-Type: application/json` header, which the client then parses as JSON.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK is the standard code for successful GETs."
    },
    {
      "question_id": "EQ5074",
      "type": "Writing",
      "gold": "That the server rejects unsupported request body formats.",
      "model_answer": "It validates that the Accept header sent by the client indicates support for the `415` media type."
    },
    {
      "question_id": "EQ5075",
      "question": "Which HTTP status code indicates server is temporarily down for maintenance?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable – indicates the server is temporarily unable to handle requests.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 is used when service is unavailable due to overload or maintenance."
    },
    {
      "question_id": "EQ5076",
      "question": "Which HTTP method is commonly used for updating only part of a resource?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "Correct answer: C. PATCH.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH is designed for partial updates."
    },
    {
      "question_id": "EQ5077",
      "type": "Writing",
      "gold": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "The positive test is: `GET /status` → `200 OK` with a simple `{\"status\": \"healthy\"}` response."
    },
    {
      "question_id": "EQ5078",
      "question": "Which HTTP status indicates a successful resource creation?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 201 Created indicates that a new resource has been successfully created on the server.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created confirms successful creation of resource."
    },
    {
      "question_id": "EQ5079",
      "type": "Writing",
      "gold": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content is a successful request response that indicates the server understood the client's request and there is no content to send in the response body. It's often used for `DELETE` or `PATCH` requests where only the server's state changes."
    },
    {
      "question_id": "EQ5080",
      "question": "Which HTTP status code is used when a request is valid but access is forbidden?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden. This status code is used to indicate that the client does not have access rights to perform the specified action, even if the request is valid and the client is authenticated.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden means valid credentials but insufficient permissions."
    },
    {
      "question_id": "EQ5081",
      "type": "Writing",
      "gold": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "Send a request with a `Content-Type` header like `application=csv`. The server should either return a `415 Unsupported Media Type` error or change the format to something unsupported."
    },
    {
      "question_id": "EQ5082",
      "question": "Which HTTP status code indicates success but the resource is empty?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "400 Bad Request",
        "D": "204 No Content"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 204 No Content – indicates success but the resource is empty.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 is returned when no body content is available."
    },
    {
      "question_id": "EQ5083",
      "type": "Writing",
      "gold": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header tells the server which content types the client can understand and process. It prevents the client from receiving data it cannot handle."
    },
    {
      "question_id": "EQ5084",
      "question": "Which HTTP status code is appropriate for invalid user credentials?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B, as 401 Unauthorized indicates that the authentication credentials used in the request are invalid or have expired.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized indicates invalid login credentials."
    },
    {
      "question_id": "EQ5085",
      "type": "Writing",
      "gold": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Logout API**\n- **Preconditions:** User logged in with valid session.\n- **Test Steps:** Send `POST` request to `/logout`.\n- **Expected Result:** `200 OK` and no new session created."
    },
    {
      "question_id": "EQ5086",
      "question": "Which HTTP method is used to retrieve resource details?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. GET. This is the standard HTTP method used to retrieve or read the details of a specific resource from the server.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET is used to retrieve data."
    },
    {
      "question_id": "EQ5087",
      "type": "Writing",
      "gold": "It means the client must provide valid authentication credentials.",
      "model_answer": "A 401 Unauthorized response indicates that the client authentication details (e.g., API key, username, password) for the request are missing or invalid. It is similar to a login failure."
    },
    {
      "question_id": "EQ5088",
      "question": "Which HTTP status code indicates duplicate resource creation attempt?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 409 Conflict, as it indicates a conflict resolution mechanism where the request cannot be completed due to a previous attempt.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict means duplicate or conflicting request."
    },
    {
      "question_id": "EQ5089",
      "type": "Writing",
      "gold": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test creates a user with valid details (name, email, password) and retrieves it successfully."
    },
    {
      "question_id": "EQ5090",
      "question": "Which HTTP status code indicates request was valid but the server failed to fulfill it?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "500",
        "D": "201"
      },
      "gold_answer": "C",
      "model_raw_answer": "A valid response with a `3xx` status code. In this case, the most appropriate is `201 Created` because the client requested a resource creation, and the server chose to not fulfill that request but still wanted to keep the client happy by giving them a `201 Created` status code.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "500 Internal Server Error signals server-side failure."
    },
    {
      "question_id": "EQ5091",
      "type": "Writing",
      "gold": "It indicates temporary redirection to another URL.",
      "model_answer": "The 302 Found status code indicates that the client requested a resource that can be found under a different URL. It is a `3xx` redirect response, telling the client to access the resource located at the URL provided in the `-location` header. This allows caching and is common for redirects to alternative endpoints."
    },
    {
      "question_id": "EQ5092",
      "question": "Which HTTP status is correct for a successfully updated resource using PUT?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. 200 OK – indicates the request was successful and the resource was updated.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK indicates the resource was updated successfully."
    },
    {
      "question_id": "EQ5093",
      "type": "Writing",
      "gold": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "Preconditions: User exists with correct password. Test: Send wrong password → expect `401 Unauthorized` status code, not login success."
    },
    {
      "question_id": "EQ5094",
      "question": "Which HTTP method is safe and cacheable?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "GET",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. GET. It is both safe (it does not alter the server state) and cacheable (the browser can store its response).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "GET is safe, idempotent, and cacheable."
    },
    {
      "question_id": "EQ5095",
      "type": "Writing",
      "gold": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "It means the server could not process the request."
    },
    {
      "question_id": "EQ5096",
      "question": "Which HTTP status is appropriate when service is temporarily overloaded?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "201",
        "B": "200",
        "C": "503",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "Temporary overload implies a brief condition, so 200 OK is appropriate.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "503 Service Unavailable indicates overload or maintenance."
    },
    {
      "question_id": "EQ5097",
      "type": "Writing",
      "gold": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "Send a valid user creation payload with a unique username. \nExpected: `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5098",
      "question": "Which HTTP header specifies the size of the request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Length",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Cache-Control"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct answer is A. Content-Length. This header is used to indicate the size of the payload body in bytes.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Length defines body size in bytes."
    },
    {
      "question_id": "EQ5099",
      "type": "Writing",
      "gold": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most direct and successful sequence of steps in a system or process. In testing, it is the expected flow of actions that leads to a positive outcome, such as logging in successfully."
    },
    {
      "question_id": "EQ5100",
      "question": "Which HTTP status code is used when a request method is not allowed on a resource?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "405 Method Not Allowed"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 405 Method Not Allowed. This status code is used when a request method is not allowed on a resource.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "405 is used when HTTP method is invalid for the resource."
    },
    {
      "question_id": "EQ2001",
      "question": "When designing API tests, which scenario best represents a boundary condition for a pagination parameter?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sending page=2 when total items=200",
        "B": "Sending page=10 when each page size=10 and total items=100",
        "C": "Sending page=11 when total items=100 with size=10",
        "D": "Sending page=1 when size=20 and total items=300"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. Sending page=11 when total items=100 with size=10. This is because page 11 would be beyond the actual data available, simulating an edge case.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Page=11 would exceed the available range (max 10), testing a boundary overflow."
    },
    {
      "question_id": "EQ2002",
      "type": "Writing",
      "gold": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Send a request to the endpoint without including a valid OAuth2 Bearer token. The expected result is a `401 Unauthorized` status code, indicating that the request could not be fully understood without proper authentication credentials."
    },
    {
      "question_id": "EQ2003",
      "question": "Which of the following is the most effective way to validate an API’s response time under simulated user load?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Manual sequential API calls with stopwatch measurement",
        "B": "Automated load test with concurrent virtual users",
        "C": "Single request execution and measuring response time",
        "D": "Unit testing with mocked responses"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Automated load test with concurrent virtual users. This method simulates multiple users at once, generating load that mirrors real-world usage, and provides accurate, repeatable metrics on response time under peak load.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Load testing with concurrent virtual users mimics real-world conditions."
    },
    {
      "question_id": "EQ2004",
      "type": "Writing",
      "gold": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "**Happy Path:** Send a `POST` request with a valid refund ID and amount, expecting a `200 OK` response. **Error Path:** Send a request with an invalid refund ID, expecting a `400 Bad Request` status code."
    },
    {
      "question_id": "EQ2005",
      "question": "Which practice reduces the flakiness of automated API tests running in CI/CD pipelines?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcoding API keys in scripts",
        "B": "Using random sleep delays before assertions",
        "C": "Running tests only once per release",
        "D": "Using stable test data and environment setup hooks"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Using stable test data and environment setup hooks reduces flakiness by ensuring consistent conditions.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Stable test data and environment setup reduce randomness and flakiness."
    },
    {
      "question_id": "EQ2006",
      "type": "Writing",
      "gold": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "Run contract tests, update client generation, and ensure no existing clients fail."
    },
    {
      "question_id": "EQ2007",
      "question": "Which of the following represents a correct negative test for input validation on a date-of-birth field?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sending dateOfBirth=‘2025-13-40’",
        "B": "Sending dateOfBirth=‘1990-05-20’",
        "C": "Leaving dateOfBirth empty when optional",
        "D": "Sending dateOfBirth=‘2000-01-01’"
      },
      "gold_answer": "A",
      "model_raw_answer": "A correct negative test would ensure that the system rejects or handles an invalid input gracefully. In this case, the invalid input is a date that does not exist (January 40th, March 13th, February 31st in 1990, but 2000 is valid). Therefore, the correct negative test is sending a date that violates the rules for a valid date. \n\n- Option A is correct because '2025-13-40' is an invalid date (month is 13, which does not exist) and should be rejected by the validation. \n- Option B is incorrect because '1990-05-20' is a valid date (May 20th), so it should not be rejected by the validation.\n- Option C is incorrect because leaving the field empty when it is allowed to be optional does not test the negative validation of a specific date.\n- Option D is incorrect because '2000-01-01' is a valid date, so it should not be rejected by the validation.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Invalid month/day makes it a correct negative input validation case."
    },
    {
      "question_id": "EQ2008",
      "type": "Writing",
      "gold": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "Mocking allows you to simulate the payment processing function without actually calling the bank. The API will interact with a mock bank service, which will be configured to either succeed or fail according to the test. This isolates the payment API from external dependencies."
    },
    {
      "question_id": "EQ2009",
      "question": "Which monitoring approach helps detect sudden spikes in API error rates?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Code coverage reports",
        "B": "Manual log review every week",
        "C": "Real-time alerting on error rate metrics",
        "D": "Static code analysis"
      },
      "gold_answer": "C",
      "model_raw_answer": "C is the correct answer because real-time alerting on error rate metrics immediately notifies teams of sudden spikes, which is crucial for quick response times.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Real-time alerting ensures immediate detection of error rate spikes."
    },
    {
      "question_id": "EQ2010",
      "type": "Writing",
      "gold": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "Boundary Test: `POST /registration` with `age` = 65 (valid boundary). Invalid Test: `POST /registration` with `age` = 0 (too young)."
    },
    {
      "question_id": "EQ2011",
      "question": "Which of these is an example of contract validation in API testing?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking response latency",
        "B": "Validating response JSON matches OpenAPI schema",
        "C": "Measuring server CPU load",
        "D": "Asserting SQL queries from logs"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Validating response JSON matches OpenAPI schema. This is an example of contract validation because it ensures that the API response conforms to the expected JSON structure defined in the OpenAPI specification.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Contract validation ensures responses match defined schemas."
    },
    {
      "question_id": "EQ2012",
      "type": "Writing",
      "gold": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "By configuring a mock server to simulate a slow connection or by using a network emulator like WireMock with a timeout configuration."
    },
    {
      "question_id": "EQ2013",
      "question": "Which scenario best represents an intermediate load test?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "10,000 concurrent users for stress testing",
        "B": "Single-user functional check",
        "C": "Unit testing one function",
        "D": "100–200 concurrent users simulating average traffic"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 100–200 concurrent users simulating average traffic. This represents an intermediate load test as it involves a moderate number of concurrent users that should simulate typical user activity but is still within the acceptable range for the system to handle gracefully.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Intermediate load tests simulate moderate, realistic user traffic."
    },
    {
      "question_id": "EQ2014",
      "type": "Writing",
      "gold": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "Precondition: A user's session token is required. \nStep: The API call for creating a new order must include this token."
    },
    {
      "question_id": "EQ2015",
      "question": "Which approach helps detect unauthorized access attempts in an API?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Penetration test using invalid or missing tokens",
        "B": "Unit tests on helper functions",
        "C": "CI pipeline build success",
        "D": "Running API in debug mode"
      },
      "gold_answer": "A",
      "model_raw_answer": "Running penetration tests with invalid tokens (A) helps detect unauthorized access attempts. Unit tests on helper functions (B) validate core API functionalities, but not specifically access attempts. CI pipeline build success (C) validates code compilation, not security. Running API in debug mode (D) exposes sensitive information.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Penetration tests reveal weaknesses in authorization handling."
    },
    {
      "question_id": "EQ2016",
      "type": "Writing",
      "gold": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "1. **Test Case: Rate Limit Enforcement**\n\t* **Preconditions:** API rate limit (e.g., 100 requests/min) is active.\n\t* **Steps:**\n\t\t1. Send `GET /resources` repeatedly until the limit is reached (e.g., 101 requests).\n\t\t2. The API should return a `429 Too Many Requests` status code with a `rateLimitRemaining` count after the limit is exceeded.\n\t* **Expected Result:** No unauthorized requests are accepted after the limit is reached."
    },
    {
      "question_id": "EQ2017",
      "question": "Which strategy ensures reproducibility of integration API tests?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Running against random live production data",
        "B": "Using seeded test databases and reset scripts",
        "C": "Hardcoding timestamps in requests",
        "D": "Disabling cleanup steps after tests"
      },
      "gold_answer": "B",
      "model_raw_answer": "Ensuring reproducibility in integration API tests requires consistent data and environment setup. Running against random live production data (A) introduces variability that cannot be reliably reproduced. Using seeded test databases and reset scripts (B) provides a controlled environment where tests can be run repeatedly without data leakage or inconsistencies. Hardcoding timestamps in requests (C) is not a reliable strategy for reproducibility as external systems may not always respond exactly to the same timestamp. Disabling cleanup steps after tests (D) can lead to resource leaks and is not a strategy for reproducibility.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Seeded test data ensures consistent reproducibility."
    },
    {
      "question_id": "EQ2018",
      "type": "Writing",
      "gold": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "It allows testing with simplified or mock services before real ones are ready."
    },
    {
      "question_id": "EQ2019",
      "question": "Which of these is an appropriate recovery step if API monitoring detects consistent 500 errors?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Ignore them until next release",
        "B": "Add random retry logic to all clients",
        "C": "Alert ops team and trigger rollback of recent deployment",
        "D": "Turn off error logs"
      },
      "gold_answer": "C",
      "model_raw_answer": "Ignoring 500 errors (A) or adding random retries (B) may hide underlying issues. A more proactive approach is to alert the ops team and trigger a rollback of the recent deployment (C) to ensure stability. Turning off error logs (D) would hinder debugging.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Rollback and alerts ensure quick mitigation."
    },
    {
      "question_id": "EQ2020",
      "type": "Writing",
      "gold": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "Positive Test (Valid Login): Input valid username and password → expect `200 OK` with token. Boundary Test: Input shortest allowed username (e.g., 'abc') → expect `200 OK` with token."
    },
    {
      "question_id": "EQ2021",
      "question": "Which of the following scenarios is an example of a chained API test case?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Calling GET /status repeatedly",
        "B": "Creating a user, then using that user’s ID in GET /profile",
        "C": "Testing an endpoint with invalid headers",
        "D": "Measuring average latency of one endpoint"
      },
      "gold_answer": "B",
      "model_raw_answer": "B is the correct answer because it represents a chained scenario where an initial action (Creating a user) leads to another action (Using that user's ID in GET /profile). Both are part of the same test case.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Chained test cases depend on output of one API being input to another."
    },
    {
      "question_id": "EQ2022",
      "type": "Writing",
      "gold": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Send a request with a non-accepted media type (e.g., 'image/base64'). The expected result is a `200 OK` status code with a payload like `{ \"status\": \"okay\" }` and a `VND` header for `unsupported-media-type`."
    },
    {
      "question_id": "EQ2023",
      "question": "Which practice helps detect contract violations early in a CI/CD pipeline?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Load testing in production only",
        "B": "Manual regression testing once a month",
        "C": "Schema validation tests integrated into pipeline",
        "D": "Using mocks for all external dependencies"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Schema validation tests integrated into pipeline.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Automated schema validation in CI/CD detects breaking changes quickly."
    },
    {
      "question_id": "EQ2024",
      "type": "Writing",
      "gold": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Inject a latency injection tool into the database connection pool. Verify that the API's response time is properly highlighted in a monitoring tool like Prometheus or Datadog. Example: inject a 2-second delay between API request processing and the first database query execution."
    },
    {
      "question_id": "EQ2025",
      "question": "Which of the following is an example of a negative authorization test?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Calling DELETE /users without admin privileges",
        "B": "Calling GET /users with valid token",
        "C": "Logging in with valid credentials",
        "D": "Refreshing a valid session token"
      },
      "gold_answer": "A",
      "model_raw_answer": "Negative authorization tests verify that access is denied when it shouldn’t be. \nA. Attempting to delete a user without admin privileges (should fail). \nB. Trying to access a resource protected by admin-only access (should fail). \nC. Logging in with regular credentials (should fail).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Attempting to delete users without privileges tests access restrictions."
    },
    {
      "question_id": "EQ2026",
      "type": "Writing",
      "gold": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Send the same request multiple times. Expected: All requests should return `200 OK`, no new entries should appear in a retry log, and state should not change."
    },
    {
      "question_id": "EQ2027",
      "question": "Which method ensures sensitive API keys are not exposed during automated testing?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcoding them in test scripts",
        "B": "Printing them in CI/CD logs",
        "C": "Storing them in public GitHub repos",
        "D": "Using encrypted environment variables"
      },
      "gold_answer": "D",
      "model_raw_answer": "Exposing API keys is a security risk. Hardcoding them (A) is secure, printing in logs (B) is insecure, storing in repos (C) is very insecure, using environment variables (D) is secure but requires setup. The correct answer is A.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Encrypted env variables keep secrets secure."
    },
    {
      "question_id": "EQ2028",
      "type": "Writing",
      "gold": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "Boundary: Upload a 5 MB file and verify the response. Invalid Test: Attempt to upload a file larger than 5 MB (e.g., 10 MB) and expect a `413` (Payload Too Large) error."
    },
    {
      "question_id": "EQ2029",
      "question": "Which monitoring metric would best indicate a memory leak in an API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Spike in average latency",
        "B": "Steadily increasing memory usage",
        "C": "Decreasing CPU utilization",
        "D": "Random increase in cache hit ratio"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. Steadily increasing memory usage. Memory leaks are characterized by a gradual increase in memory consumption over time, often because of unmanaged resources or poorly cleaned up objects. Monitoring this directly via tools like jvmdump or profiling APIs will show a steady rise in heap usage.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "A memory leak manifests as continuously rising memory usage."
    },
    {
      "question_id": "EQ2030",
      "type": "Writing",
      "gold": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "**Test Case: Missing Email**\n- **Precondition:** API endpoint for creating an account.\n- **Test Step:** Send `POST` request to `/register` (e.g., `https://api.example.com/register`) **without** a `email` field in the payload.\n- **Expected Result:** The API returns a `400 Bad Request` or `401 Unauthorized` status code with a clear error message indicating that the `email` field is required."
    },
    {
      "question_id": "EQ2031",
      "question": "Which of the following best describes service virtualization?",
      "type": "MCQ",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Running APIs only in production",
        "B": "Using local database replicas",
        "C": "Simulating unavailable dependencies with virtual services",
        "D": "Replacing backend logic with new microservices"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Simulating unavailable dependencies with virtual services.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Service virtualization allows testing without real dependencies."
    },
    {
      "question_id": "EQ2032",
      "type": "Writing",
      "gold": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "1. **Precondition:** Set up a mock server to simulate a 503 Bad Gateway response. 2. **Test Steps:** 1) Send a `POST` request with a timeout (e.g., 5 seconds). 2) Verify that the initial request fails with a `Gateway Timeout` error or a `503` response. 3) The retry mechanism should then kick in, and subsequent requests should succeed. 4) Ensure the retry count is capped."
    },
    {
      "question_id": "EQ2033",
      "question": "Which error scenario best represents a client-side failure?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "HTTP 400 Bad Request",
        "B": "HTTP 500 Internal Server Error",
        "C": "Database timeout",
        "D": "Out-of-memory on server"
      },
      "gold_answer": "A",
      "model_raw_answer": "A client-side failure occurs when the client (typically a web browser) cannot fulfill a request. This would typically result in an HTTP status code like 'Bad Request' (400) because the client has made a mistake, such as a malformed request. Internal Server Errors (500) and timeout errors are server-side issues. Out-of-memory errors are also server-side and not client-side.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "400 Bad Request indicates client-side invalid request."
    },
    {
      "question_id": "EQ2034",
      "type": "Writing",
      "gold": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "Test sends a request with a unique trace ID → expect logs matched by that ID in the test case. Verify logs associated with correct span ID and level (e.g., 'INFO 12345') are retrieved. Fail if logs not found or mismatched."
    },
    {
      "question_id": "EQ2035",
      "question": "Which of these scenarios requires schema validation during testing?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking average API response time",
        "B": "Ensuring response JSON fields match OpenAPI definition",
        "C": "Measuring throughput under load",
        "D": "Analyzing SQL query logs"
      },
      "gold_answer": "B",
      "model_raw_answer": "Schema validation is crucial for ensuring API responses (B) and database queries (D) follow the expected structure. It is not required for measuring performance (C) or logging API response times (A).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Schema validation ensures structural correctness of responses."
    },
    {
      "question_id": "EQ2036",
      "type": "Writing",
      "gold": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "Test sends 5 requests instantly, then verify 3/5 of requests are rate-limited with `200 OK` and count is correct."
    },
    {
      "question_id": "EQ2037",
      "question": "Which of the following improves reproducibility of API tests in multiple environments?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Using hardcoded environment URLs",
        "B": "Randomizing all test data",
        "C": "Executing tests against production data",
        "D": "Parameterizing endpoints and using environment configs"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Parameterizing endpoints and using environment configs improves reproducibility by making tests independent of specific environment conditions.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Parameterization ensures same test logic works across environments."
    },
    {
      "question_id": "EQ2038",
      "type": "Writing",
      "gold": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "Positive Test: Send a request with a valid phone number and expected response is `200 OK` with a successful message. Negative Test: Send a request with a phone number that does not exist in the database, expected response is `404 Not Found`."
    },
    {
      "question_id": "EQ2039",
      "question": "Which of these best describes performance baseline testing?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Measuring normal response times under expected load",
        "B": "Testing API with invalid inputs",
        "C": "Validating API against OpenAPI spec",
        "D": "Simulating 10x peak traffic"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Measuring normal response times under expected load.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Baseline testing captures normal expected performance."
    },
    {
      "question_id": "EQ2040",
      "type": "Writing",
      "gold": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "Mocking prevents real users or services from being impacted."
    },
    {
      "question_id": "EQ2041",
      "question": "Which of these is a correct test case for validating session expiration?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Login with valid credentials, expect 200 OK",
        "B": "Send request with valid token immediately after login",
        "C": "Send request with token after session timeout, expect 401 Unauthorized",
        "D": "Send request without token, expect 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "Correct answer: C. Send request with token after session timeout, expect 401 Unauthorized.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Expired sessions must return 401 Unauthorized."
    },
    {
      "question_id": "EQ2042",
      "type": "Writing",
      "gold": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "**Test Case: Malformed JSON Error**\n- **Precondition:** API configured to reject malformed inputs.\n- **Action:** Send `POST` request with a JSON body containing unexpected keys (e.g., `{\"user\": {\"id\": 123}}` instead of `{\"id\": 123}`).\n- **Expected Result:** API returns `400 Bad Request` with a clear error message, not a `200 OK`."
    },
    {
      "question_id": "EQ2043",
      "question": "Which strategy helps validate backward compatibility after adding new optional fields?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Ensure older clients still work without sending new fields",
        "B": "Force clients to update immediately",
        "C": "Remove old fields from responses",
        "D": "Require schema changes to be breaking"
      },
      "gold_answer": "A",
      "model_raw_answer": "A ensures backward compatibility by confirming older clients still function correctly without being sent new fields.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Backward compatibility means old clients should still function without new fields."
    },
    {
      "question_id": "EQ2044",
      "type": "Writing",
      "gold": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "Send a request to an API endpoint with a high request limit. The expected result is that the API responds with a `200 OK` status code and the rate limiting headers (e.g., `X-RateLimit-Remaining`) present in the response body."
    },
    {
      "question_id": "EQ2045",
      "question": "Which is the most effective way to test resilience when an API’s downstream service fails?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "options": {
        "A": "Disable retries in client",
        "B": "Stop testing until service recovers",
        "C": "Run unit tests only",
        "D": "Inject failures using chaos testing or mocks"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. Inject failures using chaos testing or mocks. This allows you to simulate a failure without impacting real users, test the API’s error handling, and verify that it can still recover gracefully.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Chaos testing/mocks allow controlled simulation of dependency failures."
    },
    {
      "question_id": "EQ2046",
      "type": "Writing",
      "gold": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic allows for independent setup and teardown of the test environment, improving test repeatability."
    },
    {
      "question_id": "EQ2047",
      "question": "Which response status code is appropriate for a request blocked due to missing authorization header?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct response status code for a request blocked due to missing an authorization header is 401 Unauthorized. This is because the client failed to provide the necessary credentials to authenticate their request. \n\nOptions:\nA. 200 OK – This is incorrect because the request was not successful.\nB. 401 Unauthorized – This is correct because the client failed to provide an authentication token.\nC. 403 Forbidden – This is incorrect because the client was authenticated but lacked the necessary permissions.\nD. 409 Conflict – This is incorrect because there is no conflict in the request itself, just a missing requirement.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Missing authorization results in 401 Unauthorized."
    },
    {
      "question_id": "EQ2048",
      "type": "Writing",
      "gold": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "Test sends request for cached resource → expect `403 Forbidden` or `404 Not Found`. Verify API reverts to original response instead of error stack. Ensure DB state intact."
    },
    {
      "question_id": "EQ2049",
      "question": "Which of the following represents a proper boundary test for a password length field (min=8, max=20)?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Testing with 7, 8, 20, and 21 characters",
        "B": "Testing with 10 characters only",
        "C": "Testing with 15 characters only",
        "D": "Testing with empty password only"
      },
      "gold_answer": "A",
      "model_raw_answer": "A proper boundary test for a password length field (min=8, max=20) would ensure that all valid boundaries are met. \n\n- **Option A (Testing with 7, 8, 20, and 21 characters):** This test covers the minimum limit (8), the maximum limit (20), and the boundaries just beyond them (7 is below min, 21 is above max). It validates that the field enforces both the minimum and maximum length requirements correctly.\n- **Option B (Testing with 10 characters only):** This test only verifies the minimum length requirement (8) but does not confirm the maximum limit (20).\n- **Option C (Testing with 15 characters only):** This test only verifies the maximum length requirement (20) but does not confirm the minimum limit (8).\n- **Option D (Testing with empty password only):** While testing for an empty password is important, it does not directly test the length boundaries (min and max). An empty string technically has no length, so it doesn't validate the length rules as directly as testing the min and max limits with specific character counts does.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Boundary testing includes values at, below, and above limits."
    },
    {
      "question_id": "EQ2050",
      "type": "Writing",
      "gold": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "Automatically hash and store test passwords, then query logs to verify they are encoded correctly. A negative validation is to inject a known hash into a log field, then check the database to confirm the system remembers the hash."
    },
    {
      "question_id": "EQ2051",
      "question": "Which monitoring method helps identify gradual latency increases over weeks?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Single request stopwatch timing",
        "B": "Manual debugging during incidents",
        "C": "Time-series trend analysis with dashboards",
        "D": "Code coverage metrics"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Time-series trend analysis with dashboards. Dashboards show historical latency trends over time.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Dashboards and time-series monitoring highlight latency trends."
    },
    {
      "question_id": "EQ2052",
      "type": "Writing",
      "gold": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "Negative Test: Input 'USD' (valid code) as 'EUR'. Boundary Test: Input 'USD' (valid code) as 'USD'."
    },
    {
      "question_id": "EQ2053",
      "question": "Which strategy ensures contract tests remain useful when APIs evolve?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Never updating schema tests",
        "B": "Removing optional fields from tests",
        "C": "Running only manual regression tests",
        "D": "Versioning schema contracts and maintaining backward compatibility"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Versioning schema contracts and maintaining backward compatibility.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Versioning and backward compatibility keep contract tests reliable."
    },
    {
      "question_id": "EQ2054",
      "type": "Writing",
      "gold": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "Test sends 10 packets for a single request. Expected: API returns `500 Internal Server Error` or timeout if threshold exceeded."
    },
    {
      "question_id": "EQ2055",
      "question": "Which of these scenarios correctly validates API observability using distributed tracing?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Checking only HTTP status codes",
        "B": "Following a trace ID across multiple microservices",
        "C": "Checking memory usage in server logs",
        "D": "Using manual testing notes"
      },
      "gold_answer": "B",
      "model_raw_answer": "B correctly validates API observability using distributed tracing.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tracing IDs track requests across services."
    },
    {
      "question_id": "EQ2056",
      "type": "Writing",
      "gold": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "Preconditions: Table or database with known test data inserted. After API test execution, query the database for the inserted data. Expected: The specific record should either exist (positive scenario) or not exist (negative scenario with deletion)."
    },
    {
      "question_id": "EQ2057",
      "question": "Which of the following indicates a denial-of-service vulnerability?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "API accepts unlimited requests without throttling",
        "B": "API returns 404 Not Found",
        "C": "API schema missing a description field",
        "D": "Unit test coverage is low"
      },
      "gold_answer": "A",
      "model_raw_answer": "A denial-of-service (DoS) vulnerability occurs when a system is unable to function properly under certain conditions, often because of excessive resource requests or invalid inputs.\n\nA. Accepting unlimited requests without throttling is a classic DoS vulnerability. An attacker could flood the API with requests, consuming resources and potentially crashing the system. This is a direct example of a DoS vulnerability.\n\nB. Returning a 404 Not Found is a standard HTTP status code indicating that the requested resource could not be found. It does not relate directly to DoS vulnerabilities but rather to proper resource handling.\n\nC. An API schema missing a description field is a security vulnerability, but it's more about lack of documentation than a DoS attack. It does not directly impact the system's ability to handle excessive requests.\n\nD. Low unit test coverage is a quality and reliability issue but not specifically a DoS vulnerability. It might indicate other problems, but it is not directly related to the system's inability to handle excessive load.\n\nTherefore, the correct answer is A.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Unrestricted requests can exhaust resources, causing DoS."
    },
    {
      "question_id": "EQ2058",
      "type": "Writing",
      "gold": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "Test involves executing a sequence of DB operations (e.g., `INSERT`, `UPDATE`, `DELETE`). Inject failure midway (e.g., `INSERT` fails). Expected: Transaction rolls back to initial state, no partial changes left in DB."
    },
    {
      "question_id": "EQ2059",
      "question": "Which HTTP status code should be validated when an API request is well-formed but forbidden due to role restrictions?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. 403 Forbidden. This status code indicates that the server understood the request, but it could not authorize access to the requested resource. It is the appropriate response when an authenticated user is trying to access a resource they do not have permission to see.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden indicates client is authenticated but not authorized."
    },
    {
      "question_id": "EQ2060",
      "type": "Writing",
      "gold": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "Automatically validate each endpoint's response against a shared JSON schema. This ensures that error messages, like `400 Bad Request`, follow the same structure and key names everywhere. Tools like JSON Schema validators or integrated API test suites can perform this automated validation."
    },
    {
      "question_id": "EQ3001",
      "question": "Which of the following scenarios best represents a multi-hop test involving login and refresh token endpoints?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Send a request to GET /health",
        "B": "Obtain access token via POST /login, then use POST /refresh to extend session",
        "C": "Send request with expired token to protected endpoint",
        "D": "Check status 200 on GET /docs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Obtain access token via POST /login, then use POST /refresh to extend session.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Multi-hop testing means chaining login with subsequent refresh token usage."
    },
    {
      "question_id": "EQ3002",
      "type": "Writing",
      "gold": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "Test: 1) Login -> 2) Token Refresh -> 3) Call Protected API with Fresh Token."
    },
    {
      "question_id": "EQ3003",
      "question": "Which HTTP status code should a server return when a refresh token is expired?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "401 Unauthorized",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "A server should return a `403 Forbidden` status code when a refresh token is expired, as it indicates that the client lacks access to the protected resources.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Expired refresh token means the client must log in again → 401 Unauthorized."
    },
    {
      "question_id": "EQ3004",
      "type": "Writing",
      "gold": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: User A's token is valid. 2. Action: Send failed login attempt (wrong username). 3. Expected: No refresh token generated."
    },
    {
      "question_id": "EQ3005",
      "question": "Which of the following maps an application-specific error code to the correct HTTP status?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "APP_1001 (User not found) → 404 Not Found",
        "B": "APP_2002 (Invalid password) → 201 Created",
        "C": "APP_3003 (Success) → 500 Internal Server Error",
        "D": "APP_9999 (Database error) → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct answer because it defines a valid mapping between an application-specific error code (APP_1001) and its corresponding HTTP status code (404 Not Found). This is a common practice in API design.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Mapping user-not-found to 404 is the correct HTTP translation."
    },
    {
      "question_id": "EQ3006",
      "type": "Writing",
      "gold": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Create a business rules engine mapping (e.g., a JSON file) that defines order status codes like `ORDER_001 -> 200 OK`. Automate tests by injecting this mapping into a test script, which then asserts that the correct status code is returned for each valid order status."
    },
    {
      "question_id": "EQ3007",
      "question": "Which scenario demonstrates chained negative testing?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Testing single GET /status request",
        "B": "Valid login followed by accessing /profile",
        "C": "Checking server uptime with GET /health",
        "D": "Logging in with expired password → 401, then retrying refresh token → 401"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. Logging in with expired password → 401, then retrying refresh token → 401. This demonstrates chained negative testing because a failed first attempt (expired password) leads to a second failure (retrying refresh token).",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Chained negative tests validate failures across endpoints."
    },
    {
      "question_id": "EQ3008",
      "type": "Writing",
      "gold": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "1. Order creation → 2. Payment processing → 3. Refund generation."
    },
    {
      "question_id": "EQ3009",
      "question": "Which HTTP status code is correct for mapping a custom error ORDER_DUPLICATE to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "404 Not Found",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct HTTP status code for a custom error like `ORDER_DUPLICATE` is 409 Conflict. This indicates that the request could not be completed because of a conflict with the current state of the resource (in this case, an existing order with the same ID). \n\n*   200 OK is used for successful requests.\n*   404 Not Found is used when the requested resource is not found.\n*   500 Internal Server Error is a generic error code for unexpected server failures. It is not specific to client-side errors like conflicts.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Duplicate order is a conflict → 409."
    },
    {
      "question_id": "EQ3010",
      "type": "Writing",
      "gold": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "Test case: Token Refresh Loop. 1. Service A (consumer) requests a token from Service B (token provider). 2. Service B generates a short-lived token (e.g., 5 minutes). 3. Service A sends the token to a payment gateway (Service C). 4. After token lifetime expires, Service B refreshes the token. 5. Verify that the refreshed token now works with Service C for more than 5 minutes."
    },
    {
      "question_id": "EQ3011",
      "question": "Which scenario correctly validates multi-hop error handling in an e-commerce workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Create order → invalid payment details → 402 Payment Required",
        "B": "Check inventory → product exists → 200 OK",
        "C": "Call healthcheck endpoint → 200 OK",
        "D": "Request product catalog → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A correctly validates multi-hop error handling by introducing a single invalid step within a complex workflow and ensuring the subsequent hops handle the error gracefully. In this case, the payment details failing (a valid error condition) leads to a successful order creation attempt being rejected with a suitable error code (e.g., `402 Payment Required`). This is the only scenario where error propagation and recovery are tested within a multi-hop flow.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Payment failure after order creation is a multi-hop negative test."
    },
    {
      "question_id": "EQ3012",
      "type": "Writing",
      "gold": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "Preconditions: Validation library mocked with specific error codes. Test sends invalid request with each code → expect `400 Bad Request` with correct error text."
    },
    {
      "question_id": "EQ3013",
      "question": "Which of these represents a hard-level chained login test?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Only testing GET /login-docs",
        "B": "Logging in once and stopping",
        "C": "Login → refresh token → logout → confirm refresh fails",
        "D": "Checking GET /health endpoint"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. A hard-level chained login test involves a sequence of actions to ensure the login process and refresh tokens work correctly: 1) Log in, 2) Get refresh tokens, 3) Log out, 4) Attempt to refresh (which should fail because a valid session is no longer active). This ensures the login process is robust and handles various scenarios.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Combines multiple endpoints into a workflow validation."
    },
    {
      "question_id": "EQ3014",
      "type": "Writing",
      "gold": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: A user token and refresh token (with expiration time known) are set up. 2. The test sends a 401 Unauthorized response when using an expired refresh token to obtain a new access token. 3. The system must prevent a valid access token from being issued with an expired refresh token."
    },
    {
      "question_id": "EQ3015",
      "question": "Which mapping is correct for business error PAYMENT_DECLINED?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "A is correct because a successful payment (200 OK) indicates that the transaction was processed and the customer was not declined. Business error codes like 402 Payment Required or 403 Forbidden (not found) indicate specific failure conditions, not success.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Payment declined → 402 Payment Required."
    },
    {
      "question_id": "EQ3016",
      "type": "Writing",
      "gold": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Perform a multi-hop chained test by 1) logging in, 2) performing action A, 3) logging out, 4) attempting action B, and 5) asserting that action B fails with'session not active'."
    },
    {
      "question_id": "EQ3017",
      "question": "Which scenario maps to the correct HTTP code for an internal application error?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "APP_TIMEOUT → 200 OK",
        "B": "APP_TIMEOUT → 504 Gateway Timeout",
        "C": "APP_TIMEOUT → 201 Created",
        "D": "APP_TIMEOUT → 400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct scenario and HTTP code for an internal application error is:\nInternal Server Error (500 series) typically indicates a generic error on the server side. However, a more specific and common code for an internal application error, like a timeout, is:\n`503 Service Unavailable` (a timeout or failure to process request).",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Timeouts should map to 504 Gateway Timeout."
    },
    {
      "question_id": "EQ3018",
      "type": "Writing",
      "gold": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "Test: 1) Precondition: User email exists. 2) Signup → `201 Created`. 3) Email Verification → `200 OK` (if valid). 4) Login → `200 OK` with correct credentials."
    },
    {
      "question_id": "EQ3019",
      "question": "Which test validates chained role-based access?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login as user → access /admin → expect 403 Forbidden",
        "B": "Login as admin → access /admin → expect 200 OK",
        "C": "Login as user → view profile → 200 OK",
        "D": "GET /health → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct answer because it validates that a regular user (logged in as a user) cannot access an admin-level resource, which is the definition of a chained role-based access check.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Role mismatch leading to 403 is a multi-hop role validation."
    },
    {
      "question_id": "EQ3020",
      "type": "Writing",
      "gold": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "1. **Precondition:** User `A` exists with an email and password reset token. 2. **Action:** Perform a hard-level chained test by simulating a valid login (`A` logs in), a password reset request (`A` clicks reset), and finally, attempting to use the reset token (`A` submits reset form). 3. **Verification:** The test validates whether the system correctly enforces a single use per token (`reset submitted → 401 Unauthorized`) and whether the token cannot be reused (`same token used twice → 409 Conflict`), all while ensuring the flow remains stateful and secure."
    },
    {
      "question_id": "EQ3021",
      "question": "Which scenario validates a chained login, refresh, and logout sequence?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → use token once",
        "B": "Refresh token immediately after login",
        "C": "Logout only",
        "D": "Login → refresh token → logout → confirm refresh fails"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Login → refresh token → logout → confirm refresh fails. This sequence validates the chain by attempting to use a refresh token after login, then immediately refreshing it, and finally logging out. The expected outcome is that the refresh operation will fail because the initial token has expired, confirming the correct usage of the logout step to invalidate tokens.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "This full sequence tests the entire authentication lifecycle."
    },
    {
      "question_id": "EQ3022",
      "type": "Writing",
      "gold": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "Create a test case with three sub-cases: user creation, profile update, and profile retrieval, all chained together."
    },
    {
      "question_id": "EQ3023",
      "question": "Which mapping correctly translates a business error STOCK_OUT to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "201 Created",
        "D": "403 Forbidden"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct mapping is a `409 Conflict` because the business error `STOCK_OUT` implies that the stock is unavailable and the order cannot be fulfilled, similar to a conflict in a database.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Stock-out means a conflict with order fulfillment, mapping to 409."
    },
    {
      "question_id": "EQ3024",
      "type": "Writing",
      "gold": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "1. **Test:** Use a valid refresh token to obtain a new access token. 2. **Expected Result:** The response for the new access token request should not include an `expires_at` field or a `token_type` of `200 OK`. 3. **Rationale:** If the token is valid, it should still have expiration information."
    },
    {
      "question_id": "EQ3025",
      "question": "Which scenario validates chained negative testing for a shopping cart workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Add valid item to cart → 200 OK",
        "B": "Checkout with valid payment → 200 OK",
        "C": "Add item → remove item → checkout → expect 400 Bad Request",
        "D": "View cart after login → 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "Chained negative testing validates that the system correctly handles invalid sequences. The correct test case is:\nC. Add item → remove item → checkout → expect 400 Bad Request\nThis tests the cart state transitions and ensures the system responds with a valid error (400 Bad Request) when the cart state is invalid (remove item not found).",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Empty cart checkout is a chained negative scenario."
    },
    {
      "question_id": "EQ3026",
      "type": "Writing",
      "gold": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "**Test Case: Authentication Expiration**\n- **Preconditions:** User session expires after 5 minutes.\n- **Test Steps:** 1) Send `POST /login` with expired token → expect `401 Unauthorized` not `200 OK`. 2) Verify authentication service returns `AUTH_EXPIRED` error code.\n- **Expected Result:** API response should map `AUTH_EXPIRED` to HTTP status `401 Unauthorized`."
    },
    {
      "question_id": "EQ3027",
      "question": "Which scenario best validates chained order cancellation?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Hard",
      "options": {
        "A": "Create order → cancel order → GET /orders/{id} shows status=cancelled",
        "B": "Cancel non-existent order → 404",
        "C": "Create order only",
        "D": "Check /status endpoint"
      },
      "gold_answer": "A",
      "model_raw_answer": "The correct option is A. This scenario involves creating an order, then cancelling that order, and finally verifying the status of the order. It validates the chain of events (creating an order → cancelling an order → checking the order status) and ensures that the status is correctly updated to 'cancelled'.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Covers lifecycle of order creation → cancellation → verification."
    },
    {
      "question_id": "EQ3028",
      "type": "Writing",
      "gold": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Send valid email confirmation → expect `200 OK`. 2) Send email with invalid token (e.g., `123` instead of `abc`): expect `404 Not Found` or `401 Unauthorized`. 3) Send email with expired token: expect `400 Bad Request`."
    },
    {
      "question_id": "EQ3029",
      "question": "Which mapping correctly translates FILE_TOO_LARGE to HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "404 Not Found",
        "D": "413 Payload Too Large"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 413 Payload Too Large.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "File too large should map to 413."
    },
    {
      "question_id": "EQ3030",
      "type": "Writing",
      "gold": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "Test case: 'Loan Approval Flow'. Preconditions: Test account, mock credit service. Steps: 1) Valid Loan → 3xx Approved, 2) Declined Credit → 401 Unauthorized, 3) Missing Field → 400 Bad Request. Expected: Loan service returns approved or rejected."
    },
    {
      "question_id": "EQ3031",
      "question": "Which chained sequence validates refresh tokens across multiple sessions?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → logout only",
        "B": "Login → refresh token → logout → login again → confirm old refresh invalid",
        "C": "Refresh token without login",
        "D": "Check GET /status"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Login → refresh token → logout → login again → confirm old refresh invalid. This ensures the refresh token is bound to a single user session and can't be reused.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Ensures session handling across multiple logins."
    },
    {
      "question_id": "EQ3032",
      "type": "Writing",
      "gold": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "Test Case: End-to-End Authentication. Preconditions: User exists. Steps: Signup → Password Reset → Login with new credentials. Expected: Corrected email/username."
    },
    {
      "question_id": "EQ3033",
      "question": "Which mapping is correct for mapping business error INVALID_COUPON?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request, as the invalid coupon is a client-side error.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Invalid coupon should map to 400 Bad Request."
    },
    {
      "question_id": "EQ3034",
      "type": "Writing",
      "gold": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "Test case includes steps for uploading files, triggering a virus scan, and then downloading the scan report."
    },
    {
      "question_id": "EQ3035",
      "question": "Which scenario validates correct multi-hop error mapping in payment workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Payment API returns DECLINED → mapped to HTTP 402",
        "B": "Payment API returns APPROVED → mapped to HTTP 404",
        "C": "Payment API returns DECLINED → mapped to HTTP 201",
        "D": "Payment API returns ERROR → mapped to HTTP 200"
      },
      "gold_answer": "A",
      "model_raw_answer": "A -> Declined payment → correct HTTP status (402 Bad Request) in payment workflow.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Payment declined correctly maps to 402 Payment Required."
    },
    {
      "question_id": "EQ3036",
      "type": "Writing",
      "gold": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "1. Token 1 (short lifetime) + 1 refresh → new token. 2. Same Token 1 reused → 401 Unauthorized. Verify system prevents reuse."
    },
    {
      "question_id": "EQ3037",
      "question": "Which mapping is correct for mapping RATE_LIMIT_EXCEEDED to HTTP?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "Correct answer: D. 429 Too Many Requests.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rate limits exceeded should map to 429."
    },
    {
      "question_id": "EQ3038",
      "type": "Writing",
      "gold": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "1. **Search Product:** Send `GET /products` with a specific ID → `200 OK` with product details. 2. **Add-to-Cart:** Send `POST /cart` with product ID → `201 Created` with cart update. 3. **Checkout:** Send `POST /checkout` with customer data and cart ID → `302 Found` with order confirmation."
    },
    {
      "question_id": "EQ3039",
      "question": "Which scenario validates chained negative testing in ticket booking workflow?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Book valid ticket → 200 OK",
        "B": "Book ticket → cancel ticket → attempt refund → expect 400 Bad Request",
        "C": "View available seats → 200 OK",
        "D": "Check GET /status → 200 OK"
      },
      "gold_answer": "B",
      "model_raw_answer": "Negative testing chain: 1) `Book ticket → 200 OK` (valid request → OK response). 2) `View available seats → 200 OK` (valid request → OK response). 3) `Attempt refund for non-existent ticket → 404 Not Found` (negative → specific status). 4) `Cancel ticket → cancel ticket → 200 OK` (negative → OK response). 5) `Book ticket → cancel ticket → attempt refund → expect 400 Bad Request` (chain of negatives → bad response). Only B represents a chained negative test case where multiple negative inputs lead to different expected results.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Chained negative: refunding after cancel is invalid."
    },
    {
      "question_id": "EQ3040",
      "type": "Writing",
      "gold": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "1. Log in with a valid token → session established.\n2. Perform second login attempt with identical credentials → expect `401 Unauthorized` or session rejection.\n3. If multiple requests reuse token, API must enforce logout or expire session quickly."
    },
    {
      "question_id": "EQ3041",
      "question": "Which chained flow correctly validates token rotation with refresh token reuse detection?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Login → call API once → logout",
        "B": "Login → refresh token → attempt reuse of old refresh → expect 401 Unauthorized",
        "C": "Login only",
        "D": "Refresh without login"
      },
      "gold_answer": "B",
      "model_raw_answer": "Correct answer is B, as attempting to reuse an old refresh token after logout will fail with a 401 Unauthorized.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Token reuse must be rejected after rotation to prevent replay attacks."
    },
    {
      "question_id": "EQ3042",
      "type": "Writing",
      "gold": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "1. **Test Scenario:** Send `POST /resource` with ETag `ETG-123` → `201 Created`. 2. **Chained Test:** Send `GET /resource` with `If-Match: ETG-123` → `200 OK` if fresh. 3. **Optimistic Update:** Send `PUT /resource` (update) with new ETag `ETG-456`. → `409 Conflict` if concurrent. 4. **Chained Test (continued):** Send `PUT /resource` with stale ETag → `412 Precondition Failed`."
    },
    {
      "question_id": "EQ3043",
      "question": "Which HTTP status should be returned when an If-Match precondition fails due to stale ETag during PUT /resource/{id}?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "412 Precondition Failed",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct status code for a precondition failure, especially with an expired ETag, is 412 Precondition Failed. A 400 Bad Request is incorrect because the client action is valid, but the state is wrong. A 200 OK is inappropriate because the request failed a precondition. A 404 Not Found is incorrect because the resource exists. Therefore, the only correct option is C.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Stale ETag should map to 412 Precondition Failed."
    },
    {
      "question_id": "EQ3044",
      "type": "Writing",
      "gold": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "1. Send initial POST /exports request with async export job. 2. Poll GET /jobs/{id} until status changes from 'pending' to 'completed'. 3. Verify final export status with GET /exports/{id], asserting final state (e.g., 'complete', file available)."
    },
    {
      "question_id": "EQ3045",
      "question": "Which mapping from business code to HTTP is most appropriate for RESOURCE_VERSION_CONFLICT during update?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct mapping is 409 Conflict, as it indicates that the resource already exists with the specified version and the request could not be completed.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Version conflict maps correctly to 409 Conflict."
    },
    {
      "question_id": "EQ3046",
      "type": "Writing",
      "gold": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Send a request for an authorization code with no scope (e.g., `/authorize?client_id=abc&redirect_uri=http://example.com/callback&state=xyz` but no `scope=`) and verify the response is an `403 Forbidden` or `400 Bad Request` with an error code like `invalid_grant`."
    },
    {
      "question_id": "EQ3047",
      "question": "Which status code best represents a refresh token presented to the wrong client_id in a multi-tenant system?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. 400 Bad Request. This status code indicates that the request could not be completed because it was malformed (in this case, an invalid client ID was provided).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "OAuth2 specifies invalid_grant (400) for wrong client/refresh usage."
    },
    {
      "question_id": "EQ3048",
      "type": "Writing",
      "gold": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. Given a user with an Idempotency-Key, create chained tests for retry and refund: 1) Charge → 200 OK, 2) Retry → 202 Accepted, 3) Refund → 200 OK with no double charge."
    },
    {
      "question_id": "EQ3049",
      "question": "Which status mapping is correct for business code INSUFFICIENT_FUNDS from payment gateway?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct status mapping is 403 Forbidden, as the payment gateway indicates insufficient funds, which means the transaction cannot be completed.",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "Insufficient funds → 402 Payment Required."
    },
    {
      "question_id": "EQ3050",
      "type": "Writing",
      "gold": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "1. **Action/Request:** Send `POST /process` with file and action=submit.\n2. **State Check:** Poll `/status` until 'processing complete' response.\n3. **Verification:** Confirm file downloaded and integrity preserved."
    },
    {
      "question_id": "EQ3051",
      "question": "Which scenario correctly validates backoff + retry policy across gateway 429 -> 200 transitions?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "options": {
        "A": "API returns 429 Too Many Requests → client retries with backoff → 200 OK",
        "B": "API returns 401 Unauthorized → retry succeeds",
        "C": "API returns 404 Not Found → retry succeeds",
        "D": "API returns 500 → retry without backoff"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is correct because it describes a valid scenario where the client is temporarily prevented from making requests (429) and, after retrying with a delay (backoff), is granted permission to proceed (200 OK). This validates both the backoff and retry policies.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Retry with exponential backoff is required for 429 handling."
    },
    {
      "question_id": "EQ3052",
      "type": "Writing",
      "gold": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "1. Log in with SSO → session granted → revoke session → expect API response `403` or `404 Not Found` for protected endpoints."
    },
    {
      "question_id": "EQ3053",
      "question": "Which HTTP code should map to BUSINESS_LIMIT_EXCEEDED when per-user quota blocks a valid, authenticated request?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct HTTP status code for the scenario described is 429 Too Many Requests, as it indicates that the client has exceeded the rate allowed by the server for a specific resource.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Quota exhaustion maps to 429 Too Many Requests."
    },
    {
      "question_id": "EQ3054",
      "type": "Writing",
      "gold": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "1. Given an order, when it's created, it should reserve inventory and partial ship some items. 2. The system should then process a cancel for the remaining items. 3. Verify that only the initial order cost (not partial shipment) is refunded."
    },
    {
      "question_id": "EQ3055",
      "question": "Which mapping is most accurate for error code SIGNATURE_INVALID on webhook delivery verification?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is B. 404 Not Found. The error code SIGNATURE_INVALID means the signature verification failed, and the webhook server could not find the expected signature. This is equivalent to a 'Not Found' error for the expected signature.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Invalid webhook signature should return 401 Unauthorized."
    },
    {
      "question_id": "EQ3056",
      "type": "Writing",
      "gold": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "1. Log in normally → `200 OK`. 2. Send 2FA verification request with wrong verification code → `401 Unauthorized`. 3. Send request to refresh token → `403 Forbidden`."
    },
    {
      "question_id": "EQ3057",
      "question": "Which HTTP code best represents a soft-deleted resource requested by GET /resource/{id} after DELETE (with recoverable state)?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "204 No Content"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is D. 204 No Content. This is because the resource exists but is in a deleted state (soft-deleted), and the API design dictates that a successful status code with no content is used to indicate the resource's current (deleted) state without forcing a response from the server.",
      "model_normalized_answer": "D",
      "correct": false,
      "explanation": "Soft-deleted resource should be treated as not found."
    },
    {
      "question_id": "EQ3058",
      "type": "Writing",
      "gold": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "Create chain with 10 items (page=1), verify page count and total count on list, delete last → expect DB consistent removal (no duplicate counts)."
    },
    {
      "question_id": "EQ3059",
      "question": "Which mapping is correct when dependency outage triggers circuit breaker OPEN, causing gateway to reject requests immediately?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "400 Bad Request"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct mapping is 503 Service Unavailable, as it indicates that the service is temporarily unavailable due to a dependency outage.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Circuit breaker OPEN maps to 503 Service Unavailable."
    },
    {
      "question_id": "EQ3060",
      "type": "Writing",
      "gold": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "1. Chain: 1) Login user A. 2) Call API via load balancer -> expect 200 OK. 3) Logout user A. 4) Verify no node (e.g., DB API) accepts session token for user A after logout."
    },
    {
      "question_id": "EQ4001",
      "question": "Which chained flow correctly validates an order lifecycle with create → capture → refund, ensuring idempotency across retries?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Create order → retry refund twice → refund fails",
        "B": "Capture payment without creating order",
        "C": "Create order → capture payment → retry capture with same idempotency key → single charge → refund succeeds",
        "D": "Refund before order creation"
      },
      "gold_answer": "C",
      "model_raw_answer": "C correctly validates an order lifecycle with idempotency across retries.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Idempotency must ensure duplicate captures do not create multiple charges."
    },
    {
      "question_id": "EQ4002",
      "type": "Writing",
      "gold": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "Define states: Active, Suspended, Deactivated. Transitions validated by preconditions (e.g., valid email → create), actions (e.g., activate, suspend), and reverse transitions (e.g., reactivate). Postconditions ensure state transitions are correct."
    },
    {
      "question_id": "EQ4003",
      "question": "Which mapping is correct for handling a duplicate transaction detected during a refund request?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct mapping for handling a duplicate transaction detected during a refund request is 409 Conflict. This status code indicates that the request could not be completed because of a conflict with the current state of the resource (in this case, a unique transaction ID). \n\n- **200 OK** is used for successful requests, which doesn't apply here.\n- **409 Conflict** is the standard status code for this scenario.\n- **403 Forbidden** is used when the client does not have access to the resource, which is not applicable.\n- **500 Internal Server Error** is a generic status code for unexpected server errors, which is too broad for this specific use case.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Duplicate transaction must map to 409 Conflict."
    },
    {
      "question_id": "EQ4004",
      "type": "Writing",
      "gold": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "Test steps: 1) Initiate money transfer. 2) Simulate fraudulent transaction. 3) Verify database rolled back, not committed."
    },
    {
      "question_id": "EQ4005",
      "question": "Which chained scenario validates proper error propagation in a distributed saga transaction?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Start saga → all steps succeed",
        "B": "Start saga → ignore error in step 2",
        "C": "Start saga → rollback ignored",
        "D": "Start saga → step 3 fails → compensating rollback of steps 1 & 2 executed"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. This is the only scenario where error propagation is properly chained and compensating actions (like rolling back successful steps) are executed.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Saga pattern ensures compensating actions on failure."
    },
    {
      "question_id": "EQ4006",
      "type": "Writing",
      "gold": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "1. **Precondition:** A user with a valid payment method exists in the database. \n2. **Test Steps:**\n   - Log in as that user.\n   - Create a new order via the login service.\n   - Trigger payment processing.\n   - Cancel the order.\n   - **Verification:** The order's status should change from 'pending' to 'cancelled'."
    },
    {
      "question_id": "EQ4007",
      "question": "Which error handling scenario best validates sanity checks in payment APIs?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Submitting refund > captured amount → 400 Bad Request",
        "B": "Submitting refund = captured amount → 200 OK",
        "C": "Submitting refund < captured amount → 200 OK",
        "D": "Refund without capture → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct answer because it ensures that invalid requests (e.g., submitting a refund for an amount greater than the available balance) are handled gracefully and prevent unauthorized transactions. Submitting a refund for an amount > captured → 400 Bad Request ensures the API enforces business rules. The other options do not validate sanity checks for payment APIs.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Refunds larger than capture must fail with 400."
    },
    {
      "question_id": "EQ4008",
      "type": "Writing",
      "gold": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "Test: 1) Log in with valid password → set. 2) Wait for password expiration → 'password expired' error. 3) Attempt reset → successful reset. 4) Verify new password is reused → negative validation."
    },
    {
      "question_id": "EQ4009",
      "question": "Which mapping best validates format error handling for malformed JSON payloads?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. 400 Bad Request. This status code indicates that the server cannot process the request due to a malformed format, in this case, a malformed JSON payload.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Malformed JSON must result in 400 Bad Request."
    },
    {
      "question_id": "EQ4010",
      "type": "Writing",
      "gold": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "1. Precondition: Loan system mocked to return 'approved' for valid application and'rejected' for failed credit check.\n2. Test Steps: Submit valid loan application → expect 'Approved' response and db update. Submit loan application with failed credit check → expect 'Rejected' response and db update. Chain failure: Submit loan application with service mocked to return 'error' (e.g., DB connection failure)."
    },
    {
      "question_id": "EQ4011",
      "question": "Which chained flow validates consistent state during distributed booking workflow?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Reserve hotel only",
        "B": "Reserve hotel → book flight → flight fails → hotel reservation auto-cancelled",
        "C": "Book flight only",
        "D": "Book hotel and keep reservation even if payment fails"
      },
      "gold_answer": "B",
      "model_raw_answer": "Validating consistent state in a chained flow for a distributed booking (hotel and flight) involves ensuring that each step's success or failure propagates correctly across the workflow. \n\n- **Option A (Reserve hotel only):** This does not validate the distributed booking process as a whole, only a part of it. It doesn't check the consistency of the state when both components are involved.\n\n- **Option B (Reserve hotel → book flight → flight fails → hotel reservation auto-cancelled):** This option describes a valid distributed failure scenario. When a flight booking fails, the chained flow should auto-cancel any pending or reserved hotel room to prevent double charging or conflicting reservations. This ensures that the state remains valid and consistent with the failure.\n\n- **Option C (Book flight only):** Similar to Option A, this only validates a part of the distributed booking and does not check the consistency of the state during a failure scenario.\n\n- **Option D (Book hotel and keep reservation even if payment fails):** This does not validate the consistency of the state during a distributed booking failure. If payment for a hotel fails, the system should not keep a pending or reserved state for that booking, as it's an invalid transaction.\n\nTherefore, the correct answer is **B (Reserve hotel → book flight → flight fails → hotel reservation auto-cancelled)** because it validates the consistent state during a distributed failure scenario.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Hotel auto-cancellation ensures consistent state across systems."
    },
    {
      "question_id": "EQ4012",
      "type": "Writing",
      "gold": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "Preconditions: Two writers attempt to update user profile with different values (e.g., 'John' and 'Jane') simultaneously. Expected Result: Only one update succeeds, DB contains single, consistent profile record, and other writer's attempt fails with 409 Conflict Error."
    },
    {
      "question_id": "EQ4013",
      "question": "Which HTTP code is correct for validating sanity check on withdraw > account balance?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "400 Bad Request"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct HTTP code for validating a sanity check on a withdraw operation, such as checking if the account balance is sufficient, is `400 Bad Request`. This is because the request is malformed (invalid data), specifically the amount provided is invalid or missing, and the server cannot fulfill the request without this validation.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Over-withdrawal must be rejected as 400 Bad Request."
    },
    {
      "question_id": "EQ4014",
      "type": "Writing",
      "gold": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "Create a test where a signed document is uploaded, then tampered with, signed again, and verified. Preconditions: document content known, tamper-proof seal available. Expected: verification fails if tampered, signed again unique."
    },
    {
      "question_id": "EQ4015",
      "question": "Which scenario validates state rollback when an API partially updates user info and DB transaction fails?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Update fails mid-way → no partial changes persist",
        "B": "Update fails mid-way → partial changes remain",
        "C": "Update fails mid-way → system crashes",
        "D": "Update succeeds despite DB rollback"
      },
      "gold_answer": "A",
      "model_raw_answer": "Scenario B: Update fails mid-way → partial changes remain. API updates DB partially before failing. State rolls back to last consistent state (before failure). DB remains inconsistent but API state is valid.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Proper rollback prevents partial/inconsistent data."
    },
    {
      "question_id": "EQ4016",
      "question": "Which chained scenario best validates the idempotency of a payment capture endpoint?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "POST /capture twice with different Idempotency-Key values → two charges",
        "B": "POST /capture twice with the same Idempotency-Key → single charge recorded",
        "C": "POST /refund without capture → success",
        "D": "GET /capture-status once"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. POST /capture twice with the same Idempotency-Key → single charge recorded. Idempotency requires that a request and its repeat execution have the same effect. In this case, capturing a payment (or failing to capture it) is idempotent, meaning executing the same payment capture request twice should result in only one payment being recorded.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Idempotency ensures duplicate requests with same key do not create multiple charges."
    },
    {
      "question_id": "EQ4017",
      "type": "Writing",
      "gold": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "Test case: 1) Subscribe → 2) Upgrade subscription → 3) Downgrade → 4) Cancel subscription. Expected: Subscription state transitions follow lifecycle rules."
    },
    {
      "question_id": "EQ4018",
      "question": "Which mapping correctly handles application error LIMIT_EXCEEDED for per-account API quota?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct response code for exceeding an API quota (e.g., LIMIT_EXCEEDED) is `429 Too Many Requests`. This indicates that the client exceeded the rate limit for the resource they are requesting. \n\n*   `200 OK` is used for successful requests and has nothing to do with rate limits or quotas.\n*   `400 Bad Request` is typically used for malformed request data.\n*   `403 Forbidden` is used when the client does not have access to the requested resource, which is different from exceeding rate limits.\n*   `429 Too Many Requests` is the specific status code for this scenario.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Rate/limit exceeded maps to 429 Too Many Requests."
    },
    {
      "question_id": "EQ4019",
      "type": "Writing",
      "gold": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "Send order for payment, shipping, and inventory updates in sequence. Expected: Order state should still be 'pending' but all dependent events (e.g., shipped order with missing inventory update) should be rolled back to state 'pending' or 'failed'. No database consistency violations."
    },
    {
      "question_id": "EQ4020",
      "question": "Which chained flow validates OAuth2 token misuse detection across services?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "options": {
        "A": "Login once",
        "B": "Refresh token immediately",
        "C": "Login → get token → attempt to use token in another client → 403 Forbidden",
        "D": "Logout only"
      },
      "gold_answer": "C",
      "model_raw_answer": "C is the correct option as it demonstrates the misuse detection scenario.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Cross-client token misuse should be forbidden."
    },
    {
      "question_id": "EQ4021",
      "type": "Writing",
      "gold": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "1. Perform a debit transaction. 2. Immediately call a payment service API to process a subsequent credit transaction. 3. Roll back the debit transaction (e.g., via API's cancel method or database rollback). Verify that the debit amount is still available in the debit's original account, but the credit transaction was never processed."
    },
    {
      "question_id": "EQ4022",
      "question": "Which scenario best validates format error handling for XML vs JSON input mismatch?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "Send XML body with Content-Type: application/json → 415 Unsupported Media Type",
        "B": "Send JSON body with application/json → 200 OK",
        "C": "Send XML body with application/xml → 200 OK",
        "D": "Send YAML → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "Validating format error handling for XML vs JSON input mismatch: \n- **Scenario A:** Sending an XML payload as a JSON request (e.g., `Content-Type: application/json`) → **Expected:** `415 Unsupported Media Type` is returned because the server expects JSON but receives XML. \n- **Scenario B:** Sending a JSON payload with an incorrect content type (e.g., sending `application/json` but the payload is in `text/plain`) → **Expected:** `400 Bad Request` or a specific JSON parsing error is returned, not `200 OK`.\n- **Scenario C:** Sending an XML payload with the correct `Content-Type` (e.g., `Content-Type: application/xml`) → **Expected:** `200 OK` is returned because the server expects XML and is configured to handle it correctly.\n- **Scenario D:** Sending a YAML payload → **Expected:** `415 Unsupported Media Type` or a `400 Bad Request` with a specific error message, as YAML is not a standard HTTP media type.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Mismatch in body vs header must result in 415."
    },
    {
      "question_id": "EQ4023",
      "type": "Writing",
      "gold": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Preconditions: stock → products allocated → shipments confirmed → returns processed. Test steps: add stock → ship product → return item → reconcile stock. Verify state transitions: stock → allocated → shipped → returned → reconciled."
    },
    {
      "question_id": "EQ4024",
      "question": "Which HTTP status is correct when a schema validation error occurs for a nested field?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct HTTP status code for a schema validation error is 400 Bad Request. This is because the request (in this case, the JSON payload) is malformed according to the schema, which is a client-side validation error. \n\n- 201 Created is used for successfully creating a new resource.\n- 500 Internal Server Error is too general and indicates a server-side bug.\n- 404 Not Found is used for a resource that cannot be found on the server.\n- 400 Bad Request is the specific status code for a malformed request, which includes a validation error against a schema.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Schema validation errors must return 400."
    },
    {
      "question_id": "EQ4025",
      "type": "Writing",
      "gold": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "1. Send login request → expect `auth_token` in response.\n2. Send `auth_token` to API → expect `200 OK` with new token (token refresh).\n3. Send logout request → expect `204 No Content`.\n4. Send refresh with old `auth_token` → expect `401 Unauthorized` or `404 Not Found`."
    },
    {
      "question_id": "EQ4026",
      "question": "Which chained scenario validates proper rollback after multi-step booking (flight + hotel) when payment fails?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Book flight → 200 OK",
        "B": "Book hotel → 200 OK",
        "C": "Book flight + hotel → payment succeeds",
        "D": "Book flight + hotel → payment fails → rollback both bookings"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Rollback ensures no inconsistent bookings remain."
    },
    {
      "question_id": "EQ4027",
      "type": "Writing",
      "gold": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. Send email → 2. Verify email opened → 3. Confirm unsubscribe processed → 4. Assert no further emails sent."
    },
    {
      "question_id": "EQ4028",
      "question": "Which mapping is correct for application code TOKEN_REPLAY_DETECTED?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct mapping for an application code like `TOKEN_REPLAY_DETECTED` is typically a `200 OK` status code, as it indicates the successful validation or detection of a token replay attempt. Other codes like `201 Created` would be for creating a resource, `401 Unauthorized` for lack of credentials, or `409 Conflict` for a conflict issue, none of which apply directly to detecting a replay. Therefore, the best answer is A.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Token replay must be treated as 401 Unauthorized."
    },
    {
      "question_id": "EQ4029",
      "type": "Writing",
      "gold": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "Chain: 1) Apply valid coupon → 2) Click 'Apply Coupon' → 3) 4) Use expired coupon → 5) Mock payment service to fail → 6) Purchase flow should rollback with 'Coupon expired' error."
    },
    {
      "question_id": "EQ4030",
      "question": "Which chained workflow validates asynchronous payment settlement with reconciliation?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Create order only",
        "B": "Create order → capture payment → async settlement → reconcile → final status=settled",
        "C": "Refund without settlement",
        "D": "Check API health"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. This is because it represents a complete, chained workflow where each step (order creation, payment capture, asynchronous payment settlement, reconciliation, final status) is validated in sequence.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Asynchronous settlement must reconcile correctly."
    },
    {
      "question_id": "EQ5001-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để truy xuất dữ liệu từ một API?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "Truy xuất dữ liệu thường được thực hiện bằng `GET` vì nó chỉ trả về tài liệu hoặc dữ liệu cụ thể mà không cần thay đổi dữ liệu gốc. `POST` dùng để tạo mới, `PUT` dùng để cập nhật toàn bộ, `DELETE` dùng để xóa.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là phương thức chuẩn để truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5002-VN",
      "question": "Mã trạng thái HTTP 404 đại diện cho điều gì?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "OK",
        "B": "Unauthorized",
        "C": "Not Found",
        "D": "Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Not Found. Trạng thái này được sử dụng khi hệ thống tìm kiếm không thể tìm thấy một tài nguyên cụ thể trong server và client.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "404 cho biết tài nguyên được yêu cầu không thể tìm thấy."
    },
    {
      "question_id": "EQ5003-VN",
      "question": "Mục đích của phương thức HTTP POST là gì?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "Truy xuất dữ liệu",
        "B": "Gửi dữ liệu để tạo tài nguyên",
        "C": "Cập nhật tài nguyên hiện có",
        "D": "Xóa tài nguyên"
      },
      "gold_answer": "B",
      "model_raw_answer": "Gửi dữ liệu để tạo tài nguyên.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST được sử dụng để tạo tài nguyên mới với dữ liệu trong request body."
    },
    {
      "question_id": "EQ5004-VN",
      "type": "Writing",
      "gold": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "Đăng nhập với tài khoản đã tồn tại và xác minh được session được trả về."
    },
    {
      "question_id": "EQ5005-VN",
      "question": "Mã trạng thái HTTP nào trong số này có nghĩa là 'Unauthorized'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 401 là mã trạng thái HTTP có nghĩa là 'Unauthorized'.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
    },
    {
      "question_id": "EQ5006-VN",
      "type": "Writing",
      "gold": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "A valid user token or authentication header. Test ensures only authorized users can access profile."
    },
    {
      "question_id": "EQ5007-VN",
      "question": "Phương thức HTTP nào được coi là idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "PUT",
        "D": "CONNECT"
      },
      "gold_answer": "C",
      "model_raw_answer": "A. POST. Because sending the same `POST` request multiple times will have the same effect as sending it once.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "PUT là idempotent vì nhiều request giống hệt nhau có cùng một hiệu ứng."
    },
    {
      "question_id": "EQ5008-VN",
      "type": "Writing",
      "gold": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Triggers a `401 Unauthorized` với tài khoản không tồn tại."
    },
    {
      "question_id": "EQ5009-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'OK'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "A",
      "model_raw_answer": "Trạng thái mã 'OK' là 200.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK là mã thành công chuẩn."
    },
    {
      "question_id": "EQ5010-VN",
      "type": "Writing",
      "gold": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "A schema defines the expected structure and data types for API requests and responses. It acts as a contract between the API provider and consumers, ensuring consistent data exchange. Without a schema, testing becomes unrepeatable and unreliable."
    },
    {
      "question_id": "EQ5011-VN",
      "question": "Phương thức HTTP nào được sử dụng để xóa một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "D",
      "model_raw_answer": "Đáp án D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "DELETE xóa tài nguyên được chỉ định trong URL."
    },
    {
      "question_id": "EQ5012-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "1. **Action:** Send a `POST` request (e.g., to `/products`).\n2.  **Validation:** After the request, access the newly created resource's ID. \n    1. **Expected:** The ID should be present and unique (not `null` or `0`, unique)."
    },
    {
      "question_id": "EQ5013-VN",
      "question": "HTTP header nào thường được sử dụng cho các authentication token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "Accept",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Authorization.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Authorization header mang thông tin xác thực hoặc token."
    },
    {
      "question_id": "EQ5014-VN",
      "type": "Writing",
      "gold": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking simulates the behavior of real dependencies like APIs or databases during testing. Its goal is to isolate the API under test from external failures, allowing consistent and faster test execution."
    },
    {
      "question_id": "EQ5015-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Created'?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "403"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 201 Created là mã trạng thái HTTP cho biết 'Created'.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created xác nhận tạo tài nguyên thành công."
    },
    {
      "question_id": "EQ5016-VN",
      "type": "Writing",
      "gold": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "Tiêu chí: API trả danh sách không vaz lỗi khi không tìm thấy sản phẩm."
    },
    {
      "question_id": "EQ5017-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Internal Server Error'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "403",
        "D": "500"
      },
      "gold_answer": "D",
      "model_raw_answer": "B. 400 is used for bad requests, 403 is used for forbidden, and 500 is used for server errors. 200 is used for successful requests.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "500 cho biết lỗi không mong muốn phía server."
    },
    {
      "question_id": "EQ5018-VN",
      "type": "Writing",
      "gold": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Preconditions xác định điều kiện bắt đầu cần đáp ứng. Ví dụ, hệ thống cần có một tài khoản đã được tạo."
    },
    {
      "question_id": "EQ5019-VN",
      "question": "Trạng thái HTTP nào phù hợp cho quyền truy cập bị cấm với thông tin đăng nhập hợp lệ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trạng thái HTTP `403 Forbidden` được sử dụng khi một người dùng có đăng nhập nhưng quyền truy cập vào một tài nguyên nhất định bị cấm. Điều này khác với `401 Unauthorized` (đăng nhập không hợp lệ) hoặc `404 Not Found` (tài nguyên không tồn tại). `200 OK` là trạng thái bình thường cho yêu cầu thành công.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "403 Forbidden cho biết không đủ quyền hạn mặc dù đăng nhập hợp lệ."
    },
    {
      "question_id": "EQ5020-VN",
      "type": "Writing",
      "gold": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chọn một file format không được server hỗ trợ (như file audio). Send request upload file với mã body này. Expected: `400 Bad Request` hoặc `403 Forbidden`."
    },
    {
      "question_id": "EQ5021-VN",
      "question": "Phương thức HTTP nào thường được sử dụng cho các partial update?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PATCH",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "PATCH được sử dụng vì nó cho phép gửi các thay đổi nhỏ mà không cần gửi toàn bộ tài liệu.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PATCH được sử dụng để sửa đổi một phần của tài nguyên."
    },
    {
      "question_id": "EQ5022-VN",
      "type": "Writing",
      "gold": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "A test case description explains what the test case aims to verify. It's a concise summary of the test's objective and preconditions."
    },
    {
      "question_id": "EQ5023-VN",
      "question": "HTTP header nào cho biết định dạng của request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Accept-Encoding"
      },
      "gold_answer": "A",
      "model_raw_answer": "Only A is correct because Content-Type tells client and server what format the request body is in.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Type định nghĩa kiểu media của request body."
    },
    {
      "question_id": "EQ5024-VN",
      "type": "Writing",
      "gold": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "1. **Precondition:** Configured API to cache responses.\n2. **Action:** Send request for static resource.\n3. **Validation:** Check response time (< 1s)."
    },
    {
      "question_id": "EQ5025-VN",
      "question": "Mã trạng thái HTTP nào cho biết conflict, chẳng hạn như tạo tài nguyên trùng lặp?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict được sử dụng khi request conflict với trạng thái hiện tại."
    },
    {
      "question_id": "EQ5026-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'Bad Request'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 Bad Request cho biết cú pháp hoặc tham số không hợp lệ."
    },
    {
      "question_id": "EQ5027-VN",
      "type": "Writing",
      "gold": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "Send a `GET` request to `/health`. Expect the API to respond with a `200 OK` status code and a simple body like `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5028-VN",
      "question": "Phương thức HTTP nào được sử dụng để cập nhật hoàn toàn một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "Cập nhật hoàn toàn một tài nguyên được thực hiện bằng method PUT, vì nó thay đổi toàn bộ tài nguyên.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "PUT thay thế một tài nguyên hiện có bằng dữ liệu mới."
    },
    {
      "question_id": "EQ5029-VN",
      "type": "Writing",
      "gold": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "It ensures consistent and repeatable test execution with valid data."
    },
    {
      "question_id": "EQ5030-VN",
      "question": "Mã trạng thái HTTP nào cho biết 'Forbidden'?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "401",
        "D": "403"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 403.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "403 Forbidden có nghĩa là người dùng đã được xác thực nhưng không được authorization."
    },
    {
      "question_id": "EQ5031-VN",
      "type": "Writing",
      "gold": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Trả lời: Send a `POST` request với body chứa ký tự đặc biệt như `\\u00e1` (á). Expect `201 Created` nếu trường dữ liệu tồn tại. Kiểm tra database để assert không tìm thấy record với giá trị như này."
    },
    {
      "question_id": "EQ5032-VN",
      "question": "Mã trạng thái HTTP nào đại diện cho 'Too Many Requests'?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Easy",
      "options": {
        "A": "408",
        "B": "429",
        "C": "503",
        "D": "504"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 429 là mã trạng thái HTTP cho 'Too Many Requests' (Liều lượng quá nhiều).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "429 Too Many Requests được trả về khi rate limit bị vượt quá."
    },
    {
      "question_id": "EQ5033-VN",
      "type": "Writing",
      "gold": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "It confirms that API behaves exactly as expected."
    },
    {
      "question_id": "EQ5034-VN",
      "question": "Mã trạng thái HTTP nào cho biết một timeout từ server?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "400",
        "C": "200",
        "D": "504"
      },
      "gold_answer": "D",
      "model_raw_answer": "Timeout là một lỗi client, nên 400 Bad Request là lỗi không hợp lệ. 404 Not Found là lỗi client cho request không tồn tại. 200 OK là trạng thái thành công. 504 Gateway Timeout là lỗi server.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "504 Gateway Timeout cho biết server không phản hồi kịp thời."
    },
    {
      "question_id": "EQ5035-VN",
      "type": "Writing",
      "gold": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "Test case: **Delete User**. Precondition: User ID = 123 exists. Action: Send DELETE request → expect `204 No Content` response."
    },
    {
      "question_id": "EQ5036-VN",
      "question": "Phương thức HTTP nào là safe (không thay đổi trạng thái server)?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "GET là safe vì nó không thay đổi trạng thái của server.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là safe vì nó chỉ truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5037-VN",
      "type": "Writing",
      "gold": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "Mã trạng thái HTTP 201 Created được sử dụng để chỉ báo một tài nguyên đã được tạo mới."
    },
    {
      "question_id": "EQ5038-VN",
      "question": "Trạng thái HTTP nào được trả về khi một client request được định dạng tốt nhưng bị unauthorized?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "401",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả về mã status 401 Bad Request không đúng vì client request được định dạng tốt. Trả về mã status 401 Unauthorized đúng vì client không được phép. Trả về mã status 200 OK hoặc 400 Bad Request không đúng vì client request bị lỗi. Trả về mã status 500 Internal Server Error không đúng vì client request hợp lệ.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "401 Unauthorized được sử dụng cho thông tin đăng nhập không hợp lệ."
    },
    {
      "question_id": "EQ5039-VN",
      "type": "Writing",
      "gold": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "Trả về một JSON với ID và tên hợp lệ."
    },
    {
      "question_id": "EQ5040-VN",
      "question": "Mã trạng thái HTTP nào cho biết thành công nhưng không có content nào được trả về?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời: D. 204 (No Content – chỉ trả trạng thái thành công).",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content được trả về khi xóa thành công hoặc response rỗng."
    },
    {
      "question_id": "EQ5041-VN",
      "type": "Writing",
      "gold": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "It indicates the request was successful and the response body contains the resource requested."
    },
    {
      "question_id": "EQ5042-VN",
      "question": "Header nào được sử dụng để chỉ định các định dạng response được chấp nhận?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Type",
        "B": "Accept",
        "C": "Authorization",
        "D": "Cache-Control"
      },
      "gold_answer": "B",
      "model_raw_answer": "Only A (Content-Type) is correct as it defines the response format. B (Accept) is a request header, not a response header. C (Authorization) is used for authentication, not for specifying response formats. D (Cache-Control) is used to control caching behavior, not to define response formats.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Accept header cho server biết những định dạng nào được mong đợi (ví dụ: application/json)."
    },
    {
      "question_id": "EQ5043-VN",
      "type": "Writing",
      "gold": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "Send a request with an invalid or missing argument (e.g., `/users/` without ID). Expected: `400 Bad Request` hoặc `404 Not Found`. Response không được thay đổi."
    },
    {
      "question_id": "EQ5044-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi client phải authenticate để truy cập một tài nguyên?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "403",
        "C": "401",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả lời: C. 401 (Unauthorized) được sử dụng cho các yêu cầu requiring authentication. 200 (OK) không liên quan đến trạng thái auth. 403 (Forbidden) là lỗi khác vì client được phép truy cập. 404 (Not Found) không liên quan.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "401 Unauthorized yêu cầu thông tin xác thực."
    },
    {
      "question_id": "EQ5045-VN",
      "type": "Writing",
      "gold": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Test case assertion xác nhận kết quả của test case. Nó là câu lệnh `Then` hoặc `Expected` trong ngôn ngữ mô tả chức năng. Nó xác định điều gì được coi là hànhingen (đáp ứng) khi mã được thực hiện."
    },
    {
      "question_id": "EQ5046-VN",
      "question": "Trạng thái HTTP nào cho biết server không thể xử lý request do quá tải?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "503 Service Unavailable",
        "B": "200 OK",
        "C": "404 Not Found",
        "D": "201 Created"
      },
      "gold_answer": "A",
      "model_raw_answer": "Answer: A. 503 Service Unavailable – được sử dụng khi server không thể xử lý request do quá tải hoặc quá sức.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "503 cho biết quá tải tạm thời hoặc đang bảo trì."
    },
    {
      "question_id": "EQ5047-VN",
      "type": "Writing",
      "gold": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "Send a `POST` request with a valid file (e.g., `image.jpg`) and assert the response status is `200 OK`."
    },
    {
      "question_id": "EQ5048-VN",
      "question": "Phương thức HTTP nào là safe và idempotent?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PATCH",
        "C": "GET",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "GET, PATCH, and DELETE are idempotent (calling them multiple times has no different effect than once). They are also safe because they usually don't change data (except DELETE), so they don't risk damaging the system. POST is not considered safe because it can create new data with a single request.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "GET vừa là safe vừa là idempotent."
    },
    {
      "question_id": "EQ5049-VN",
      "type": "Writing",
      "gold": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "415 Unsupported Media Type được sử dụng khi server không hỗ trợ một loại dữ liệu cụ thể. Nó là mã phản hồi chung khi request gửi format không được server hỗ trợ. Nó không liên quan đến dữ liệu không được chấp nhận."
    },
    {
      "question_id": "EQ5050-VN",
      "question": "Mã trạng thái HTTP nào có nghĩa là 'Request Timeout'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "408",
        "C": "500",
        "D": "429"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. 408 là mã trạng thái HTTP có nghĩa là 'Request Timeout'.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout cho biết client mất quá nhiều thời gian để gửi request."
    },
    {
      "question_id": "EQ5051-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để tạo một tài nguyên mới?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "POST là phương thức HTTP được sử dụng để tạo một tài nguyên mới.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "POST là phương thức chuẩn để tạo tài nguyên."
    },
    {
      "question_id": "EQ5052-VN",
      "type": "Writing",
      "gold": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "*   **Định nghĩa:** Test sẽ gửi yêu cầu `POST /products` với bộ dữ liệu sản phẩm đầy đủ (id, tên, giá, mô tả, danh mục). **Kết quả:** API trả lời `201 Created` với body chứa thông tin sản phẩm mới."
    },
    {
      "question_id": "EQ5053-VN",
      "question": "Mã trạng thái HTTP nào được trả về khi một tài nguyên được xóa thành công?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "204"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả về 204 No Content vì request thành công nhưng không chứa dữ liệu.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 No Content xác nhận việc xóa thành công."
    },
    {
      "question_id": "EQ5054-VN",
      "type": "Writing",
      "gold": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "It restricts access to protected resources."
    },
    {
      "question_id": "EQ5055-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một client gửi một JSON payload không hợp lệ?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 400 Bad Request.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "400 cho biết request không thể hiểu được do cú pháp không hợp lệ."
    },
    {
      "question_id": "EQ5056-VN",
      "type": "Writing",
      "gold": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Provide a valid token in the request, then deliberately omit the authentication header."
    },
    {
      "question_id": "EQ5057-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để cập nhật hoàn toàn một tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "Cập nhật toàn bộ một tài nguyên là một hành động lớn và thường được thực hiện bằng `PUT`. `POST` được sử dụng để tạo tài nguyên mới, `PATCH` được sử dụng để cập nhật phần nào của một tài nguyên, và `DELETE` được sử dụng để xóa một tài nguyên.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "PUT thay thế hoàn toàn tài nguyên bằng dữ liệu mới."
    },
    {
      "question_id": "EQ5058-VN",
      "type": "Writing",
      "gold": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "Internal Server Error 500 được trả khi API gặp lỗi không được client hiểu, như một vấn đề server. Trong API testing, nó giúp xác định điểm lỗi internal trên server."
    },
    {
      "question_id": "EQ5059-VN",
      "question": "Trạng thái HTTP nào có nghĩa là 'Conflict'?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "409"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "409 Conflict xảy ra khi việc tạo/cập nhật tài nguyên conflict với trạng thái."
    },
    {
      "question_id": "EQ5060-VN",
      "type": "Writing",
      "gold": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "**Test Case:** **Retrieve List of Orders**\n- **Preconditions:** Đã có ít nhất 3 đơn hàng được tạo trước.\n- **Action:** Send `GET` request đến `/orders`.\n- **Expected Result:** API trả `200 OK` với mảng danh sách các đơn hàng (ví dụ: `[{id: 1, customer_id: 2},...]`)."
    },
    {
      "question_id": "EQ5061-VN",
      "question": "Phương thức HTTP nào được sử dụng cho các partial update tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH, vì nó cho phép cập nhật phần nào một tài nguyên.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH chỉ sửa đổi một phần của tài nguyên."
    },
    {
      "question_id": "EQ5062-VN",
      "type": "Writing",
      "gold": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "They provide metadata about the request and response, such as status code, content type, and caching instructions. Useful for automating API requests without needing to know the full response body."
    },
    {
      "question_id": "EQ5063-VN",
      "question": "Mã trạng thái HTTP nào được trả về khi authentication là bắt buộc nhưng bị thiếu?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trả về mã trạng thái 401 là đúng vì mã này được sử dụng để chỉ định rằng token authentication (các loại token như API key, token JWT, token OAuth, token Basic) bị thiếu hoặc không hợp lệ.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thiếu hoặc không hợp lệ thông tin đăng nhập."
    },
    {
      "question_id": "EQ5064-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "1. **Đầu vào:** Chia sẻ cùng một tài nguyên giữa hai job.\n2. **Kết quả mong đợi:** Job thứ hai nên tạo ra một tài nguyên khác biệt với job đầu tiên, không phải bản sao lặp lại."
    },
    {
      "question_id": "EQ5065-VN",
      "question": "Phương thức HTTP nào thường được sử dụng cho các read-only operation an toàn?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "POST",
        "D": "DELETE"
      },
      "gold_answer": "A",
      "model_raw_answer": "GET và DELETE đều an toàn vì không cần thay đổi nội dung. PUT và POST thường được sử dụng với data.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET là safe và read-only."
    },
    {
      "question_id": "EQ5066-VN",
      "type": "Writing",
      "gold": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "It xác định rằng request đã được xác minh và không bị từ chối vì thời hạn."
    },
    {
      "question_id": "EQ5067-VN",
      "question": "Trạng thái HTTP nào được trả về khi một tài nguyên đã được di chuyển vĩnh viễn?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "404",
        "B": "302",
        "C": "301",
        "D": "500"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả về 404 Not Found nếu tài nguyên không tìm thấy. Trả về 301 Moved Permanently hoặc 302 Found nếu di chuyển vĩnh viễn. Trả về 303 See Available or 304 Not Modified cho di chuyển tạm thời.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "301 Moved Permanently cho biết redirection."
    },
    {
      "question_id": "EQ5068-VN",
      "type": "Writing",
      "gold": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Send a `POST` request with all required fields (e.g., `user={id}`). Verify the API returns a `200 OK` status with a valid response schema in the body."
    },
    {
      "question_id": "EQ5069-VN",
      "question": "Trạng thái HTTP nào cho biết request hợp lệ nhưng không tìm thấy tài nguyên?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "201",
        "C": "400",
        "D": "404"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời: 200 OK (Hợp lệ và tìm thấy).",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "404 Not Found có nghĩa là tài nguyên không tồn tại."
    },
    {
      "question_id": "EQ5070-VN",
      "type": "Writing",
      "gold": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Response body chứa dữ liệu trả về client sau một yêu cầu. Trong API testing, bạn kiểm tra nội dung này để xác minh mã trả về, trạng thái cơ bản, hoặc các dữ liệu được tạo."
    },
    {
      "question_id": "EQ5071-VN",
      "question": "Trạng thái HTTP nào cho biết client request timeout?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "500",
        "B": "408",
        "C": "403",
        "D": "404"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trạng thái HTTP 408 (Timeout for request) cho biết client request timeout.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "408 Request Timeout có nghĩa là client không gửi xong kịp thời."
    },
    {
      "question_id": "EQ5072-VN",
      "type": "Writing",
      "gold": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "- **Action:** Click logout button.\n- **Expected:** Session count (e.g., count of authenticated users) should reset to 0."
    },
    {
      "question_id": "EQ5073-VN",
      "question": "Trạng thái HTTP nào cho biết một request thành công trả về dữ liệu JSON?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "Trả về dữ liệu JSON là một `200 OK` status code, vì nó chỉ báo request thành công và trả về dữ liệu (chính là phản ứng JSON). Các status code khác không liên quan đến trả về dữ liệu.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "200 OK là mã chuẩn cho các GET thành công."
    },
    {
      "question_id": "EQ5074-VN",
      "type": "Writing",
      "gold": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "It validates that the media type (format) in the request is not supported by the server."
    },
    {
      "question_id": "EQ5075-VN",
      "question": "Mã trạng thái HTTP nào cho biết server tạm thời ngừng hoạt động để bảo trì?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable – mã này dùng để báo cáo tình trạng tạm thời.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "503 được sử dụng khi dịch vụ không khả dụng do quá tải hoặc bảo trì."
    },
    {
      "question_id": "EQ5076-VN",
      "question": "Phương thức HTTP nào thường được sử dụng để cập nhật chỉ một phần của tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "PUT",
        "C": "PATCH",
        "D": "DELETE"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. PATCH.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "PATCH được thiết kế cho các partial update."
    },
    {
      "question_id": "EQ5077-VN",
      "type": "Writing",
      "gold": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Triggers request to `/status` with status `200 OK`. Expected: `200 OK` with body `OK`."
    },
    {
      "question_id": "EQ5078-VN",
      "question": "Trạng thái HTTP nào cho biết việc tạo tài nguyên thành công?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trả lời: B. 201 Created là mã status code dùng để báo cáo về tác vụ thành công, chẳng hạn tạo tài nguyên.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "201 Created xác nhận việc tạo tài nguyên thành công."
    },
    {
      "question_id": "EQ5079-VN",
      "type": "Writing",
      "gold": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "No Content (204) được sử dụng khi client yêu cầu một resource nhưng không muốn tải toàn bộ resource vào bộ nhớ. Server sẽ trả back header `Content-Length` nhưng không gửi body."
    },
    {
      "question_id": "EQ5080-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một request hợp lệ nhưng quyền truy cập bị cấm?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "401 Unauthorized",
        "B": "200 OK",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "403 Forbidden có nghĩa là thông tin đăng nhập hợp lệ nhưng không đủ quyền."
    },
    {
      "question_id": "EQ5081-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chỉ Send a payload với Content-Type → 400 Bad Request."
    },
    {
      "question_id": "EQ5082-VN",
      "question": "Mã trạng thái HTTP nào cho biết thành công nhưng tài nguyên rỗng?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "400 Bad Request",
        "D": "204 No Content"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 204 No Content. This status code indicates that the request was successful, but the server did not want to return the data to the client, so it returned `0`Content-Length``.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "204 được trả về khi không có body content."
    },
    {
      "question_id": "EQ5083-VN",
      "type": "Writing",
      "gold": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "The `Accept` header tells the server which response formats it supports. For example, `Accept: application/json` means the client can handle JSON data. This is important for interoperability and flexibility."
    },
    {
      "question_id": "EQ5084-VN",
      "question": "Mã trạng thái HTTP nào phù hợp cho thông tin đăng nhập không hợp lệ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trả lời: B. 401 Unauthorized là mã trạng thái HTTP phù hợp cho thông tin đăng nhập không hợp lệ.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "401 Unauthorized cho biết thông tin đăng nhập không hợp lệ."
    },
    {
      "question_id": "EQ5085-VN",
      "type": "Writing",
      "gold": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "* **Preconditions:** Một token login được tạo ra. * **Action:** Call `/logout` API. * **Expected:** Trả lời `200 OK` và DB không còn session cho user."
    },
    {
      "question_id": "EQ5086-VN",
      "question": "Phương thức HTTP nào được sử dụng để truy xuất chi tiết tài nguyên?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "gold_answer": "A",
      "model_raw_answer": "Truy xuất chi tiết tài nguyên được thực hiện bằng HTTP GET.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "GET được sử dụng để truy xuất dữ liệu."
    },
    {
      "question_id": "EQ5087-VN",
      "type": "Writing",
      "gold": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "It means authentication failed, so requests need a valid token."
    },
    {
      "question_id": "EQ5088-VN",
      "question": "Mã trạng thái HTTP nào cho biết nỗ lực tạo tài nguyên trùng lặp?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "It should be 409 Conflict, as it indicates a conflict with a resource already existing.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "409 Conflict có nghĩa là request trùng lặp hoặc conflict."
    },
    {
      "question_id": "EQ5089-VN",
      "type": "Writing",
      "gold": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "- **Preconditions:** Một tài khoản được đăng ký (ID: `user_id_123`) với một email xác định.\n- **Action:** Gửi một yêu cầu đến endpoint `POST /profile` sử dụng email unique (ví dụ: `user@example.com`).\n- **Expected:** API trả mã số `201 Created` với một bản ghi profile mới (tập tin JSON)."
    },
    {
      "question_id": "EQ5090-VN",
      "question": "Mã trạng thái HTTP nào cho biết request hợp lệ nhưng server không thể hoàn thành nó?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200",
        "B": "400",
        "C": "500",
        "D": "201"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trạng thái mã 400 là Bad Request, có nghĩa là request không hợp lệ, nhưng câu hỏi nói request hợp lệ. 500 Internal Server Error là một lỗi chung, không liên quan đến trạng thái của request. 201 Created là một trạng thái mã thành công nhưng không hoàn thành. Vì request hợp lệ nhưng server không thể hoàn thành nó, nên trả mã 400 Bad Request.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "500 Internal Server Error báo hiệu lỗi phía server."
    },
    {
      "question_id": "EQ5091-VN",
      "type": "Writing",
      "gold": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "It indicates the resource has been found and moved."
    },
    {
      "question_id": "EQ5092-VN",
      "question": "Trạng thái HTTP nào là chính xác cho một tài nguyên được cập nhật thành công bằng PUT?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "400 Bad Request"
      },
      "gold_answer": "A",
      "model_raw_answer": "Trả lời: C. 204 No Content.",
      "model_normalized_answer": "C",
      "correct": false,
      "explanation": "200 OK cho biết tài nguyên đã được cập nhật thành công."
    },
    {
      "question_id": "EQ5093-VN",
      "type": "Writing",
      "gold": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "- **Preconditions:** Tài khoản exist nhưng mật khẩu không được lưu.\n-  **Steps:** Triggers login endpoint với parameter = 'wrong_password'.\n-  **Verification:** DB không ghi nhận giao dịch tạo tài khoản."
    },
    {
      "question_id": "EQ5094-VN",
      "question": "Phương thức HTTP nào là safe và cacheable?",
      "type": "MCQ",
      "category": "General Testing",
      "difficulty": "Easy",
      "options": {
        "A": "POST",
        "B": "GET",
        "C": "PUT",
        "D": "DELETE"
      },
      "gold_answer": "B",
      "model_raw_answer": "Both GET and HEAD are safe and cacheable, but the question only offers one option. The correct answer would depend on the specific request method being tested.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "GET vừa là safe, idempotent, và cacheable."
    },
    {
      "question_id": "EQ5095-VN",
      "type": "Writing",
      "gold": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "It means the server could not fulfill the request but it is a client error."
    },
    {
      "question_id": "EQ5096-VN",
      "question": "Trạng thái HTTP nào phù hợp khi dịch vụ tạm thời quá tải?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "options": {
        "A": "201",
        "B": "200",
        "C": "503",
        "D": "404"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trạng thái HTTP 503 (Service Unavailable) phù hợp khi dịch vụ tạm thời quá tải và không thể xử lý yêu cầu hiện tại. 201 (Created) và 200 (OK) thường liên quan đến tạo tài nguyên mới thành công, 404 (Not Found) liên quan đến tài nguyên không tồn tại.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "503 Service Unavailable cho biết quá tải hoặc bảo trì."
    },
    {
      "question_id": "EQ5097-VN",
      "type": "Writing",
      "gold": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Send a valid JSON payload with email and password fields. Expected: `201 Created` with user ID in response body."
    },
    {
      "question_id": "EQ5098-VN",
      "question": "HTTP header nào chỉ định kích thước của request body?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "options": {
        "A": "Content-Length",
        "B": "Authorization",
        "C": "User-Agent",
        "D": "Cache-Control"
      },
      "gold_answer": "A",
      "model_raw_answer": "Only A is correct. Content-Length specifies the size of the request body.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Content-Length định nghĩa kích thước body theo byte."
    },
    {
      "question_id": "EQ5099-VN",
      "type": "Writing",
      "gold": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "'Happy path' là một thuật ngữ testing chỉ đơn đường hợp lệ ( successful sequence of steps )."
    },
    {
      "question_id": "EQ5100-VN",
      "question": "Mã trạng thái HTTP nào được sử dụng khi một request method không được phép trên một tài nguyên?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "405 Method Not Allowed"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 405 Method Not Allowed. This status code is used to indicate that the HTTP method used in the request is not allowed for that specific resource. For example, trying to send a `PUT` request to a resource that only accepts `GET` or `POST`.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "405 được sử dụng khi phương thức HTTP không hợp lệ cho tài nguyên."
    },
    {
      "question_id": "EQ2001-VN",
      "question": "Khi thiết kế các bài kiểm tra API, kịch bản nào thể hiện rõ nhất một **điều kiện biên** cho tham số phân trang?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gửi page=2 khi total items=200",
        "B": "Gửi page=10 khi size=10 mỗi trang và total items=100",
        "C": "Gửi page=11 khi total items=100 với size=10",
        "D": "Gửi page=1 khi size=20 và total items=300"
      },
      "gold_answer": "C",
      "model_raw_answer": "Thể hiện rõ một **điều kiện biên** cho tham số phân trang là kịch bản **bỏ qua phần trang** (chẳng hạn, gửi request cho trang thứ 2 mà API chỉ trả kết quả cho trang 1) hoặc kịch bản **đặt điều kiện không rõ ràng** (chẳng hạn, gửi request với tham số phân trang không rõ ràng, chẳng hạn page=10, size=10). \n- A. **Đáp án**. Gửi page=2 khi total items=200. Điều này cho thấy, khi API được gọi với trang thứ 2, nó phải trả lại toàn bộ dữ liệu (vì total items = 200). Đây là một cách thể hiện rõ **điều kiện biên** (câu hỏi \"Liệu API trả dữ liệu cho trang thứ n?\") cho tham số phân trang.\n- B. Gửi page=10 khi size=10 mỗi trang và total items=100. Điều này không thể coi là một **điều kiện biên** vì nó không đặt ra yêu cầu về hành động của API đối với trang 10.\n- C. Gửi page=11 khi total items=100 với size=10. Điều này không thể coi là một **điều kiện biên** vì trang 11 không tồn tại.\n- D. Gửi page=1 khi size=20 và total items=300. Điều này không thể coi là một **điều kiện biên** vì nó không đặt ra yêu cầu về hành động của API đối với trang 1.\n- E. Gửi page=3. Điều này không thể coi là một **điều kiện biên** vì nó không đặt ra yêu cầu về hành động của API đối với trang 3.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Page=11 sẽ vượt quá phạm vi có sẵn (tối đa 10), kiểm tra một sự tràn **điều kiện biên**."
    },
    {
      "question_id": "EQ2002-VN",
      "type": "Writing",
      "gold": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "Test case âm tính (negative test) gửi yêu cầu với mã token không tồn tại hoặc expired. **Mô hình:** 1. **Precondition:** Chế độ phát hành (base URL) và client ID được sử dụng. 2. **Action:** Send request với tham số `access_token` là `null` hoặc `expired` (tài khoản đã hết hạn). 3. **Expected:** Trả lời là `403 Forbidden` hoặc `400 Bad Request`."
    },
    {
      "question_id": "EQ2003-VN",
      "question": "Cách nào sau đây là hiệu quả nhất để xác thực thời gian phản hồi của API dưới **tải người dùng** mô phỏng?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi API tuần tự thủ công bằng đồng hồ bấm giờ",
        "B": "**Load test** tự động với **người dùng ảo** đồng thời",
        "C": "Thực hiện một yêu cầu duy nhất và đo thời gian phản hồi",
        "D": "**Unit testing** với các phản hồi được **mock**"
      },
      "gold_answer": "B",
      "model_raw_answer": "Tự động hóa **load test** với **người dùng ảo** (option B) là phương pháp hiệu quả nhất để đo lường thời gian phản hồi của API, vì nó giả định một lượng lớn truy vấn đồng thời mà API cần xử lý. **Unit testing** với **mocking** phản hồi (D) cũng là một cách hợp lý, nhưng nó tập trung vào việc kiểm tra lógic business và phản hồi với **mocking** ở cấp đơn. **T tuần tự thủ công** (A) là một phương pháp truyền thống, hiệu quả nhưng khó kiểm soát và không tích hợp được với các công cụ automation. **Thực hiện yêu cầu duy nhất** (C) chỉ kiểm tra phản hồi cho một trường hợp cụ thể, không phản ánh tình huống load.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Load testing** với **người dùng ảo** đồng thời mô phỏng điều kiện thực tế."
    },
    {
      "question_id": "EQ2004-VN",
      "type": "Writing",
      "gold": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path:** Triggers request với số tiền đủ (e.g., 100) và từ từ xác nhận. **Test Case Error-Path:** Triggers request với số tiền 0 hoặc không tồn tại."
    },
    {
      "question_id": "EQ2005-VN",
      "question": "Thực hành nào giúp giảm **sự flaky** của **automated API tests** chạy trong các **CI/CD pipelines**?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcode **API keys** trong các script",
        "B": "Sử dụng độ trễ ngủ ngẫu nhiên trước các **assertion**",
        "C": "Chỉ chạy **test** một lần mỗi bản phát hành",
        "D": "Sử dụng dữ liệu **test** ổn định và các **hook** thiết lập môi trường"
      },
      "gold_answer": "D",
      "model_raw_answer": "B. Sử dụng độ trễ ngủ ngẫu nhiên trước các **assertion**.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Dữ liệu **test** và thiết lập môi trường ổn định giúp giảm tính ngẫu nhiên và **sự flaky**."
    },
    {
      "question_id": "EQ2006-VN",
      "type": "Writing",
      "gold": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "By running migration scripts backward and validating database snapshots."
    },
    {
      "question_id": "EQ2007-VN",
      "question": "Điều nào sau đây thể hiện một **test case âm tính** chính xác cho việc xác thực đầu vào trên trường ngày sinh?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gửi **dateOfBirth**=‘2025-13-40’",
        "B": "Gửi **dateOfBirth**=‘1990-05-20’",
        "C": "Để trống **dateOfBirth** khi nó là tùy chọn",
        "D": "Gửi **dateOfBirth**=‘2000-01-01’"
      },
      "gold_answer": "A",
      "model_raw_answer": "A test case âm tính (invalid) cho ngày sinh là:\nA. Gửi **dateOfBirth**=‘2025-13-40’. This is an invalid date because there is no valid month (13 = January, February, March, April, May, June, July, August, September, October, November, December) in the year 2025.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Tháng/ngày không hợp lệ làm cho nó trở thành một trường hợp xác thực đầu vào **âm tính** chính xác."
    },
    {
      "question_id": "EQ2008-VN",
      "type": "Writing",
      "gold": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Giả tạo một mô hình hoặc dịch vụ giả (mock) để thay thế ngân hàng. API Thanh toán sẽ gọi vào mock để thực hiện giao dịch. Điều này cho phép kiểm tra logic mà không cần liên kết với thực tế."
    },
    {
      "question_id": "EQ2009-VN",
      "question": "Cách tiếp cận giám sát nào giúp phát hiện các đợt tăng đột biến về tỷ lệ lỗi API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Báo cáo **code coverage**",
        "B": "Kiểm tra **log** thủ công mỗi tuần",
        "C": "Cảnh báo thời gian thực trên các chỉ số tỷ lệ lỗi",
        "D": "Phân tích **code** tĩnh"
      },
      "gold_answer": "C",
      "model_raw_answer": "B. Kiểm tra **log** thủ công mỗi tuần.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Cảnh báo thời gian thực đảm bảo phát hiện ngay lập tức các đợt tăng đột biến tỷ lệ lỗi."
    },
    {
      "question_id": "EQ2010-VN",
      "type": "Writing",
      "gold": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "*   **Boundary Test:** Chia age vào giới hạn (18, 65) và send request. **Invalid Test:** Send request với age < 18 (dưới 18) hoặc > 65 (trên 65)."
    },
    {
      "question_id": "EQ2011-VN",
      "question": "Điều nào sau đây là một ví dụ về **contract validation** trong **API testing**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra độ trễ phản hồi",
        "B": "Xác thực **JSON** phản hồi khớp với **OpenAPI schema**",
        "C": "Đo tải **CPU** của máy chủ",
        "D": "**Assert** các truy vấn **SQL** từ **log**"
      },
      "gold_answer": "B",
      "model_raw_answer": "Contract validation là kiểm tra phản hồi API với **JSON Schema/OpenAPI**. Trong **API testing**, đây là một cách xác minh đầu cuối cho các yêu cầu nhập dữ liệu. Ví dụ, **API tạo tài khoản** có **JSON Schema** cho trường `email`. **Test Case** tạo tài khoản sẽ **Assertion** phản hồi chứa email đúng format.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "**Contract validation** đảm bảo các phản hồi khớp với **schema** đã xác định."
    },
    {
      "question_id": "EQ2012-VN",
      "type": "Writing",
      "gold": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "Simulate a slow or unreliable network connection by manipulating the request timeout or introducing latency in the HTTP request. This allows testers to verify error handling and retries for such scenarios."
    },
    {
      "question_id": "EQ2013-VN",
      "question": "Kịch bản nào thể hiện rõ nhất một **load test** trung gian?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "10.000 **người dùng ảo** đồng thời cho **stress testing**",
        "B": "Kiểm tra chức năng một người dùng",
        "C": "**Unit testing** một chức năng",
        "D": "100–200 **người dùng ảo** đồng thời mô phỏng lưu lượng truy cập trung bình"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. 10.000 **người dùng ảo** đồng thời cho **stress testing**.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Các **load test** trung gian mô phỏng lưu lượng truy cập người dùng vừa phải, thực tế."
    },
    {
      "question_id": "EQ2014-VN",
      "type": "Writing",
      "gold": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "Precondition: Một người dùng có tài khoản. Step: Thử đăng nhập và lấy token."
    },
    {
      "question_id": "EQ2015-VN",
      "question": "Cách tiếp cận nào giúp phát hiện các nỗ lực truy cập trái phép trong một API?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "**Penetration test** sử dụng **token** không hợp lệ hoặc thiếu",
        "B": "**Unit test** trên các chức năng hỗ trợ",
        "C": "Thành công **build** **CI pipeline**",
        "D": "Chạy API ở chế độ **debug**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Penetration test sử dụng các **tool** như **Meterpan** (test token), **Auth-Bypass** tool. Unit test chỉ kiểm tra chức năng. CI build là phần mềm được build. Debug mode chỉ giúp xem response.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "**Penetration test** tiết lộ điểm yếu trong việc xử lý ủy quyền."
    },
    {
      "question_id": "EQ2016-VN",
      "type": "Writing",
      "gold": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "1. **Action:** Send 100+ requests in 1 minute via API.\n2.  **Expected:** API trả lời `600 Bad Gateway` sau giới hạn, không phản hồi `200 OK`.\n3.  **Preconditions:** API configurated với giới hạn request/minute."
    },
    {
      "question_id": "EQ2017-VN",
      "question": "Chiến lược nào đảm bảo khả năng tái tạo của các **integration API tests**?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chạy với dữ liệu sản phẩm ngẫu nhiên",
        "B": "Sử dụng các cơ sở dữ liệu **test** được **seed** và các **script reset**",
        "C": "Hardcode **timestamp** trong các yêu cầu",
        "D": "Vô hiệu hóa các **cleanup step** sau khi **test**"
      },
      "gold_answer": "B",
      "model_raw_answer": "Chọn B vì sử dụng các cơ sở dữ liệu **test** được **seed** và các **script reset** đảm bảo rằng các **integration API tests** có thể được chạy nhiều lần với dữ liệu khác nhau và vẫn có thể được reset sau mỗi lần chạy.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Dữ liệu **test** được **seed** đảm bảo khả năng tái tạo nhất quán."
    },
    {
      "question_id": "EQ2018-VN",
      "type": "Writing",
      "gold": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "It allows testing with simulated dependent services before real deployment."
    },
    {
      "question_id": "EQ2019-VN",
      "question": "Điều nào trong số này là một **recovery step** thích hợp nếu giám sát API phát hiện lỗi **500** nhất quán?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Bỏ qua chúng cho đến bản phát hành tiếp theo",
        "B": "Thêm logic **retry** ngẫu nhiên cho tất cả các máy khách",
        "C": "Cảnh báo đội ngũ vận hành và kích hoạt **rollback** của **deployment** gần đây",
        "D": "Tắt **log** lỗi"
      },
      "gold_answer": "C",
      "model_raw_answer": "Recovery step liên quan đến cách xử lý sự kiện thất bại. Vai trò của nó là đảm bảo dịch vụ vẫn hoạt động sau sự kiện thất bại. **Bỏ qua lỗi 500 cho đến bản phát hành tiếp theo (A)** là một cách hợp lý vì nó cho phép thử nghiệm CI/CD mà không bị rò rỉ lỗi. **Cảnh báo đội ngũ vận hành và kích hoạt rollback (C)** là phản ứng khẩn cấp, không phải là bước hồi phục. **Thêm logic retry ngẫu nhiên (B)** có thể làm tình trạng tồi tệ hơn. **Tắt log lỗi (D)** là không cóaction** hồi phục.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**Rollback** và cảnh báo đảm bảo giảm thiểu nhanh chóng."
    },
    {
      "question_id": "EQ2020-VN",
      "type": "Writing",
      "gold": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "A positive test case gửi parameters hợp lệ (ví dụ: \"john.doe\" và \"Password123\") và kiểm tra phản hồi 200 OK. A boundary test case kiểm tra giới hạn: nhập \"000000\" hoặc \"ZZZ\" để xem API xử lý trường hợp biên nào."
    },
    {
      "question_id": "EQ2021-VN",
      "question": "Kịch bản nào sau đây là một ví dụ về một **chained API test case**?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi GET /status lặp đi lặp lại",
        "B": "Tạo một người dùng, sau đó sử dụng ID của người dùng đó trong GET /profile",
        "C": "Kiểm tra một endpoint với các **header** không hợp lệ",
        "D": "Đo độ trễ trung bình của một endpoint"
      },
      "gold_answer": "B",
      "model_raw_answer": "A is a chained test because it calls /status (a'simple' endpoint) and then calls /profile (which requires a /status call with the ID in the path) in quick succession, simulating a user action.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**Chained test case** phụ thuộc vào đầu ra của một API là đầu vào cho API khác."
    },
    {
      "question_id": "EQ2022-VN",
      "type": "Writing",
      "gold": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "1. **Action:** Send a `POST` request đến endpoint này với đầu đề `application/octet-stream`.\n2. **Expected:** API trả `415 Unsupported Media Type`.\n3. **Verification:** Check status code và trả lời là `415`."
    },
    {
      "question_id": "EQ2023-VN",
      "question": "Thực hành nào giúp phát hiện vi phạm **contract** sớm trong **CI/CD pipeline**?",
      "type": "MCQ",
      "category": "CI/CD & Automation Integration",
      "difficulty": "Intermediate",
      "options": {
        "A": "**Load testing** trong **production** thôi",
        "B": "Kiểm tra **regression** thủ công mỗi tháng một lần",
        "C": "**Schema validation tests** được tích hợp vào **pipeline**",
        "D": "Sử dụng **mock** cho tất cả các phụ thuộc bên ngoài"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. **Schema validation tests** được tích hợp vào **pipeline**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Automated schema validation** trong **CI/CD** phát hiện các thay đổi gây lỗi nhanh chóng."
    },
    {
      "question_id": "EQ2024-VN",
      "type": "Writing",
      "gold": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "Tìm hiểu xem API trả lời nhanh hay chậm khi DB bị kẹt. Ví dụ, nếu DB slow query cólatime = 30s, API sẽ có delay đó xuất hiện trong phản hồi thời gian."
    },
    {
      "question_id": "EQ2025-VN",
      "question": "Điều nào sau đây là một ví dụ về một **negative authorization test**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Gọi **DELETE /users** mà không có đặc quyền quản trị",
        "B": "Gọi **GET /users** với **token** hợp lệ",
        "C": "Đăng nhập với thông tin đăng nhập hợp lệ",
        "D": "Làm mới một **session token** hợp lệ"
      },
      "gold_answer": "A",
      "model_raw_answer": "Negative authorization test kiểm tra xem hệ thống ngăn chặn hành động không được phép (ví dụ: user không có quyền X) hay không. **A. Gọi DELETE /users mà không có đặc quyền quản trị:** Đây là một ví dụ về negative authorization test vì user này không có quyền X (đặc quyền quản trị), nên hành động đó nên bị chặn. **B. Gọi GET /users với token hợp lệ:** Token này cho phép user có quyền X, vì vậy đây là một **positive authorization test**. **C, D:** These are positive authorization tests.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Cố gắng xóa người dùng mà không có đặc quyền kiểm tra các hạn chế truy cập."
    },
    {
      "question_id": "EQ2026-VN",
      "type": "Writing",
      "gold": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Chuẩn bị **test case** với hành động **create** hoặc **update**. Send yêu cầu lần đầu và kiểm tra rằng DB được cập nhật một lần. Tiếp theo, gửi yêu cầu **đồng** (tương tự) và expecting không thay đổi. Finally, thử **nạp lại** (retry) sau một khoảng thời gian và kiểm tra DB không bị cập nhật thêm."
    },
    {
      "question_id": "EQ2027-VN",
      "question": "Phương pháp nào đảm bảo các **API keys** nhạy cảm không bị lộ trong quá trình **automated testing**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Hardcode chúng trong các **test script**",
        "B": "In chúng trong các **log CI/CD**",
        "C": "Lưu trữ chúng trong các **repo GitHub** công khai",
        "D": "Sử dụng các biến môi trường được mã hóa"
      },
      "gold_answer": "D",
      "model_raw_answer": "Hardcoding hoặc lưu trữ **API keys** công khai là sai vì nguy cơ lộ mật secret. Sử dụng biến môi trường được mã hóa (D) là an toàn nhất.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Các biến môi trường được mã hóa giữ bí mật an toàn."
    },
    {
      "question_id": "EQ2028-VN",
      "type": "Writing",
      "gold": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "**Boundary Test:** Chia file 5 MB thành hai phần, tải hai phần cùng API. **Invalid Test:** Tải một file quá lớn hơn giới hạn (e.g., 10 MB), API trả `413 Payload Too Large`."
    },
    {
      "question_id": "EQ2029-VN",
      "question": "Chỉ số giám sát nào sẽ tốt nhất để chỉ ra rò rỉ bộ nhớ trong một API?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Tăng đột biến độ trễ trung bình",
        "B": "Sử dụng bộ nhớ tăng dần",
        "C": "Sử dụng CPU giảm",
        "D": "Tăng ngẫu nhiên tỷ lệ **cache hit**"
      },
      "gold_answer": "B",
      "model_raw_answer": "Tăng đột biến độ trễ trung bình là chỉ số tốt nhất để chỉ ra rò rỉ bộ nhớ. Tăng đột biến độ trễ trung bình là chỉ số tốt nhất. Tăng bộ nhớ tăng dần (B) là một chỉ số khác, nhưng không phải là tốt nhất. CPU giảm (C) không liên quan đến bộ nhớ. Tỷ lệ **cache hit** ngẫu nhiên (D) không liên quan đến rò rỉ bộ nhớ.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Rò rỉ bộ nhớ biểu hiện dưới dạng sử dụng bộ nhớ liên tục tăng."
    },
    {
      "question_id": "EQ2030-VN",
      "type": "Writing",
      "gold": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "**Test Case:** Triggers endpoint không cung cấp email → expect `400 Bad Request` với mã lỗi và thông đi cụ thể."
    },
    {
      "question_id": "EQ2031-VN",
      "question": "Điều nào sau đây mô tả rõ nhất **service virtualization**?",
      "type": "MCQ",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chỉ chạy API trong **production**",
        "B": "Sử dụng bản sao cơ sở dữ liệu cục bộ",
        "C": "Mô phỏng các phụ thuộc không có sẵn với các dịch vụ ảo",
        "D": "Thay thế logic **backend** bằng các **microservice** mới"
      },
      "gold_answer": "C",
      "model_raw_answer": "The correct answer is C. **Service virtualization** is a technique where one service is replaced with a virtual version (a simulated, abstracted, or mocked version of the service) to allow testing and development before the real service is ready. This allows for more flexible and earlier testing of systems where a real dependency is unavailable or not yet deployed.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Service virtualization** cho phép kiểm tra mà không có các phụ thuộc thực."
    },
    {
      "question_id": "EQ2032-VN",
      "type": "Writing",
      "gold": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "Đầu vào: `{\"url\": \"https://api.example.com\", \"status_code\": 503}`. **Test:** 1) Send request -> `503` Response. 2) Configure retry logic -> nếu thất bại, nên thử lại sau 5 phút. 3) Expected: Request thứ 2 được chèn vào Log/DB với thời gian thực hiện khác."
    },
    {
      "question_id": "EQ2033-VN",
      "question": "Kịch bản lỗi nào thể hiện rõ nhất một lỗi phía máy khách?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "HTTP 400 Bad Request",
        "B": "HTTP 500 Internal Server Error",
        "C": "Lỗi **timeout** cơ sở dữ liệu",
        "D": "**Out-of-memory** trên máy chủ"
      },
      "gold_answer": "A",
      "model_raw_answer": "Kịch bản lỗi **Bad Request (400)** thể hiện rõ nhất một lỗi phía máy khách. Lý do là khi một client gửi một request không hợp lệ (ví dụ, một tên người dùng là rỗng, một ID không tồn tại, một format của ngày sinh sai), máy chủ sẽ trả một mã status thể hiện lỗi là `400 Bad Request`. Các lỗi khác thường được trả khi xảy ra một lỗi phía máy chủ (500), lỗi cơ bản như timeout hoặc out-of-memory, hoặc một lỗi không cụ thể (501 Not Implemented).",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "**400 Bad Request** chỉ ra yêu cầu không hợp lệ từ phía máy khách."
    },
    {
      "question_id": "EQ2034-VN",
      "type": "Writing",
      "gold": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "- **Định nghĩa:** Log record có thể được liên kết với một **trace ID** (bằng nhãn trace ID trong request). \n- **Test Case:** 1) Send request với trace ID header. 2) Check log records có matching trace ID. 3) Verificaregister match correct trace."
    },
    {
      "question_id": "EQ2035-VN",
      "question": "Kịch bản nào trong số này yêu cầu **schema validation** trong quá trình **testing**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra thời gian phản hồi API trung bình",
        "B": "Đảm bảo các trường **JSON** phản hồi khớp với định nghĩa **OpenAPI**",
        "C": "Đo **throughput** dưới **tải**",
        "D": "Phân tích **log** truy vấn **SQL**"
      },
      "gold_answer": "B",
      "model_raw_answer": "B là kịch bản yêu cầu **schema validation**. Mục đích là đảm bảo các trường JSON phản hồi (câu trả lời API) tuân thủ và hoàn toàn khớp với các định nghĩa được mô tả trong **OpenAPI/Swagger** (hoặc **API Specification**). Khảo sát này thường được thực hiện ngay trước hoặc trong quá trình **testing API**.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Schema validation** đảm bảo tính chính xác về cấu trúc của các phản hồi."
    },
    {
      "question_id": "EQ2036-VN",
      "type": "Writing",
      "gold": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "1. **Test Case Name:** Verify API Rate Limiting with Concurrent Clients.\n2.  **Preconditions:** 1) API configured with rate limit (e.g., 100 requests/min). 2) 3-5 machines (máy khách) cùng chạy request script. 3) Log collector active.\n3.  **Test Steps:** 1) Machine A–Bắt đầu gửi request (`/endpoint`) liên tục. 2) Machines B & C cũng làm tương tự. 3) Wait và kiểm tra: 1) Số request total trên API phải `< cap (điểm giới) >`. 2) Logs must show tất cả 3 máy đều bị giới hạn (e.g., `200 OK` với số lượng giới hạn). 3) Nếu API bị tấn công DDoS, phải phản hồi `429 Too Many Requests` hoặc `500 Internal Server Error`."
    },
    {
      "question_id": "EQ2037-VN",
      "question": "Điều nào sau đây cải thiện khả năng tái tạo của các **API tests** trong nhiều môi trường?",
      "type": "MCQ",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "options": {
        "A": "Sử dụng các **URL** môi trường được **hardcode**",
        "B": "Ngẫu nhiên hóa tất cả dữ liệu **test**",
        "C": "Thực hiện **test** trên dữ liệu **production**",
        "D": "Tham số hóa các **endpoint** và sử dụng cấu hình môi trường"
      },
      "gold_answer": "D",
      "model_raw_answer": "Sử dụng URL **hardcode** sẽ không linh hoạt với các môi trường khác nhau. Ngẫu nhiên hóa dữ liệu **test** giúp **test** không ảnh hưởng đến **DB** của **user**. Thực hiện **test** trên **DB** production sẽ ảnh hưởng đến **state** của **user**. Tham số hóa **endpoint** và sử dụng cấu hình môi trường linh hoạt với các môi trường.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "**Parameterization** đảm bảo cùng một logic **test** hoạt động trên các môi trường."
    },
    {
      "question_id": "EQ2038-VN",
      "type": "Writing",
      "gold": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test case tích cực (Positive):** Chèn một số điện thoại hợp lệ gửi SMS và kiểm tra xem trả lời `200 OK` là hợp lý hay không.\n- **Test case âm tính (Negative):** Chèn một số điện thoại không tồn tại hoặc đã bị chặn rồi."
    },
    {
      "question_id": "EQ2039-VN",
      "question": "Điều nào trong số này mô tả rõ nhất **performance baseline testing**?",
      "type": "MCQ",
      "category": "Performance & Load Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đo thời gian phản hồi bình thường dưới **tải** dự kiến",
        "B": "Kiểm tra API với các đầu vào không hợp lệ",
        "C": "Xác thực API so với **OpenAPI spec**",
        "D": "Mô phỏng lưu lượng truy cập **peak** gấp 10 lần"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Đo thời gian phản hồi bình thường dưới **tải** dự kiến.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Baseline testing** nắm bắt hiệu suất bình thường dự kiến."
    },
    {
      "question_id": "EQ2040-VN",
      "type": "Writing",
      "gold": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Mocking API bên ngoài cho phép kiểm tra các kịch bản thất bại mà không cần truy cập internet. Lợi thế là hệ thống được test có hành động theo cách được thiết kế."
    },
    {
      "question_id": "EQ2041-VN",
      "question": "Điều nào trong số này là một **test case** chính xác để xác thực hết hạn **session**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đăng nhập với thông tin đăng nhập hợp lệ, mong đợi **200 OK**",
        "B": "Gửi yêu cầu với **token** hợp lệ ngay sau khi đăng nhập",
        "C": "Gửi yêu cầu với **token** sau khi hết **timeout session**, mong đợi **401 Unauthorized**",
        "D": "Gửi yêu cầu không có **token**, mong đợi **200 OK**"
      },
      "gold_answer": "C",
      "model_raw_answer": "Chọn C, vì nó kiểm tra tình trạng session hết hạn, trả lời 401 khi token quá hạn. Các lựa chọn còn lại không đảm bảo kiểm tra session hết hạn.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Session** đã hết hạn phải trả về **401 Unauthorized**."
    },
    {
      "question_id": "EQ2042-VN",
      "type": "Writing",
      "gold": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "**Test Case:** Triggers request với body JSON không hợp lệ (chẳng hạn, thiếu field, giá trị không hợp lệ). **Expected Result:** API trả `400 Bad Request` hoặc `400 Bad Request` với body lỗi nhưng không bị chuyển đổi thành mã JSON."
    },
    {
      "question_id": "EQ2043-VN",
      "question": "Chiến lược nào giúp xác thực **tương thích ngược** sau khi thêm các trường tùy chọn mới?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đảm bảo các máy khách cũ vẫn hoạt động mà không cần gửi các trường mới",
        "B": "Buộc các máy khách cập nhật ngay lập tức",
        "C": "Xóa các trường cũ khỏi phản hồi",
        "D": "Yêu cầu các thay đổi **schema** phải gây lỗi"
      },
      "gold_answer": "A",
      "model_raw_answer": "Đáp án A. Nếu thêm trường tùy chọn, máy khách cũ vẫn hoạt động mà không cần trả lời trường đó. Nếu không hỗ trợ, sẽ xảy ra lỗi không được kiểm tra. Câu trả lời này đảm bảo tính tương thích và tránh thay đổi không cần thiết cho các phiên bản cũ. Các lựa chọn B, C, D không chính xác vì sẽ gây rắc rối cho người dùng cũ.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Tương thích ngược** có nghĩa là các máy khách cũ vẫn phải hoạt động mà không cần các trường mới."
    },
    {
      "question_id": "EQ2044-VN",
      "type": "Writing",
      "gold": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "1. **Action:** Send request with all required rate limiting headers (e.g., `X-RateLimit-Remaining`, `X-RateLimit-Reset`, `X-RateLimit-Limit`).\n2. **Expected:** Ensure tất cả các header này *đã được gửi* và có giá trị (bằng kiểm tra `assert` trên response)."
    },
    {
      "question_id": "EQ2045-VN",
      "question": "Cách hiệu quả nhất để kiểm tra khả năng phục hồi khi một dịch vụ **downstream** của API bị lỗi là gì?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "options": {
        "A": "Vô hiệu hóa **retry** ở máy khách",
        "B": "Ngừng **testing** cho đến khi dịch vụ phục hồi",
        "C": "Chỉ chạy **unit tests**",
        "D": "Chèn lỗi bằng cách sử dụng **chaos testing** hoặc **mock**"
      },
      "gold_answer": "D",
      "model_raw_answer": "Bằng cách **ngừng **testing** cho đến khi dịch vụ phục hồi. Nếu vô hiệu hóa **retry** (A), máy khách sẽ thất bại khi tiếp cận dịch vụ lỗi. **Unit tests** (C) chỉ kiểm tra phần đơn lẻ. Chèn lỗi bằng **mock** (D) không đảm bảo hệ thống phản hồi đúng cách khi dịch vụ lỗi được fix. **Retry** (B) cần tắt để đảm bảo hệ thống phản hồi **500** Internal Server Error khi dịch vụ lỗi không được fix.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**Chaos testing/mocks** cho phép mô phỏng có kiểm soát các lỗi phụ thuộc."
    },
    {
      "question_id": "EQ2046-VN",
      "type": "Writing",
      "gold": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Tách dữ liệu **test** giúp chạy các test độc lập, tránh thay đổi tình trạng dữ liệu giữa các test run khác nhau. Lợi thế là test tự động có thể được chạy nhiều lần mà không gây sự cố."
    },
    {
      "question_id": "EQ2047-VN",
      "question": "**Response status code** nào thích hợp cho một yêu cầu bị chặn do thiếu **authorization header**?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct response status code for a request that is blocked because it lacks an **authorization header** (a required part of the **HTTP Authentication scheme** or **HTTP Basic Authentication** in this context) is **401 Unauthorized**. This is because the client did not provide the necessary credentials to access the protected resource.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Thiếu ủy quyền dẫn đến **401 Unauthorized**."
    },
    {
      "question_id": "EQ2048-VN",
      "type": "Writing",
      "gold": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "Đề xuất: 1) Triggers -> 2) Check DB instead of cache. 3) Verify no 500 error, but graceful failure (e.g., return `not found`)."
    },
    {
      "question_id": "EQ2049-VN",
      "question": "Điều nào sau đây thể hiện một **boundary test** thích hợp cho trường độ dài mật khẩu (**min**=8, **max**=20)?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "options": {
        "A": "Kiểm tra với 7, 8, 20, và 21 ký tự",
        "B": "Chỉ kiểm tra với 10 ký tự",
        "C": "Chỉ kiểm tra với 15 ký tự",
        "D": "Chỉ kiểm tra với mật khẩu trống"
      },
      "gold_answer": "A",
      "model_raw_answer": "A valid boundary test must cover all boundary values (min, max, boundary) and invalid values. \n- **Min** = 8: Test với 8 ký tự.\n- **Max** = 20: Test với 20 ký tự.\n- **Boundary**:  Test với 19 ký tự (sau max). \n- **Invalid**: Test với 0 ký tự (trống), -1 ký tự, một ký tự đặc biệt không được cho phép, hoặc một string không có chữ cái. \n- **Invalid Input**: Test nhập mật khẩu trống.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Boundary testing** bao gồm các giá trị ở, dưới và trên giới hạn."
    },
    {
      "question_id": "EQ2050-VN",
      "type": "Writing",
      "gold": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Log một phần của dữ liệu (chẳng hạn, chỉ số truy vấn) thay vì toàn bộ. Điều này cho phép bảo mật dữ liệu nhạy cảm trong khi vẫn cung cấp thông tin hữu ích."
    },
    {
      "question_id": "EQ2051-VN",
      "question": "Phương pháp giám sát nào giúp xác định sự gia tăng độ trễ dần dần qua các tuần?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Đo thời gian bằng đồng hồ bấm giờ cho một yêu cầu duy nhất",
        "B": "Gỡ lỗi thủ công trong các sự cố",
        "C": "Phân tích xu hướng chuỗi thời gian bằng **dashboard**",
        "D": "Các chỉ số **code coverage**"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Phân tích xu hướng chuỗi thời gian bằng **dashboard**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Dashboard** và giám sát chuỗi thời gian làm nổi bật các xu hướng độ trễ."
    },
    {
      "question_id": "EQ2052-VN",
      "type": "Writing",
      "gold": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "**Test Case:**\n- **Đề bài:** Đặt hàng giá 500 USD.\n- **Động viên:** Vérify mã VAT được trả đúng (US).\n- **Đáp ứng:** Nếu DB trống, DB trả 000. Nếu quy tắc, trả US.\n\n**Test Case âm tính:**\n- **Đề bài:** Xác nhận hàng không có giá (0 USD) được xử lý đúng.\n- **Động viên:** Vérify DB trống không chứa giá.\n\n**Boundary Test Case:**\n- **Đề bài:** Đặt hàng giá 999 USD.\n- **Động viên:** Vérify mã VAT được trả đúng (US)."
    },
    {
      "question_id": "EQ2053-VN",
      "question": "Chiến lược nào đảm bảo các **contract test** vẫn hữu ích khi API phát triển?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "options": {
        "A": "Không bao giờ cập nhật **schema tests**",
        "B": "Xóa các trường tùy chọn khỏi **test**",
        "C": "Chỉ chạy các **regression test** thủ công",
        "D": "Phiên bản hóa các **schema contract** và duy trì **tương thích ngược**"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. Phiên bản hóa các **schema contract** và duy trì **tương thích ngược**.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Versioning** và **tương thích ngược** giữ cho các **contract test** đáng tin cậy."
    },
    {
      "question_id": "EQ2054-VN",
      "type": "Writing",
      "gold": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "1. **Action:** Triggers API request (e.g., `POST /orders`) via client.\n2. **Condition:** Simulate packet loss or disconnection.\n3. **Expected:** API không trả lời ngay, nhưng sau một thời gian, trả lời `500 Internal Server Error` với thông báo '`Connection timed out'`."
    },
    {
      "question_id": "EQ2055-VN",
      "question": "Kịch bản nào trong số này xác thực chính xác **observability** API bằng cách sử dụng **distributed tracing**?",
      "type": "MCQ",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "options": {
        "A": "Chỉ kiểm tra các **HTTP status codes**",
        "B": "Theo dõi một **trace ID** trên nhiều **microservice**",
        "C": "Kiểm tra việc sử dụng bộ nhớ trong các **log** máy chủ",
        "D": "Sử dụng các ghi chú **test** thủ công"
      },
      "gold_answer": "B",
      "model_raw_answer": "B là câu trả lời chính xác. **Observability API** được xác thực bằng **distributed tracing**. **Trace ID** được truyền đi cùng trên mỗi yêu cầu và cần theo dõi tại **API Gateway** hay **Load Balancer**. **Microservice** phải injecting trace context vào response. **HTTP status code** (A) không liên quan đến observability API. **Log** (C) là một nguồn observability nhưng không liên quan đến **distributed tracing**. **Test notes** (D) là cách humans ghi chú test nhưng không liên quan đến **distributed tracing**.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "**Trace ID** theo dõi các yêu cầu trên các dịch vụ."
    },
    {
      "question_id": "EQ2056-VN",
      "type": "Writing",
      "gold": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Giải pháp: 1) Triggers event (thực hiện action). 2) Verify DB query (API create user) is cleared. 3) Verify storage file (e.g., log, config) is deleted. **Test:** API setup creates test user, which is then deleted to confirm cleanup."
    },
    {
      "question_id": "EQ2057-VN",
      "question": "Điều nào sau đây chỉ ra một lỗ hổng **denial-of-service**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "options": {
        "A": "API chấp nhận yêu cầu không giới hạn mà không cần **throttling**",
        "B": "API trả về **404 Not Found**",
        "C": "**API schema** thiếu trường mô tả",
        "D": "**Unit test coverage** thấp"
      },
      "gold_answer": "A",
      "model_raw_answer": "It accepts unlimited requests without throttling.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Các yêu cầu không bị hạn chế có thể làm cạn kiệt tài nguyên, gây ra **DoS**."
    },
    {
      "question_id": "EQ2058-VN",
      "type": "Writing",
      "gold": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "Test Case: Rollback with Failed Transaction. Preconditions: Transaction with two valid steps and one failed step exists. Expected Result: Only failed steps rolled back, remaining data unchanged."
    },
    {
      "question_id": "EQ2059-VN",
      "question": "**HTTP status code** nào nên được xác thực khi một yêu cầu API được định dạng tốt nhưng bị cấm do hạn chế vai trò?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 403 Forbidden là appropriate khi một yêu cầu bị cấm do hạn chế vai trò.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**403 Forbidden** chỉ ra máy khách đã được xác thực nhưng không được ủy quyền."
    },
    {
      "question_id": "EQ2060-VN",
      "type": "Writing",
      "gold": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "Xác thực: 1) Send request with `200 OK` payload → xác thực schema. 2) Valid parameters → `200 OK`. 3) Invalid → `400 Bad Request`. 4) Endpoint-specific validation → combine schemas."
    },
    {
      "question_id": "EQ3001-VN",
      "question": "Kịch bản nào sau đây thể hiện rõ nhất một bài kiểm tra multi-hop (đa bước) liên quan đến các endpoint đăng nhập và làm mới token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Gửi yêu cầu tới GET /health",
        "B": "Nhận access token qua POST /login, sau đó sử dụng POST /refresh để gia hạn session",
        "C": "Gửi yêu cầu với token đã hết hạn tới một endpoint được bảo vệ",
        "D": "Kiểm tra trạng thái 200 trên GET /docs"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Nhận access token qua POST /login, sau đó sử dụng POST /refresh để gia hạn session.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Kiểm tra multi-hop có nghĩa là nối chuỗi đăng nhập với việc sử dụng refresh token sau đó."
    },
    {
      "question_id": "EQ3002-VN",
      "type": "Writing",
      "gold": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "1. **Mô hình:** 1 user exists, API protected.\n2. **Đầu vào:** Một request đăng nhập (HTTP `POST`) với một mật khẩu valid.\n3. **Và/Or:** Một request đến một API được bảo vệ (ví dụ `/products`).\n4. **Kết luận:** API được trả về với status `200 OK` và body valid."
    },
    {
      "question_id": "EQ3003-VN",
      "question": "Một server nên trả về mã trạng thái HTTP nào khi một refresh token đã hết hạn?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "401 Unauthorized",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả về 403 Forbidden vì điều đó cho biết token đã hết hạn và access token cần được refresh hoặc thay đổi. 401 Unauthorized không đúng vì token vẫn tồn tại. 200 OK không hợp lý vì điều đó cho biết refresh token đã được sử dụng thành công. 201 Created không liên quan.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Refresh token đã hết hạn có nghĩa là client phải đăng nhập lại → 401 Unauthorized."
    },
    {
      "question_id": "EQ3004-VN",
      "type": "Writing",
      "gold": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "Chuỗi: 1) Triggers Login API. 2) Validate session. 3) Tạo Refresh Token (if valid session). 4) Verifies refresh token (if available). Bài kiểm tra: Send login request → expect `200 OK` và refresh token được trả về. Try login với account đã bị khóa → expect `200 OK` nhưng refresh token sẽ không được trả về."
    },
    {
      "question_id": "EQ3005-VN",
      "question": "Cái nào sau đây ánh xạ một mã lỗi cụ thể của ứng dụng tới mã trạng thái HTTP chính xác?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "APP_1001 (User not found) → 404 Not Found",
        "B": "APP_2002 (Invalid password) → 201 Created",
        "C": "APP_3003 (Success) → 500 Internal Server Error",
        "D": "APP_9999 (Database error) → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct answer because it maps a specific application error (APP_1001) to the corresponding HTTP status code (404 Not Found).",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Ánh xạ lỗi người dùng không tìm thấy tới 404 là một bản dịch HTTP chính xác."
    },
    {
      "question_id": "EQ3006-VN",
      "type": "Writing",
      "gold": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Tập trung vào việc mã hóa và giải mã trong quy trình xử lý. Ví dụ, nếu mã nghiệp vụ là `ORDER_001`, thì mã trạng thái HTTP là `200 OK` (mã trạng thái cơ bản). Xác thực được khi phản hồi API trả về mã trạng thái HTTP này sau khi mã hóa và kiểm tra lại với mã nghiệp vụ."
    },
    {
      "question_id": "EQ3007-VN",
      "question": "Kịch bản nào thể hiện việc kiểm tra tiêu cực chuỗi (chained negative testing)?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Kiểm tra yêu cầu GET /status đơn lẻ",
        "B": "Đăng nhập hợp lệ sau đó truy cập /profile",
        "C": "Kiểm tra thời gian hoạt động của server với GET /health",
        "D": "Đăng nhập với mật khẩu hết hạn → 401, sau đó thử lại refresh token → 401"
      },
      "gold_answer": "D",
      "model_raw_answer": "Chọn đáp án D.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Các bài kiểm tra tiêu cực chuỗi xác thực các thất bại trên nhiều endpoint."
    },
    {
      "question_id": "EQ3008-VN",
      "type": "Writing",
      "gold": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "- **Preconditions:** APIs được khởi động. - **Test Steps:** 1) Tạo đơn hàng. 2) Thẻ thanh toán được tạo và liên kết với tài khoản. 3) Hợp đồng thanh toán được tạo và kết nối với thẻ. 4) Hoàn tiền API được gọi. - **Expected Results:** DB chứa đơn hàng, thanh toán, và khoản hoàn tiền được tìm thấy."
    },
    {
      "question_id": "EQ3009-VN",
      "question": "Mã trạng thái HTTP nào là chính xác để ánh xạ một lỗi tùy chỉnh ORDER_DUPLICATE tới HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "404 Not Found",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trạng thái HTTP 409 Conflict là chính xác nhất cho tình huống này, vì nó mô tả tình trạng lỗi nhưng vẫn chính xác. 200 OK không phù hợp vì là trạng thái OK cho yêu cầu thành công, 404 Not Found không phù hợp vì không liên quan đến dữ liệu trùng lặp, 500 Internal Server Error quá rộng và không cụ thể.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Đơn hàng trùng lặp là một xung đột → 409."
    },
    {
      "question_id": "EQ3010-VN",
      "type": "Writing",
      "gold": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case: 1) Đăng nhập -> trả token. 2) Call API khác -> sử dụng token. 3) Kiểm tra DB liên quan -> token có valid."
    },
    {
      "question_id": "EQ3011-VN",
      "question": "Kịch bản nào xác thực việc xử lý lỗi đa bước (multi-hop) chính xác trong một quy trình thương mại điện tử?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Tạo đơn hàng → chi tiết thanh toán không hợp lệ → 402 Payment Required",
        "B": "Kiểm tra kho hàng → sản phẩm tồn tại → 200 OK",
        "C": "Gọi endpoint healthcheck → 200 OK",
        "D": "Yêu cầu danh mục sản phẩm → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "Xác thực lỗi đa bước (multi-hop) cần một chuỗi các hành động thất bại và thành công, được kiểm tra qua API contract tests. Chọn A vì nó mô tả một trường hợp hợp lý (đơn hàng bị từ chối), dễ kiểm tra qua contract tests, và đảm bảo có phản hồi chính xác.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thanh toán thất bại sau khi tạo đơn hàng là một bài kiểm tra tiêu cực multi-hop."
    },
    {
      "question_id": "EQ3012-VN",
      "type": "Writing",
      "gold": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "Kiểm tra yêu cầu tham số xác thực (id) trong URL. Các mã lỗi xác thực → phản hồi 400 Bad Request (ví dụ: mã lỗi 20001 → 'Expected valid ID' → 400 Bad Request). Xác minh phản hồi đúng format."
    },
    {
      "question_id": "EQ3013-VN",
      "question": "Cái nào trong số này thể hiện một bài kiểm tra đăng nhập chuỗi cấp độ khó?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Chỉ kiểm tra GET /login-docs",
        "B": "Chỉ đăng nhập một lần và dừng lại",
        "C": "Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại",
        "D": "Kiểm tra endpoint GET /health"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Đăng nhập → làm mới token → đăng xuất → xác nhận việc làm mới thất bại.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Kết hợp nhiều endpoint vào một quy trình xác thực."
    },
    {
      "question_id": "EQ3014-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Action:** Triggers refresh token lifetime (e.g., 1 minute) to expire.\n2. **Expected Result:** API reject refresh with `400 Bad Request: no valid verification code` or `403 Forbidden: token has expired`.\n3. **Precondition:** Refresh token created with known lifetime (e.g., 1 minute)."
    },
    {
      "question_id": "EQ3015-VN",
      "question": "Ánh xạ nào là chính xác cho lỗi nghiệp vụ PAYMENT_DECLINED?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "A. 200 OK - OK cho giao dịch thành công. B. 201 Created - Tạo tài liệu mới. C. 404 Not Found - Đáp ứng không tìm thấy. D. 402 Payment Required - Vui lòng thanh toán. 201 Created không phù hợp vì nó dùng để tạo tài liệu mới.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Thanh toán bị từ chối → 402 Payment Required."
    },
    {
      "question_id": "EQ3016-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra này yêu cầu người dùng: 1) Đăng xuất khỏi session. 2) Truy cập URL session bị hủy. 3) Xác định trạng thái session là 'bỏ' (e.g.,'expired'). 4) Nhấn nút 'Hủy bỏ' (e.g., 'End Session'). Đáp án: Nếu session đã bị hủy, thử nghiệm này sẽ kiểm tra hành động hủy bỏ session hợp lệ."
    },
    {
      "question_id": "EQ3017-VN",
      "question": "Kịch bản nào ánh xạ tới mã HTTP chính xác cho một lỗi ứng dụng nội bộ?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "APP_TIMEOUT → 200 OK",
        "B": "APP_TIMEOUT → 504 Gateway Timeout",
        "C": "APP_TIMEOUT → 201 Created",
        "D": "APP_TIMEOUT → 400 Bad Request"
      },
      "gold_answer": "B",
      "model_raw_answer": "Only A correctly maps to an internal server error.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Các lỗi timeout nên ánh xạ tới 504 Gateway Timeout."
    },
    {
      "question_id": "EQ3018-VN",
      "type": "Writing",
      "gold": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "- **Action:** 1) Đăng ký (POST /register) -> email được gửi. 2) Xác minh email (Verify Email, e.g., `https://api.example.com/v1/email-verify/${emailId}`). 3) Đăng nhập (POST /login). - **Expected:** All requests phải trả `200 OK`."
    },
    {
      "question_id": "EQ3019-VN",
      "question": "Bài kiểm tra nào xác thực quyền truy cập dựa trên vai trò chuỗi?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập với vai trò user → truy cập /admin → mong đợi 403 Forbidden",
        "B": "Đăng nhập với vai trò admin → truy cập /admin → mong đợi 200 OK",
        "C": "Đăng nhập với vai trò user → xem hồ sơ → 200 OK",
        "D": "GET /health → 200 OK"
      },
      "gold_answer": "A",
      "model_raw_answer": "A is the correct answer because it demonstrates the test for valid role-based access control, where a user logs in with a user role and attempts to access an admin-only endpoint, expecting a `403 Forbidden` response.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Vai trò không khớp dẫn đến 403 là một xác thực vai trò multi-hop."
    },
    {
      "question_id": "EQ3020-VN",
      "type": "Writing",
      "gold": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Thiết kế bài kiểm tra bao gồm các kịch bản: 1) Mọi thứ bình thường, 2) Sử dụng ký tự đặc biệt bị chặn, 3) Mật khẩu đã tồn tại."
    },
    {
      "question_id": "EQ3021-VN",
      "question": "Kịch bản nào xác thực một chuỗi đăng nhập, làm mới và đăng xuất?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập → sử dụng token một lần",
        "B": "Làm mới token ngay sau khi đăng nhập",
        "C": "Chỉ đăng xuất",
        "D": "Đăng nhập → làm mới token → đăng xuất → xác nhận làm mới thất bại"
      },
      "gold_answer": "D",
      "model_raw_answer": "Chọn kịch bản A: Đăng nhập → sử dụng token một lần. Kịch bản B không cần thiết vì token được sử dụng ngay. Kịch bản C chỉ một bước, không phản ánh quy trình toàn diện. Kịch bản D mô tả một chuỗi thử nghiệm xác thực cả đăng nhập, làm mới và đăng xuất.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Chuỗi đầy đủ này kiểm tra toàn bộ vòng đời xác thực."
    },
    {
      "question_id": "EQ3022-VN",
      "type": "Writing",
      "gold": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "Tìm kiếm hồ sơ của user `user_id` sau các giao dịch."
    },
    {
      "question_id": "EQ3023-VN",
      "question": "Ánh xạ nào dịch chính xác một lỗi nghiệp vụ STOCK_OUT sang HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "201 Created",
        "D": "403 Forbidden"
      },
      "gold_answer": "B",
      "model_raw_answer": "Dịch chính xác là 409 Conflict.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Hết hàng có nghĩa là một xung đột với việc thực hiện đơn hàng, ánh xạ tới 409."
    },
    {
      "question_id": "EQ3024-VN",
      "type": "Writing",
      "gold": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra là dùng refresh token và xác suất đăng nhập. Nếu token không hoạt động sau logout, test pass."
    },
    {
      "question_id": "EQ3025-VN",
      "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi cho một quy trình giỏ hàng?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Thêm mặt hàng hợp lệ vào giỏ hàng → 200 OK",
        "B": "Thanh toán với thanh toán hợp lệ → 200 OK",
        "C": "Thêm mặt hàng → xóa mặt hàng → thanh toán → mong đợi 400 Bad Request",
        "D": "Xem giỏ hàng sau khi đăng nhập → 200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "C là kịch bản chính xác vì nó mô tả việc thêm một item, xóa item, và thanh toán đều dẫn đến 400 Bad Request, tức là kiểm tra tiêu cực chuỗi. Các kịch bản còn lại không kiểm tra tình trạng xấu.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Thanh toán giỏ hàng trống là một kịch bản tiêu cực chuỗi."
    },
    {
      "question_id": "EQ3026-VN",
      "type": "Writing",
      "gold": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "Test case: Send expired session request → expect `401 Unauthorized` not `500 Internal Server Error`. Expected: API trả mã tắt HTTP không lỗi nội bộ."
    },
    {
      "question_id": "EQ3027-VN",
      "question": "Kịch bản nào thể hiện rõ nhất việc xác thực việc hủy đơn hàng chuỗi?",
      "type": "MCQ",
      "category": "Test Case",
      "difficulty": "Hard",
      "options": {
        "A": "Tạo đơn hàng → hủy đơn hàng → GET /orders/{id} hiển thị status=cancelled",
        "B": "Hủy đơn hàng không tồn tại → 404",
        "C": "Chỉ tạo đơn hàng",
        "D": "Kiểm tra endpoint /status"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. Tạo đơn hàng → hủy đơn hàng → GET /orders/{id} hiển thị status=cancelled.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Bao gồm vòng đời của việc tạo đơn hàng → hủy bỏ → xác minh."
    },
    {
      "question_id": "EQ3028-VN",
      "type": "Writing",
      "gold": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Nếu token không hợp lệ, kiểm tra sẽ trả về lỗi vì không tương ứng với session thực. Bài kiểm tra thất bại vì nó thử nghiệm một trường hợp không được hỗ trợ."
    },
    {
      "question_id": "EQ3029-VN",
      "question": "Ánh xạ nào dịch chính xác FILE_TOO_LARGE sang HTTP?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "401 Unauthorized",
        "C": "404 Not Found",
        "D": "413 Payload Too Large"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 413 Payload Too Large. This is because the file is too large to be processed by the server, and the specific status code for this type of error is 413 Payload Too Large.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "File quá lớn nên ánh xạ tới 413."
    },
    {
      "question_id": "EQ3030-VN",
      "type": "Writing",
      "gold": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "1. **Preconditions:** Tài khoản exist, API key có. 2. **Steps:** Đăng ký vay -> `POST /loans` -> trả lãi -> phê duyệt -> từ chối. 3. **Verification:** DB có record loan, responevent specific (e.g., 'Loan Approved')."
    },
    {
      "question_id": "EQ3031-VN",
      "question": "Chuỗi nào xác thực các refresh token trên nhiều session?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Chỉ đăng nhập → đăng xuất",
        "B": "Đăng nhập → làm mới token → đăng xuất → đăng nhập lại → xác nhận refresh token cũ không hợp lệ",
        "C": "Làm mới token mà không đăng nhập",
        "D": "Kiểm tra GET /status"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đăng nhập → làm mới token → đăng xuất → đăng nhập lại → xác nhận refresh token cũ không hợp lệ.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Đảm bảo xử lý session trên nhiều lần đăng nhập."
    },
    {
      "question_id": "EQ3032-VN",
      "type": "Writing",
      "gold": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Đăng ký (Preconditions: Tài khoản chưa tồn tại)** - Viết lệnh giả người đăng nhập và tạo tài khoản.\n2. **Đặt lại mật khẩu (Preconditions: Mật khẩu đã được đặt lại)** - Chọn hành động 'Đặt lại mật khẩu' và kiểm tra mã xác minh.\n3. **Đăng nhập (Preconditions: Tài khoản tồn tại và mật khẩu đã được đặt lại)** - Viết lệnh giả người đăng nhập với thông tin đăng nhập mới."
    },
    {
      "question_id": "EQ3033-VN",
      "question": "Ánh xạ nào là chính xác để ánh xạ lỗi nghiệp vụ INVALID_COUPON?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "403 Forbidden",
        "C": "400 Bad Request",
        "D": "201 Created"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả lời: B. 403 Forbidden là lỗi chính xác nhất vì nó cho biết tài khoản không được phép thực hiện hành động đó.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Coupon không hợp lệ nên ánh xạ tới 400 Bad Request."
    },
    {
      "question_id": "EQ3034-VN",
      "type": "Writing",
      "gold": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "- **Preconditions:** File exist, user authenticated.\n- - **Upload File:** Send `POST` with file → `201 Created`.\n- - **Virus Scan:** Send `GET` /`virus` → `200 OK` with results.\n- - **Download File:** Send `GET` with ID → `302 Found` with download link.\n- - **Error:** File type forbidden → `403 Forbidden`."
    },
    {
      "question_id": "EQ3035-VN",
      "question": "Kịch bản nào xác thực ánh xạ lỗi đa bước (multi-hop) chính xác trong quy trình thanh toán?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 402",
        "B": "API thanh toán trả về APPROVED → được ánh xạ tới HTTP 404",
        "C": "API thanh toán trả về DECLINED → được ánh xạ tới HTTP 201",
        "D": "API thanh toán trả về ERROR → được ánh xạ tới HTTP 200"
      },
      "gold_answer": "A",
      "model_raw_answer": "A correct kịch bản would involve a sequence of API calls where each call results in a different status code. For a multi-hop payment process, this would mean:\n- The first call (e.g., `create_payment`) returns `202 Accepted` (not present in options, but for demonstration) and is mapped to `HTTP 200 OK`.\n- The second call (`get_payment_status`) returns `200 OK` (approved) and is mapped to `HTTP 404 Not Found` because the payment is found but the endpoint handles a `200` as successful.\n- The third call (`update_payment_status`) returns `400 Bad Request` (declined) and is mapped to `HTTP 402 Payment Required` because the endpoint for declined payments is not explicitly defined but should logically map to an error response.\n\nSo, the correct answer is:\nB. API thanh toán trả về APPROVED → được ánh xạ tới HTTP 404",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Thanh toán bị từ chối ánh xạ chính xác tới 402 Payment Required."
    },
    {
      "question_id": "EQ3036-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra yêu cầu nhập token mới sau thời gian hạn cách. Đáp án đúng là token bị khóa hoặc yêu cầu xác thực."
    },
    {
      "question_id": "EQ3037-VN",
      "question": "Ánh xạ nào là chính xác để ánh xạ RATE_LIMIT_EXCEEDED sang HTTP?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "Only D is correct because 429 Too Many Requests is the standard HTTP status code for rate limiting.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Vượt quá giới hạn tốc độ nên ánh xạ tới 429."
    },
    {
      "question_id": "EQ3038-VN",
      "type": "Writing",
      "gold": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Order Flow**\n- **Preconditions:** User exists, products available.\n- **Steps:**\n  - **Search:** `/products` với từ khóa \"Laptop\".\n  - **Add to Cart:** `/cart/add` với ID sản phẩm.\n  - **Checkout:** `/checkout` với tất cả giỏ hàng.\n- **Expected:** API trả `200 OK` với mã phản hồi."
    },
    {
      "question_id": "EQ3039-VN",
      "question": "Kịch bản nào xác thực việc kiểm tra tiêu cực chuỗi trong quy trình đặt vé?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "Đặt vé hợp lệ → 200 OK",
        "B": "Đặt vé → hủy vé → thử hoàn tiền → mong đợi 400 Bad Request",
        "C": "Xem các ghế có sẵn → 200 OK",
        "D": "Kiểm tra GET /status → 200 OK"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B. This is because it tests a negative scenario (trying to complete an invalid transaction) that is specific to a test case for a \"bad request\" status code, which is not what the positive scenarios (A, C, D) test for.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Tiêu cực chuỗi: hoàn tiền sau khi hủy là không hợp lệ."
    },
    {
      "question_id": "EQ3040-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Bài kiểm tra này đảm bảo session được mã hóa và ngăn chặn truy cập bất hợp pháp."
    },
    {
      "question_id": "EQ3041-VN",
      "question": "Chuỗi nào xác thực chính xác việc xoay vòng token với phát hiện việc sử dụng lại refresh token?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "Đăng nhập → gọi API một lần → đăng xuất",
        "B": "Đăng nhập → làm mới token → thử sử dụng lại refresh token cũ → mong đợi 401 Unauthorized",
        "C": "Chỉ đăng nhập",
        "D": "Làm mới mà không đăng nhập"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đăng nhập → làm mới token → thử sử dụng lại refresh token cũ → mong đợi 401 Unauthorized.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Việc sử dụng lại token phải bị từ chối sau khi xoay vòng để ngăn chặn các cuộc tấn công replay."
    },
    {
      "question_id": "EQ3042-VN",
      "type": "Writing",
      "gold": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "- **Preconditions:** 1) Một tài khoản được tạo với bản phát hành `vA` và ETag cụ thể. 2) Một tài nguyên được tạo với trạng thái `vA`. - **Test Case:** 1. Send `POST` với ETag `\"vA\"` và tạo tài nguyên thành công. 2. Update tài nguyên với ETag `\"vB\"` và send `PUT`. 3. Send `GET` với ETag `\"vA\"` (chỉ định) và verify phản hồi có thể là `200 OK` nếu chỉxác đồng thời xảy ra. 4. Send `GET` với ETag không chính xác → `404 Not Found`. - **Expected Result:** VD1: `200 OK` nếu chỉxác đồng thời xảy ra. VD2: `404 Not Found` nếu ETag lỗi."
    },
    {
      "question_id": "EQ3043-VN",
      "question": "Mã trạng thái HTTP nào nên được trả về khi một điều kiện tiên quyết If-Match thất bại do ETag cũ trong quá trình PUT /resource/{id}?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "412 Precondition Failed",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả về 412 Precondition Failed vì If-Match là một điều kiện tiên quyết và sẽ thất bại khi sử dụng ETag không đúng. 200 OK không đúng vì điều kiện bị vi phạm. 400 Bad Request không chính xác vì nó liên quan đến định dạng lỗi, không phải lỗi trạng thái cụ thể này. 404 Not Found không đúng vì resource vẫn tồn tại.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "ETag cũ nên ánh xạ tới 412 Precondition Failed."
    },
    {
      "question_id": "EQ3044-VN",
      "type": "Writing",
      "gold": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Chuẩn bị: 1 job = 5 phút, 2 job = 10 phút. Kiểm tra DB phản hồi nhanh → test đồng bộ."
    },
    {
      "question_id": "EQ3045-VN",
      "question": "Ánh xạ nào từ mã nghiệp vụ tới HTTP là phù hợp nhất cho RESOURCE_VERSION_CONFLICT trong quá trình cập nhật?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "404 Not Found",
        "D": "409 Conflict"
      },
      "gold_answer": "D",
      "model_raw_answer": "D. 409 Conflict – vì nó phản ánh tình trạng conflict version.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Xung đột phiên bản ánh xạ chính xác tới 409 Conflict."
    },
    {
      "question_id": "EQ3046-VN",
      "type": "Writing",
      "gold": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "Trả lời: Đăng nhập vào tài khoản test. 1. Truy cập `/authorize` với mã được cấp (code) test. 2. Truy cập `/token` với mã được cấp (code) test và kiểm tra response có chứa `scope`. 3. Gọi `resource` với scope bị thiếu và kiểm tra `403` hoặc `404`NotFound."
    },
    {
      "question_id": "EQ3047-VN",
      "question": "Mã trạng thái nào thể hiện rõ nhất một refresh token được trình bày cho một client_id sai trong một hệ thống đa người thuê (multi-tenant)?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "B",
      "model_raw_answer": "The correct answer is B, 400 Bad Request. This status code is used to indicate that the request was malformed, such as a client ID that does not exist. A 200 OK status code would imply success, which is not appropriate in this scenario. A 401 Unauthorized might be used for a correct client ID but an incorrect credentials, and a 409 Conflict is typically used for database-level conflicts, not for malformed requests.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "OAuth2 chỉ định invalid_grant (400) cho việc sử dụng client/refresh sai."
    },
    {
      "question_id": "EQ3048-VN",
      "type": "Writing",
      "gold": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "- **Tính chất 1 (Idempotency-Key):** Send identical `idempotency-key` requests twice (endpoint: `/charge` hoặc `/payment`). **Expected:** First call tạo `charge` → 200 OK, DB ghi nhận. Second call → 200 OK, DB không thay đổi. **Tính chất 2 (Idempotency):** Send request nhiều lần với cùng `idempotency-key`. **Expected:** DB chỉ ghi nhận lần đầu. **Tính chất 3 (Idempotency-Key bảo mật):** `idempotency-key` không được exposure trong API response (không phải là token open, được sử dụng chỉ với DB mapping)."
    },
    {
      "question_id": "EQ3049-VN",
      "question": "Ánh xạ trạng thái nào là chính xác cho mã nghiệp vụ INSUFFICIENT_FUNDS từ cổng thanh toán?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "402 Payment Required"
      },
      "gold_answer": "D",
      "model_raw_answer": "Payment Required status code (402) is the correct response for an insufficient funds transaction because it indicates that the funds needed for the transaction are unavailable.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Không đủ tiền → 402 Payment Required."
    },
    {
      "question_id": "EQ3050-VN",
      "type": "Writing",
      "gold": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Kiểm tra bao gồm tải file lên server, gửi request POST với file, kiểm tra trạng thái 202 (tài liệu chuyển tiếp), và tải xuống file cuối cùng."
    },
    {
      "question_id": "EQ3051-VN",
      "question": "Kịch bản nào xác thực chính xác chính sách backoff + thử lại trên các chuyển đổi 429 -> 200 của gateway?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "options": {
        "A": "API trả về 429 Too Many Requests → client thử lại với backoff → 200 OK",
        "B": "API trả về 401 Unauthorized → thử lại thành công",
        "C": "API trả về 404 Not Found → thử lại thành công",
        "D": "API trả về 500 → thử lại mà không có backoff"
      },
      "gold_answer": "A",
      "model_raw_answer": "A. API trả về 429 Too Many Requests → client thử lại với backoff → 200 OK. B, C, và D không xác thực chính xác chính sách backoff + thử lại trên các chuyển đổi 429 -> 200 của gateway.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "Thử lại với backoff lũy thừa là cần thiết để xử lý 429."
    },
    {
      "question_id": "EQ3052-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "1. **API Gateway:** Send a request with a expired session token → `403 Forbidden`. 2. **Microservice:** Call authentication endpoint with expired session → `400 Bad Request`. 3. **Database:** Verify session record was properly deleted."
    },
    {
      "question_id": "EQ3053-VN",
      "question": "Mã HTTP nào nên ánh xạ tới BUSINESS_LIMIT_EXCEEDED khi hạn ngạch (quota) trên mỗi người dùng chặn một yêu cầu hợp lệ, đã xác thực?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "Trả lời đúng: D. 429 Too Many Requests là mã status code phù hợp nhất vì nó chỉ báo lỗi khi yêu cầu số lượng quá nhiều đạt hạn. Các mã còn lại không liên quan trực tiếp tới tình huống này.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Hạn ngạch cạn kiệt ánh xạ tới 429 Too Many Requests."
    },
    {
      "question_id": "EQ3054-VN",
      "type": "Writing",
      "gold": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "1. **Preconditions:** Tạo hàng tồn kho với số lượng vừa đủ. 2. **Steps:** - **Action:** Chọn phần của đơn hàng muốn ship. - **Expected:** Hàng còn lại bị hủy, thanh toán chênh lệch hoàn tiền. 3. **Post-condition:** DB xác minh trạng thái đơn hàng, thanh toán."
    },
    {
      "question_id": "EQ3055-VN",
      "question": "Ánh xạ nào là chính xác nhất cho mã lỗi SIGNATURE_INVALID trên xác minh giao hàng webhook?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "Mã lỗi SIGNATURE_INVALID thường liên quan đến vấn đề xác thực, chẳng hạn như kiểm tra chữ ký hoặc token tham gia. 404 Not Found không phù hợp vì nó liên quan đến việc tìm kiếm một tài nguyên cụ thể và không liên quan đến vấn đề xác thực. 401 Unauthorized liên quan đến xác thực người dùng, không phải là mã lỗi này. 409 Conflict thường liên quan đến các thay đổi không được hợp nhất. 200 OK là một mã trạng thái chung và không giúp xác định vấn đề là lỗi xác thực. Do đó, 409 Conflict là một lựa chọn hợp lý vì nó liên quan đến các thay đổi không được hợp nhất, một vấn đề phổ biến với xác minh giao hàng.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Chữ ký webhook không hợp lệ nên trả về 401 Unauthorized."
    },
    {
      "question_id": "EQ3056-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập 2FA:** Send `POST /login` với thông tin đăng nhập chính xác. 2. **Xác minh mã 2FA:** Send `POST /2fa/verify` với mã 2FA sai (ví dụ: `223344` thay vì `123456`). 3. **Thử refresh token:** Send `POST /refresh` với token refresh bất hợp pháp. All three sẽ trả về mã số lỗi 401/403/400."
    },
    {
      "question_id": "EQ3057-VN",
      "question": "Mã HTTP nào thể hiện rõ nhất một tài nguyên đã bị xóa mềm (soft-deleted) được yêu cầu bởi GET /resource/{id} sau DELETE (với trạng thái có thể khôi phục)?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "404 Not Found",
        "C": "403 Forbidden",
        "D": "204 No Content"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trả lời đúng nhất là 404 Not Found, vì nó chỉ cho biết tài nguyên đó không tồn tại tại thời điểm yêu cầu. 200 OK và 204 No Content không phù hợp với trường hợp này. 403 Forbidden thường dùng cho quyền truy cập bị từ chối, không liên quan đến trạng thái của tài nguyên.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Tài nguyên đã bị xóa mềm nên được coi là không tìm thấy."
    },
    {
      "question_id": "EQ3058-VN",
      "type": "Writing",
      "gold": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Thực hiện các thao tác với DB, lưu lại kết quả mỗi bước, so sánh tổng số với kết quả trước/qua. Đảm bảo phân trang rõ ở các API khác nhau."
    },
    {
      "question_id": "EQ3059-VN",
      "question": "Ánh xạ nào là chính xác khi sự cố phụ thuộc kích hoạt mạch ngắt (circuit breaker) MỞ, khiến gateway từ chối yêu cầu ngay lập tức?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "503 Service Unavailable",
        "D": "400 Bad Request"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. 503 Service Unavailable. Gateway sẽ từ chối vì nó đã được khóa do số lỗi quá nhiều. Trả lời 200 OK sẽ giả dối, 201 Created là không hợp lệ, 400 Bad Request là mã lỗi client, nhưng 503 Service Unavailable là lỗi do dịch vụ (service unavailable).",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Mạch ngắt MỞ ánh xạ tới 503 Service Unavailable."
    },
    {
      "question_id": "EQ3060-VN",
      "type": "Writing",
      "gold": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "Đăng nhập -> các yêu cầu -> đăng xuất. **Expected:** Token bị vô hiệu hóa sau logout."
    },
    {
      "question_id": "EQ4001-VN",
      "question": "Luồng **chained** nào xác thực chính xác vòng đời đơn hàng với tạo → ghi nhận → hoàn tiền, đảm bảo **idempotency** trên các lần **retry**?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Tạo đơn hàng → **retry** hoàn tiền hai lần → hoàn tiền thất bại",
        "B": "Ghi nhận thanh toán mà không tạo đơn hàng",
        "C": "Tạo đơn hàng → ghi nhận thanh toán → **retry** ghi nhận với cùng **idempotency key** → một lần ghi nhận duy nhất → hoàn tiền thành công",
        "D": "Hoàn tiền trước khi tạo đơn hàng"
      },
      "gold_answer": "C",
      "model_raw_answer": "Chọn C vì nó đảm bảo **idempotency**: một lần ghi nhận duy nhất → hoàn tiền thành công.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**Idempotency** phải đảm bảo các lần ghi nhận trùng lặp không tạo ra nhiều lần ghi nhận."
    },
    {
      "question_id": "EQ4002-VN",
      "type": "Writing",
      "gold": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "- **State Machine:** \n    - **Initial:** Tạo tài khoản → `account_created` → kích hoạt.\n    - **Active:** Kích hoạt → `account_activated` → sử dụng.\n    - **Suspended:** Tạm ngừng → `account_suspended` → xóa khi muốn.\n    - **Deleted:** Xóa tài khoản → `account_deleted`.\n- **Test Steps:**\n    1. Tạo tài khoản → `account_created`.\n    2. Kích hoạt → `account_activated`.\n    3. Tạm ngừng → `account_suspended`.\n    4. Kích hoạt lại → `account_activated` (nếu dịch vụ hỗ trợ).\n    5. Xóa → `account_deleted`.\n- **Expected Results:**\n    - Vòng đời được quản lý chính xác.\n    - Các trạng thái không lặp nhau."
    },
    {
      "question_id": "EQ4003-VN",
      "question": "Ánh xạ nào là đúng để xử lý một giao dịch trùng lặp được phát hiện trong quá trình yêu cầu hoàn tiền?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "409 Conflict",
        "C": "403 Forbidden",
        "D": "500 Internal Server Error"
      },
      "gold_answer": "B",
      "model_raw_answer": "Trùng lặp là một trạng thái cơ bản. Hơn nữa, nó không liên quan đến lỗi cơ bản mà là một tình huống cụ thể. Do đó, phản hồi 409 Conflict (Tập hợp đã tồn tại) là phù hợp nhất.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Giao dịch trùng lặp phải ánh xạ tới **409 Conflict**."
    },
    {
      "question_id": "EQ4004-VN",
      "type": "Writing",
      "gold": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Giao dịch đầu tiên:** Initiate a transfer transaction (Step 1).\n2. **Giao dịch thứ hai:** Trigger a second transaction, this time a'save' operation (e.g., storing order details) which depends on the successful transfer.\n3. **Giao dịch thứ ba:** Attempt a 'rollback' transaction, simulating the failure of the initial transfer (e.g., reversing the account debit).\n4. **Xác minh:** Verify that the rollback transaction successfully reverses the failed transfer's effects, resulting in the account being credited back."
    },
    {
      "question_id": "EQ4005-VN",
      "question": "Kịch bản **chained** nào xác thực đúng việc truyền lỗi trong một giao dịch **distributed saga**?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Bắt đầu saga → tất cả các bước thành công",
        "B": "Bắt đầu saga → bỏ qua lỗi ở bước 2",
        "C": "Bắt đầu saga → **rollback** bị bỏ qua",
        "D": "Bắt đầu saga → bước 3 thất bại → **rollback** bù trừ của các bước 1 & 2 được thực thi"
      },
      "gold_answer": "D",
      "model_raw_answer": "B. Bắt đầu saga → bỏ qua lỗi ở bước 2.",
      "model_normalized_answer": "B",
      "correct": false,
      "explanation": "Mô hình **saga** đảm bảo các hành động bù trừ khi thất bại."
    },
    {
      "question_id": "EQ4006-VN",
      "type": "Writing",
      "gold": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "- **Test Case:** 1) Đăng nhập vào tài khoản khách hàng. 2) Thực hiện tạo đơn hàng. 3) Xử lý thanh toán. 4) Hủy đơn hàng. 5) Xác minh trạng thái đơn hàng được cập nhật thành 'Chưa giao' sau khi hủy."
    },
    {
      "question_id": "EQ4007-VN",
      "question": "Kịch bản xử lý lỗi nào tốt nhất để xác thực các kiểm tra hợp lý trong **payment APIs**?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Gửi hoàn tiền > số tiền đã ghi nhận → **400 Bad Request**",
        "B": "Gửi hoàn tiền = số tiền đã ghi nhận → **200 OK**",
        "C": "Gửi hoàn tiền < số tiền đã ghi nhận → **200 OK**",
        "D": "Hoàn tiền mà không ghi nhận → **200 OK**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Chọn kịch bản tốt nhất. Trong **payment APIs**, việc gửi hoàn tiền là một hành động logic. **400 Bad Request** là trả lời hợp lý khi gửi hoàn tiền với số tiền không hợp lệ hoặc không tồn tại. **200 OK** không hợp lý vì không xác định tình trạng. **200 OK** với số tiền < ghi nhận hoặc không ghi nhận là lỗi Business Logic. **200 OK** khi không tồn tại transaction là lỗi System.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Số tiền hoàn tiền lớn hơn số tiền đã ghi nhận phải thất bại với **400**."
    },
    {
      "question_id": "EQ4008-VN",
      "type": "Writing",
      "gold": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "Đặt mật khẩu → test đảm bảo hoạt động hạn chế sau → thử đăng nhập nhiều lần."
    },
    {
      "question_id": "EQ4009-VN",
      "question": "Ánh xạ nào tốt nhất để xác thực xử lý lỗi định dạng cho các tải trọng **JSON** bị định dạng sai?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "200 OK"
      },
      "gold_answer": "C",
      "model_raw_answer": "Trả lời: Chọn **C. 400 Bad Request** vì mã này được sử dụng cho phản hồi khi dữ liệu không hợp lệ (ví dụ, thiếu hoặc không đúng định dạng). Các mã khác không phù hợp với trường hợp này.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "**JSON** bị định dạng sai phải dẫn đến **400 Bad Request**."
    },
    {
      "question_id": "EQ4010-VN",
      "type": "Writing",
      "gold": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "1. Đăng nhập với tài khoản hợp lệ -> 2. Mở khoản vay -> 3. Triggers action registration -> 4. Đăng nhập tài khoản thất bại -> 5. Branch registration fails -> 6. Verify no DB entry created."
    },
    {
      "question_id": "EQ4011-VN",
      "question": "Luồng **chained** nào xác thực trạng thái nhất quán trong quy trình đặt phòng phân tán?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Chỉ đặt khách sạn",
        "B": "Đặt khách sạn → đặt chuyến bay → chuyến bay thất bại → đặt phòng khách sạn tự động bị hủy",
        "C": "Chỉ đặt chuyến bay",
        "D": "Đặt khách sạn và giữ đặt phòng ngay cả khi thanh toán thất bại"
      },
      "gold_answer": "B",
      "model_raw_answer": "B. Đặt khách sạn → đặt chuyến bay → chuyến bay thất bại → đặt phòng khách sạn tự động bị hủy.",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "Việc tự động hủy khách sạn đảm bảo trạng thái nhất quán trên các hệ thống."
    },
    {
      "question_id": "EQ4012-VN",
      "type": "Writing",
      "gold": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "**Kết hợp:** Simulate nhiều giao thức cập nhật đồng thời. **Vấn đề:** Nếu không đảm bảo toàn vẹn, một cập nhật lén thay đổi giá trị (VD:'status' -> 'xóa') nhưng giao thức còn cập nhật chính xác 'tên người dùng'. **Giải thích:** Test này kiểm tra xem DB được giữ nguyên khi nhiều giao thức cập nhật đồng thời."
    },
    {
      "question_id": "EQ4013-VN",
      "question": "**HTTP code** nào là đúng để xác thực kiểm tra hợp lý khi rút tiền > số dư tài khoản?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "403 Forbidden",
        "D": "400 Bad Request"
      },
      "gold_answer": "D",
      "model_raw_answer": "Answer: A. 200 OK là code hợp lý cho request successful. Trong trường hợp rút tiền > số dư, API sẽ xác thực và trả 200 OK nếu tiền sufficient, 403 Forbidden nếu insufficient, 400 Bad Request nếu format là sai. 201 Created không phù hợp.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Rút tiền quá số dư phải bị từ chối với **400 Bad Request**."
    },
    {
      "question_id": "EQ4014-VN",
      "type": "Writing",
      "gold": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Test chained cần simulate hành động ký và xác minh. Tuy nhiên, tải lên → tải xuống → xác minh giả mạo là thử thách thực tế khó xác thực. Hơn nữa, cần đảm bảo hệ thống ký tài liệu không bị ảnh hưởng khi test diễn ra."
    },
    {
      "question_id": "EQ4015-VN",
      "question": "Kịch bản nào xác thực **rollback** trạng thái khi một API cập nhật thông tin người dùng một phần và giao dịch **DB** thất bại?",
      "type": "MCQ",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "Cập nhật thất bại giữa chừng → không có thay đổi một phần nào tồn tại",
        "B": "Cập nhật thất bại giữa chừng → thay đổi một phần vẫn còn",
        "C": "Cập nhật thất bại giữa chừng → hệ thống bị lỗi",
        "D": "Cập nhật thành công mặc dù **DB rollback**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Correct answer: A. Cập nhật thất bại giữa chừng → không có thay đổi một phần nào tồn tại.",
      "model_normalized_answer": "A",
      "correct": true,
      "explanation": "**Rollback** thích hợp ngăn ngừa dữ liệu một phần/không nhất quán."
    },
    {
      "question_id": "EQ4016-VN",
      "question": "Kịch bản **chained** nào tốt nhất để xác thực **idempotency** của một **endpoint** ghi nhận thanh toán?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "POST /capture hai lần với các giá trị **Idempotency-Key** khác nhau → hai lần ghi nhận",
        "B": "POST /capture hai lần với cùng một **Idempotency-Key** → một lần ghi nhận duy nhất được ghi lại",
        "C": "POST /refund mà không ghi nhận → thành công",
        "D": "GET /capture-status một lần"
      },
      "gold_answer": "B",
      "model_raw_answer": "Tốt nhất là **B. POST /capture hai lần với cùng một Idempotency-Key → một lần ghi nhận duy nhất được ghi lại.** Vì **idempotency** là tính chất đảm bảo gọi một cách bất kỳ là có hiệu ứng nhưเดิม, và **chained** là một cách để kiểm tra tính chất này. Trong trường hợp này, **POST** với cùng **Idempotency-Key** (ví dụ: `{\"idempotency-key\": \"abc\"}`) sẽ tạo một record DB duy nhất. Tiếp theo **POST** với cùng **Idempotency-Key** (nó phải là **idempotent**), nhưng DB sẽ trả lời chỉ có một record DB được tạo (vì cập nhật record existing → không **idempotent**).",
      "model_normalized_answer": "B",
      "correct": true,
      "explanation": "**Idempotency** đảm bảo các yêu cầu trùng lặp với cùng một khóa không tạo ra nhiều lần ghi nhận."
    },
    {
      "question_id": "EQ4017-VN",
      "type": "Writing",
      "gold": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Action:** Register → `POST /register`.\n2. **Expected:** → `201 Created`.\n3. **Negative:** → `409 Conflict` (duplicated).\n4. **Upgrade:** → `202 Accepted`.\n5. **Downgrade:** → `200 OK`.\n6. **Unregister:** → `DELETE /register`."
    },
    {
      "question_id": "EQ4018-VN",
      "question": "Ánh xạ nào là đúng để xử lý mã lỗi ứng dụng **LIMIT_EXCEEDED** cho hạn ngạch API mỗi tài khoản?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "400 Bad Request",
        "C": "403 Forbidden",
        "D": "429 Too Many Requests"
      },
      "gold_answer": "D",
      "model_raw_answer": "The correct answer is D. 429 Too Many Requests. This status code is used to indicate that the request limit (often the rate limit for an API) has been exceeded. It is the standard response for **LIMIT_EXCEEDED** when the client request rate is higher than the provider-determined limit.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "Vượt quá giới hạn/hạn ngạch ánh xạ tới **429 Too Many Requests**."
    },
    {
      "question_id": "EQ4019-VN",
      "type": "Writing",
      "gold": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Distributed orders require multiple services and dependencies, making test chaining invalid for recovery tests. A simpler approach is to isolate the failed step and test recovery individually."
    },
    {
      "question_id": "EQ4020-VN",
      "question": "Luồng **chained** nào xác thực việc phát hiện lạm dụng **OAuth2 token** trên các dịch vụ?",
      "type": "MCQ",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "options": {
        "A": "Đăng nhập một lần",
        "B": "Làm mới **token** ngay lập tức",
        "C": "Đăng nhập → lấy **token** → cố gắng sử dụng **token** trong một máy khách khác → **403 Forbidden**",
        "D": "Chỉ đăng xuất"
      },
      "gold_answer": "C",
      "model_raw_answer": "C. Đăng nhập → lấy **token** → cố gắng sử dụng **token** trong một máy khách khác → **403 Forbidden**.",
      "model_normalized_answer": "C",
      "correct": true,
      "explanation": "Việc lạm dụng **token** chéo máy khách phải bị cấm."
    },
    {
      "question_id": "EQ4021-VN",
      "type": "Writing",
      "gold": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "To design a test that verifies rollback of a financial transaction, you need to simulate a scenario where a debit (ghi nợ) is successfully recorded, followed by a credit (ghi có) to the exact opposite amount. After the system is configured to fail rollbacks, the test must inject a failure signal into the database or system state immediately after the debit is recorded. The expected outcome is that the debit transaction is reversed, and its records ( debit amount, timestamp) are removed from the database."
    },
    {
      "question_id": "EQ4022-VN",
      "question": "Kịch bản nào tốt nhất để xác thực xử lý lỗi định dạng cho sự không khớp đầu vào **XML vs JSON**?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "Gửi thân **XML** với **Content-Type: application/json** → **415 Unsupported Media Type**",
        "B": "Gửi thân **JSON** với **application/json** → **200 OK**",
        "C": "Gửi thân **XML** với **application/xml** → **200 OK**",
        "D": "Gửi **YAML** → **200 OK**"
      },
      "gold_answer": "A",
      "model_raw_answer": "Kịch bản tốt nhất là gửi thân **XML** với **Content-Type: application/xml** → **415 Unsupported Media Type**. Lỗi 415 là lỗi không hỗ trợ phương thức HTTP này. Nếu gửi **JSON** hoặc **XML** với **Content-Type: application/json** hoặc **Content-Type: application/xml**, thì server sẽ trả **200 OK** cho yêu cầu.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Sự không khớp trong thân so với **header** phải dẫn đến **415**."
    },
    {
      "question_id": "EQ4023-VN",
      "type": "Writing",
      "gold": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Đặt hàng → 2) Xác nhận phân bổ → 3) Vận chuyển → 4) Trả lại → 5) Ký hợp đồng → expected: hàng được phân bổ đúng cách."
    },
    {
      "question_id": "EQ4024-VN",
      "question": "**HTTP status** nào là đúng khi xảy ra lỗi xác thực **schema** cho một trường lồng nhau?",
      "type": "MCQ",
      "category": "Contract & Schema Validation",
      "difficulty": "Very Hard",
      "options": {
        "A": "201 Created",
        "B": "500 Internal Server Error",
        "C": "400 Bad Request",
        "D": "404 Not Found"
      },
      "gold_answer": "C",
      "model_raw_answer": "Bad Request (400) là status lỗi khi request không hợp lệ. Internal Server Error (500) xảy khi server không thể xử lý. 201 Created không liên quan vì trường lồng nhau chưa được tạo. 404 Not Found không liên quan vì lỗi không về dữ liệu.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Lỗi xác thực **schema** phải trả về **400**."
    },
    {
      "question_id": "EQ4025-VN",
      "type": "Writing",
      "gold": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "- **Action 1:** Triggers đăng nhập và mã hóa token.\n- **Action 2:** Triggers làm mới token.\n- **Action 3:** Triggers đăng xuất và xóa token.\n- **Action 4:** Triggers làm mới token với ID cũ → `401 Unauthorized` được trả về."
    },
    {
      "question_id": "EQ4026-VN",
      "question": "Kịch bản **chained** nào xác thực **rollback** thích hợp sau khi đặt phòng nhiều bước (chuyến bay + khách sạn) khi thanh toán thất bại?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Đặt chuyến bay → **200 OK**",
        "B": "Đặt khách sạn → **200 OK**",
        "C": "Đặt chuyến bay + khách sạn → thanh toán thành công",
        "D": "Đặt chuyến bay + khách sạn → thanh toán thất bại → **rollback** cả hai đặt phòng"
      },
      "gold_answer": "D",
      "model_raw_answer": "Only D describes a **chained** contract where a single failure triggers rollback.",
      "model_normalized_answer": "D",
      "correct": true,
      "explanation": "**Rollback** đảm bảo không còn đặt phòng không nhất quán."
    },
    {
      "question_id": "EQ4027-VN",
      "type": "Writing",
      "gold": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "Chained test: 1) Đăng nhập, gửi email → mail sent là true. 2) Mở email → mail sent là false. 3) Hủy đăng ký → API không gửi email nữa."
    },
    {
      "question_id": "EQ4028-VN",
      "question": "Ánh xạ nào là đúng cho mã ứng dụng **TOKEN_REPLAY_DETECTED**?",
      "type": "MCQ",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "401 Unauthorized",
        "D": "409 Conflict"
      },
      "gold_answer": "C",
      "model_raw_answer": "Answer: A. 200 OK. Mã ứng dụng **TOKEN_REPLAY_DETECTED** được sử dụng khi server xác minh token đã được tạo và chưa bị giả mạo. Vấn đề này thường được trả lời bằng **200 OK** vì nó chỉ xác minh tính hợp lệ của token mà không tạo ra một resource mới.",
      "model_normalized_answer": "A",
      "correct": false,
      "explanation": "Tái sử dụng **token** phải được xử lý như **401 Unauthorized**."
    },
    {
      "question_id": "EQ4029-VN",
      "type": "Writing",
      "gold": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chained: 1) Đưa hàng (shipment) và áp dụng giảm giá → 2) Thanh toán (payment) → 3) Giảm giá không hợp lệ → **rollback** (vệ sinh DB với mã giảm giá không tồn tại)."
    },
    {
      "question_id": "EQ4030-VN",
      "question": "Luồng **chained** nào xác thực việc thanh toán không đồng bộ với đối chiếu?",
      "type": "MCQ",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "options": {
        "A": "Chỉ tạo đơn hàng",
        "B": "Tạo đơn hàng → ghi nhận thanh toán → đối chiếu không đồng bộ → trạng thái cuối cùng=đã đối chiếu",
        "C": "Hoàn tiền mà không đối chiếu",
        "D": "Kiểm tra tình trạng API"
      },
      "gold_answer": "B",
      "model_raw_answer": "Chained order created → payment processed → order status updated → no async validation → state'shipped' only when paid.",
      "model_normalized_answer": "model not anwser",
      "correct": false,
      "explanation": "Thanh toán không đồng bộ phải đối chiếu chính xác."
    }
  ],
  "writing_for_review": [
    {
      "question_id": "EQ5004",
      "question": "Write one simple positive test case for a login API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user exists with a valid password.\n- **Test Steps:** Send a `POST /login` request with a valid username and password (e.g., `{\"username\": \"testuser\", \"password\": \"TestPassword123\"}`).\n- **Expected Result:** The API returns a `200 OK` status code with a login token in the response."
    },
    {
      "question_id": "EQ5006",
      "question": "What is a common precondition for testing a user profile endpoint?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "User must be logged in and have a valid token.",
      "model_answer": "A valid user account and appropriate permissions (e.g., admin or regular user) are necessary. Additionally, the user's profile should already exist in the database."
    },
    {
      "question_id": "EQ5008",
      "question": "Write a simple negative test for a register API.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Send a `POST` request with an invalid user ID (e.g., 999) and assert that the response status is `404 Not Found`."
    },
    {
      "question_id": "EQ5010",
      "question": "What is the role of a schema in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure of the API request body, headers, and query parameters. It ensures consistent data formatting across tests."
    },
    {
      "question_id": "EQ5012",
      "question": "Write a simple test step for validating a 201 Created response.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "Send a `POST` request with valid data. Expected: The response status code should be `201 Created`."
    },
    {
      "question_id": "EQ5014",
      "question": "What is the purpose of mocking in API testing?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependent systems (like databases or other microservices) with simulated versions during testing. This allows tests to be run independently of the full infrastructure, making them faster and more reliable. It ensures the API behaves as expected without relying on external systems."
    },
    {
      "question_id": "EQ5016",
      "question": "Write one easy test case for an API that fetches product list.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "**Test Case: Get Product List**\n- **Preconditions:** API is running, product with ID=123 exists.\n- **Test Step:** Call `GET /products` endpoint.\n- **Expected Result:** API returns `200 OK` with a valid JSON array of products."
    },
    {
      "question_id": "EQ5018",
      "question": "What is the purpose of a precondition in a test case?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "A precondition is a state that must be true before a test case can be executed. It ensures that the test runs under controlled conditions."
    },
    {
      "question_id": "EQ5020",
      "question": "Write one negative test for file upload with an unsupported format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Negative Test: Upload a file in a format unsupported by the server (e.g., an executable or a proprietary format). Expected Result: The upload fails with an appropriate error message (e.g., 'File type not allowed')."
    },
    {
      "question_id": "EQ5022",
      "question": "What is the purpose of a test case description?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "To explain the objective and scope of a test scenario.",
      "model_answer": "The purpose of a test case description is to provide a clear and concise explanation of what the test case aims to verify. It serves as a summary of the test's objectives, preconditions, and expected results."
    },
    {
      "question_id": "EQ5024",
      "question": "Write a test step to validate response time under 1 second.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "1. Send request and record timestamp.\n2. Compare with threshold (e.g., 500ms).\n3. Verify response status code."
    },
    {
      "question_id": "EQ5027",
      "question": "Write one simple positive test for GET /health endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "1. **Test:** Send a `GET` request to `/health`. \n2.  **Expected:** The API returns a successful `200 OK` status code with a simple response like 'healthy'."
    },
    {
      "question_id": "EQ5029",
      "question": "What is the purpose of using test data management in API testing?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management provides consistent and reliable data for API testing, eliminating the need to hardcode sensitive information. It improves test repeatability, reduces manual data creation efforts, and enhances overall test efficiency."
    },
    {
      "question_id": "EQ5031",
      "question": "Write one easy negative test case for an API expecting JSON format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "Send a `GET` request to a non-existent resource and assert that the response body does not contain the expected `{\"id\": 1}` JSON key."
    },
    {
      "question_id": "EQ5033",
      "question": "What is the role of assertions in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions verify conditions in API responses. They validate status codes, error messages, and data consistency, helping detect bugs early in testing."
    },
    {
      "question_id": "EQ5035",
      "question": "Write a test case to check DELETE /users/{id} works correctly.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "Create a user, send a DELETE request, and verify the user is now gone from the database."
    },
    {
      "question_id": "EQ5037",
      "question": "What does HTTP status 201 Created indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "A new resource has been successfully created.",
      "model_answer": "That the resource was successfully created."
    },
    {
      "question_id": "EQ5039",
      "question": "Write one simple test for GET /users/{id} returning correct response.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test involves sending a GET request to `/users/123` and asserting the HTTP status code is `200 OK`."
    },
    {
      "question_id": "EQ5041",
      "question": "What is the purpose of a 200 OK response?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It confirms that the request has succeeded.",
      "model_answer": "It indicates the request was successful and the resource exists."
    },
    {
      "question_id": "EQ5043",
      "question": "Write one negative test to validate response for an invalid endpoint.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "Send a request to an endpoint with a missing or invalid parameter (e.g., `/users/123` without a `page` parameter). The server response should not be `200 OK`, but instead a `404 Not Found` or a custom error with a clear message."
    },
    {
      "question_id": "EQ5045",
      "question": "What does a test case assertion do?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion is a statement (e.g., 'assert that the total is 100') that defines what the correct outcome should be. It is the 'what' part of what the test case is verifying."
    },
    {
      "question_id": "EQ5047",
      "question": "Write one positive test for file upload endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "**Positive Test: File Upload**\n1. **Action:** Send a `POST` request to the file upload endpoint.\n2. **Condition:** The API should accept a valid file (e.g., `image.jpg`) and return a successful `201 Created` response with a specific upload ID."
    },
    {
      "question_id": "EQ5049",
      "question": "What is the role of 415 Unsupported Media Type?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "415 is an unsupported media type. Its role is to indicate that the client understands the format but the server cannot validate it. It's commonly used in POST requests for payloads not defined by the resource's URI."
    },
    {
      "question_id": "EQ5052",
      "question": "Write a simple positive test for checking product details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "Send a `GET` request to `/products/123` with a valid ID. Expected result: `200 OK` with a JSON object containing product name, price, and description."
    },
    {
      "question_id": "EQ5054",
      "question": "What is the purpose of using Authorization headers in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The Authorization header is used to include a valid token or credential in requests, allowing clients to access protected resources. In testing, it simulates a valid session or permission level."
    },
    {
      "question_id": "EQ5056",
      "question": "Write a negative test case for an API requiring authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "Send a request without a valid authentication token. Expected result: `401 Unauthorized` status code."
    },
    {
      "question_id": "EQ5058",
      "question": "What is the role of 500 Internal Server Error in API testing?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "It indicates an unexpected condition that occurred on the server."
    },
    {
      "question_id": "EQ5060",
      "question": "Write one positive test case for an API returning list of orders.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "**Test Case: Get Orders**\n- **Preconditions:** User authenticated, 3 orders existing.\n- **Test Steps:** Call `/orders` endpoint → expect `200 OK`, array of valid orders with IDs, `200` indicates successful retrieval of multiple resources.\n- **Expected Result:** No errors, correct data format."
    },
    {
      "question_id": "EQ5062",
      "question": "What is the function of response headers in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "They provide metadata about responses, such as `Location` for redirects or `ETag` for caching validation."
    },
    {
      "question_id": "EQ5064",
      "question": "Write one negative test for creating a duplicate resource.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Create Resource A with ID=1. Send `POST /resources` again with the same data as Resource A. Expected Result: `201 Created` is not returned, and Resource B should not exist."
    },
    {
      "question_id": "EQ5066",
      "question": "What is the role of 202 Accepted in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "202 Accepted is a status code indicating the request was successful but resulted in one or more unintended changes. It's often used for `PUT` or `PATCH` operations that modify the resource."
    },
    {
      "question_id": "EQ5068",
      "question": "Write one easy positive test for checking API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "A simple positive test is to call an endpoint with a known valid parameter (e.g., `id=123`) and assert that the response body contains the expected `status` field with value `200` (or `201`, etc.)."
    },
    {
      "question_id": "EQ5070",
      "question": "What is the purpose of response body in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body is the main data section returned by an API in an HTTP response. In API testing, it's used to verify that the API returns the expected data format, content, and structure (e.g., JSON, XML, text) for specific endpoints and under various conditions."
    },
    {
      "question_id": "EQ5072",
      "question": "Write one test case for verifying logout functionality.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "Test Case: Logout Functionality\n- Log in successfully.\n- Perform logout action (e.g., click logout button).\n- Expected Result: The user session should be cleared, and access to protected pages should be denied."
    },
    {
      "question_id": "EQ5074",
      "question": "What does a 415 Unsupported Media Type error validate?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "That the server rejects unsupported request body formats.",
      "model_answer": "It validates that the Accept header sent by the client indicates support for the `415` media type."
    },
    {
      "question_id": "EQ5077",
      "question": "Write one simple positive test for GET /status endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "The positive test is: `GET /status` → `200 OK` with a simple `{\"status\": \"healthy\"}` response."
    },
    {
      "question_id": "EQ5079",
      "question": "What does a 204 No Content response mean?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content is a successful request response that indicates the server understood the client's request and there is no content to send in the response body. It's often used for `DELETE` or `PATCH` requests where only the server's state changes."
    },
    {
      "question_id": "EQ5081",
      "question": "Write a negative test case for sending an invalid Content-Type header.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "Send a request with a `Content-Type` header like `application=csv`. The server should either return a `415 Unsupported Media Type` error or change the format to something unsupported."
    },
    {
      "question_id": "EQ5083",
      "question": "What is the purpose of the Accept header in API requests?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header tells the server which content types the client can understand and process. It prevents the client from receiving data it cannot handle."
    },
    {
      "question_id": "EQ5085",
      "question": "Write a simple test case for a successful logout API call.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Logout API**\n- **Preconditions:** User logged in with valid session.\n- **Test Steps:** Send `POST` request to `/logout`.\n- **Expected Result:** `200 OK` and no new session created."
    },
    {
      "question_id": "EQ5087",
      "question": "What is the meaning of 401 Unauthorized in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "It means the client must provide valid authentication credentials.",
      "model_answer": "A 401 Unauthorized response indicates that the client authentication details (e.g., API key, username, password) for the request are missing or invalid. It is similar to a login failure."
    },
    {
      "question_id": "EQ5089",
      "question": "Write one easy positive test case for checking profile details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test creates a user with valid details (name, email, password) and retrieves it successfully."
    },
    {
      "question_id": "EQ5091",
      "question": "What is the purpose of 302 Found in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates temporary redirection to another URL.",
      "model_answer": "The 302 Found status code indicates that the client requested a resource that can be found under a different URL. It is a `3xx` redirect response, telling the client to access the resource located at the URL provided in the `-location` header. This allows caching and is common for redirects to alternative endpoints."
    },
    {
      "question_id": "EQ5093",
      "question": "Write a test case for negative login attempt with wrong password.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "Preconditions: User exists with correct password. Test: Send wrong password → expect `401 Unauthorized` status code, not login success."
    },
    {
      "question_id": "EQ5095",
      "question": "What does 422 Unprocessable Entity indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "It means the server could not process the request."
    },
    {
      "question_id": "EQ5097",
      "question": "Write a positive test for POST /users endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "Send a valid user creation payload with a unique username. \nExpected: `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5099",
      "question": "What does the term 'happy path' mean in testing?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most direct and successful sequence of steps in a system or process. In testing, it is the expected flow of actions that leads to a positive outcome, such as logging in successfully."
    },
    {
      "question_id": "EQ2002",
      "question": "Explain how you would design a negative test case for an API endpoint that requires OAuth2 Bearer tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Send a request to the endpoint without including a valid OAuth2 Bearer token. The expected result is a `401 Unauthorized` status code, indicating that the request could not be fully understood without proper authentication credentials."
    },
    {
      "question_id": "EQ2004",
      "question": "Provide one happy-path and one error-path test case for a payment refund API endpoint.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "**Happy Path:** Send a `POST` request with a valid refund ID and amount, expecting a `200 OK` response. **Error Path:** Send a request with an invalid refund ID, expecting a `400 Bad Request` status code."
    },
    {
      "question_id": "EQ2006",
      "question": "How would you validate schema changes in a backward-compatible API upgrade?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "Run contract tests, update client generation, and ensure no existing clients fail."
    },
    {
      "question_id": "EQ2008",
      "question": "Explain how mocking can be used to test a payment API without calling the real bank service.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "Mocking allows you to simulate the payment processing function without actually calling the bank. The API will interact with a mock bank service, which will be configured to either succeed or fail according to the test. This isolates the payment API from external dependencies."
    },
    {
      "question_id": "EQ2010",
      "question": "Design one boundary test and one invalid test for an API field `age` (range 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "Boundary Test: `POST /registration` with `age` = 65 (valid boundary). Invalid Test: `POST /registration` with `age` = 0 (too young)."
    },
    {
      "question_id": "EQ2012",
      "question": "Explain how you would simulate a network timeout error in API testing.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "By configuring a mock server to simulate a slow connection or by using a network emulator like WireMock with a timeout configuration."
    },
    {
      "question_id": "EQ2014",
      "question": "Give one example of an API precondition and one step that follows it.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "Precondition: A user's session token is required. \nStep: The API call for creating a new order must include this token."
    },
    {
      "question_id": "EQ2016",
      "question": "Write one test case to validate that API rate limiting is enforced correctly.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "1. **Test Case: Rate Limit Enforcement**\n\t* **Preconditions:** API rate limit (e.g., 100 requests/min) is active.\n\t* **Steps:**\n\t\t1. Send `GET /resources` repeatedly until the limit is reached (e.g., 101 requests).\n\t\t2. The API should return a `429 Too Many Requests` status code with a `rateLimitRemaining` count after the limit is exceeded.\n\t* **Expected Result:** No unauthorized requests are accepted after the limit is reached."
    },
    {
      "question_id": "EQ2018",
      "question": "Explain one advantage of using service virtualization in API testing.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "It allows testing with simplified or mock services before real ones are ready."
    },
    {
      "question_id": "EQ2020",
      "question": "Describe how to design one positive and one boundary test case for a login API requiring username and password.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "Positive Test (Valid Login): Input valid username and password → expect `200 OK` with token. Boundary Test: Input shortest allowed username (e.g., 'abc') → expect `200 OK` with token."
    },
    {
      "question_id": "EQ2022",
      "question": "Write one test step to validate that an API correctly returns 415 Unsupported Media Type.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Send a request with a non-accepted media type (e.g., 'image/base64'). The expected result is a `200 OK` status code with a payload like `{ \"status\": \"okay\" }` and a `VND` header for `unsupported-media-type`."
    },
    {
      "question_id": "EQ2024",
      "question": "Describe one way to test observability when an API experiences a slow database query.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Inject a latency injection tool into the database connection pool. Verify that the API's response time is properly highlighted in a monitoring tool like Prometheus or Datadog. Example: inject a 2-second delay between API request processing and the first database query execution."
    },
    {
      "question_id": "EQ2026",
      "question": "Explain how you would test API idempotency for a retry scenario.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Send the same request multiple times. Expected: All requests should return `200 OK`, no new entries should appear in a retry log, and state should not change."
    },
    {
      "question_id": "EQ2028",
      "question": "Give one boundary and one invalid test for a file upload API accepting max 5 MB files.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "Boundary: Upload a 5 MB file and verify the response. Invalid Test: Attempt to upload a file larger than 5 MB (e.g., 10 MB) and expect a `413` (Payload Too Large) error."
    },
    {
      "question_id": "EQ2030",
      "question": "Write a test case to validate proper error handling when an API is called with a missing required field `email`.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "**Test Case: Missing Email**\n- **Precondition:** API endpoint for creating an account.\n- **Test Step:** Send `POST` request to `/register` (e.g., `https://api.example.com/register`) **without** a `email` field in the payload.\n- **Expected Result:** The API returns a `400 Bad Request` or `401 Unauthorized` status code with a clear error message indicating that the `email` field is required."
    },
    {
      "question_id": "EQ2032",
      "question": "How would you design a test to validate retry logic when an API occasionally returns 503?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "1. **Precondition:** Set up a mock server to simulate a 503 Bad Gateway response. 2. **Test Steps:** 1) Send a `POST` request with a timeout (e.g., 5 seconds). 2) Verify that the initial request fails with a `Gateway Timeout` error or a `503` response. 3) The retry mechanism should then kick in, and subsequent requests should succeed. 4) Ensure the retry count is capped."
    },
    {
      "question_id": "EQ2034",
      "question": "Write a test case that validates log correlation using a trace ID header.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "Test sends a request with a unique trace ID → expect logs matched by that ID in the test case. Verify logs associated with correct span ID and level (e.g., 'INFO 12345') are retrieved. Fail if logs not found or mismatched."
    },
    {
      "question_id": "EQ2036",
      "question": "Design one intermediate-level test case for validating API rate limiting when multiple clients are involved.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "Test sends 5 requests instantly, then verify 3/5 of requests are rate-limited with `200 OK` and count is correct."
    },
    {
      "question_id": "EQ2038",
      "question": "Describe one positive and one negative test case for an API endpoint that sends SMS codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "Positive Test: Send a request with a valid phone number and expected response is `200 OK` with a successful message. Negative Test: Send a request with a phone number that does not exist in the database, expected response is `404 Not Found`."
    },
    {
      "question_id": "EQ2040",
      "question": "Explain one advantage of mocking external APIs when testing failure scenarios.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "Mocking prevents real users or services from being impacted."
    },
    {
      "question_id": "EQ2042",
      "question": "Write one test case to validate error handling when API returns malformed JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "**Test Case: Malformed JSON Error**\n- **Precondition:** API configured to reject malformed inputs.\n- **Action:** Send `POST` request with a JSON body containing unexpected keys (e.g., `{\"user\": {\"id\": 123}}` instead of `{\"id\": 123}`).\n- **Expected Result:** API returns `400 Bad Request` with a clear error message, not a `200 OK`."
    },
    {
      "question_id": "EQ2044",
      "question": "Design one test step to confirm rate limiting headers (e.g., X-RateLimit-Remaining) are present.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "Send a request to an API endpoint with a high request limit. The expected result is that the API responds with a `200 OK` status code and the rate limiting headers (e.g., `X-RateLimit-Remaining`) present in the response body."
    },
    {
      "question_id": "EQ2046",
      "question": "Describe one advantage of separating test data from test logic in API testing.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic allows for independent setup and teardown of the test environment, improving test repeatability."
    },
    {
      "question_id": "EQ2048",
      "question": "Write a test case for validating graceful degradation when API cache is unavailable.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "Test sends request for cached resource → expect `403 Forbidden` or `404 Not Found`. Verify API reverts to original response instead of error stack. Ensure DB state intact."
    },
    {
      "question_id": "EQ2050",
      "question": "Explain one way to validate logging for sensitive fields such as passwords.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "Automatically hash and store test passwords, then query logs to verify they are encoded correctly. A negative validation is to inject a known hash into a log field, then check the database to confirm the system remembers the hash."
    },
    {
      "question_id": "EQ2052",
      "question": "Provide one negative and one boundary test case for a currency field that must match ISO 4217 codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "Negative Test: Input 'USD' (valid code) as 'EUR'. Boundary Test: Input 'USD' (valid code) as 'USD'."
    },
    {
      "question_id": "EQ2054",
      "question": "Write one test case to validate API behavior under network packet loss.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "Test sends 10 packets for a single request. Expected: API returns `500 Internal Server Error` or timeout if threshold exceeded."
    },
    {
      "question_id": "EQ2056",
      "question": "Describe one method to verify test data cleanup after API test execution.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "Preconditions: Table or database with known test data inserted. After API test execution, query the database for the inserted data. Expected: The specific record should either exist (positive scenario) or not exist (negative scenario with deletion)."
    },
    {
      "question_id": "EQ2058",
      "question": "Write a test case to verify proper rollback when a multi-step transaction partially fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "Test involves executing a sequence of DB operations (e.g., `INSERT`, `UPDATE`, `DELETE`). Inject failure midway (e.g., `INSERT` fails). Expected: Transaction rolls back to initial state, no partial changes left in DB."
    },
    {
      "question_id": "EQ2060",
      "question": "Explain one approach to validating error messages follow a consistent JSON schema across all endpoints.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "Automatically validate each endpoint's response against a shared JSON schema. This ensures that error messages, like `400 Bad Request`, follow the same structure and key names everywhere. Tools like JSON Schema validators or integrated API test suites can perform this automated validation."
    },
    {
      "question_id": "EQ3002",
      "question": "Write a test case that validates login, token refresh, and accessing a protected API using the refreshed token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "Test: 1) Login -> 2) Token Refresh -> 3) Call Protected API with Fresh Token."
    },
    {
      "question_id": "EQ3004",
      "question": "Design a chained test validating that a failed login attempt still prevents refresh token generation.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: User A's token is valid. 2. Action: Send failed login attempt (wrong username). 3. Expected: No refresh token generated."
    },
    {
      "question_id": "EQ3006",
      "question": "Explain how you would validate correct mapping of business codes (e.g., ORDER_001) to HTTP status codes in API responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Create a business rules engine mapping (e.g., a JSON file) that defines order status codes like `ORDER_001 -> 200 OK`. Automate tests by injecting this mapping into a test script, which then asserts that the correct status code is returned for each valid order status."
    },
    {
      "question_id": "EQ3008",
      "question": "Write one hard-level test case chaining order creation, payment, and refund APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "1. Order creation → 2. Payment processing → 3. Refund generation."
    },
    {
      "question_id": "EQ3010",
      "question": "Explain one test case that validates token refresh works across multiple microservices.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "Test case: Token Refresh Loop. 1. Service A (consumer) requests a token from Service B (token provider). 2. Service B generates a short-lived token (e.g., 5 minutes). 3. Service A sends the token to a payment gateway (Service C). 4. After token lifetime expires, Service B refreshes the token. 5. Verify that the refreshed token now works with Service C for more than 5 minutes."
    },
    {
      "question_id": "EQ3012",
      "question": "Write a test that validates mapping of validation error codes to HTTP 400 responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "Preconditions: Validation library mocked with specific error codes. Test sends invalid request with each code → expect `400 Bad Request` with correct error text."
    },
    {
      "question_id": "EQ3014",
      "question": "Design a test case validating expired refresh tokens cannot issue new access tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: A user token and refresh token (with expiration time known) are set up. 2. The test sends a 401 Unauthorized response when using an expired refresh token to obtain a new access token. 3. The system must prevent a valid access token from being issued with an expired refresh token."
    },
    {
      "question_id": "EQ3016",
      "question": "Explain one multi-hop chained test that validates session invalidation after logout.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Perform a multi-hop chained test by 1) logging in, 2) performing action A, 3) logging out, 4) attempting action B, and 5) asserting that action B fails with'session not active'."
    },
    {
      "question_id": "EQ3018",
      "question": "Write a test case chaining signup, email verification, and login endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "Test: 1) Precondition: User email exists. 2) Signup → `201 Created`. 3) Email Verification → `200 OK` (if valid). 4) Login → `200 OK` with correct credentials."
    },
    {
      "question_id": "EQ3020",
      "question": "Design one hard-level chained test validating a password reset flow.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "1. **Precondition:** User `A` exists with an email and password reset token. 2. **Action:** Perform a hard-level chained test by simulating a valid login (`A` logs in), a password reset request (`A` clicks reset), and finally, attempting to use the reset token (`A` submits reset form). 3. **Verification:** The test validates whether the system correctly enforces a single use per token (`reset submitted → 401 Unauthorized`) and whether the token cannot be reused (`same token used twice → 409 Conflict`), all while ensuring the flow remains stateful and secure."
    },
    {
      "question_id": "EQ3022",
      "question": "Write a chained test case for validating user creation, profile update, and profile retrieval.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "Create a test case with three sub-cases: user creation, profile update, and profile retrieval, all chained together."
    },
    {
      "question_id": "EQ3024",
      "question": "Explain one test to validate refresh token cannot be used after logout.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "1. **Test:** Use a valid refresh token to obtain a new access token. 2. **Expected Result:** The response for the new access token request should not include an `expires_at` field or a `token_type` of `200 OK`. 3. **Rationale:** If the token is valid, it should still have expiration information."
    },
    {
      "question_id": "EQ3026",
      "question": "Write a test case validating correct mapping of internal error code AUTH_EXPIRED to HTTP status.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "**Test Case: Authentication Expiration**\n- **Preconditions:** User session expires after 5 minutes.\n- **Test Steps:** 1) Send `POST /login` with expired token → expect `401 Unauthorized` not `200 OK`. 2) Verify authentication service returns `AUTH_EXPIRED` error code.\n- **Expected Result:** API response should map `AUTH_EXPIRED` to HTTP status `401 Unauthorized`."
    },
    {
      "question_id": "EQ3028",
      "question": "Explain a chained test validating email verification failure if token is invalid.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Send valid email confirmation → expect `200 OK`. 2) Send email with invalid token (e.g., `123` instead of `abc`): expect `404 Not Found` or `401 Unauthorized`. 3) Send email with expired token: expect `400 Bad Request`."
    },
    {
      "question_id": "EQ3030",
      "question": "Write a hard-level test case chaining loan application, credit check, and approval endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "Test case: 'Loan Approval Flow'. Preconditions: Test account, mock credit service. Steps: 1) Valid Loan → 3xx Approved, 2) Declined Credit → 401 Unauthorized, 3) Missing Field → 400 Bad Request. Expected: Loan service returns approved or rejected."
    },
    {
      "question_id": "EQ3032",
      "question": "Design a test case chaining signup, password reset, and login with new credentials.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "Test Case: End-to-End Authentication. Preconditions: User exists. Steps: Signup → Password Reset → Login with new credentials. Expected: Corrected email/username."
    },
    {
      "question_id": "EQ3034",
      "question": "Write a test case chaining file upload, virus scan, and download endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "Test case includes steps for uploading files, triggering a virus scan, and then downloading the scan report."
    },
    {
      "question_id": "EQ3036",
      "question": "Explain one chained test for validating refresh token reuse prevention.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "1. Token 1 (short lifetime) + 1 refresh → new token. 2. Same Token 1 reused → 401 Unauthorized. Verify system prevents reuse."
    },
    {
      "question_id": "EQ3038",
      "question": "Write a test case chaining search, add-to-cart, and checkout APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "1. **Search Product:** Send `GET /products` with a specific ID → `200 OK` with product details. 2. **Add-to-Cart:** Send `POST /cart` with product ID → `201 Created` with cart update. 3. **Checkout:** Send `POST /checkout` with customer data and cart ID → `302 Found` with order confirmation."
    },
    {
      "question_id": "EQ3040",
      "question": "Explain one chained test for validating API session hijacking prevention.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "1. Log in with a valid token → session established.\n2. Perform second login attempt with identical credentials → expect `401 Unauthorized` or session rejection.\n3. If multiple requests reuse token, API must enforce logout or expire session quickly."
    },
    {
      "question_id": "EQ3042",
      "question": "Provide exactly one chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "1. **Test Scenario:** Send `POST /resource` with ETag `ETG-123` → `201 Created`. 2. **Chained Test:** Send `GET /resource` with `If-Match: ETG-123` → `200 OK` if fresh. 3. **Optimistic Update:** Send `PUT /resource` (update) with new ETag `ETG-456`. → `409 Conflict` if concurrent. 4. **Chained Test (continued):** Send `PUT /resource` with stale ETag → `412 Precondition Failed`."
    },
    {
      "question_id": "EQ3044",
      "question": "Design a multi-hop test verifying async export job: POST /exports -> poll GET /jobs/{id} until complete -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "1. Send initial POST /exports request with async export job. 2. Poll GET /jobs/{id} until status changes from 'pending' to 'completed'. 3. Verify final export status with GET /exports/{id], asserting final state (e.g., 'complete', file available)."
    },
    {
      "question_id": "EQ3046",
      "question": "Give one chained negative test for OAuth2 Authorization Code: /authorize -> /token -> resource call with missing scope.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Send a request for an authorization code with no scope (e.g., `/authorize?client_id=abc&redirect_uri=http://example.com/callback&state=xyz` but no `scope=`) and verify the response is an `403 Forbidden` or `400 Bad Request` with an error code like `invalid_grant`."
    },
    {
      "question_id": "EQ3048",
      "question": "Write one chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. Given a user with an Idempotency-Key, create chained tests for retry and refund: 1) Charge → 200 OK, 2) Retry → 202 Accepted, 3) Refund → 200 OK with no double charge."
    },
    {
      "question_id": "EQ3050",
      "question": "Provide one chained test for file processing pipeline: upload -> POST /process -> poll status -> download, including 202 handling.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "1. **Action/Request:** Send `POST /process` with file and action=submit.\n2. **State Check:** Poll `/status` until 'processing complete' response.\n3. **Verification:** Confirm file downloaded and integrity preserved."
    },
    {
      "question_id": "EQ3052",
      "question": "Give one chained test to validate SSO session revocation propagates to API gateway and microservice access.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "1. Log in with SSO → session granted → revoke session → expect API response `403` or `404 Not Found` for protected endpoints."
    },
    {
      "question_id": "EQ3054",
      "question": "Write one chained test for partial order fulfillment: create order -> reserve inventory -> partial ship -> cancel remaining and refund delta.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "1. Given an order, when it's created, it should reserve inventory and partial ship some items. 2. The system should then process a cancel for the remaining items. 3. Verify that only the initial order cost (not partial shipment) is refunded."
    },
    {
      "question_id": "EQ3056",
      "question": "Provide exactly one chained negative test for 2FA login: POST /login -> POST /2fa/verify with wrong code -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "1. Log in normally → `200 OK`. 2. Send 2FA verification request with wrong verification code → `401 Unauthorized`. 3. Send request to refresh token → `403 Forbidden`."
    },
    {
      "question_id": "EQ3058",
      "question": "Design a chained test verifying pagination consistency across create -> list -> delete -> list (with total count assertions).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "Create chain with 10 items (page=1), verify page count and total count on list, delete last → expect DB consistent removal (no duplicate counts)."
    },
    {
      "question_id": "EQ3060",
      "question": "Write one chained test for session stickiness: login -> subsequent calls via load balancer -> logout -> verify no node accepts old token.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "1. Chain: 1) Login user A. 2) Call API via load balancer -> expect 200 OK. 3) Logout user A. 4) Verify no node (e.g., DB API) accepts session token for user A after logout."
    },
    {
      "question_id": "EQ4002",
      "question": "Write a state-machine style test validating account lifecycle: create → activate → suspend → reactivate → delete.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "Define states: Active, Suspended, Deactivated. Transitions validated by preconditions (e.g., valid email → create), actions (e.g., activate, suspend), and reverse transitions (e.g., reactivate). Postconditions ensure state transitions are correct."
    },
    {
      "question_id": "EQ4004",
      "question": "Design a chained test that validates transaction rollback when step 2 of a 3-step money transfer fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "Test steps: 1) Initiate money transfer. 2) Simulate fraudulent transaction. 3) Verify database rolled back, not committed."
    },
    {
      "question_id": "EQ4006",
      "question": "Write one test validating a multi-service chain: login → create order → process payment → cancel order after capture.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "1. **Precondition:** A user with a valid payment method exists in the database. \n2. **Test Steps:**\n   - Log in as that user.\n   - Create a new order via the login service.\n   - Trigger payment processing.\n   - Cancel the order.\n   - **Verification:** The order's status should change from 'pending' to 'cancelled'."
    },
    {
      "question_id": "EQ4008",
      "question": "Describe one state-machine test validating password lifecycle: set → expire → reset → reuse prevention.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "Test: 1) Log in with valid password → set. 2) Wait for password expiration → 'password expired' error. 3) Attempt reset → successful reset. 4) Verify new password is reused → negative validation."
    },
    {
      "question_id": "EQ4010",
      "question": "Write one complex chained test covering a loan application flow with branch failure in credit check.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "1. Precondition: Loan system mocked to return 'approved' for valid application and'rejected' for failed credit check.\n2. Test Steps: Submit valid loan application → expect 'Approved' response and db update. Submit loan application with failed credit check → expect 'Rejected' response and db update. Chain failure: Submit loan application with service mocked to return 'error' (e.g., DB connection failure)."
    },
    {
      "question_id": "EQ4012",
      "question": "Write a test validating data integrity when concurrent writes occur: update user profile with conflicting values.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "Preconditions: Two writers attempt to update user profile with different values (e.g., 'John' and 'Jane') simultaneously. Expected Result: Only one update succeeds, DB contains single, consistent profile record, and other writer's attempt fails with 409 Conflict Error."
    },
    {
      "question_id": "EQ4014",
      "question": "Write one very hard test validating chained document signing: upload → sign → verify → tamper detection.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "Create a test where a signed document is uploaded, then tampered with, signed again, and verified. Preconditions: document content known, tamper-proof seal available. Expected: verification fails if tampered, signed again unique."
    },
    {
      "question_id": "EQ4017",
      "question": "Write one state-machine test validating subscription lifecycle: create → upgrade → downgrade → cancel.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "Test case: 1) Subscribe → 2) Upgrade subscription → 3) Downgrade → 4) Cancel subscription. Expected: Subscription state transitions follow lifecycle rules."
    },
    {
      "question_id": "EQ4019",
      "question": "Write a very hard chained test validating recovery after partial failure in a distributed order saga.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "Send order for payment, shipping, and inventory updates in sequence. Expected: Order state should still be 'pending' but all dependent events (e.g., shipped order with missing inventory update) should be rolled back to state 'pending' or 'failed'. No database consistency violations."
    },
    {
      "question_id": "EQ4021",
      "question": "Write one very hard test verifying financial transaction reversals: debit → credit → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "1. Perform a debit transaction. 2. Immediately call a payment service API to process a subsequent credit transaction. 3. Roll back the debit transaction (e.g., via API's cancel method or database rollback). Verify that the debit amount is still available in the debit's original account, but the credit transaction was never processed."
    },
    {
      "question_id": "EQ4023",
      "question": "Design a state-machine test for warehouse inventory: add stock → allocate → ship → return → reconcile.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Preconditions: stock → products allocated → shipments confirmed → returns processed. Test steps: add stock → ship product → return item → reconcile stock. Verify state transitions: stock → allocated → shipped → returned → reconciled."
    },
    {
      "question_id": "EQ4025",
      "question": "Write one chained test validating mobile session lifecycle: login → token refresh → logout → refresh with old token → fail.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "1. Send login request → expect `auth_token` in response.\n2. Send `auth_token` to API → expect `200 OK` with new token (token refresh).\n3. Send logout request → expect `204 No Content`.\n4. Send refresh with old `auth_token` → expect `401 Unauthorized` or `404 Not Found`."
    },
    {
      "question_id": "EQ4027",
      "question": "Write one chained test validating email delivery API: send → open-tracking → unsubscribe → ensure no further emails sent.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. Send email → 2. Verify email opened → 3. Confirm unsubscribe processed → 4. Assert no further emails sent."
    },
    {
      "question_id": "EQ4029",
      "question": "Write one very hard chained test for purchase flow with coupon application and failure branch: apply coupon → checkout → coupon invalid → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "Chain: 1) Apply valid coupon → 2) Click 'Apply Coupon' → 3) 4) Use expired coupon → 5) Mock payment service to fail → 6) Purchase flow should rollback with 'Coupon expired' error."
    },
    {
      "question_id": "EQ5004-VN",
      "question": "Viết một test case positive đơn giản cho một API đăng nhập.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "Đăng nhập với tài khoản đã tồn tại và xác minh được session được trả về."
    },
    {
      "question_id": "EQ5006-VN",
      "question": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "A valid user token or authentication header. Test ensures only authorized users can access profile."
    },
    {
      "question_id": "EQ5008-VN",
      "question": "Viết một test negative đơn giản cho một API đăng ký.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Triggers a `401 Unauthorized` với tài khoản không tồn tại."
    },
    {
      "question_id": "EQ5010-VN",
      "question": "Vai trò của một schema trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "A schema defines the expected structure and data types for API requests and responses. It acts as a contract between the API provider and consumers, ensuring consistent data exchange. Without a schema, testing becomes unrepeatable and unreliable."
    },
    {
      "question_id": "EQ5012-VN",
      "question": "Viết một test step đơn giản để validate một response 201 Created.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "1. **Action:** Send a `POST` request (e.g., to `/products`).\n2.  **Validation:** After the request, access the newly created resource's ID. \n    1. **Expected:** The ID should be present and unique (not `null` or `0`, unique)."
    },
    {
      "question_id": "EQ5014-VN",
      "question": "Mục đích của mocking trong API testing là gì?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking simulates the behavior of real dependencies like APIs or databases during testing. Its goal is to isolate the API under test from external failures, allowing consistent and faster test execution."
    },
    {
      "question_id": "EQ5016-VN",
      "question": "Viết một test case dễ dàng cho một API lấy danh sách sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "Tiêu chí: API trả danh sách không vaz lỗi khi không tìm thấy sản phẩm."
    },
    {
      "question_id": "EQ5018-VN",
      "question": "Mục đích của một precondition trong một test case là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Preconditions xác định điều kiện bắt đầu cần đáp ứng. Ví dụ, hệ thống cần có một tài khoản đã được tạo."
    },
    {
      "question_id": "EQ5020-VN",
      "question": "Viết một test negative cho việc upload file với định dạng không được hỗ trợ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chọn một file format không được server hỗ trợ (như file audio). Send request upload file với mã body này. Expected: `400 Bad Request` hoặc `403 Forbidden`."
    },
    {
      "question_id": "EQ5022-VN",
      "question": "Mục đích của một test case description là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "A test case description explains what the test case aims to verify. It's a concise summary of the test's objective and preconditions."
    },
    {
      "question_id": "EQ5024-VN",
      "question": "Viết một test step để validate thời gian response dưới 1 giây.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "1. **Precondition:** Configured API to cache responses.\n2. **Action:** Send request for static resource.\n3. **Validation:** Check response time (< 1s)."
    },
    {
      "question_id": "EQ5027-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /health.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "Send a `GET` request to `/health`. Expect the API to respond with a `200 OK` status code and a simple body like `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5029-VN",
      "question": "Mục đích của việc sử dụng test data management trong API testing là gì?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "It ensures consistent and repeatable test execution with valid data."
    },
    {
      "question_id": "EQ5031-VN",
      "question": "Viết một test negative dễ dàng cho một API mong đợi định dạng JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Trả lời: Send a `POST` request với body chứa ký tự đặc biệt như `\\u00e1` (á). Expect `201 Created` nếu trường dữ liệu tồn tại. Kiểm tra database để assert không tìm thấy record với giá trị như này."
    },
    {
      "question_id": "EQ5033-VN",
      "question": "Vai trò của assertion trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "It confirms that API behaves exactly as expected."
    },
    {
      "question_id": "EQ5035-VN",
      "question": "Viết một test case để kiểm tra DELETE /users/{id} hoạt động đúng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "Test case: **Delete User**. Precondition: User ID = 123 exists. Action: Send DELETE request → expect `204 No Content` response."
    },
    {
      "question_id": "EQ5037-VN",
      "question": "Mã trạng thái HTTP 201 Created cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "Mã trạng thái HTTP 201 Created được sử dụng để chỉ báo một tài nguyên đã được tạo mới."
    },
    {
      "question_id": "EQ5039-VN",
      "question": "Viết một test đơn giản cho GET /users/{id} trả về response chính xác.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "Trả về một JSON với ID và tên hợp lệ."
    },
    {
      "question_id": "EQ5041-VN",
      "question": "Mục đích của một response 200 OK là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "It indicates the request was successful and the response body contains the resource requested."
    },
    {
      "question_id": "EQ5043-VN",
      "question": "Viết một test negative để validate response cho một endpoint không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "Send a request with an invalid or missing argument (e.g., `/users/` without ID). Expected: `400 Bad Request` hoặc `404 Not Found`. Response không được thay đổi."
    },
    {
      "question_id": "EQ5045-VN",
      "question": "Một test case assertion làm gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Test case assertion xác nhận kết quả của test case. Nó là câu lệnh `Then` hoặc `Expected` trong ngôn ngữ mô tả chức năng. Nó xác định điều gì được coi là hànhingen (đáp ứng) khi mã được thực hiện."
    },
    {
      "question_id": "EQ5047-VN",
      "question": "Viết một test positive cho endpoint upload file.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "Send a `POST` request with a valid file (e.g., `image.jpg`) and assert the response status is `200 OK`."
    },
    {
      "question_id": "EQ5049-VN",
      "question": "Vai trò của 415 Unsupported Media Type là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "415 Unsupported Media Type được sử dụng khi server không hỗ trợ một loại dữ liệu cụ thể. Nó là mã phản hồi chung khi request gửi format không được server hỗ trợ. Nó không liên quan đến dữ liệu không được chấp nhận."
    },
    {
      "question_id": "EQ5052-VN",
      "question": "Viết một test positive đơn giản để kiểm tra API chi tiết sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "*   **Định nghĩa:** Test sẽ gửi yêu cầu `POST /products` với bộ dữ liệu sản phẩm đầy đủ (id, tên, giá, mô tả, danh mục). **Kết quả:** API trả lời `201 Created` với body chứa thông tin sản phẩm mới."
    },
    {
      "question_id": "EQ5054-VN",
      "question": "Mục đích của việc sử dụng Authorization headers trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "It restricts access to protected resources."
    },
    {
      "question_id": "EQ5056-VN",
      "question": "Viết một test negative case cho một API yêu cầu authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Provide a valid token in the request, then deliberately omit the authentication header."
    },
    {
      "question_id": "EQ5058-VN",
      "question": "Vai trò của 500 Internal Server Error trong API testing là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "Internal Server Error 500 được trả khi API gặp lỗi không được client hiểu, như một vấn đề server. Trong API testing, nó giúp xác định điểm lỗi internal trên server."
    },
    {
      "question_id": "EQ5060-VN",
      "question": "Viết một test case positive cho một API trả về danh sách đơn hàng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "**Test Case:** **Retrieve List of Orders**\n- **Preconditions:** Đã có ít nhất 3 đơn hàng được tạo trước.\n- **Action:** Send `GET` request đến `/orders`.\n- **Expected Result:** API trả `200 OK` với mảng danh sách các đơn hàng (ví dụ: `[{id: 1, customer_id: 2},...]`)."
    },
    {
      "question_id": "EQ5062-VN",
      "question": "Chức năng của response header trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "They provide metadata about the request and response, such as status code, content type, and caching instructions. Useful for automating API requests without needing to know the full response body."
    },
    {
      "question_id": "EQ5064-VN",
      "question": "Viết một test negative cho việc tạo một tài nguyên trùng lặp.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "1. **Đầu vào:** Chia sẻ cùng một tài nguyên giữa hai job.\n2. **Kết quả mong đợi:** Job thứ hai nên tạo ra một tài nguyên khác biệt với job đầu tiên, không phải bản sao lặp lại."
    },
    {
      "question_id": "EQ5066-VN",
      "question": "Vai trò của 202 Accepted trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "It xác định rằng request đã được xác minh và không bị từ chối vì thời hạn."
    },
    {
      "question_id": "EQ5068-VN",
      "question": "Viết một test positive dễ dàng để kiểm tra API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Send a `POST` request with all required fields (e.g., `user={id}`). Verify the API returns a `200 OK` status with a valid response schema in the body."
    },
    {
      "question_id": "EQ5070-VN",
      "question": "Mục đích của response body trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Response body chứa dữ liệu trả về client sau một yêu cầu. Trong API testing, bạn kiểm tra nội dung này để xác minh mã trả về, trạng thái cơ bản, hoặc các dữ liệu được tạo."
    },
    {
      "question_id": "EQ5072-VN",
      "question": "Viết một test case để verify chức năng logout.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "- **Action:** Click logout button.\n- **Expected:** Session count (e.g., count of authenticated users) should reset to 0."
    },
    {
      "question_id": "EQ5074-VN",
      "question": "Lỗi 415 Unsupported Media Type validate điều gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "It validates that the media type (format) in the request is not supported by the server."
    },
    {
      "question_id": "EQ5077-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /status.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Triggers request to `/status` with status `200 OK`. Expected: `200 OK` with body `OK`."
    },
    {
      "question_id": "EQ5079-VN",
      "question": "Một response 204 No Content có nghĩa là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "No Content (204) được sử dụng khi client yêu cầu một resource nhưng không muốn tải toàn bộ resource vào bộ nhớ. Server sẽ trả back header `Content-Length` nhưng không gửi body."
    },
    {
      "question_id": "EQ5081-VN",
      "question": "Viết một test negative case cho việc gửi một Content-Type header không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chỉ Send a payload với Content-Type → 400 Bad Request."
    },
    {
      "question_id": "EQ5083-VN",
      "question": "Mục đích của Accept header trong các API request là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "The `Accept` header tells the server which response formats it supports. For example, `Accept: application/json` means the client can handle JSON data. This is important for interoperability and flexibility."
    },
    {
      "question_id": "EQ5085-VN",
      "question": "Viết một test case đơn giản cho một API logout thành công.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "* **Preconditions:** Một token login được tạo ra. * **Action:** Call `/logout` API. * **Expected:** Trả lời `200 OK` và DB không còn session cho user."
    },
    {
      "question_id": "EQ5087-VN",
      "question": "Ý nghĩa của 401 Unauthorized trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "It means authentication failed, so requests need a valid token."
    },
    {
      "question_id": "EQ5089-VN",
      "question": "Viết một test case positive dễ dàng để kiểm tra API chi tiết profile.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "- **Preconditions:** Một tài khoản được đăng ký (ID: `user_id_123`) với một email xác định.\n- **Action:** Gửi một yêu cầu đến endpoint `POST /profile` sử dụng email unique (ví dụ: `user@example.com`).\n- **Expected:** API trả mã số `201 Created` với một bản ghi profile mới (tập tin JSON)."
    },
    {
      "question_id": "EQ5091-VN",
      "question": "Mục đích của 302 Found trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "It indicates the resource has been found and moved."
    },
    {
      "question_id": "EQ5093-VN",
      "question": "Viết một test case cho nỗ lực đăng nhập negative với mật khẩu sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "- **Preconditions:** Tài khoản exist nhưng mật khẩu không được lưu.\n-  **Steps:** Triggers login endpoint với parameter = 'wrong_password'.\n-  **Verification:** DB không ghi nhận giao dịch tạo tài khoản."
    },
    {
      "question_id": "EQ5095-VN",
      "question": "422 Unprocessable Entity cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "It means the server could not fulfill the request but it is a client error."
    },
    {
      "question_id": "EQ5097-VN",
      "question": "Viết một test positive cho endpoint POST /users.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Send a valid JSON payload with email and password fields. Expected: `201 Created` with user ID in response body."
    },
    {
      "question_id": "EQ5099-VN",
      "question": "Thuật ngữ 'happy path' trong testing có nghĩa là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "'Happy path' là một thuật ngữ testing chỉ đơn đường hợp lệ ( successful sequence of steps )."
    },
    {
      "question_id": "EQ2002-VN",
      "question": "Hãy giải thích cách bạn thiết kế một **test case âm tính** cho một endpoint API yêu cầu **OAuth2 Bearer token**.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "Test case âm tính (negative test) gửi yêu cầu với mã token không tồn tại hoặc expired. **Mô hình:** 1. **Precondition:** Chế độ phát hành (base URL) và client ID được sử dụng. 2. **Action:** Send request với tham số `access_token` là `null` hoặc `expired` (tài khoản đã hết hạn). 3. **Expected:** Trả lời là `403 Forbidden` hoặc `400 Bad Request`."
    },
    {
      "question_id": "EQ2004-VN",
      "question": "Cung cấp một **test case happy-path** và một **test case error-path** cho một endpoint API hoàn tiền thanh toán.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path:** Triggers request với số tiền đủ (e.g., 100) và từ từ xác nhận. **Test Case Error-Path:** Triggers request với số tiền 0 hoặc không tồn tại."
    },
    {
      "question_id": "EQ2006-VN",
      "question": "Bạn sẽ xác thực các thay đổi **schema** trong một nâng cấp API **tương thích ngược** như thế nào?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "By running migration scripts backward and validating database snapshots."
    },
    {
      "question_id": "EQ2008-VN",
      "question": "Giải thích cách **mocking** có thể được sử dụng để kiểm tra một API thanh toán mà không gọi dịch vụ ngân hàng thực.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Giả tạo một mô hình hoặc dịch vụ giả (mock) để thay thế ngân hàng. API Thanh toán sẽ gọi vào mock để thực hiện giao dịch. Điều này cho phép kiểm tra logic mà không cần liên kết với thực tế."
    },
    {
      "question_id": "EQ2010-VN",
      "question": "Thiết kế một **boundary test** và một **invalid test** cho trường API `age` (phạm vi 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "*   **Boundary Test:** Chia age vào giới hạn (18, 65) và send request. **Invalid Test:** Send request với age < 18 (dưới 18) hoặc > 65 (trên 65)."
    },
    {
      "question_id": "EQ2012-VN",
      "question": "Giải thích cách bạn mô phỏng lỗi **network timeout** trong **API testing**.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "Simulate a slow or unreliable network connection by manipulating the request timeout or introducing latency in the HTTP request. This allows testers to verify error handling and retries for such scenarios."
    },
    {
      "question_id": "EQ2014-VN",
      "question": "Đưa ra một ví dụ về một **precondition** API và một **step** theo sau nó.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "Precondition: Một người dùng có tài khoản. Step: Thử đăng nhập và lấy token."
    },
    {
      "question_id": "EQ2016-VN",
      "question": "Viết một **test case** để xác thực rằng **API rate limiting** được thực thi đúng.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "1. **Action:** Send 100+ requests in 1 minute via API.\n2.  **Expected:** API trả lời `600 Bad Gateway` sau giới hạn, không phản hồi `200 OK`.\n3.  **Preconditions:** API configurated với giới hạn request/minute."
    },
    {
      "question_id": "EQ2018-VN",
      "question": "Giải thích một lợi thế của việc sử dụng **service virtualization** trong **API testing**.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "It allows testing with simulated dependent services before real deployment."
    },
    {
      "question_id": "EQ2020-VN",
      "question": "Mô tả cách thiết kế một **test case tích cực** và một **boundary test case** cho một API đăng nhập yêu cầu tên người dùng và mật khẩu.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "A positive test case gửi parameters hợp lệ (ví dụ: \"john.doe\" và \"Password123\") và kiểm tra phản hồi 200 OK. A boundary test case kiểm tra giới hạn: nhập \"000000\" hoặc \"ZZZ\" để xem API xử lý trường hợp biên nào."
    },
    {
      "question_id": "EQ2022-VN",
      "question": "Viết một **test step** để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "1. **Action:** Send a `POST` request đến endpoint này với đầu đề `application/octet-stream`.\n2. **Expected:** API trả `415 Unsupported Media Type`.\n3. **Verification:** Check status code và trả lời là `415`."
    },
    {
      "question_id": "EQ2024-VN",
      "question": "Mô tả một cách để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "Tìm hiểu xem API trả lời nhanh hay chậm khi DB bị kẹt. Ví dụ, nếu DB slow query cólatime = 30s, API sẽ có delay đó xuất hiện trong phản hồi thời gian."
    },
    {
      "question_id": "EQ2026-VN",
      "question": "Giải thích cách bạn sẽ kiểm tra **API idempotency** cho một kịch bản **retry**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Chuẩn bị **test case** với hành động **create** hoặc **update**. Send yêu cầu lần đầu và kiểm tra rằng DB được cập nhật một lần. Tiếp theo, gửi yêu cầu **đồng** (tương tự) và expecting không thay đổi. Finally, thử **nạp lại** (retry) sau một khoảng thời gian và kiểm tra DB không bị cập nhật thêm."
    },
    {
      "question_id": "EQ2028-VN",
      "question": "Đưa ra một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "**Boundary Test:** Chia file 5 MB thành hai phần, tải hai phần cùng API. **Invalid Test:** Tải một file quá lớn hơn giới hạn (e.g., 10 MB), API trả `413 Payload Too Large`."
    },
    {
      "question_id": "EQ2030-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "**Test Case:** Triggers endpoint không cung cấp email → expect `400 Bad Request` với mã lỗi và thông đi cụ thể."
    },
    {
      "question_id": "EQ2032-VN",
      "question": "Bạn sẽ thiết kế một **test** để xác thực logic **retry** như thế nào khi một API thỉnh thoảng trả về **503**?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "Đầu vào: `{\"url\": \"https://api.example.com\", \"status_code\": 503}`. **Test:** 1) Send request -> `503` Response. 2) Configure retry logic -> nếu thất bại, nên thử lại sau 5 phút. 3) Expected: Request thứ 2 được chèn vào Log/DB với thời gian thực hiện khác."
    },
    {
      "question_id": "EQ2034-VN",
      "question": "Viết một **test case** xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "- **Định nghĩa:** Log record có thể được liên kết với một **trace ID** (bằng nhãn trace ID trong request). \n- **Test Case:** 1) Send request với trace ID header. 2) Check log records có matching trace ID. 3) Verificaregister match correct trace."
    },
    {
      "question_id": "EQ2036-VN",
      "question": "Thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting** khi có nhiều máy khách tham gia.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "1. **Test Case Name:** Verify API Rate Limiting with Concurrent Clients.\n2.  **Preconditions:** 1) API configured with rate limit (e.g., 100 requests/min). 2) 3-5 machines (máy khách) cùng chạy request script. 3) Log collector active.\n3.  **Test Steps:** 1) Machine A–Bắt đầu gửi request (`/endpoint`) liên tục. 2) Machines B & C cũng làm tương tự. 3) Wait và kiểm tra: 1) Số request total trên API phải `< cap (điểm giới) >`. 2) Logs must show tất cả 3 máy đều bị giới hạn (e.g., `200 OK` với số lượng giới hạn). 3) Nếu API bị tấn công DDoS, phải phản hồi `429 Too Many Requests` hoặc `500 Internal Server Error`."
    },
    {
      "question_id": "EQ2038-VN",
      "question": "Mô tả một **test case tích cực** và một **test case âm tính** cho một endpoint API gửi mã **SMS**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test case tích cực (Positive):** Chèn một số điện thoại hợp lệ gửi SMS và kiểm tra xem trả lời `200 OK` là hợp lý hay không.\n- **Test case âm tính (Negative):** Chèn một số điện thoại không tồn tại hoặc đã bị chặn rồi."
    },
    {
      "question_id": "EQ2040-VN",
      "question": "Giải thích một lợi thế của việc **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Mocking API bên ngoài cho phép kiểm tra các kịch bản thất bại mà không cần truy cập internet. Lợi thế là hệ thống được test có hành động theo cách được thiết kế."
    },
    {
      "question_id": "EQ2042-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi khi API trả về **JSON** bị định dạng sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "**Test Case:** Triggers request với body JSON không hợp lệ (chẳng hạn, thiếu field, giá trị không hợp lệ). **Expected Result:** API trả `400 Bad Request` hoặc `400 Bad Request` với body lỗi nhưng không bị chuyển đổi thành mã JSON."
    },
    {
      "question_id": "EQ2044-VN",
      "question": "Thiết kế một **test step** để xác nhận các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "1. **Action:** Send request with all required rate limiting headers (e.g., `X-RateLimit-Remaining`, `X-RateLimit-Reset`, `X-RateLimit-Limit`).\n2. **Expected:** Ensure tất cả các header này *đã được gửi* và có giá trị (bằng kiểm tra `assert` trên response)."
    },
    {
      "question_id": "EQ2046-VN",
      "question": "Mô tả một lợi thế của việc tách dữ liệu **test** khỏi logic **test** trong **API testing**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Tách dữ liệu **test** giúp chạy các test độc lập, tránh thay đổi tình trạng dữ liệu giữa các test run khác nhau. Lợi thế là test tự động có thể được chạy nhiều lần mà không gây sự cố."
    },
    {
      "question_id": "EQ2048-VN",
      "question": "Viết một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "Đề xuất: 1) Triggers -> 2) Check DB instead of cache. 3) Verify no 500 error, but graceful failure (e.g., return `not found`)."
    },
    {
      "question_id": "EQ2050-VN",
      "question": "Giải thích một cách để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Log một phần của dữ liệu (chẳng hạn, chỉ số truy vấn) thay vì toàn bộ. Điều này cho phép bảo mật dữ liệu nhạy cảm trong khi vẫn cung cấp thông tin hữu ích."
    },
    {
      "question_id": "EQ2052-VN",
      "question": "Cung cấp một **test case âm tính** và một **boundary test case** cho một trường tiền tệ phải khớp với mã **ISO 4217**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "**Test Case:**\n- **Đề bài:** Đặt hàng giá 500 USD.\n- **Động viên:** Vérify mã VAT được trả đúng (US).\n- **Đáp ứng:** Nếu DB trống, DB trả 000. Nếu quy tắc, trả US.\n\n**Test Case âm tính:**\n- **Đề bài:** Xác nhận hàng không có giá (0 USD) được xử lý đúng.\n- **Động viên:** Vérify DB trống không chứa giá.\n\n**Boundary Test Case:**\n- **Đề bài:** Đặt hàng giá 999 USD.\n- **Động viên:** Vérify mã VAT được trả đúng (US)."
    },
    {
      "question_id": "EQ2054-VN",
      "question": "Viết một **test case** để xác thực hành vi API dưới tình trạng mất gói mạng.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "1. **Action:** Triggers API request (e.g., `POST /orders`) via client.\n2. **Condition:** Simulate packet loss or disconnection.\n3. **Expected:** API không trả lời ngay, nhưng sau một thời gian, trả lời `500 Internal Server Error` với thông báo '`Connection timed out'`."
    },
    {
      "question_id": "EQ2056-VN",
      "question": "Mô tả một phương pháp để xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Giải pháp: 1) Triggers event (thực hiện action). 2) Verify DB query (API create user) is cleared. 3) Verify storage file (e.g., log, config) is deleted. **Test:** API setup creates test user, which is then deleted to confirm cleanup."
    },
    {
      "question_id": "EQ2058-VN",
      "question": "Viết một **test case** để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "Test Case: Rollback with Failed Transaction. Preconditions: Transaction with two valid steps and one failed step exists. Expected Result: Only failed steps rolled back, remaining data unchanged."
    },
    {
      "question_id": "EQ2060-VN",
      "question": "Giải thích một cách tiếp cận để xác thực các thông báo lỗi tuân theo một **JSON schema** nhất quán trên tất cả các **endpoint**.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "Xác thực: 1) Send request with `200 OK` payload → xác thực schema. 2) Valid parameters → `200 OK`. 3) Invalid → `400 Bad Request`. 4) Endpoint-specific validation → combine schemas."
    },
    {
      "question_id": "EQ3002-VN",
      "question": "Viết một test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "1. **Mô hình:** 1 user exists, API protected.\n2. **Đầu vào:** Một request đăng nhập (HTTP `POST`) với một mật khẩu valid.\n3. **Và/Or:** Một request đến một API được bảo vệ (ví dụ `/products`).\n4. **Kết luận:** API được trả về với status `200 OK` và body valid."
    },
    {
      "question_id": "EQ3004-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "Chuỗi: 1) Triggers Login API. 2) Validate session. 3) Tạo Refresh Token (if valid session). 4) Verifies refresh token (if available). Bài kiểm tra: Send login request → expect `200 OK` và refresh token được trả về. Try login với account đã bị khóa → expect `200 OK` nhưng refresh token sẽ không được trả về."
    },
    {
      "question_id": "EQ3006-VN",
      "question": "Giải thích cách bạn sẽ xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Tập trung vào việc mã hóa và giải mã trong quy trình xử lý. Ví dụ, nếu mã nghiệp vụ là `ORDER_001`, thì mã trạng thái HTTP là `200 OK` (mã trạng thái cơ bản). Xác thực được khi phản hồi API trả về mã trạng thái HTTP này sau khi mã hóa và kiểm tra lại với mã nghiệp vụ."
    },
    {
      "question_id": "EQ3008-VN",
      "question": "Viết một test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "- **Preconditions:** APIs được khởi động. - **Test Steps:** 1) Tạo đơn hàng. 2) Thẻ thanh toán được tạo và liên kết với tài khoản. 3) Hợp đồng thanh toán được tạo và kết nối với thẻ. 4) Hoàn tiền API được gọi. - **Expected Results:** DB chứa đơn hàng, thanh toán, và khoản hoàn tiền được tìm thấy."
    },
    {
      "question_id": "EQ3010-VN",
      "question": "Giải thích một test case xác thực việc làm mới token hoạt động trên nhiều microservice.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case: 1) Đăng nhập -> trả token. 2) Call API khác -> sử dụng token. 3) Kiểm tra DB liên quan -> token có valid."
    },
    {
      "question_id": "EQ3012-VN",
      "question": "Viết một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "Kiểm tra yêu cầu tham số xác thực (id) trong URL. Các mã lỗi xác thực → phản hồi 400 Bad Request (ví dụ: mã lỗi 20001 → 'Expected valid ID' → 400 Bad Request). Xác minh phản hồi đúng format."
    },
    {
      "question_id": "EQ3014-VN",
      "question": "Thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Action:** Triggers refresh token lifetime (e.g., 1 minute) to expire.\n2. **Expected Result:** API reject refresh with `400 Bad Request: no valid verification code` or `403 Forbidden: token has expired`.\n3. **Precondition:** Refresh token created with known lifetime (e.g., 1 minute)."
    },
    {
      "question_id": "EQ3016-VN",
      "question": "Giải thích một bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra này yêu cầu người dùng: 1) Đăng xuất khỏi session. 2) Truy cập URL session bị hủy. 3) Xác định trạng thái session là 'bỏ' (e.g.,'expired'). 4) Nhấn nút 'Hủy bỏ' (e.g., 'End Session'). Đáp án: Nếu session đã bị hủy, thử nghiệm này sẽ kiểm tra hành động hủy bỏ session hợp lệ."
    },
    {
      "question_id": "EQ3018-VN",
      "question": "Viết một test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "- **Action:** 1) Đăng ký (POST /register) -> email được gửi. 2) Xác minh email (Verify Email, e.g., `https://api.example.com/v1/email-verify/${emailId}`). 3) Đăng nhập (POST /login). - **Expected:** All requests phải trả `200 OK`."
    },
    {
      "question_id": "EQ3020-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Thiết kế bài kiểm tra bao gồm các kịch bản: 1) Mọi thứ bình thường, 2) Sử dụng ký tự đặc biệt bị chặn, 3) Mật khẩu đã tồn tại."
    },
    {
      "question_id": "EQ3022-VN",
      "question": "Viết một test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "Tìm kiếm hồ sơ của user `user_id` sau các giao dịch."
    },
    {
      "question_id": "EQ3024-VN",
      "question": "Giải thích một bài kiểm tra để xác thực refresh token không thể được sử dụng sau khi đăng xuất.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra là dùng refresh token và xác suất đăng nhập. Nếu token không hoạt động sau logout, test pass."
    },
    {
      "question_id": "EQ3026-VN",
      "question": "Viết một test case xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "Test case: Send expired session request → expect `401 Unauthorized` not `500 Internal Server Error`. Expected: API trả mã tắt HTTP không lỗi nội bộ."
    },
    {
      "question_id": "EQ3028-VN",
      "question": "Giải thích một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Nếu token không hợp lệ, kiểm tra sẽ trả về lỗi vì không tương ứng với session thực. Bài kiểm tra thất bại vì nó thử nghiệm một trường hợp không được hỗ trợ."
    },
    {
      "question_id": "EQ3030-VN",
      "question": "Viết một test case cấp độ khó chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "1. **Preconditions:** Tài khoản exist, API key có. 2. **Steps:** Đăng ký vay -> `POST /loans` -> trả lãi -> phê duyệt -> từ chối. 3. **Verification:** DB có record loan, responevent specific (e.g., 'Loan Approved')."
    },
    {
      "question_id": "EQ3032-VN",
      "question": "Thiết kế một test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Đăng ký (Preconditions: Tài khoản chưa tồn tại)** - Viết lệnh giả người đăng nhập và tạo tài khoản.\n2. **Đặt lại mật khẩu (Preconditions: Mật khẩu đã được đặt lại)** - Chọn hành động 'Đặt lại mật khẩu' và kiểm tra mã xác minh.\n3. **Đăng nhập (Preconditions: Tài khoản tồn tại và mật khẩu đã được đặt lại)** - Viết lệnh giả người đăng nhập với thông tin đăng nhập mới."
    },
    {
      "question_id": "EQ3034-VN",
      "question": "Viết một test case chuỗi các endpoint tải lên file, quét virus và tải xuống.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "- **Preconditions:** File exist, user authenticated.\n- - **Upload File:** Send `POST` with file → `201 Created`.\n- - **Virus Scan:** Send `GET` /`virus` → `200 OK` with results.\n- - **Download File:** Send `GET` with ID → `302 Found` with download link.\n- - **Error:** File type forbidden → `403 Forbidden`."
    },
    {
      "question_id": "EQ3036-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn việc sử dụng lại refresh token.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra yêu cầu nhập token mới sau thời gian hạn cách. Đáp án đúng là token bị khóa hoặc yêu cầu xác thực."
    },
    {
      "question_id": "EQ3038-VN",
      "question": "Viết một test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Order Flow**\n- **Preconditions:** User exists, products available.\n- **Steps:**\n  - **Search:** `/products` với từ khóa \"Laptop\".\n  - **Add to Cart:** `/cart/add` với ID sản phẩm.\n  - **Checkout:** `/checkout` với tất cả giỏ hàng.\n- **Expected:** API trả `200 OK` với mã phản hồi."
    },
    {
      "question_id": "EQ3040-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn tấn công chiếm đoạt session API.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Bài kiểm tra này đảm bảo session được mã hóa và ngăn chặn truy cập bất hợp pháp."
    },
    {
      "question_id": "EQ3042-VN",
      "question": "Cung cấp chính xác một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "- **Preconditions:** 1) Một tài khoản được tạo với bản phát hành `vA` và ETag cụ thể. 2) Một tài nguyên được tạo với trạng thái `vA`. - **Test Case:** 1. Send `POST` với ETag `\"vA\"` và tạo tài nguyên thành công. 2. Update tài nguyên với ETag `\"vB\"` và send `PUT`. 3. Send `GET` với ETag `\"vA\"` (chỉ định) và verify phản hồi có thể là `200 OK` nếu chỉxác đồng thời xảy ra. 4. Send `GET` với ETag không chính xác → `404 Not Found`. - **Expected Result:** VD1: `200 OK` nếu chỉxác đồng thời xảy ra. VD2: `404 Not Found` nếu ETag lỗi."
    },
    {
      "question_id": "EQ3044-VN",
      "question": "Thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ: POST /exports -> thăm dò GET /jobs/{id} cho đến khi hoàn thành -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Chuẩn bị: 1 job = 5 phút, 2 job = 10 phút. Kiểm tra DB phản hồi nhanh → test đồng bộ."
    },
    {
      "question_id": "EQ3046-VN",
      "question": "Cung cấp một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code: /authorize -> /token -> gọi tài nguyên với scope bị thiếu.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "Trả lời: Đăng nhập vào tài khoản test. 1. Truy cập `/authorize` với mã được cấp (code) test. 2. Truy cập `/token` với mã được cấp (code) test và kiểm tra response có chứa `scope`. 3. Gọi `resource` với scope bị thiếu và kiểm tra `403` hoặc `404`NotFound."
    },
    {
      "question_id": "EQ3048-VN",
      "question": "Viết một bài kiểm tra chuỗi bao gồm việc tạo charge幂等 (idempotent charge creation) với Idempotency-Key trên các endpoint thử lại và hoàn tiền.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "- **Tính chất 1 (Idempotency-Key):** Send identical `idempotency-key` requests twice (endpoint: `/charge` hoặc `/payment`). **Expected:** First call tạo `charge` → 200 OK, DB ghi nhận. Second call → 200 OK, DB không thay đổi. **Tính chất 2 (Idempotency):** Send request nhiều lần với cùng `idempotency-key`. **Expected:** DB chỉ ghi nhận lần đầu. **Tính chất 3 (Idempotency-Key bảo mật):** `idempotency-key` không được exposure trong API response (không phải là token open, được sử dụng chỉ với DB mapping)."
    },
    {
      "question_id": "EQ3050-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi cho quy trình xử lý file: tải lên -> POST /process -> thăm dò trạng thái -> tải xuống, bao gồm cả việc xử lý 202.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Kiểm tra bao gồm tải file lên server, gửi request POST với file, kiểm tra trạng thái 202 (tài liệu chuyển tiếp), và tải xuống file cuối cùng."
    },
    {
      "question_id": "EQ3052-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "1. **API Gateway:** Send a request with a expired session token → `403 Forbidden`. 2. **Microservice:** Call authentication endpoint with expired session → `400 Bad Request`. 3. **Database:** Verify session record was properly deleted."
    },
    {
      "question_id": "EQ3054-VN",
      "question": "Viết một test case chuỗi cho việc thực hiện đơn hàng một phần: tạo đơn hàng -> dự trữ hàng tồn kho -> ship một phần -> hủy phần còn lại và hoàn tiền chênh lệch.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "1. **Preconditions:** Tạo hàng tồn kho với số lượng vừa đủ. 2. **Steps:** - **Action:** Chọn phần của đơn hàng muốn ship. - **Expected:** Hàng còn lại bị hủy, thanh toán chênh lệch hoàn tiền. 3. **Post-condition:** DB xác minh trạng thái đơn hàng, thanh toán."
    },
    {
      "question_id": "EQ3056-VN",
      "question": "Cung cấp chính xác một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA: POST /login -> POST /2fa/verify với mã sai -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập 2FA:** Send `POST /login` với thông tin đăng nhập chính xác. 2. **Xác minh mã 2FA:** Send `POST /2fa/verify` với mã 2FA sai (ví dụ: `223344` thay vì `123456`). 3. **Thử refresh token:** Send `POST /refresh` với token refresh bất hợp pháp. All three sẽ trả về mã số lỗi 401/403/400."
    },
    {
      "question_id": "EQ3058-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê (với các xác nhận tổng số đếm).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Thực hiện các thao tác với DB, lưu lại kết quả mỗi bước, so sánh tổng số với kết quả trước/qua. Đảm bảo phân trang rõ ở các API khác nhau."
    },
    {
      "question_id": "EQ3060-VN",
      "question": "Viết một bài kiểm tra chuỗi cho tính dính session (session stickiness): đăng nhập -> các cuộc gọi tiếp theo qua load balancer -> đăng xuất -> xác minh không có node nào chấp nhận token cũ.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "Đăng nhập -> các yêu cầu -> đăng xuất. **Expected:** Token bị vô hiệu hóa sau logout."
    },
    {
      "question_id": "EQ4002-VN",
      "question": "Viết một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản: tạo → kích hoạt → tạm ngừng → kích hoạt lại → xóa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "- **State Machine:** \n    - **Initial:** Tạo tài khoản → `account_created` → kích hoạt.\n    - **Active:** Kích hoạt → `account_activated` → sử dụng.\n    - **Suspended:** Tạm ngừng → `account_suspended` → xóa khi muốn.\n    - **Deleted:** Xóa tài khoản → `account_deleted`.\n- **Test Steps:**\n    1. Tạo tài khoản → `account_created`.\n    2. Kích hoạt → `account_activated`.\n    3. Tạm ngừng → `account_suspended`.\n    4. Kích hoạt lại → `account_activated` (nếu dịch vụ hỗ trợ).\n    5. Xóa → `account_deleted`.\n- **Expected Results:**\n    - Vòng đời được quản lý chính xác.\n    - Các trạng thái không lặp nhau."
    },
    {
      "question_id": "EQ4004-VN",
      "question": "Thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Giao dịch đầu tiên:** Initiate a transfer transaction (Step 1).\n2. **Giao dịch thứ hai:** Trigger a second transaction, this time a'save' operation (e.g., storing order details) which depends on the successful transfer.\n3. **Giao dịch thứ ba:** Attempt a 'rollback' transaction, simulating the failure of the initial transfer (e.g., reversing the account debit).\n4. **Xác minh:** Verify that the rollback transaction successfully reverses the failed transfer's effects, resulting in the account being credited back."
    },
    {
      "question_id": "EQ4006-VN",
      "question": "Viết một **test** xác thực chuỗi nhiều dịch vụ: đăng nhập → tạo đơn hàng → xử lý thanh toán → hủy đơn hàng sau khi ghi nhận.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "- **Test Case:** 1) Đăng nhập vào tài khoản khách hàng. 2) Thực hiện tạo đơn hàng. 3) Xử lý thanh toán. 4) Hủy đơn hàng. 5) Xác minh trạng thái đơn hàng được cập nhật thành 'Chưa giao' sau khi hủy."
    },
    {
      "question_id": "EQ4008-VN",
      "question": "Mô tả một **test state-machine** xác thực vòng đời mật khẩu: đặt → hết hạn → đặt lại → ngăn tái sử dụng.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "Đặt mật khẩu → test đảm bảo hoạt động hạn chế sau → thử đăng nhập nhiều lần."
    },
    {
      "question_id": "EQ4010-VN",
      "question": "Viết một **test chained** phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "1. Đăng nhập với tài khoản hợp lệ -> 2. Mở khoản vay -> 3. Triggers action registration -> 4. Đăng nhập tài khoản thất bại -> 5. Branch registration fails -> 6. Verify no DB entry created."
    },
    {
      "question_id": "EQ4012-VN",
      "question": "Viết một **test** xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra: cập nhật hồ sơ người dùng với các giá trị xung đột.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "**Kết hợp:** Simulate nhiều giao thức cập nhật đồng thời. **Vấn đề:** Nếu không đảm bảo toàn vẹn, một cập nhật lén thay đổi giá trị (VD:'status' -> 'xóa') nhưng giao thức còn cập nhật chính xác 'tên người dùng'. **Giải thích:** Test này kiểm tra xem DB được giữ nguyên khi nhiều giao thức cập nhật đồng thời."
    },
    {
      "question_id": "EQ4014-VN",
      "question": "Viết một **test chained** rất khó xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Test chained cần simulate hành động ký và xác minh. Tuy nhiên, tải lên → tải xuống → xác minh giả mạo là thử thách thực tế khó xác thực. Hơn nữa, cần đảm bảo hệ thống ký tài liệu không bị ảnh hưởng khi test diễn ra."
    },
    {
      "question_id": "EQ4017-VN",
      "question": "Viết một **test state-machine** xác thực vòng đời đăng ký: tạo → nâng cấp → hạ cấp → hủy.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Action:** Register → `POST /register`.\n2. **Expected:** → `201 Created`.\n3. **Negative:** → `409 Conflict` (duplicated).\n4. **Upgrade:** → `202 Accepted`.\n5. **Downgrade:** → `200 OK`.\n6. **Unregister:** → `DELETE /register`."
    },
    {
      "question_id": "EQ4019-VN",
      "question": "Viết một **test chained** rất khó xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Distributed orders require multiple services and dependencies, making test chaining invalid for recovery tests. A simpler approach is to isolate the failed step and test recovery individually."
    },
    {
      "question_id": "EQ4021-VN",
      "question": "Viết một **test** rất khó xác minh việc đảo ngược giao dịch tài chính: ghi nợ → ghi có → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "To design a test that verifies rollback of a financial transaction, you need to simulate a scenario where a debit (ghi nợ) is successfully recorded, followed by a credit (ghi có) to the exact opposite amount. After the system is configured to fail rollbacks, the test must inject a failure signal into the database or system state immediately after the debit is recorded. The expected outcome is that the debit transaction is reversed, and its records ( debit amount, timestamp) are removed from the database."
    },
    {
      "question_id": "EQ4023-VN",
      "question": "Thiết kế một **test state-machine** cho kho hàng: thêm hàng → phân bổ → vận chuyển → trả lại → đối chiếu.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Đặt hàng → 2) Xác nhận phân bổ → 3) Vận chuyển → 4) Trả lại → 5) Ký hợp đồng → expected: hàng được phân bổ đúng cách."
    },
    {
      "question_id": "EQ4025-VN",
      "question": "Viết một **test chained** xác thực vòng đời **session mobile**: đăng nhập → làm mới **token** → đăng xuất → làm mới với **token** cũ → thất bại.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "- **Action 1:** Triggers đăng nhập và mã hóa token.\n- **Action 2:** Triggers làm mới token.\n- **Action 3:** Triggers đăng xuất và xóa token.\n- **Action 4:** Triggers làm mới token với ID cũ → `401 Unauthorized` được trả về."
    },
    {
      "question_id": "EQ4027-VN",
      "question": "Viết một **test chained** xác thực API gửi email: gửi → theo dõi mở → hủy đăng ký → đảm bảo không gửi thêm email nào nữa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "Chained test: 1) Đăng nhập, gửi email → mail sent là true. 2) Mở email → mail sent là false. 3) Hủy đăng ký → API không gửi email nữa."
    },
    {
      "question_id": "EQ4029-VN",
      "question": "Viết một **test chained** rất khó cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại: áp dụng phiếu giảm giá → thanh toán → phiếu giảm giá không hợp lệ → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chained: 1) Đưa hàng (shipment) và áp dụng giảm giá → 2) Thanh toán (payment) → 3) Giảm giá không hợp lệ → **rollback** (vệ sinh DB với mã giảm giá không tồn tại)."
    }
  ]
}