{
  "metadata": {
    "timestamp": "20250909_204740",
    "total_writing_questions": 242
  },
  "topic_distribution": {
    "Unknown": 242
  },
  "difficulty_distribution": {
    "Easy": 94,
    "Intermediate": 60,
    "Hard": 60,
    "Very Hard": 28
  },
  "detailed_results": [
    {
      "question_id": "EQ5004",
      "question": "Write one simple positive test case for a login API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username and password → expect 200 OK with token.",
      "model_answer": "**Test Case: Successful Login**\n- **Preconditions:** A user exists with a valid password.\n- **Test Steps:** Send a `POST /login` request with a valid username and password (e.g., `{\"username\": \"testuser\", \"password\": \"TestPassword123\"}`).\n- **Expected Result:** The API returns a `200 OK` status code with a login token in the response."
    },
    {
      "question_id": "EQ5006",
      "question": "What is a common precondition for testing a user profile endpoint?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "User must be logged in and have a valid token.",
      "model_answer": "A valid user account and appropriate permissions (e.g., admin or regular user) are necessary. Additionally, the user's profile should already exist in the database."
    },
    {
      "question_id": "EQ5008",
      "question": "Write a simple negative test for a register API.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /register without password field → expect 400 Bad Request.",
      "model_answer": "Send a `POST` request with an invalid user ID (e.g., 999) and assert that the response status is `404 Not Found`."
    },
    {
      "question_id": "EQ5010",
      "question": "What is the role of a schema in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "To define the expected structure of request and response data.",
      "model_answer": "A schema defines the structure of the API request body, headers, and query parameters. It ensures consistent data formatting across tests."
    },
    {
      "question_id": "EQ5012",
      "question": "Write a simple test step for validating a 201 Created response.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid data → expect 201 Created and Location header.",
      "model_answer": "Send a `POST` request with valid data. Expected: The response status code should be `201 Created`."
    },
    {
      "question_id": "EQ5014",
      "question": "What is the purpose of mocking in API testing?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "To simulate external dependencies or services that are unavailable.",
      "model_answer": "Mocking replaces real dependent systems (like databases or other microservices) with simulated versions during testing. This allows tests to be run independently of the full infrastructure, making them faster and more reliable. It ensures the API behaves as expected without relying on external systems."
    },
    {
      "question_id": "EQ5016",
      "question": "Write one easy test case for an API that fetches product list.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products → expect 200 OK with non-empty array.",
      "model_answer": "**Test Case: Get Product List**\n- **Preconditions:** API is running, product with ID=123 exists.\n- **Test Step:** Call `GET /products` endpoint.\n- **Expected Result:** API returns `200 OK` with a valid JSON array of products."
    },
    {
      "question_id": "EQ5018",
      "question": "What is the purpose of a precondition in a test case?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It specifies the conditions that must be met before a test can run.",
      "model_answer": "A precondition is a state that must be true before a test case can be executed. It ensures that the test runs under controlled conditions."
    },
    {
      "question_id": "EQ5020",
      "question": "Write one negative test for file upload with an unsupported format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with .exe file → expect 415 Unsupported Media Type.",
      "model_answer": "Negative Test: Upload a file in a format unsupported by the server (e.g., an executable or a proprietary format). Expected Result: The upload fails with an appropriate error message (e.g., 'File type not allowed')."
    },
    {
      "question_id": "EQ5022",
      "question": "What is the purpose of a test case description?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "To explain the objective and scope of a test scenario.",
      "model_answer": "The purpose of a test case description is to provide a clear and concise explanation of what the test case aims to verify. It serves as a summary of the test's objectives, preconditions, and expected results."
    },
    {
      "question_id": "EQ5024",
      "question": "Write a test step to validate response time under 1 second.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → assert response time < 1000 ms.",
      "model_answer": "1. Send request and record timestamp.\n2. Compare with threshold (e.g., 500ms).\n3. Verify response status code."
    },
    {
      "question_id": "EQ5027",
      "question": "Write one simple positive test for GET /health endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /health → expect 200 OK with status=healthy.",
      "model_answer": "1. **Test:** Send a `GET` request to `/health`. \n2.  **Expected:** The API returns a successful `200 OK` status code with a simple response like 'healthy'."
    },
    {
      "question_id": "EQ5029",
      "question": "What is the purpose of using test data management in API testing?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "To ensure consistent and reusable datasets for testing across environments.",
      "model_answer": "Test data management provides consistent and reliable data for API testing, eliminating the need to hardcode sensitive information. It improves test repeatability, reduces manual data creation efforts, and enhances overall test efficiency."
    },
    {
      "question_id": "EQ5031",
      "question": "Write one easy negative test case for an API expecting JSON format.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /api with Content-Type: text/plain → expect 415 Unsupported Media Type.",
      "model_answer": "Send a `GET` request to a non-existent resource and assert that the response body does not contain the expected `{\"id\": 1}` JSON key."
    },
    {
      "question_id": "EQ5033",
      "question": "What is the role of assertions in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To verify that the actual response matches the expected result.",
      "model_answer": "Assertions verify conditions in API responses. They validate status codes, error messages, and data consistency, helping detect bugs early in testing."
    },
    {
      "question_id": "EQ5035",
      "question": "Write a test case to check DELETE /users/{id} works correctly.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send DELETE /users/123 → expect 204 No Content, then GET /users/123 → 404 Not Found.",
      "model_answer": "Create a user, send a DELETE request, and verify the user is now gone from the database."
    },
    {
      "question_id": "EQ5037",
      "question": "What does HTTP status 201 Created indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "A new resource has been successfully created.",
      "model_answer": "That the resource was successfully created."
    },
    {
      "question_id": "EQ5039",
      "question": "Write one simple test for GET /users/{id} returning correct response.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users/123 → expect 200 OK with correct user data.",
      "model_answer": "Test involves sending a GET request to `/users/123` and asserting the HTTP status code is `200 OK`."
    },
    {
      "question_id": "EQ5041",
      "question": "What is the purpose of a 200 OK response?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It confirms that the request has succeeded.",
      "model_answer": "It indicates the request was successful and the resource exists."
    },
    {
      "question_id": "EQ5043",
      "question": "Write one negative test to validate response for an invalid endpoint.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /unknown → expect 404 Not Found.",
      "model_answer": "Send a request to an endpoint with a missing or invalid parameter (e.g., `/users/123` without a `page` parameter). The server response should not be `200 OK`, but instead a `404 Not Found` or a custom error with a clear message."
    },
    {
      "question_id": "EQ5045",
      "question": "What does a test case assertion do?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "It checks that the actual result matches the expected outcome.",
      "model_answer": "A test case assertion is a statement (e.g., 'assert that the total is 100') that defines what the correct outcome should be. It is the 'what' part of what the test case is verifying."
    },
    {
      "question_id": "EQ5047",
      "question": "Write one positive test for file upload endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /upload with valid image.jpg → expect 201 Created and fileId returned.",
      "model_answer": "**Positive Test: File Upload**\n1. **Action:** Send a `POST` request to the file upload endpoint.\n2. **Condition:** The API should accept a valid file (e.g., `image.jpg`) and return a successful `201 Created` response with a specific upload ID."
    },
    {
      "question_id": "EQ5049",
      "question": "What is the role of 415 Unsupported Media Type?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates the server refuses to process the request because of unsupported format.",
      "model_answer": "415 is an unsupported media type. Its role is to indicate that the client understands the format but the server cannot validate it. It's commonly used in POST requests for payloads not defined by the resource's URI."
    },
    {
      "question_id": "EQ5052",
      "question": "Write a simple positive test for checking product details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /products/101 → expect 200 OK with product JSON fields present.",
      "model_answer": "Send a `GET` request to `/products/123` with a valid ID. Expected result: `200 OK` with a JSON object containing product name, price, and description."
    },
    {
      "question_id": "EQ5054",
      "question": "What is the purpose of using Authorization headers in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "To provide credentials or tokens required to access secured endpoints.",
      "model_answer": "The Authorization header is used to include a valid token or credential in requests, allowing clients to access protected resources. In testing, it simulates a valid session or permission level."
    },
    {
      "question_id": "EQ5056",
      "question": "Write a negative test case for an API requiring authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile without Authorization header → expect 401 Unauthorized.",
      "model_answer": "Send a request without a valid authentication token. Expected result: `401 Unauthorized` status code."
    },
    {
      "question_id": "EQ5058",
      "question": "What is the role of 500 Internal Server Error in API testing?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates unexpected failures in the server during request processing.",
      "model_answer": "It indicates an unexpected condition that occurred on the server."
    },
    {
      "question_id": "EQ5060",
      "question": "Write one positive test case for an API returning list of orders.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /orders → expect 200 OK with array of order objects.",
      "model_answer": "**Test Case: Get Orders**\n- **Preconditions:** User authenticated, 3 orders existing.\n- **Test Steps:** Call `/orders` endpoint → expect `200 OK`, array of valid orders with IDs, `200` indicates successful retrieval of multiple resources.\n- **Expected Result:** No errors, correct data format."
    },
    {
      "question_id": "EQ5062",
      "question": "What is the function of response headers in API testing?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "They provide metadata about the response, such as content type and caching info.",
      "model_answer": "They provide metadata about responses, such as `Location` for redirects or `ETag` for caching validation."
    },
    {
      "question_id": "EQ5064",
      "question": "Write one negative test for creating a duplicate resource.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with existing email → expect 409 Conflict.",
      "model_answer": "Create Resource A with ID=1. Send `POST /resources` again with the same data as Resource A. Expected Result: `201 Created` is not returned, and Resource B should not exist."
    },
    {
      "question_id": "EQ5066",
      "question": "What is the role of 202 Accepted in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates that the request is accepted for processing but not completed yet.",
      "model_answer": "202 Accepted is a status code indicating the request was successful but resulted in one or more unintended changes. It's often used for `PUT` or `PATCH` operations that modify the resource."
    },
    {
      "question_id": "EQ5068",
      "question": "Write one easy positive test for checking API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Send GET /users → expect 200 OK and response fields match schema definition.",
      "model_answer": "A simple positive test is to call an endpoint with a known valid parameter (e.g., `id=123`) and assert that the response body contains the expected `status` field with value `200` (or `201`, etc.)."
    },
    {
      "question_id": "EQ5070",
      "question": "What is the purpose of response body in API testing?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "To provide the actual data returned from an endpoint.",
      "model_answer": "The response body is the main data section returned by an API in an HTTP response. In API testing, it's used to verify that the API returns the expected data format, content, and structure (e.g., JSON, XML, text) for specific endpoints and under various conditions."
    },
    {
      "question_id": "EQ5072",
      "question": "Write one test case for verifying logout functionality.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login to get token. 2) POST /logout with token → expect 200 OK. 3) Retry GET /profile with same token → expect 401 Unauthorized.",
      "model_answer": "Test Case: Logout Functionality\n- Log in successfully.\n- Perform logout action (e.g., click logout button).\n- Expected Result: The user session should be cleared, and access to protected pages should be denied."
    },
    {
      "question_id": "EQ5074",
      "question": "What does a 415 Unsupported Media Type error validate?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "That the server rejects unsupported request body formats.",
      "model_answer": "It validates that the Accept header sent by the client indicates support for the `415` media type."
    },
    {
      "question_id": "EQ5077",
      "question": "Write one simple positive test for GET /status endpoint.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Send GET /status → expect 200 OK with message='Service running'.",
      "model_answer": "The positive test is: `GET /status` → `200 OK` with a simple `{\"status\": \"healthy\"}` response."
    },
    {
      "question_id": "EQ5079",
      "question": "What does a 204 No Content response mean?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It means the request was successful but no data is returned.",
      "model_answer": "A 204 No Content is a successful request response that indicates the server understood the client's request and there is no content to send in the response body. It's often used for `DELETE` or `PATCH` requests where only the server's state changes."
    },
    {
      "question_id": "EQ5081",
      "question": "Write a negative test case for sending an invalid Content-Type header.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with Content-Type: application/xml → expect 415 Unsupported Media Type.",
      "model_answer": "Send a request with a `Content-Type` header like `application=csv`. The server should either return a `415 Unsupported Media Type` error or change the format to something unsupported."
    },
    {
      "question_id": "EQ5083",
      "question": "What is the purpose of the Accept header in API requests?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "It specifies the expected response format such as JSON or XML.",
      "model_answer": "The Accept header tells the server which content types the client can understand and process. It prevents the client from receiving data it cannot handle."
    },
    {
      "question_id": "EQ5085",
      "question": "Write a simple test case for a successful logout API call.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /logout with valid token → expect 200 OK, then GET /profile with same token → 401 Unauthorized.",
      "model_answer": "**Test Case: Logout API**\n- **Preconditions:** User logged in with valid session.\n- **Test Steps:** Send `POST` request to `/logout`.\n- **Expected Result:** `200 OK` and no new session created."
    },
    {
      "question_id": "EQ5087",
      "question": "What is the meaning of 401 Unauthorized in API testing?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "It means the client must provide valid authentication credentials.",
      "model_answer": "A 401 Unauthorized response indicates that the client authentication details (e.g., API key, username, password) for the request are missing or invalid. It is similar to a login failure."
    },
    {
      "question_id": "EQ5089",
      "question": "Write one easy positive test case for checking profile details API.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send GET /profile with valid token → expect 200 OK and correct user data.",
      "model_answer": "Test creates a user with valid details (name, email, password) and retrieves it successfully."
    },
    {
      "question_id": "EQ5091",
      "question": "What is the purpose of 302 Found in APIs?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "It indicates temporary redirection to another URL.",
      "model_answer": "The 302 Found status code indicates that the client requested a resource that can be found under a different URL. It is a `3xx` redirect response, telling the client to access the resource located at the URL provided in the `-location` header. This allows caching and is common for redirects to alternative endpoints."
    },
    {
      "question_id": "EQ5093",
      "question": "Write a test case for negative login attempt with wrong password.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Send POST /login with valid username but wrong password → expect 401 Unauthorized.",
      "model_answer": "Preconditions: User exists with correct password. Test: Send wrong password → expect `401 Unauthorized` status code, not login success."
    },
    {
      "question_id": "EQ5095",
      "question": "What does 422 Unprocessable Entity indicate?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "That the request is syntactically correct but semantically invalid.",
      "model_answer": "It means the server could not process the request."
    },
    {
      "question_id": "EQ5097",
      "question": "Write a positive test for POST /users endpoint.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Send POST /users with valid user details → expect 201 Created with userId.",
      "model_answer": "Send a valid user creation payload with a unique username. \nExpected: `201 Created` with the new user's ID."
    },
    {
      "question_id": "EQ5099",
      "question": "What does the term 'happy path' mean in testing?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "It refers to the expected successful execution scenario.",
      "model_answer": "The 'happy path' refers to the most direct and successful sequence of steps in a system or process. In testing, it is the expected flow of actions that leads to a positive outcome, such as logging in successfully."
    },
    {
      "question_id": "EQ2002",
      "question": "Explain how you would design a negative test case for an API endpoint that requires OAuth2 Bearer tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "One negative test is sending the request with an expired token and expecting a 401 Unauthorized error.",
      "model_answer": "Send a request to the endpoint without including a valid OAuth2 Bearer token. The expected result is a `401 Unauthorized` status code, indicating that the request could not be fully understood without proper authentication credentials."
    },
    {
      "question_id": "EQ2004",
      "question": "Provide one happy-path and one error-path test case for a payment refund API endpoint.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Happy path: valid transaction ID returns 200 OK with refund confirmation. Error path: invalid transaction ID returns 404 Not Found.",
      "model_answer": "**Happy Path:** Send a `POST` request with a valid refund ID and amount, expecting a `200 OK` response. **Error Path:** Send a request with an invalid refund ID, expecting a `400 Bad Request` status code."
    },
    {
      "question_id": "EQ2006",
      "question": "How would you validate schema changes in a backward-compatible API upgrade?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Compare the new schema with the old one to ensure no required fields are removed and existing data types remain unchanged.",
      "model_answer": "Run contract tests, update client generation, and ensure no existing clients fail."
    },
    {
      "question_id": "EQ2008",
      "question": "Explain how mocking can be used to test a payment API without calling the real bank service.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Mocking simulates the bank’s responses (success, failure) so tests can run without making real financial transactions.",
      "model_answer": "Mocking allows you to simulate the payment processing function without actually calling the bank. The API will interact with a mock bank service, which will be configured to either succeed or fail according to the test. This isolates the payment API from external dependencies."
    },
    {
      "question_id": "EQ2010",
      "question": "Design one boundary test and one invalid test for an API field `age` (range 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary test: age=18 and age=65 return 200 OK. Invalid test: age=17 or age=66 return 400 Bad Request.",
      "model_answer": "Boundary Test: `POST /registration` with `age` = 65 (valid boundary). Invalid Test: `POST /registration` with `age` = 0 (too young)."
    },
    {
      "question_id": "EQ2012",
      "question": "Explain how you would simulate a network timeout error in API testing.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Introduce artificial network delay or configure client timeout lower than server response time to trigger timeout handling.",
      "model_answer": "By configuring a mock server to simulate a slow connection or by using a network emulator like WireMock with a timeout configuration."
    },
    {
      "question_id": "EQ2014",
      "question": "Give one example of an API precondition and one step that follows it.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Precondition: User must be logged in with a valid token. Step: Call profile API with the token to fetch user data.",
      "model_answer": "Precondition: A user's session token is required. \nStep: The API call for creating a new order must include this token."
    },
    {
      "question_id": "EQ2016",
      "question": "Write one test case to validate that API rate limiting is enforced correctly.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send 110 requests within 1 minute when the limit is 100 requests/minute; expect 429 Too Many Requests for excess calls.",
      "model_answer": "1. **Test Case: Rate Limit Enforcement**\n\t* **Preconditions:** API rate limit (e.g., 100 requests/min) is active.\n\t* **Steps:**\n\t\t1. Send `GET /resources` repeatedly until the limit is reached (e.g., 101 requests).\n\t\t2. The API should return a `429 Too Many Requests` status code with a `rateLimitRemaining` count after the limit is exceeded.\n\t* **Expected Result:** No unauthorized requests are accepted after the limit is reached."
    },
    {
      "question_id": "EQ2018",
      "question": "Explain one advantage of using service virtualization in API testing.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows testing APIs that depend on unavailable or costly third-party services by simulating their behavior.",
      "model_answer": "It allows testing with simplified or mock services before real ones are ready."
    },
    {
      "question_id": "EQ2020",
      "question": "Describe how to design one positive and one boundary test case for a login API requiring username and password.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: valid username and password return 200 OK with token. Boundary: username at max length returns 200 OK if valid.",
      "model_answer": "Positive Test (Valid Login): Input valid username and password → expect `200 OK` with token. Boundary Test: Input shortest allowed username (e.g., 'abc') → expect `200 OK` with token."
    },
    {
      "question_id": "EQ2022",
      "question": "Write one test step to validate that an API correctly returns 415 Unsupported Media Type.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Send a POST request with Content-Type: text/plain to an endpoint expecting application/json, expect 415.",
      "model_answer": "Send a request with a non-accepted media type (e.g., 'image/base64'). The expected result is a `200 OK` status code with a payload like `{ \"status\": \"okay\" }` and a `VND` header for `unsupported-media-type`."
    },
    {
      "question_id": "EQ2024",
      "question": "Describe one way to test observability when an API experiences a slow database query.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Inject artificial DB slowness and confirm that tracing/logging captures the delay and propagates metrics.",
      "model_answer": "Inject a latency injection tool into the database connection pool. Verify that the API's response time is properly highlighted in a monitoring tool like Prometheus or Datadog. Example: inject a 2-second delay between API request processing and the first database query execution."
    },
    {
      "question_id": "EQ2026",
      "question": "Explain how you would test API idempotency for a retry scenario.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Send the same POST request twice with the same idempotency key; confirm only one resource is created.",
      "model_answer": "Send the same request multiple times. Expected: All requests should return `200 OK`, no new entries should appear in a retry log, and state should not change."
    },
    {
      "question_id": "EQ2028",
      "question": "Give one boundary and one invalid test for a file upload API accepting max 5 MB files.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: upload 5 MB file, expect 200 OK. Invalid: upload 6 MB file, expect 413 Payload Too Large.",
      "model_answer": "Boundary: Upload a 5 MB file and verify the response. Invalid Test: Attempt to upload a file larger than 5 MB (e.g., 10 MB) and expect a `413` (Payload Too Large) error."
    },
    {
      "question_id": "EQ2030",
      "question": "Write a test case to validate proper error handling when an API is called with a missing required field `email`.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send POST /register without email field; expect 400 Bad Request with validation error message.",
      "model_answer": "**Test Case: Missing Email**\n- **Precondition:** API endpoint for creating an account.\n- **Test Step:** Send `POST` request to `/register` (e.g., `https://api.example.com/register`) **without** a `email` field in the payload.\n- **Expected Result:** The API returns a `400 Bad Request` or `401 Unauthorized` status code with a clear error message indicating that the `email` field is required."
    },
    {
      "question_id": "EQ2032",
      "question": "How would you design a test to validate retry logic when an API occasionally returns 503?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Configure mock service to return 503 for first two requests, then 200 OK on third. Validate client retries correctly.",
      "model_answer": "1. **Precondition:** Set up a mock server to simulate a 503 Bad Gateway response. 2. **Test Steps:** 1) Send a `POST` request with a timeout (e.g., 5 seconds). 2) Verify that the initial request fails with a `Gateway Timeout` error or a `503` response. 3) The retry mechanism should then kick in, and subsequent requests should succeed. 4) Ensure the retry count is capped."
    },
    {
      "question_id": "EQ2034",
      "question": "Write a test case that validates log correlation using a trace ID header.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Send GET /orders with X-Trace-ID header, confirm logs include the same trace ID across service boundaries.",
      "model_answer": "Test sends a request with a unique trace ID → expect logs matched by that ID in the test case. Verify logs associated with correct span ID and level (e.g., 'INFO 12345') are retrieved. Fail if logs not found or mismatched."
    },
    {
      "question_id": "EQ2036",
      "question": "Design one intermediate-level test case for validating API rate limiting when multiple clients are involved.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate two clients each sending 60 requests in a minute when limit is 100 total; confirm excess requests get 429 Too Many Requests.",
      "model_answer": "Test sends 5 requests instantly, then verify 3/5 of requests are rate-limited with `200 OK` and count is correct."
    },
    {
      "question_id": "EQ2038",
      "question": "Describe one positive and one negative test case for an API endpoint that sends SMS codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Positive: send SMS to valid phone number, expect 200 OK. Negative: send SMS to invalid number format, expect 400 Bad Request.",
      "model_answer": "Positive Test: Send a request with a valid phone number and expected response is `200 OK` with a successful message. Negative Test: Send a request with a phone number that does not exist in the database, expected response is `404 Not Found`."
    },
    {
      "question_id": "EQ2040",
      "question": "Explain one advantage of mocking external APIs when testing failure scenarios.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "It allows deterministic simulation of errors (timeouts, 500s) without depending on real external failures.",
      "model_answer": "Mocking prevents real users or services from being impacted."
    },
    {
      "question_id": "EQ2042",
      "question": "Write one test case to validate error handling when API returns malformed JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate API returning incomplete JSON body; client should raise parsing error or return proper 500-level error message.",
      "model_answer": "**Test Case: Malformed JSON Error**\n- **Precondition:** API configured to reject malformed inputs.\n- **Action:** Send `POST` request with a JSON body containing unexpected keys (e.g., `{\"user\": {\"id\": 123}}` instead of `{\"id\": 123}`).\n- **Expected Result:** API returns `400 Bad Request` with a clear error message, not a `200 OK`."
    },
    {
      "question_id": "EQ2044",
      "question": "Design one test step to confirm rate limiting headers (e.g., X-RateLimit-Remaining) are present.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Send requests close to limit and verify X-RateLimit-Remaining decreases until exhausted.",
      "model_answer": "Send a request to an API endpoint with a high request limit. The expected result is that the API responds with a `200 OK` status code and the rate limiting headers (e.g., `X-RateLimit-Remaining`) present in the response body."
    },
    {
      "question_id": "EQ2046",
      "question": "Describe one advantage of separating test data from test logic in API testing.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "It allows the same test logic to be reused with different datasets across environments, improving maintainability.",
      "model_answer": "Separating test data from test logic allows for independent setup and teardown of the test environment, improving test repeatability."
    },
    {
      "question_id": "EQ2048",
      "question": "Write a test case for validating graceful degradation when API cache is unavailable.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate cache outage, API should still return data from DB though slower, not fail completely.",
      "model_answer": "Test sends request for cached resource → expect `403 Forbidden` or `404 Not Found`. Verify API reverts to original response instead of error stack. Ensure DB state intact."
    },
    {
      "question_id": "EQ2050",
      "question": "Explain one way to validate logging for sensitive fields such as passwords.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Check logs after login requests and confirm sensitive values like passwords are redacted or masked.",
      "model_answer": "Automatically hash and store test passwords, then query logs to verify they are encoded correctly. A negative validation is to inject a known hash into a log field, then check the database to confirm the system remembers the hash."
    },
    {
      "question_id": "EQ2052",
      "question": "Provide one negative and one boundary test case for a currency field that must match ISO 4217 codes.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Boundary: use valid code ‘USD’. Negative: use invalid code ‘USDX’, expect 400 Bad Request.",
      "model_answer": "Negative Test: Input 'USD' (valid code) as 'EUR'. Boundary Test: Input 'USD' (valid code) as 'USD'."
    },
    {
      "question_id": "EQ2054",
      "question": "Write one test case to validate API behavior under network packet loss.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Simulate 30% packet loss using a network emulator; API client should retry or fail gracefully with clear error.",
      "model_answer": "Test sends 10 packets for a single request. Expected: API returns `500 Internal Server Error` or timeout if threshold exceeded."
    },
    {
      "question_id": "EQ2056",
      "question": "Describe one method to verify test data cleanup after API test execution.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Insert a test record, run test, then query DB to confirm cleanup job removed it.",
      "model_answer": "Preconditions: Table or database with known test data inserted. After API test execution, query the database for the inserted data. Expected: The specific record should either exist (positive scenario) or not exist (negative scenario with deletion)."
    },
    {
      "question_id": "EQ2058",
      "question": "Write a test case to verify proper rollback when a multi-step transaction partially fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Perform transaction with 3 steps; force failure in step 2; verify no partial data persists from step 1.",
      "model_answer": "Test involves executing a sequence of DB operations (e.g., `INSERT`, `UPDATE`, `DELETE`). Inject failure midway (e.g., `INSERT` fails). Expected: Transaction rolls back to initial state, no partial changes left in DB."
    },
    {
      "question_id": "EQ2060",
      "question": "Explain one approach to validating error messages follow a consistent JSON schema across all endpoints.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Send invalid inputs to multiple endpoints and check if error response follows standard schema {code, message, details}.",
      "model_answer": "Automatically validate each endpoint's response against a shared JSON schema. This ensures that error messages, like `400 Bad Request`, follow the same structure and key names everywhere. Tools like JSON Schema validators or integrated API test suites can perform this automated validation."
    },
    {
      "question_id": "EQ3002",
      "question": "Write a test case that validates login, token refresh, and accessing a protected API using the refreshed token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login with valid creds → 200 OK with token. 2) Wait until token nearly expires. 3) POST /refresh with refresh token → 200 OK with new token. 4) Call protected API with new token → 200 OK.",
      "model_answer": "Test: 1) Login -> 2) Token Refresh -> 3) Call Protected API with Fresh Token."
    },
    {
      "question_id": "EQ3004",
      "question": "Design a chained test validating that a failed login attempt still prevents refresh token generation.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Attempt POST /login with wrong password → 401. Try POST /refresh without a valid refresh token → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: User A's token is valid. 2. Action: Send failed login attempt (wrong username). 3. Expected: No refresh token generated."
    },
    {
      "question_id": "EQ3006",
      "question": "Explain how you would validate correct mapping of business codes (e.g., ORDER_001) to HTTP status codes in API responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send requests triggering each business error, verify that ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, etc., as per mapping table.",
      "model_answer": "Create a business rules engine mapping (e.g., a JSON file) that defines order status codes like `ORDER_001 -> 200 OK`. Automate tests by injecting this mapping into a test script, which then asserts that the correct status code is returned for each valid order status."
    },
    {
      "question_id": "EQ3008",
      "question": "Write one hard-level test case chaining order creation, payment, and refund APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment with orderId → 200 OK. 3) POST /refund with same orderId → 200 OK and refund processed.",
      "model_answer": "1. Order creation → 2. Payment processing → 3. Refund generation."
    },
    {
      "question_id": "EQ3010",
      "question": "Explain one test case that validates token refresh works across multiple microservices.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Login to Auth service → get token → refresh token → call Service A and Service B with new token → both return 200 OK.",
      "model_answer": "Test case: Token Refresh Loop. 1. Service A (consumer) requests a token from Service B (token provider). 2. Service B generates a short-lived token (e.g., 5 minutes). 3. Service A sends the token to a payment gateway (Service C). 4. After token lifetime expires, Service B refreshes the token. 5. Verify that the refreshed token now works with Service C for more than 5 minutes."
    },
    {
      "question_id": "EQ3012",
      "question": "Write a test that validates mapping of validation error codes to HTTP 400 responses.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Send invalid payloads like missing required fields → expect HTTP 400 with app code VALIDATION_ERR_01.",
      "model_answer": "Preconditions: Validation library mocked with specific error codes. Test sends invalid request with each code → expect `400 Bad Request` with correct error text."
    },
    {
      "question_id": "EQ3014",
      "question": "Design a test case validating expired refresh tokens cannot issue new access tokens.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get refresh token. 2) Expire token manually or wait. 3) Call /refresh → expect 401 Unauthorized.",
      "model_answer": "1. Precondition: A user token and refresh token (with expiration time known) are set up. 2. The test sends a 401 Unauthorized response when using an expired refresh token to obtain a new access token. 3. The system must prevent a valid access token from being issued with an expired refresh token."
    },
    {
      "question_id": "EQ3016",
      "question": "Explain one multi-hop chained test that validates session invalidation after logout.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call protected endpoint → 200 OK. 3) Call /logout. 4) Call protected endpoint again → expect 401 Unauthorized.",
      "model_answer": "Perform a multi-hop chained test by 1) logging in, 2) performing action A, 3) logging out, 4) attempting action B, and 5) asserting that action B fails with'session not active'."
    },
    {
      "question_id": "EQ3018",
      "question": "Write a test case chaining signup, email verification, and login endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created with verification link. 2) GET /verify with token → 200 OK. 3) POST /login → 200 OK with access token.",
      "model_answer": "Test: 1) Precondition: User email exists. 2) Signup → `201 Created`. 3) Email Verification → `200 OK` (if valid). 4) Login → `200 OK` with correct credentials."
    },
    {
      "question_id": "EQ3020",
      "question": "Design one hard-level chained test validating a password reset flow.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password with email → 200 OK. 2) GET /reset-link with token → 200 OK. 3) POST /reset-password with new password → 200 OK. 4) Login with new password → 200 OK.",
      "model_answer": "1. **Precondition:** User `A` exists with an email and password reset token. 2. **Action:** Perform a hard-level chained test by simulating a valid login (`A` logs in), a password reset request (`A` clicks reset), and finally, attempting to use the reset token (`A` submits reset form). 3. **Verification:** The test validates whether the system correctly enforces a single use per token (`reset submitted → 401 Unauthorized`) and whether the token cannot be reused (`same token used twice → 409 Conflict`), all while ensuring the flow remains stateful and secure."
    },
    {
      "question_id": "EQ3022",
      "question": "Write a chained test case for validating user creation, profile update, and profile retrieval.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 with userId. 2) PUT /users/{id} with updated data → 200. 3) GET /users/{id} → 200 with updated fields.",
      "model_answer": "Create a test case with three sub-cases: user creation, profile update, and profile retrieval, all chained together."
    },
    {
      "question_id": "EQ3024",
      "question": "Explain one test to validate refresh token cannot be used after logout.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Login to get refresh token → logout → attempt POST /refresh with old token → expect 401 Unauthorized.",
      "model_answer": "1. **Test:** Use a valid refresh token to obtain a new access token. 2. **Expected Result:** The response for the new access token request should not include an `expires_at` field or a `token_type` of `200 OK`. 3. **Rationale:** If the token is valid, it should still have expiration information."
    },
    {
      "question_id": "EQ3026",
      "question": "Write a test case validating correct mapping of internal error code AUTH_EXPIRED to HTTP status.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Trigger expired token → expect HTTP 401 Unauthorized with app code AUTH_EXPIRED.",
      "model_answer": "**Test Case: Authentication Expiration**\n- **Preconditions:** User session expires after 5 minutes.\n- **Test Steps:** 1) Send `POST /login` with expired token → expect `401 Unauthorized` not `200 OK`. 2) Verify authentication service returns `AUTH_EXPIRED` error code.\n- **Expected Result:** API response should map `AUTH_EXPIRED` to HTTP status `401 Unauthorized`."
    },
    {
      "question_id": "EQ3028",
      "question": "Explain a chained test validating email verification failure if token is invalid.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → user created. 2) GET /verify?token=invalid → expect 400 or 401. 3) Login attempt fails until verified.",
      "model_answer": "Test steps: 1) Send valid email confirmation → expect `200 OK`. 2) Send email with invalid token (e.g., `123` instead of `abc`): expect `404 Not Found` or `401 Unauthorized`. 3) Send email with expired token: expect `400 Bad Request`."
    },
    {
      "question_id": "EQ3030",
      "question": "Write a hard-level test case chaining loan application, credit check, and approval endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check with appId → 200 with status passed. 3) POST /approve with appId → 200 approved.",
      "model_answer": "Test case: 'Loan Approval Flow'. Preconditions: Test account, mock credit service. Steps: 1) Valid Loan → 3xx Approved, 2) Declined Credit → 401 Unauthorized, 3) Missing Field → 400 Bad Request. Expected: Loan service returns approved or rejected."
    },
    {
      "question_id": "EQ3032",
      "question": "Design a test case chaining signup, password reset, and login with new credentials.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password with email → 200. 3) Login with new password → 200 OK.",
      "model_answer": "Test Case: End-to-End Authentication. Preconditions: User exists. Steps: Signup → Password Reset → Login with new credentials. Expected: Corrected email/username."
    },
    {
      "question_id": "EQ3034",
      "question": "Write a test case chaining file upload, virus scan, and download endpoints.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 clean. 3) GET /download/{id} → 200 file returned.",
      "model_answer": "Test case includes steps for uploading files, triggering a virus scan, and then downloading the scan report."
    },
    {
      "question_id": "EQ3036",
      "question": "Explain one chained test for validating refresh token reuse prevention.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login → get refresh token. 2) POST /refresh once → new token. 3) Retry old refresh token again → expect 401 Unauthorized.",
      "model_answer": "1. Token 1 (short lifetime) + 1 refresh → new token. 2. Same Token 1 reused → 401 Unauthorized. Verify system prevents reuse."
    },
    {
      "question_id": "EQ3038",
      "question": "Write a test case chaining search, add-to-cart, and checkout APIs.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 results. 2) POST /cart → 201 with itemId. 3) POST /checkout → 200 with order confirmation.",
      "model_answer": "1. **Search Product:** Send `GET /products` with a specific ID → `200 OK` with product details. 2. **Add-to-Cart:** Send `POST /cart` with product ID → `201 Created` with cart update. 3. **Checkout:** Send `POST /checkout` with customer data and cart ID → `302 Found` with order confirmation."
    },
    {
      "question_id": "EQ3040",
      "question": "Explain one chained test for validating API session hijacking prevention.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Login as User A → get token. 2) Attempt to use token from User A in User B’s session → expect 403 Forbidden.",
      "model_answer": "1. Log in with a valid token → session established.\n2. Perform second login attempt with identical credentials → expect `401 Unauthorized` or session rejection.\n3. If multiple requests reuse token, API must enforce logout or expire session quickly."
    },
    {
      "question_id": "EQ3042",
      "question": "Provide exactly one chained test case to verify optimistic concurrency using ETag with If-Match across update and read endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → receive ETag=v1. 2) PUT /resource with If-Match=v1 → 200 OK. 3) Retry PUT /resource with stale If-Match=v1 → 412 Precondition Failed.",
      "model_answer": "1. **Test Scenario:** Send `POST /resource` with ETag `ETG-123` → `201 Created`. 2. **Chained Test:** Send `GET /resource` with `If-Match: ETG-123` → `200 OK` if fresh. 3. **Optimistic Update:** Send `PUT /resource` (update) with new ETag `ETG-456`. → `409 Conflict` if concurrent. 4. **Chained Test (continued):** Send `PUT /resource` with stale ETag → `412 Precondition Failed`."
    },
    {
      "question_id": "EQ3044",
      "question": "Design a multi-hop test verifying async export job: POST /exports -> poll GET /jobs/{id} until complete -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted with jobId. 2) Poll GET /jobs/{id} until status=done. 3) GET /exports/{id} → 200 OK with file.",
      "model_answer": "1. Send initial POST /exports request with async export job. 2. Poll GET /jobs/{id} until status changes from 'pending' to 'completed'. 3. Verify final export status with GET /exports/{id], asserting final state (e.g., 'complete', file available)."
    },
    {
      "question_id": "EQ3046",
      "question": "Give one chained negative test for OAuth2 Authorization Code: /authorize -> /token -> resource call with missing scope.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize with user consent → code. 2) /token → access token with limited scope. 3) Call resource requiring scopeX → 403 Forbidden.",
      "model_answer": "Send a request for an authorization code with no scope (e.g., `/authorize?client_id=abc&redirect_uri=http://example.com/callback&state=xyz` but no `scope=`) and verify the response is an `403 Forbidden` or `400 Bad Request` with an error code like `invalid_grant`."
    },
    {
      "question_id": "EQ3048",
      "question": "Write one chained test that covers idempotent charge creation with Idempotency-Key across retry and refund endpoints.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge with Idempotency-Key=abc → 201 Created. 2) Retry same request with Idempotency-Key=abc → 200 OK (same chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "1. Given a user with an Idempotency-Key, create chained tests for retry and refund: 1) Charge → 200 OK, 2) Retry → 202 Accepted, 3) Refund → 200 OK with no double charge."
    },
    {
      "question_id": "EQ3050",
      "question": "Provide one chained test for file processing pipeline: upload -> POST /process -> poll status -> download, including 202 handling.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 with fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Poll GET /status/{id} until done. 4) GET /download/{id} → 200 file returned.",
      "model_answer": "1. **Action/Request:** Send `POST /process` with file and action=submit.\n2. **State Check:** Poll `/status` until 'processing complete' response.\n3. **Verification:** Confirm file downloaded and integrity preserved."
    },
    {
      "question_id": "EQ3052",
      "question": "Give one chained test to validate SSO session revocation propagates to API gateway and microservice access.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login via SSO → token issued. 2) Access API gateway → 200. 3) Revoke session in IdP. 4) Retry API call → 401 Unauthorized across all microservices.",
      "model_answer": "1. Log in with SSO → session granted → revoke session → expect API response `403` or `404 Not Found` for protected endpoints."
    },
    {
      "question_id": "EQ3054",
      "question": "Write one chained test for partial order fulfillment: create order -> reserve inventory -> partial ship -> cancel remaining and refund delta.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 with orderId. 2) POST /reserve/{id} → 200 reserved. 3) POST /ship/{id} with partial items → 200 shipped. 4) POST /cancel/{id} → refund issued.",
      "model_answer": "1. Given an order, when it's created, it should reserve inventory and partial ship some items. 2. The system should then process a cancel for the remaining items. 3. Verify that only the initial order cost (not partial shipment) is refunded."
    },
    {
      "question_id": "EQ3056",
      "question": "Provide exactly one chained negative test for 2FA login: POST /login -> POST /2fa/verify with wrong code -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Login with username/password → 200 pending 2FA. 2) POST /2fa/verify with wrong code → 401 Unauthorized. 3) Attempt refresh → 401 Unauthorized.",
      "model_answer": "1. Log in normally → `200 OK`. 2. Send 2FA verification request with wrong verification code → `401 Unauthorized`. 3. Send request to refresh token → `403 Forbidden`."
    },
    {
      "question_id": "EQ3058",
      "question": "Design a chained test verifying pagination consistency across create -> list -> delete -> list (with total count assertions).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → count increases. 3) DELETE /items/{id} → 200. 4) GET /items → count decreases.",
      "model_answer": "Create chain with 10 items (page=1), verify page count and total count on list, delete last → expect DB consistent removal (no duplicate counts)."
    },
    {
      "question_id": "EQ3060",
      "question": "Write one chained test for session stickiness: login -> subsequent calls via load balancer -> logout -> verify no node accepts old token.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Login to get token. 2) Call service through LB multiple times → same node/session. 3) Logout. 4) Retry → all nodes return 401.",
      "model_answer": "1. Chain: 1) Login user A. 2) Call API via load balancer -> expect 200 OK. 3) Logout user A. 4) Verify no node (e.g., DB API) accepts session token for user A after logout."
    },
    {
      "question_id": "EQ4002",
      "question": "Write a state-machine style test validating account lifecycle: create → activate → suspend → reactivate → delete.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /accounts → 201 Created. 2) POST /activate/{id} → 200. 3) POST /suspend/{id} → 200. 4) POST /reactivate/{id} → 200. 5) DELETE /accounts/{id} → 204. Confirm GET /accounts/{id} → 404.",
      "model_answer": "Define states: Active, Suspended, Deactivated. Transitions validated by preconditions (e.g., valid email → create), actions (e.g., activate, suspend), and reverse transitions (e.g., reactivate). Postconditions ensure state transitions are correct."
    },
    {
      "question_id": "EQ4004",
      "question": "Design a chained test that validates transaction rollback when step 2 of a 3-step money transfer fails.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /transfer/initiate → 201. 2) POST /transfer/step2 with invalid details → failure 400. 3) Verify DB shows no partial transfer recorded.",
      "model_answer": "Test steps: 1) Initiate money transfer. 2) Simulate fraudulent transaction. 3) Verify database rolled back, not committed."
    },
    {
      "question_id": "EQ4006",
      "question": "Write one test validating a multi-service chain: login → create order → process payment → cancel order after capture.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → 200 token. 2) POST /orders → 201. 3) POST /payment → 200 capture. 4) POST /cancel/{orderId} → refund → 200 OK. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "1. **Precondition:** A user with a valid payment method exists in the database. \n2. **Test Steps:**\n   - Log in as that user.\n   - Create a new order via the login service.\n   - Trigger payment processing.\n   - Cancel the order.\n   - **Verification:** The order's status should change from 'pending' to 'cancelled'."
    },
    {
      "question_id": "EQ4008",
      "question": "Describe one state-machine test validating password lifecycle: set → expire → reset → reuse prevention.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /password/set → 200. 2) Expire password manually. 3) POST /password/reset → 200. 4) Attempt reuse of old password → 400 Bad Request.",
      "model_answer": "Test: 1) Log in with valid password → set. 2) Wait for password expiration → 'password expired' error. 3) Attempt reset → successful reset. 4) Verify new password is reused → negative validation."
    },
    {
      "question_id": "EQ4010",
      "question": "Write one complex chained test covering a loan application flow with branch failure in credit check.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /loan/apply → 201. 2) POST /loan/credit-check with bad history → 400 failed. 3) Ensure /loan/approve not allowed. 4) GET /loan/{id} → status=denied.",
      "model_answer": "1. Precondition: Loan system mocked to return 'approved' for valid application and'rejected' for failed credit check.\n2. Test Steps: Submit valid loan application → expect 'Approved' response and db update. Submit loan application with failed credit check → expect 'Rejected' response and db update. Chain failure: Submit loan application with service mocked to return 'error' (e.g., DB connection failure)."
    },
    {
      "question_id": "EQ4012",
      "question": "Write a test validating data integrity when concurrent writes occur: update user profile with conflicting values.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) PUT /users/{id} name=Alice with If-Match=v1 → 200. 2) PUT /users/{id} name=Bob with stale If-Match=v1 → 412 Precondition Failed. 3) GET /users/{id} → Alice.",
      "model_answer": "Preconditions: Two writers attempt to update user profile with different values (e.g., 'John' and 'Jane') simultaneously. Expected Result: Only one update succeeds, DB contains single, consistent profile record, and other writer's attempt fails with 409 Conflict Error."
    },
    {
      "question_id": "EQ4014",
      "question": "Write one very hard test validating chained document signing: upload → sign → verify → tamper detection.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /documents → 201. 2) POST /sign/{id} → 200. 3) GET /verify/{id} → valid signature. 4) Modify file → GET /verify/{id} → invalid signature detected.",
      "model_answer": "Create a test where a signed document is uploaded, then tampered with, signed again, and verified. Preconditions: document content known, tamper-proof seal available. Expected: verification fails if tampered, signed again unique."
    },
    {
      "question_id": "EQ4017",
      "question": "Write one state-machine test validating subscription lifecycle: create → upgrade → downgrade → cancel.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /subscriptions → 201. 2) POST /upgrade/{id} → 200. 3) POST /downgrade/{id} → 200. 4) DELETE /subscriptions/{id} → 204. GET /subscriptions/{id} → 404.",
      "model_answer": "Test case: 1) Subscribe → 2) Upgrade subscription → 3) Downgrade → 4) Cancel subscription. Expected: Subscription state transitions follow lifecycle rules."
    },
    {
      "question_id": "EQ4019",
      "question": "Write a very hard chained test validating recovery after partial failure in a distributed order saga.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /order → 201. 2) Reserve stock → 200. 3) Payment fails → 402. 4) Verify stock reservation auto-cancelled. 5) GET /orders/{id} → status=cancelled.",
      "model_answer": "Send order for payment, shipping, and inventory updates in sequence. Expected: Order state should still be 'pending' but all dependent events (e.g., shipped order with missing inventory update) should be rolled back to state 'pending' or 'failed'. No database consistency violations."
    },
    {
      "question_id": "EQ4021",
      "question": "Write one very hard test verifying financial transaction reversals: debit → credit → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /debit → 200. 2) POST /credit → 200. 3) Simulate system failure. 4) Rollback both debit and credit. 5) Verify account balances unchanged.",
      "model_answer": "1. Perform a debit transaction. 2. Immediately call a payment service API to process a subsequent credit transaction. 3. Roll back the debit transaction (e.g., via API's cancel method or database rollback). Verify that the debit amount is still available in the debit's original account, but the credit transaction was never processed."
    },
    {
      "question_id": "EQ4023",
      "question": "Design a state-machine test for warehouse inventory: add stock → allocate → ship → return → reconcile.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /stock/add → 200. 2) POST /allocate → 200. 3) POST /ship → 200. 4) POST /return → 200. 5) GET /inventory → final count reconciled.",
      "model_answer": "Preconditions: stock → products allocated → shipments confirmed → returns processed. Test steps: add stock → ship product → return item → reconcile stock. Verify state transitions: stock → allocated → shipped → returned → reconciled."
    },
    {
      "question_id": "EQ4025",
      "question": "Write one chained test validating mobile session lifecycle: login → token refresh → logout → refresh with old token → fail.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /login → token. 2) POST /refresh → new token. 3) POST /logout. 4) Attempt refresh again with old token → 401 Unauthorized.",
      "model_answer": "1. Send login request → expect `auth_token` in response.\n2. Send `auth_token` to API → expect `200 OK` with new token (token refresh).\n3. Send logout request → expect `204 No Content`.\n4. Send refresh with old `auth_token` → expect `401 Unauthorized` or `404 Not Found`."
    },
    {
      "question_id": "EQ4027",
      "question": "Write one chained test validating email delivery API: send → open-tracking → unsubscribe → ensure no further emails sent.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /emails → 202 Accepted. 2) GET /tracking/{id} → open recorded. 3) POST /unsubscribe → 200. 4) POST /emails → 202 but no delivery for unsubscribed user.",
      "model_answer": "1. Send email → 2. Verify email opened → 3. Confirm unsubscribe processed → 4. Assert no further emails sent."
    },
    {
      "question_id": "EQ4029",
      "question": "Write one very hard chained test for purchase flow with coupon application and failure branch: apply coupon → checkout → coupon invalid → rollback.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) POST /apply-coupon → 400 invalid. 2) POST /checkout → rejected. 3) Ensure order not persisted. 4) GET /orders → coupon not applied.",
      "model_answer": "Chain: 1) Apply valid coupon → 2) Click 'Apply Coupon' → 3) 4) Use expired coupon → 5) Mock payment service to fail → 6) Purchase flow should rollback with 'Coupon expired' error."
    },
    {
      "question_id": "EQ5004-VN",
      "question": "Viết một test case positive đơn giản cho một API đăng nhập.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username và password hợp lệ → mong đợi 200 OK kèm token.",
      "model_answer": "Đăng nhập với tài khoản đã tồn tại và xác minh được session được trả về."
    },
    {
      "question_id": "EQ5006-VN",
      "question": "Điều kiện tiên quyết phổ biến để test một endpoint user profile là gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Người dùng phải được đăng nhập và có một token hợp lệ.",
      "model_answer": "A valid user token or authentication header. Test ensures only authorized users can access profile."
    },
    {
      "question_id": "EQ5008-VN",
      "question": "Viết một test negative đơn giản cho một API đăng ký.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /register mà không có trường password → mong đợi 400 Bad Request.",
      "model_answer": "Triggers a `401 Unauthorized` với tài khoản không tồn tại."
    },
    {
      "question_id": "EQ5010-VN",
      "question": "Vai trò của một schema trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Để định nghĩa cấu trúc dữ liệu mong đợi của request và response.",
      "model_answer": "A schema defines the expected structure and data types for API requests and responses. It acts as a contract between the API provider and consumers, ensuring consistent data exchange. Without a schema, testing becomes unrepeatable and unreliable."
    },
    {
      "question_id": "EQ5012-VN",
      "question": "Viết một test step đơn giản để validate một response 201 Created.",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với dữ liệu hợp lệ → mong đợi 201 Created và Location header.",
      "model_answer": "1. **Action:** Send a `POST` request (e.g., to `/products`).\n2.  **Validation:** After the request, access the newly created resource's ID. \n    1. **Expected:** The ID should be present and unique (not `null` or `0`, unique)."
    },
    {
      "question_id": "EQ5014-VN",
      "question": "Mục đích của mocking trong API testing là gì?",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Easy",
      "gold_answer": "Để mô phỏng các phụ thuộc hoặc dịch vụ bên ngoài không khả dụng.",
      "model_answer": "Mocking simulates the behavior of real dependencies like APIs or databases during testing. Its goal is to isolate the API under test from external failures, allowing consistent and faster test execution."
    },
    {
      "question_id": "EQ5016-VN",
      "question": "Viết một test case dễ dàng cho một API lấy danh sách sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products → mong đợi 200 OK với một array không rỗng.",
      "model_answer": "Tiêu chí: API trả danh sách không vaz lỗi khi không tìm thấy sản phẩm."
    },
    {
      "question_id": "EQ5018-VN",
      "question": "Mục đích của một precondition trong một test case là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định các điều kiện phải được đáp ứng trước khi một test có thể chạy.",
      "model_answer": "Preconditions xác định điều kiện bắt đầu cần đáp ứng. Ví dụ, hệ thống cần có một tài khoản đã được tạo."
    },
    {
      "question_id": "EQ5020-VN",
      "question": "Viết một test negative cho việc upload file với định dạng không được hỗ trợ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với file .exe → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chọn một file format không được server hỗ trợ (như file audio). Send request upload file với mã body này. Expected: `400 Bad Request` hoặc `403 Forbidden`."
    },
    {
      "question_id": "EQ5022-VN",
      "question": "Mục đích của một test case description là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Để giải thích mục tiêu và phạm vi của một test scenario.",
      "model_answer": "A test case description explains what the test case aims to verify. It's a concise summary of the test's objective and preconditions."
    },
    {
      "question_id": "EQ5024-VN",
      "question": "Viết một test step để validate thời gian response dưới 1 giây.",
      "category": "Performance & Load Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → assert response time < 1000 ms.",
      "model_answer": "1. **Precondition:** Configured API to cache responses.\n2. **Action:** Send request for static resource.\n3. **Validation:** Check response time (< 1s)."
    },
    {
      "question_id": "EQ5027-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /health.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /health → mong đợi 200 OK với status=healthy.",
      "model_answer": "Send a `GET` request to `/health`. Expect the API to respond with a `200 OK` status code and a simple body like `{\"status\": \"healthy\"}`."
    },
    {
      "question_id": "EQ5029-VN",
      "question": "Mục đích của việc sử dụng test data management trong API testing là gì?",
      "category": "Environment & Test Data Management",
      "difficulty": "Easy",
      "gold_answer": "Để đảm bảo các bộ dữ liệu nhất quán và có thể tái sử dụng để testing trên các môi trường.",
      "model_answer": "It ensures consistent and repeatable test execution with valid data."
    },
    {
      "question_id": "EQ5031-VN",
      "question": "Viết một test negative dễ dàng cho một API mong đợi định dạng JSON.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /api với Content-Type: text/plain → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Trả lời: Send a `POST` request với body chứa ký tự đặc biệt như `\\u00e1` (á). Expect `201 Created` nếu trường dữ liệu tồn tại. Kiểm tra database để assert không tìm thấy record với giá trị như này."
    },
    {
      "question_id": "EQ5033-VN",
      "question": "Vai trò của assertion trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để xác minh rằng response thực tế khớp với kết quả mong đợi.",
      "model_answer": "It confirms that API behaves exactly as expected."
    },
    {
      "question_id": "EQ5035-VN",
      "question": "Viết một test case để kiểm tra DELETE /users/{id} hoạt động đúng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi DELETE /users/123 → mong đợi 204 No Content, sau đó GET /users/123 → 404 Not Found.",
      "model_answer": "Test case: **Delete User**. Precondition: User ID = 123 exists. Action: Send DELETE request → expect `204 No Content` response."
    },
    {
      "question_id": "EQ5037-VN",
      "question": "Mã trạng thái HTTP 201 Created cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Một tài nguyên mới đã được tạo thành công.",
      "model_answer": "Mã trạng thái HTTP 201 Created được sử dụng để chỉ báo một tài nguyên đã được tạo mới."
    },
    {
      "question_id": "EQ5039-VN",
      "question": "Viết một test đơn giản cho GET /users/{id} trả về response chính xác.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users/123 → mong đợi 200 OK với dữ liệu người dùng chính xác.",
      "model_answer": "Trả về một JSON với ID và tên hợp lệ."
    },
    {
      "question_id": "EQ5041-VN",
      "question": "Mục đích của một response 200 OK là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó xác nhận rằng request đã thành công.",
      "model_answer": "It indicates the request was successful and the response body contains the resource requested."
    },
    {
      "question_id": "EQ5043-VN",
      "question": "Viết một test negative để validate response cho một endpoint không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /unknown → mong đợi 404 Not Found.",
      "model_answer": "Send a request with an invalid or missing argument (e.g., `/users/` without ID). Expected: `400 Bad Request` hoặc `404 Not Found`. Response không được thay đổi."
    },
    {
      "question_id": "EQ5045-VN",
      "question": "Một test case assertion làm gì?",
      "category": "Test Step",
      "difficulty": "Easy",
      "gold_answer": "Nó kiểm tra rằng kết quả thực tế khớp với kết quả mong đợi.",
      "model_answer": "Test case assertion xác nhận kết quả của test case. Nó là câu lệnh `Then` hoặc `Expected` trong ngôn ngữ mô tả chức năng. Nó xác định điều gì được coi là hànhingen (đáp ứng) khi mã được thực hiện."
    },
    {
      "question_id": "EQ5047-VN",
      "question": "Viết một test positive cho endpoint upload file.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /upload với image.jpg hợp lệ → mong đợi 201 Created và fileId được trả về.",
      "model_answer": "Send a `POST` request with a valid file (e.g., `image.jpg`) and assert the response status is `200 OK`."
    },
    {
      "question_id": "EQ5049-VN",
      "question": "Vai trò của 415 Unsupported Media Type là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết server từ chối xử lý request vì định dạng không được hỗ trợ.",
      "model_answer": "415 Unsupported Media Type được sử dụng khi server không hỗ trợ một loại dữ liệu cụ thể. Nó là mã phản hồi chung khi request gửi format không được server hỗ trợ. Nó không liên quan đến dữ liệu không được chấp nhận."
    },
    {
      "question_id": "EQ5052-VN",
      "question": "Viết một test positive đơn giản để kiểm tra API chi tiết sản phẩm.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /products/101 → mong đợi 200 OK với các trường JSON sản phẩm hiện diện.",
      "model_answer": "*   **Định nghĩa:** Test sẽ gửi yêu cầu `POST /products` với bộ dữ liệu sản phẩm đầy đủ (id, tên, giá, mô tả, danh mục). **Kết quả:** API trả lời `201 Created` với body chứa thông tin sản phẩm mới."
    },
    {
      "question_id": "EQ5054-VN",
      "question": "Mục đích của việc sử dụng Authorization headers trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp thông tin đăng nhập hoặc token cần thiết để truy cập các endpoint được bảo mật.",
      "model_answer": "It restricts access to protected resources."
    },
    {
      "question_id": "EQ5056-VN",
      "question": "Viết một test negative case cho một API yêu cầu authentication.",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile mà không có Authorization header → mong đợi 401 Unauthorized.",
      "model_answer": "Provide a valid token in the request, then deliberately omit the authentication header."
    },
    {
      "question_id": "EQ5058-VN",
      "question": "Vai trò của 500 Internal Server Error trong API testing là gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết các lỗi không mong muốn trong server trong quá trình xử lý request.",
      "model_answer": "Internal Server Error 500 được trả khi API gặp lỗi không được client hiểu, như một vấn đề server. Trong API testing, nó giúp xác định điểm lỗi internal trên server."
    },
    {
      "question_id": "EQ5060-VN",
      "question": "Viết một test case positive cho một API trả về danh sách đơn hàng.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /orders → mong đợi 200 OK với một array các order object.",
      "model_answer": "**Test Case:** **Retrieve List of Orders**\n- **Preconditions:** Đã có ít nhất 3 đơn hàng được tạo trước.\n- **Action:** Send `GET` request đến `/orders`.\n- **Expected Result:** API trả `200 OK` với mảng danh sách các đơn hàng (ví dụ: `[{id: 1, customer_id: 2},...]`)."
    },
    {
      "question_id": "EQ5062-VN",
      "question": "Chức năng của response header trong API testing là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Chúng cung cấp metadata về response, như content type và caching info.",
      "model_answer": "They provide metadata about the request and response, such as status code, content type, and caching instructions. Useful for automating API requests without needing to know the full response body."
    },
    {
      "question_id": "EQ5064-VN",
      "question": "Viết một test negative cho việc tạo một tài nguyên trùng lặp.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với email đã tồn tại → mong đợi 409 Conflict.",
      "model_answer": "1. **Đầu vào:** Chia sẻ cùng một tài nguyên giữa hai job.\n2. **Kết quả mong đợi:** Job thứ hai nên tạo ra một tài nguyên khác biệt với job đầu tiên, không phải bản sao lặp lại."
    },
    {
      "question_id": "EQ5066-VN",
      "question": "Vai trò của 202 Accepted trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết rằng request được chấp nhận để xử lý nhưng chưa hoàn thành.",
      "model_answer": "It xác định rằng request đã được xác minh và không bị từ chối vì thời hạn."
    },
    {
      "question_id": "EQ5068-VN",
      "question": "Viết một test positive dễ dàng để kiểm tra API response schema.",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /users → mong đợi 200 OK và các trường response khớp với schema definition.",
      "model_answer": "Send a `POST` request with all required fields (e.g., `user={id}`). Verify the API returns a `200 OK` status with a valid response schema in the body."
    },
    {
      "question_id": "EQ5070-VN",
      "question": "Mục đích của response body trong API testing là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Để cung cấp dữ liệu thực tế được trả về từ một endpoint.",
      "model_answer": "Response body chứa dữ liệu trả về client sau một yêu cầu. Trong API testing, bạn kiểm tra nội dung này để xác minh mã trả về, trạng thái cơ bản, hoặc các dữ liệu được tạo."
    },
    {
      "question_id": "EQ5072-VN",
      "question": "Viết một test case để verify chức năng logout.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "1) Login để lấy token. 2) POST /logout với token → mong đợi 200 OK. 3) Thử lại GET /profile với cùng token → mong đợi 401 Unauthorized.",
      "model_answer": "- **Action:** Click logout button.\n- **Expected:** Session count (e.g., count of authenticated users) should reset to 0."
    },
    {
      "question_id": "EQ5074-VN",
      "question": "Lỗi 415 Unsupported Media Type validate điều gì?",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Rằng server từ chối các định dạng request body không được hỗ trợ.",
      "model_answer": "It validates that the media type (format) in the request is not supported by the server."
    },
    {
      "question_id": "EQ5077-VN",
      "question": "Viết một test positive đơn giản cho endpoint GET /status.",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /status → mong đợi 200 OK với message='Service running'.",
      "model_answer": "Triggers request to `/status` with status `200 OK`. Expected: `200 OK` with body `OK`."
    },
    {
      "question_id": "EQ5079-VN",
      "question": "Một response 204 No Content có nghĩa là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là request đã thành công nhưng không có dữ liệu nào được trả về.",
      "model_answer": "No Content (204) được sử dụng khi client yêu cầu một resource nhưng không muốn tải toàn bộ resource vào bộ nhớ. Server sẽ trả back header `Content-Length` nhưng không gửi body."
    },
    {
      "question_id": "EQ5081-VN",
      "question": "Viết một test negative case cho việc gửi một Content-Type header không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với Content-Type: application/xml → mong đợi 415 Unsupported Media Type.",
      "model_answer": "Chỉ Send a payload với Content-Type → 400 Bad Request."
    },
    {
      "question_id": "EQ5083-VN",
      "question": "Mục đích của Accept header trong các API request là gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Nó chỉ định định dạng response mong đợi như JSON hoặc XML.",
      "model_answer": "The `Accept` header tells the server which response formats it supports. For example, `Accept: application/json` means the client can handle JSON data. This is important for interoperability and flexibility."
    },
    {
      "question_id": "EQ5085-VN",
      "question": "Viết một test case đơn giản cho một API logout thành công.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /logout với token hợp lệ → mong đợi 200 OK, sau đó GET /profile với cùng token → 401 Unauthorized.",
      "model_answer": "* **Preconditions:** Một token login được tạo ra. * **Action:** Call `/logout` API. * **Expected:** Trả lời `200 OK` và DB không còn session cho user."
    },
    {
      "question_id": "EQ5087-VN",
      "question": "Ý nghĩa của 401 Unauthorized trong API testing là gì?",
      "category": "Authentication & Authorization",
      "difficulty": "Easy",
      "gold_answer": "Nó có nghĩa là client phải cung cấp thông tin xác thực hợp lệ.",
      "model_answer": "It means authentication failed, so requests need a valid token."
    },
    {
      "question_id": "EQ5089-VN",
      "question": "Viết một test case positive dễ dàng để kiểm tra API chi tiết profile.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi GET /profile với token hợp lệ → mong đợi 200 OK và dữ liệu người dùng chính xác.",
      "model_answer": "- **Preconditions:** Một tài khoản được đăng ký (ID: `user_id_123`) với một email xác định.\n- **Action:** Gửi một yêu cầu đến endpoint `POST /profile` sử dụng email unique (ví dụ: `user@example.com`).\n- **Expected:** API trả mã số `201 Created` với một bản ghi profile mới (tập tin JSON)."
    },
    {
      "question_id": "EQ5091-VN",
      "question": "Mục đích của 302 Found trong các API là gì?",
      "category": "General Testing",
      "difficulty": "Easy",
      "gold_answer": "Nó cho biết việc redirection tạm thời đến một URL khác.",
      "model_answer": "It indicates the resource has been found and moved."
    },
    {
      "question_id": "EQ5093-VN",
      "question": "Viết một test case cho nỗ lực đăng nhập negative với mật khẩu sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /login với username hợp lệ nhưng password sai → mong đợi 401 Unauthorized.",
      "model_answer": "- **Preconditions:** Tài khoản exist nhưng mật khẩu không được lưu.\n-  **Steps:** Triggers login endpoint với parameter = 'wrong_password'.\n-  **Verification:** DB không ghi nhận giao dịch tạo tài khoản."
    },
    {
      "question_id": "EQ5095-VN",
      "question": "422 Unprocessable Entity cho biết điều gì?",
      "category": "Contract & Schema Validation",
      "difficulty": "Easy",
      "gold_answer": "Rằng request có cú pháp đúng nhưng ngữ nghĩa không hợp lệ.",
      "model_answer": "It means the server could not fulfill the request but it is a client error."
    },
    {
      "question_id": "EQ5097-VN",
      "question": "Viết một test positive cho endpoint POST /users.",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Gửi POST /users với user details hợp lệ → mong đợi 201 Created với userId.",
      "model_answer": "Send a valid JSON payload with email and password fields. Expected: `201 Created` with user ID in response body."
    },
    {
      "question_id": "EQ5099-VN",
      "question": "Thuật ngữ 'happy path' trong testing có nghĩa là gì?",
      "category": "Test Case",
      "difficulty": "Easy",
      "gold_answer": "Nó đề cập đến kịch bản thực thi thành công mong đợi.",
      "model_answer": "'Happy path' là một thuật ngữ testing chỉ đơn đường hợp lệ ( successful sequence of steps )."
    },
    {
      "question_id": "EQ2002-VN",
      "question": "Hãy giải thích cách bạn thiết kế một **test case âm tính** cho một endpoint API yêu cầu **OAuth2 Bearer token**.",
      "category": "Authentication & Authorization",
      "difficulty": "Intermediate",
      "gold_answer": "Một **test case âm tính** là gửi yêu cầu với một **token** đã hết hạn và mong đợi lỗi **401 Unauthorized**.",
      "model_answer": "Test case âm tính (negative test) gửi yêu cầu với mã token không tồn tại hoặc expired. **Mô hình:** 1. **Precondition:** Chế độ phát hành (base URL) và client ID được sử dụng. 2. **Action:** Send request với tham số `access_token` là `null` hoặc `expired` (tài khoản đã hết hạn). 3. **Expected:** Trả lời là `403 Forbidden` hoặc `400 Bad Request`."
    },
    {
      "question_id": "EQ2004-VN",
      "question": "Cung cấp một **test case happy-path** và một **test case error-path** cho một endpoint API hoàn tiền thanh toán.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Happy path**: ID giao dịch hợp lệ trả về **200 OK** với xác nhận hoàn tiền. **Error path**: ID giao dịch không hợp lệ trả về **404 Not Found**.",
      "model_answer": "**Test Case Happy-Path:** Triggers request với số tiền đủ (e.g., 100) và từ từ xác nhận. **Test Case Error-Path:** Triggers request với số tiền 0 hoặc không tồn tại."
    },
    {
      "question_id": "EQ2006-VN",
      "question": "Bạn sẽ xác thực các thay đổi **schema** trong một nâng cấp API **tương thích ngược** như thế nào?",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "So sánh **schema** mới với **schema** cũ để đảm bảo không có trường bắt buộc nào bị xóa và các kiểu dữ liệu hiện có vẫn không thay đổi.",
      "model_answer": "By running migration scripts backward and validating database snapshots."
    },
    {
      "question_id": "EQ2008-VN",
      "question": "Giải thích cách **mocking** có thể được sử dụng để kiểm tra một API thanh toán mà không gọi dịch vụ ngân hàng thực.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "**Mocking** mô phỏng các phản hồi của ngân hàng (thành công, thất bại) để các **test** có thể chạy mà không thực hiện các giao dịch tài chính thực tế.",
      "model_answer": "Giả tạo một mô hình hoặc dịch vụ giả (mock) để thay thế ngân hàng. API Thanh toán sẽ gọi vào mock để thực hiện giao dịch. Điều này cho phép kiểm tra logic mà không cần liên kết với thực tế."
    },
    {
      "question_id": "EQ2010-VN",
      "question": "Thiết kế một **boundary test** và một **invalid test** cho trường API `age` (phạm vi 18–65).",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary test**: **age**=18 và **age**=65 trả về **200 OK**. **Invalid test**: **age**=17 hoặc **age**=66 trả về **400 Bad Request**.",
      "model_answer": "*   **Boundary Test:** Chia age vào giới hạn (18, 65) và send request. **Invalid Test:** Send request với age < 18 (dưới 18) hoặc > 65 (trên 65)."
    },
    {
      "question_id": "EQ2012-VN",
      "question": "Giải thích cách bạn mô phỏng lỗi **network timeout** trong **API testing**.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Đưa vào độ trễ mạng nhân tạo hoặc cấu hình **timeout** của máy khách thấp hơn thời gian phản hồi của máy chủ để kích hoạt xử lý **timeout**.",
      "model_answer": "Simulate a slow or unreliable network connection by manipulating the request timeout or introducing latency in the HTTP request. This allows testers to verify error handling and retries for such scenarios."
    },
    {
      "question_id": "EQ2014-VN",
      "question": "Đưa ra một ví dụ về một **precondition** API và một **step** theo sau nó.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "**Precondition**: Người dùng phải đăng nhập với một **token** hợp lệ. **Step**: Gọi API hồ sơ với **token** để lấy dữ liệu người dùng.",
      "model_answer": "Precondition: Một người dùng có tài khoản. Step: Thử đăng nhập và lấy token."
    },
    {
      "question_id": "EQ2016-VN",
      "question": "Viết một **test case** để xác thực rằng **API rate limiting** được thực thi đúng.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi 110 yêu cầu trong 1 phút khi giới hạn là 100 yêu cầu/phút; mong đợi **429 Too Many Requests** cho các cuộc gọi vượt quá.",
      "model_answer": "1. **Action:** Send 100+ requests in 1 minute via API.\n2.  **Expected:** API trả lời `600 Bad Gateway` sau giới hạn, không phản hồi `200 OK`.\n3.  **Preconditions:** API configurated với giới hạn request/minute."
    },
    {
      "question_id": "EQ2018-VN",
      "question": "Giải thích một lợi thế của việc sử dụng **service virtualization** trong **API testing**.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép kiểm tra các API phụ thuộc vào các dịch vụ bên thứ ba không có sẵn hoặc tốn kém bằng cách mô phỏng hành vi của chúng.",
      "model_answer": "It allows testing with simulated dependent services before real deployment."
    },
    {
      "question_id": "EQ2020-VN",
      "question": "Mô tả cách thiết kế một **test case tích cực** và một **boundary test case** cho một API đăng nhập yêu cầu tên người dùng và mật khẩu.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: tên người dùng và mật khẩu hợp lệ trả về **200 OK** với **token**. **Boundary**: tên người dùng có độ dài tối đa trả về **200 OK** nếu hợp lệ.",
      "model_answer": "A positive test case gửi parameters hợp lệ (ví dụ: \"john.doe\" và \"Password123\") và kiểm tra phản hồi 200 OK. A boundary test case kiểm tra giới hạn: nhập \"000000\" hoặc \"ZZZ\" để xem API xử lý trường hợp biên nào."
    },
    {
      "question_id": "EQ2022-VN",
      "question": "Viết một **test step** để xác thực rằng một API trả về **415 Unsupported Media Type** một cách chính xác.",
      "category": "Test Step",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi một yêu cầu **POST** với **Content-Type: text/plain** đến một **endpoint** mong đợi **application/json**, mong đợi **415**.",
      "model_answer": "1. **Action:** Send a `POST` request đến endpoint này với đầu đề `application/octet-stream`.\n2. **Expected:** API trả `415 Unsupported Media Type`.\n3. **Verification:** Check status code và trả lời là `415`."
    },
    {
      "question_id": "EQ2024-VN",
      "question": "Mô tả một cách để **test** **observability** khi một API gặp phải một truy vấn cơ sở dữ liệu chậm.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn độ chậm cơ sở dữ liệu nhân tạo và xác nhận rằng **tracing/logging** nắm bắt được độ trễ và truyền các chỉ số.",
      "model_answer": "Tìm hiểu xem API trả lời nhanh hay chậm khi DB bị kẹt. Ví dụ, nếu DB slow query cólatime = 30s, API sẽ có delay đó xuất hiện trong phản hồi thời gian."
    },
    {
      "question_id": "EQ2026-VN",
      "question": "Giải thích cách bạn sẽ kiểm tra **API idempotency** cho một kịch bản **retry**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi cùng một yêu cầu **POST** hai lần với cùng một **idempotency key**; xác nhận chỉ có một tài nguyên được tạo.",
      "model_answer": "Chuẩn bị **test case** với hành động **create** hoặc **update**. Send yêu cầu lần đầu và kiểm tra rằng DB được cập nhật một lần. Tiếp theo, gửi yêu cầu **đồng** (tương tự) và expecting không thay đổi. Finally, thử **nạp lại** (retry) sau một khoảng thời gian và kiểm tra DB không bị cập nhật thêm."
    },
    {
      "question_id": "EQ2028-VN",
      "question": "Đưa ra một **boundary test** và một **invalid test** cho một API tải file chấp nhận file tối đa 5 MB.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: tải file 5 MB, mong đợi **200 OK**. **Invalid**: tải file 6 MB, mong đợi **413 Payload Too Large**.",
      "model_answer": "**Boundary Test:** Chia file 5 MB thành hai phần, tải hai phần cùng API. **Invalid Test:** Tải một file quá lớn hơn giới hạn (e.g., 10 MB), API trả `413 Payload Too Large`."
    },
    {
      "question_id": "EQ2030-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi thích hợp khi một API được gọi với trường bắt buộc `email` bị thiếu.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **POST /register** mà không có trường email; mong đợi **400 Bad Request** với thông báo lỗi xác thực.",
      "model_answer": "**Test Case:** Triggers endpoint không cung cấp email → expect `400 Bad Request` với mã lỗi và thông đi cụ thể."
    },
    {
      "question_id": "EQ2032-VN",
      "question": "Bạn sẽ thiết kế một **test** để xác thực logic **retry** như thế nào khi một API thỉnh thoảng trả về **503**?",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Cấu hình dịch vụ **mock** để trả về **503** cho hai yêu cầu đầu tiên, sau đó **200 OK** ở lần thứ ba. Xác thực máy khách **retry** đúng cách.",
      "model_answer": "Đầu vào: `{\"url\": \"https://api.example.com\", \"status_code\": 503}`. **Test:** 1) Send request -> `503` Response. 2) Configure retry logic -> nếu thất bại, nên thử lại sau 5 phút. 3) Expected: Request thứ 2 được chèn vào Log/DB với thời gian thực hiện khác."
    },
    {
      "question_id": "EQ2034-VN",
      "question": "Viết một **test case** xác thực việc tương quan **log** bằng cách sử dụng **trace ID header**.",
      "category": "Observability & Monitoring",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi **GET /orders** với **header X-Trace-ID**, xác nhận các **log** bao gồm cùng một **trace ID** trên các ranh giới dịch vụ.",
      "model_answer": "- **Định nghĩa:** Log record có thể được liên kết với một **trace ID** (bằng nhãn trace ID trong request). \n- **Test Case:** 1) Send request với trace ID header. 2) Check log records có matching trace ID. 3) Verificaregister match correct trace."
    },
    {
      "question_id": "EQ2036-VN",
      "question": "Thiết kế một **test case** cấp độ trung gian để xác thực **API rate limiting** khi có nhiều máy khách tham gia.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng hai máy khách, mỗi máy gửi 60 yêu cầu trong một phút khi giới hạn là 100 tổng cộng; xác nhận các yêu cầu vượt quá nhận được **429 Too Many Requests**.",
      "model_answer": "1. **Test Case Name:** Verify API Rate Limiting with Concurrent Clients.\n2.  **Preconditions:** 1) API configured with rate limit (e.g., 100 requests/min). 2) 3-5 machines (máy khách) cùng chạy request script. 3) Log collector active.\n3.  **Test Steps:** 1) Machine A–Bắt đầu gửi request (`/endpoint`) liên tục. 2) Machines B & C cũng làm tương tự. 3) Wait và kiểm tra: 1) Số request total trên API phải `< cap (điểm giới) >`. 2) Logs must show tất cả 3 máy đều bị giới hạn (e.g., `200 OK` với số lượng giới hạn). 3) Nếu API bị tấn công DDoS, phải phản hồi `429 Too Many Requests` hoặc `500 Internal Server Error`."
    },
    {
      "question_id": "EQ2038-VN",
      "question": "Mô tả một **test case tích cực** và một **test case âm tính** cho một endpoint API gửi mã **SMS**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "Tích cực: gửi **SMS** đến số điện thoại hợp lệ, mong đợi **200 OK**. Âm tính: gửi **SMS** đến định dạng số không hợp lệ, mong đợi **400 Bad Request**.",
      "model_answer": "- **Test case tích cực (Positive):** Chèn một số điện thoại hợp lệ gửi SMS và kiểm tra xem trả lời `200 OK` là hợp lý hay không.\n- **Test case âm tính (Negative):** Chèn một số điện thoại không tồn tại hoặc đã bị chặn rồi."
    },
    {
      "question_id": "EQ2040-VN",
      "question": "Giải thích một lợi thế của việc **mock** các API bên ngoài khi kiểm tra các kịch bản thất bại.",
      "category": "Mocking & Service Virtualization",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép mô phỏng lỗi có tính xác định (**timeout**, **500**) mà không phụ thuộc vào các lỗi bên ngoài thực tế.",
      "model_answer": "Mocking API bên ngoài cho phép kiểm tra các kịch bản thất bại mà không cần truy cập internet. Lợi thế là hệ thống được test có hành động theo cách được thiết kế."
    },
    {
      "question_id": "EQ2042-VN",
      "question": "Viết một **test case** để xác thực việc xử lý lỗi khi API trả về **JSON** bị định dạng sai.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng API trả về thân **JSON** không đầy đủ; máy khách phải đưa ra lỗi phân tích cú pháp hoặc trả về thông báo lỗi cấp **500** thích hợp.",
      "model_answer": "**Test Case:** Triggers request với body JSON không hợp lệ (chẳng hạn, thiếu field, giá trị không hợp lệ). **Expected Result:** API trả `400 Bad Request` hoặc `400 Bad Request` với body lỗi nhưng không bị chuyển đổi thành mã JSON."
    },
    {
      "question_id": "EQ2044-VN",
      "question": "Thiết kế một **test step** để xác nhận các **rate limiting header** (ví dụ: **X-RateLimit-Remaining**) có mặt.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi yêu cầu gần giới hạn và xác minh **X-RateLimit-Remaining** giảm cho đến khi cạn kiệt.",
      "model_answer": "1. **Action:** Send request with all required rate limiting headers (e.g., `X-RateLimit-Remaining`, `X-RateLimit-Reset`, `X-RateLimit-Limit`).\n2. **Expected:** Ensure tất cả các header này *đã được gửi* và có giá trị (bằng kiểm tra `assert` trên response)."
    },
    {
      "question_id": "EQ2046-VN",
      "question": "Mô tả một lợi thế của việc tách dữ liệu **test** khỏi logic **test** trong **API testing**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Nó cho phép cùng một logic **test** được sử dụng lại với các tập dữ liệu khác nhau trên các môi trường, cải thiện khả năng bảo trì.",
      "model_answer": "Tách dữ liệu **test** giúp chạy các test độc lập, tránh thay đổi tình trạng dữ liệu giữa các test run khác nhau. Lợi thế là test tự động có thể được chạy nhiều lần mà không gây sự cố."
    },
    {
      "question_id": "EQ2048-VN",
      "question": "Viết một **test case** để xác thực việc suy thoái **graceful** khi **cache** API không có sẵn.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất **cache**, API vẫn phải trả về dữ liệu từ **DB** mặc dù chậm hơn, không phải thất bại hoàn toàn.",
      "model_answer": "Đề xuất: 1) Triggers -> 2) Check DB instead of cache. 3) Verify no 500 error, but graceful failure (e.g., return `not found`)."
    },
    {
      "question_id": "EQ2050-VN",
      "question": "Giải thích một cách để xác thực việc **logging** cho các trường nhạy cảm như mật khẩu.",
      "category": "Security Testing",
      "difficulty": "Intermediate",
      "gold_answer": "Kiểm tra các **log** sau yêu cầu đăng nhập và xác nhận các giá trị nhạy cảm như mật khẩu được che hoặc che mặt.",
      "model_answer": "Log một phần của dữ liệu (chẳng hạn, chỉ số truy vấn) thay vì toàn bộ. Điều này cho phép bảo mật dữ liệu nhạy cảm trong khi vẫn cung cấp thông tin hữu ích."
    },
    {
      "question_id": "EQ2052-VN",
      "question": "Cung cấp một **test case âm tính** và một **boundary test case** cho một trường tiền tệ phải khớp với mã **ISO 4217**.",
      "category": "Test Case",
      "difficulty": "Intermediate",
      "gold_answer": "**Boundary**: sử dụng mã hợp lệ ‘USD’. Âm tính: sử dụng mã không hợp lệ ‘USDX’, mong đợi **400 Bad Request**.",
      "model_answer": "**Test Case:**\n- **Đề bài:** Đặt hàng giá 500 USD.\n- **Động viên:** Vérify mã VAT được trả đúng (US).\n- **Đáp ứng:** Nếu DB trống, DB trả 000. Nếu quy tắc, trả US.\n\n**Test Case âm tính:**\n- **Đề bài:** Xác nhận hàng không có giá (0 USD) được xử lý đúng.\n- **Động viên:** Vérify DB trống không chứa giá.\n\n**Boundary Test Case:**\n- **Đề bài:** Đặt hàng giá 999 USD.\n- **Động viên:** Vérify mã VAT được trả đúng (US)."
    },
    {
      "question_id": "EQ2054-VN",
      "question": "Viết một **test case** để xác thực hành vi API dưới tình trạng mất gói mạng.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Mô phỏng mất 30% gói bằng cách sử dụng một trình giả lập mạng; máy khách API nên **retry** hoặc thất bại một cách **graceful** với lỗi rõ ràng.",
      "model_answer": "1. **Action:** Triggers API request (e.g., `POST /orders`) via client.\n2. **Condition:** Simulate packet loss or disconnection.\n3. **Expected:** API không trả lời ngay, nhưng sau một thời gian, trả lời `500 Internal Server Error` với thông báo '`Connection timed out'`."
    },
    {
      "question_id": "EQ2056-VN",
      "question": "Mô tả một phương pháp để xác minh việc dọn dẹp dữ liệu **test** sau khi thực hiện **API test**.",
      "category": "Environment & Test Data Management",
      "difficulty": "Intermediate",
      "gold_answer": "Chèn một bản ghi **test**, chạy **test**, sau đó truy vấn **DB** để xác nhận công việc dọn dẹp đã xóa nó.",
      "model_answer": "Giải pháp: 1) Triggers event (thực hiện action). 2) Verify DB query (API create user) is cleared. 3) Verify storage file (e.g., log, config) is deleted. **Test:** API setup creates test user, which is then deleted to confirm cleanup."
    },
    {
      "question_id": "EQ2058-VN",
      "question": "Viết một **test case** để xác minh việc **rollback** đúng cách khi một giao dịch nhiều bước thất bại một phần.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Intermediate",
      "gold_answer": "Thực hiện giao dịch với 3 bước; buộc thất bại ở bước 2; xác minh không có dữ liệu một phần nào tồn tại từ bước 1.",
      "model_answer": "Test Case: Rollback with Failed Transaction. Preconditions: Transaction with two valid steps and one failed step exists. Expected Result: Only failed steps rolled back, remaining data unchanged."
    },
    {
      "question_id": "EQ2060-VN",
      "question": "Giải thích một cách tiếp cận để xác thực các thông báo lỗi tuân theo một **JSON schema** nhất quán trên tất cả các **endpoint**.",
      "category": "Contract & Schema Validation",
      "difficulty": "Intermediate",
      "gold_answer": "Gửi các đầu vào không hợp lệ đến nhiều **endpoint** và kiểm tra xem phản hồi lỗi có tuân theo **schema** tiêu chuẩn {code, message, details} hay không.",
      "model_answer": "Xác thực: 1) Send request with `200 OK` payload → xác thực schema. 2) Valid parameters → `200 OK`. 3) Invalid → `400 Bad Request`. 4) Endpoint-specific validation → combine schemas."
    },
    {
      "question_id": "EQ3002-VN",
      "question": "Viết một test case xác thực việc đăng nhập, làm mới token và truy cập một API được bảo vệ bằng token đã được làm mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /login với thông tin đăng nhập hợp lệ → 200 OK kèm token. 2) Chờ đến khi token gần hết hạn. 3) POST /refresh với refresh token → 200 OK kèm token mới. 4) Gọi API được bảo vệ với token mới → 200 OK.",
      "model_answer": "1. **Mô hình:** 1 user exists, API protected.\n2. **Đầu vào:** Một request đăng nhập (HTTP `POST`) với một mật khẩu valid.\n3. **Và/Or:** Một request đến một API được bảo vệ (ví dụ `/products`).\n4. **Kết luận:** API được trả về với status `200 OK` và body valid."
    },
    {
      "question_id": "EQ3004-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác thực rằng một nỗ lực đăng nhập không thành công vẫn ngăn cản việc tạo refresh token.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "Thử POST /login với mật khẩu sai → 401. Thử POST /refresh mà không có refresh token hợp lệ → mong đợi 401 Unauthorized.",
      "model_answer": "Chuỗi: 1) Triggers Login API. 2) Validate session. 3) Tạo Refresh Token (if valid session). 4) Verifies refresh token (if available). Bài kiểm tra: Send login request → expect `200 OK` và refresh token được trả về. Try login với account đã bị khóa → expect `200 OK` nhưng refresh token sẽ không được trả về."
    },
    {
      "question_id": "EQ3006-VN",
      "question": "Giải thích cách bạn sẽ xác thực việc ánh xạ chính xác các mã nghiệp vụ (ví dụ: ORDER_001) tới các mã trạng thái HTTP trong các phản hồi API.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các yêu cầu kích hoạt từng lỗi nghiệp vụ, xác minh rằng ORDER_001 → 409 Conflict, ORDER_002 → 404 Not Found, v.v., theo bảng ánh xạ.",
      "model_answer": "Tập trung vào việc mã hóa và giải mã trong quy trình xử lý. Ví dụ, nếu mã nghiệp vụ là `ORDER_001`, thì mã trạng thái HTTP là `200 OK` (mã trạng thái cơ bản). Xác thực được khi phản hồi API trả về mã trạng thái HTTP này sau khi mã hóa và kiểm tra lại với mã nghiệp vụ."
    },
    {
      "question_id": "EQ3008-VN",
      "question": "Viết một test case cấp độ khó chuỗi các API tạo đơn hàng, thanh toán và hoàn tiền.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 Created. 2) POST /payment với orderId → 200 OK. 3) POST /refund với cùng orderId → 200 OK và hoàn tiền được xử lý.",
      "model_answer": "- **Preconditions:** APIs được khởi động. - **Test Steps:** 1) Tạo đơn hàng. 2) Thẻ thanh toán được tạo và liên kết với tài khoản. 3) Hợp đồng thanh toán được tạo và kết nối với thẻ. 4) Hoàn tiền API được gọi. - **Expected Results:** DB chứa đơn hàng, thanh toán, và khoản hoàn tiền được tìm thấy."
    },
    {
      "question_id": "EQ3010-VN",
      "question": "Giải thích một test case xác thực việc làm mới token hoạt động trên nhiều microservice.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập vào dịch vụ Auth → lấy token → làm mới token → gọi Service A và Service B với token mới → cả hai đều trả về 200 OK.",
      "model_answer": "Test case: 1) Đăng nhập -> trả token. 2) Call API khác -> sử dụng token. 3) Kiểm tra DB liên quan -> token có valid."
    },
    {
      "question_id": "EQ3012-VN",
      "question": "Viết một bài kiểm tra xác thực ánh xạ các mã lỗi xác thực tới các phản hồi HTTP 400.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Gửi các payload không hợp lệ như thiếu các trường bắt buộc → mong đợi HTTP 400 với mã ứng dụng VALIDATION_ERR_01.",
      "model_answer": "Kiểm tra yêu cầu tham số xác thực (id) trong URL. Các mã lỗi xác thực → phản hồi 400 Bad Request (ví dụ: mã lỗi 20001 → 'Expected valid ID' → 400 Bad Request). Xác minh phản hồi đúng format."
    },
    {
      "question_id": "EQ3014-VN",
      "question": "Thiết kế một test case xác thực rằng các refresh token đã hết hạn không thể cấp các access token mới.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy refresh token. 2) Làm cho token hết hạn thủ công hoặc chờ. 3) Gọi /refresh → mong đợi 401 Unauthorized.",
      "model_answer": "1. **Action:** Triggers refresh token lifetime (e.g., 1 minute) to expire.\n2. **Expected Result:** API reject refresh with `400 Bad Request: no valid verification code` or `403 Forbidden: token has expired`.\n3. **Precondition:** Refresh token created with known lifetime (e.g., 1 minute)."
    },
    {
      "question_id": "EQ3016-VN",
      "question": "Giải thích một bài kiểm tra chuỗi đa bước (multi-hop chained test) xác thực việc hủy bỏ session sau khi đăng xuất.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi endpoint được bảo vệ → 200 OK. 3) Gọi /logout. 4) Gọi lại endpoint được bảo vệ → mong đợi 401 Unauthorized.",
      "model_answer": "Bài kiểm tra này yêu cầu người dùng: 1) Đăng xuất khỏi session. 2) Truy cập URL session bị hủy. 3) Xác định trạng thái session là 'bỏ' (e.g.,'expired'). 4) Nhấn nút 'Hủy bỏ' (e.g., 'End Session'). Đáp án: Nếu session đã bị hủy, thử nghiệm này sẽ kiểm tra hành động hủy bỏ session hợp lệ."
    },
    {
      "question_id": "EQ3018-VN",
      "question": "Viết một test case chuỗi các endpoint đăng ký, xác minh email và đăng nhập.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201 Created với link xác minh. 2) GET /verify với token → 200 OK. 3) POST /login → 200 OK với access token.",
      "model_answer": "- **Action:** 1) Đăng ký (POST /register) -> email được gửi. 2) Xác minh email (Verify Email, e.g., `https://api.example.com/v1/email-verify/${emailId}`). 3) Đăng nhập (POST /login). - **Expected:** All requests phải trả `200 OK`."
    },
    {
      "question_id": "EQ3020-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi cấp độ khó xác thực quy trình đặt lại mật khẩu.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /forgot-password với email → 200 OK. 2) GET /reset-link với token → 200 OK. 3) POST /reset-password với mật khẩu mới → 200 OK. 4) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "Thiết kế bài kiểm tra bao gồm các kịch bản: 1) Mọi thứ bình thường, 2) Sử dụng ký tự đặc biệt bị chặn, 3) Mật khẩu đã tồn tại."
    },
    {
      "question_id": "EQ3022-VN",
      "question": "Viết một test case chuỗi để xác thực việc tạo người dùng, cập nhật hồ sơ và truy xuất hồ sơ.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /users → 201 với userId. 2) PUT /users/{id} với dữ liệu cập nhật → 200. 3) GET /users/{id} → 200 với các trường đã cập nhật.",
      "model_answer": "Tìm kiếm hồ sơ của user `user_id` sau các giao dịch."
    },
    {
      "question_id": "EQ3024-VN",
      "question": "Giải thích một bài kiểm tra để xác thực refresh token không thể được sử dụng sau khi đăng xuất.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "Đăng nhập để lấy refresh token → đăng xuất → thử POST /refresh với token cũ → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra là dùng refresh token và xác suất đăng nhập. Nếu token không hoạt động sau logout, test pass."
    },
    {
      "question_id": "EQ3026-VN",
      "question": "Viết một test case xác thực việc ánh xạ chính xác mã lỗi nội bộ AUTH_EXPIRED tới trạng thái HTTP.",
      "category": "Contract & Schema Validation",
      "difficulty": "Hard",
      "gold_answer": "Kích hoạt token đã hết hạn → mong đợi HTTP 401 Unauthorized với mã ứng dụng AUTH_EXPIRED.",
      "model_answer": "Test case: Send expired session request → expect `401 Unauthorized` not `500 Internal Server Error`. Expected: API trả mã tắt HTTP không lỗi nội bộ."
    },
    {
      "question_id": "EQ3028-VN",
      "question": "Giải thích một bài kiểm tra chuỗi xác thực thất bại của xác minh email nếu token không hợp lệ.",
      "category": "Error Handling & Negative Testing",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → người dùng được tạo. 2) GET /verify?token=invalid → mong đợi 400 hoặc 401. 3) Nỗ lực đăng nhập thất bại cho đến khi được xác minh.",
      "model_answer": "Nếu token không hợp lệ, kiểm tra sẽ trả về lỗi vì không tương ứng với session thực. Bài kiểm tra thất bại vì nó thử nghiệm một trường hợp không được hỗ trợ."
    },
    {
      "question_id": "EQ3030-VN",
      "question": "Viết một test case cấp độ khó chuỗi các endpoint nộp đơn vay, kiểm tra tín dụng và phê duyệt.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /loan-application → 201. 2) POST /credit-check với appId → 200 với trạng thái passed. 3) POST /approve với appId → 200 được phê duyệt.",
      "model_answer": "1. **Preconditions:** Tài khoản exist, API key có. 2. **Steps:** Đăng ký vay -> `POST /loans` -> trả lãi -> phê duyệt -> từ chối. 3. **Verification:** DB có record loan, responevent specific (e.g., 'Loan Approved')."
    },
    {
      "question_id": "EQ3032-VN",
      "question": "Thiết kế một test case chuỗi đăng ký, đặt lại mật khẩu và đăng nhập với thông tin đăng nhập mới.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /signup → 201. 2) POST /reset-password với email → 200. 3) Đăng nhập với mật khẩu mới → 200 OK.",
      "model_answer": "1. **Đăng ký (Preconditions: Tài khoản chưa tồn tại)** - Viết lệnh giả người đăng nhập và tạo tài khoản.\n2. **Đặt lại mật khẩu (Preconditions: Mật khẩu đã được đặt lại)** - Chọn hành động 'Đặt lại mật khẩu' và kiểm tra mã xác minh.\n3. **Đăng nhập (Preconditions: Tài khoản tồn tại và mật khẩu đã được đặt lại)** - Viết lệnh giả người đăng nhập với thông tin đăng nhập mới."
    },
    {
      "question_id": "EQ3034-VN",
      "question": "Viết một test case chuỗi các endpoint tải lên file, quét virus và tải xuống.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201. 2) GET /scan/{id} → 200 sạch. 3) GET /download/{id} → 200 file được trả về.",
      "model_answer": "- **Preconditions:** File exist, user authenticated.\n- - **Upload File:** Send `POST` with file → `201 Created`.\n- - **Virus Scan:** Send `GET` /`virus` → `200 OK` with results.\n- - **Download File:** Send `GET` with ID → `302 Found` with download link.\n- - **Error:** File type forbidden → `403 Forbidden`."
    },
    {
      "question_id": "EQ3036-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn việc sử dụng lại refresh token.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập → lấy refresh token. 2) POST /refresh một lần → token mới. 3) Thử lại refresh token cũ một lần nữa → mong đợi 401 Unauthorized.",
      "model_answer": "Kiểm tra yêu cầu nhập token mới sau thời gian hạn cách. Đáp án đúng là token bị khóa hoặc yêu cầu xác thực."
    },
    {
      "question_id": "EQ3038-VN",
      "question": "Viết một test case chuỗi các API tìm kiếm, thêm vào giỏ hàng và thanh toán.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) GET /search?q=item → 200 kết quả. 2) POST /cart → 201 với itemId. 3) POST /checkout → 200 với xác nhận đơn hàng.",
      "model_answer": "**Test Case: Order Flow**\n- **Preconditions:** User exists, products available.\n- **Steps:**\n  - **Search:** `/products` với từ khóa \"Laptop\".\n  - **Add to Cart:** `/cart/add` với ID sản phẩm.\n  - **Checkout:** `/checkout` với tất cả giỏ hàng.\n- **Expected:** API trả `200 OK` với mã phản hồi."
    },
    {
      "question_id": "EQ3040-VN",
      "question": "Giải thích một bài kiểm tra chuỗi để xác thực việc ngăn chặn tấn công chiếm đoạt session API.",
      "category": "Security Testing",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với tư cách Người dùng A → lấy token. 2) Cố gắng sử dụng token từ Người dùng A trong session của Người dùng B → mong đợi 403 Forbidden.",
      "model_answer": "Bài kiểm tra này đảm bảo session được mã hóa và ngăn chặn truy cập bất hợp pháp."
    },
    {
      "question_id": "EQ3042-VN",
      "question": "Cung cấp chính xác một test case chuỗi để xác minh tính đồng thời lạc quan (optimistic concurrency) bằng cách sử dụng ETag với If-Match trên các endpoint cập nhật và đọc.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) GET /resource → nhận ETag=v1. 2) PUT /resource với If-Match=v1 → 200 OK. 3) Thử lại PUT /resource với If-Match=v1 cũ → 412 Precondition Failed.",
      "model_answer": "- **Preconditions:** 1) Một tài khoản được tạo với bản phát hành `vA` và ETag cụ thể. 2) Một tài nguyên được tạo với trạng thái `vA`. - **Test Case:** 1. Send `POST` với ETag `\"vA\"` và tạo tài nguyên thành công. 2. Update tài nguyên với ETag `\"vB\"` và send `PUT`. 3. Send `GET` với ETag `\"vA\"` (chỉ định) và verify phản hồi có thể là `200 OK` nếu chỉxác đồng thời xảy ra. 4. Send `GET` với ETag không chính xác → `404 Not Found`. - **Expected Result:** VD1: `200 OK` nếu chỉxác đồng thời xảy ra. VD2: `404 Not Found` nếu ETag lỗi."
    },
    {
      "question_id": "EQ3044-VN",
      "question": "Thiết kế một bài kiểm tra multi-hop xác minh công việc xuất không đồng bộ: POST /exports -> thăm dò GET /jobs/{id} cho đến khi hoàn thành -> GET /exports/{id}.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /exports → 202 Accepted với jobId. 2) Thăm dò GET /jobs/{id} cho đến khi status=done. 3) GET /exports/{id} → 200 OK với file.",
      "model_answer": "Chuẩn bị: 1 job = 5 phút, 2 job = 10 phút. Kiểm tra DB phản hồi nhanh → test đồng bộ."
    },
    {
      "question_id": "EQ3046-VN",
      "question": "Cung cấp một bài kiểm tra tiêu cực chuỗi cho OAuth2 Authorization Code: /authorize -> /token -> gọi tài nguyên với scope bị thiếu.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) /authorize với sự đồng ý của người dùng → code. 2) /token → access token với scope hạn chế. 3) Gọi tài nguyên yêu cầu scopeX → 403 Forbidden.",
      "model_answer": "Trả lời: Đăng nhập vào tài khoản test. 1. Truy cập `/authorize` với mã được cấp (code) test. 2. Truy cập `/token` với mã được cấp (code) test và kiểm tra response có chứa `scope`. 3. Gọi `resource` với scope bị thiếu và kiểm tra `403` hoặc `404`NotFound."
    },
    {
      "question_id": "EQ3048-VN",
      "question": "Viết một bài kiểm tra chuỗi bao gồm việc tạo charge幂等 (idempotent charge creation) với Idempotency-Key trên các endpoint thử lại và hoàn tiền.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) POST /charge với Idempotency-Key=abc → 201 Created. 2) Thử lại cùng một yêu cầu với Idempotency-Key=abc → 200 OK (cùng chargeId). 3) POST /refund → 200 OK.",
      "model_answer": "- **Tính chất 1 (Idempotency-Key):** Send identical `idempotency-key` requests twice (endpoint: `/charge` hoặc `/payment`). **Expected:** First call tạo `charge` → 200 OK, DB ghi nhận. Second call → 200 OK, DB không thay đổi. **Tính chất 2 (Idempotency):** Send request nhiều lần với cùng `idempotency-key`. **Expected:** DB chỉ ghi nhận lần đầu. **Tính chất 3 (Idempotency-Key bảo mật):** `idempotency-key` không được exposure trong API response (không phải là token open, được sử dụng chỉ với DB mapping)."
    },
    {
      "question_id": "EQ3050-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi cho quy trình xử lý file: tải lên -> POST /process -> thăm dò trạng thái -> tải xuống, bao gồm cả việc xử lý 202.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /upload → 201 với fileId. 2) POST /process/{fileId} → 202 Accepted. 3) Thăm dò GET /status/{id} cho đến khi hoàn thành. 4) GET /download/{id} → 200 file được trả về.",
      "model_answer": "Kiểm tra bao gồm tải file lên server, gửi request POST với file, kiểm tra trạng thái 202 (tài liệu chuyển tiếp), và tải xuống file cuối cùng."
    },
    {
      "question_id": "EQ3052-VN",
      "question": "Cung cấp một bài kiểm tra chuỗi để xác thực việc hủy bỏ session SSO được truyền tới API gateway và truy cập microservice.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập qua SSO → token được cấp. 2) Truy cập API gateway → 200. 3) Hủy bỏ session trong IdP. 4) Thử lại cuộc gọi API → 401 Unauthorized trên tất cả các microservice.",
      "model_answer": "1. **API Gateway:** Send a request with a expired session token → `403 Forbidden`. 2. **Microservice:** Call authentication endpoint with expired session → `400 Bad Request`. 3. **Database:** Verify session record was properly deleted."
    },
    {
      "question_id": "EQ3054-VN",
      "question": "Viết một test case chuỗi cho việc thực hiện đơn hàng một phần: tạo đơn hàng -> dự trữ hàng tồn kho -> ship một phần -> hủy phần còn lại và hoàn tiền chênh lệch.",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /orders → 201 với orderId. 2) POST /reserve/{id} → 200 đã được dự trữ. 3) POST /ship/{id} với các mặt hàng một phần → 200 đã được ship. 4) POST /cancel/{id} → hoàn tiền được cấp.",
      "model_answer": "1. **Preconditions:** Tạo hàng tồn kho với số lượng vừa đủ. 2. **Steps:** - **Action:** Chọn phần của đơn hàng muốn ship. - **Expected:** Hàng còn lại bị hủy, thanh toán chênh lệch hoàn tiền. 3. **Post-condition:** DB xác minh trạng thái đơn hàng, thanh toán."
    },
    {
      "question_id": "EQ3056-VN",
      "question": "Cung cấp chính xác một bài kiểm tra tiêu cực chuỗi cho đăng nhập 2FA: POST /login -> POST /2fa/verify với mã sai -> POST /refresh.",
      "category": "Authentication & Authorization",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập với username/password → 200 đang chờ 2FA. 2) POST /2fa/verify với mã sai → 401 Unauthorized. 3) Thử refresh → 401 Unauthorized.",
      "model_answer": "1. **Đăng nhập 2FA:** Send `POST /login` với thông tin đăng nhập chính xác. 2. **Xác minh mã 2FA:** Send `POST /2fa/verify` với mã 2FA sai (ví dụ: `223344` thay vì `123456`). 3. **Thử refresh token:** Send `POST /refresh` với token refresh bất hợp pháp. All three sẽ trả về mã số lỗi 401/403/400."
    },
    {
      "question_id": "EQ3058-VN",
      "question": "Thiết kế một bài kiểm tra chuỗi xác minh tính nhất quán phân trang trên các thao tác tạo -> liệt kê -> xóa -> liệt kê (với các xác nhận tổng số đếm).",
      "category": "Test Case",
      "difficulty": "Hard",
      "gold_answer": "1) POST /items → 201. 2) GET /items → số đếm tăng. 3) DELETE /items/{id} → 200. 4) GET /items → số đếm giảm.",
      "model_answer": "Thực hiện các thao tác với DB, lưu lại kết quả mỗi bước, so sánh tổng số với kết quả trước/qua. Đảm bảo phân trang rõ ở các API khác nhau."
    },
    {
      "question_id": "EQ3060-VN",
      "question": "Viết một bài kiểm tra chuỗi cho tính dính session (session stickiness): đăng nhập -> các cuộc gọi tiếp theo qua load balancer -> đăng xuất -> xác minh không có node nào chấp nhận token cũ.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Hard",
      "gold_answer": "1) Đăng nhập để lấy token. 2) Gọi dịch vụ qua LB nhiều lần → cùng một node/session. 3) Đăng xuất. 4) Thử lại → tất cả các node đều trả về 401.",
      "model_answer": "Đăng nhập -> các yêu cầu -> đăng xuất. **Expected:** Token bị vô hiệu hóa sau logout."
    },
    {
      "question_id": "EQ4002-VN",
      "question": "Viết một **test** theo kiểu **state-machine** xác thực vòng đời tài khoản: tạo → kích hoạt → tạm ngừng → kích hoạt lại → xóa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /accounts** → 201 Created. 2) **POST /activate/{id}** → 200. 3) **POST /suspend/{id}** → 200. 4) **POST /reactivate/{id}** → 200. 5) **DELETE /accounts/{id}** → 204. Xác nhận **GET /accounts/{id}** → 404.",
      "model_answer": "- **State Machine:** \n    - **Initial:** Tạo tài khoản → `account_created` → kích hoạt.\n    - **Active:** Kích hoạt → `account_activated` → sử dụng.\n    - **Suspended:** Tạm ngừng → `account_suspended` → xóa khi muốn.\n    - **Deleted:** Xóa tài khoản → `account_deleted`.\n- **Test Steps:**\n    1. Tạo tài khoản → `account_created`.\n    2. Kích hoạt → `account_activated`.\n    3. Tạm ngừng → `account_suspended`.\n    4. Kích hoạt lại → `account_activated` (nếu dịch vụ hỗ trợ).\n    5. Xóa → `account_deleted`.\n- **Expected Results:**\n    - Vòng đời được quản lý chính xác.\n    - Các trạng thái không lặp nhau."
    },
    {
      "question_id": "EQ4004-VN",
      "question": "Thiết kế một **test chained** xác thực **rollback** giao dịch khi bước 2 của giao dịch chuyển tiền 3 bước thất bại.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /transfer/initiate** → 201. 2) **POST /transfer/step2** với chi tiết không hợp lệ → thất bại 400. 3) Xác minh **DB** không hiển thị dữ liệu chuyển tiền một phần nào được ghi lại.",
      "model_answer": "1. **Giao dịch đầu tiên:** Initiate a transfer transaction (Step 1).\n2. **Giao dịch thứ hai:** Trigger a second transaction, this time a'save' operation (e.g., storing order details) which depends on the successful transfer.\n3. **Giao dịch thứ ba:** Attempt a 'rollback' transaction, simulating the failure of the initial transfer (e.g., reversing the account debit).\n4. **Xác minh:** Verify that the rollback transaction successfully reverses the failed transfer's effects, resulting in the account being credited back."
    },
    {
      "question_id": "EQ4006-VN",
      "question": "Viết một **test** xác thực chuỗi nhiều dịch vụ: đăng nhập → tạo đơn hàng → xử lý thanh toán → hủy đơn hàng sau khi ghi nhận.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → 200 **token**. 2) **POST /orders** → 201. 3) **POST /payment** → 200 ghi nhận. 4) **POST /cancel/{orderId}** → hoàn tiền → 200 OK. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "- **Test Case:** 1) Đăng nhập vào tài khoản khách hàng. 2) Thực hiện tạo đơn hàng. 3) Xử lý thanh toán. 4) Hủy đơn hàng. 5) Xác minh trạng thái đơn hàng được cập nhật thành 'Chưa giao' sau khi hủy."
    },
    {
      "question_id": "EQ4008-VN",
      "question": "Mô tả một **test state-machine** xác thực vòng đời mật khẩu: đặt → hết hạn → đặt lại → ngăn tái sử dụng.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /password/set** → 200. 2) Hết hạn mật khẩu thủ công. 3) **POST /password/reset** → 200. 4) Cố gắng tái sử dụng mật khẩu cũ → **400 Bad Request**.",
      "model_answer": "Đặt mật khẩu → test đảm bảo hoạt động hạn chế sau → thử đăng nhập nhiều lần."
    },
    {
      "question_id": "EQ4010-VN",
      "question": "Viết một **test chained** phức tạp bao gồm luồng đăng ký khoản vay với nhánh thất bại trong kiểm tra tín dụng.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /loan/apply** → 201. 2) **POST /loan/credit-check** với lịch sử xấu → thất bại 400. 3) Đảm bảo **GET /loan/approve** không được phép. 4) **GET /loan/{id}** → **status**=bị từ chối.",
      "model_answer": "1. Đăng nhập với tài khoản hợp lệ -> 2. Mở khoản vay -> 3. Triggers action registration -> 4. Đăng nhập tài khoản thất bại -> 5. Branch registration fails -> 6. Verify no DB entry created."
    },
    {
      "question_id": "EQ4012-VN",
      "question": "Viết một **test** xác thực tính toàn vẹn dữ liệu khi các thao tác ghi đồng thời xảy ra: cập nhật hồ sơ người dùng với các giá trị xung đột.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **PUT /users/{id} name=Alice** với **If-Match=v1** → 200. 2) **PUT /users/{id} name=Bob** với **stale If-Match=v1** → **412 Precondition Failed**. 3) **GET /users/{id}** → Alice.",
      "model_answer": "**Kết hợp:** Simulate nhiều giao thức cập nhật đồng thời. **Vấn đề:** Nếu không đảm bảo toàn vẹn, một cập nhật lén thay đổi giá trị (VD:'status' -> 'xóa') nhưng giao thức còn cập nhật chính xác 'tên người dùng'. **Giải thích:** Test này kiểm tra xem DB được giữ nguyên khi nhiều giao thức cập nhật đồng thời."
    },
    {
      "question_id": "EQ4014-VN",
      "question": "Viết một **test chained** rất khó xác thực việc ký tài liệu chuỗi: tải lên → ký → xác minh → phát hiện giả mạo.",
      "category": "Security Testing",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /documents** → 201. 2) **POST /sign/{id}** → 200. 3) **GET /verify/{id}** → chữ ký hợp lệ. 4) Sửa đổi tệp → **GET /verify/{id}** → phát hiện chữ ký không hợp lệ.",
      "model_answer": "Test chained cần simulate hành động ký và xác minh. Tuy nhiên, tải lên → tải xuống → xác minh giả mạo là thử thách thực tế khó xác thực. Hơn nữa, cần đảm bảo hệ thống ký tài liệu không bị ảnh hưởng khi test diễn ra."
    },
    {
      "question_id": "EQ4017-VN",
      "question": "Viết một **test state-machine** xác thực vòng đời đăng ký: tạo → nâng cấp → hạ cấp → hủy.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /subscriptions** → 201. 2) **POST /upgrade/{id}** → 200. 3) **POST /downgrade/{id}** → 200. 4) **DELETE /subscriptions/{id}** → 204. **GET /subscriptions/{id}** → 404.",
      "model_answer": "1. **Action:** Register → `POST /register`.\n2. **Expected:** → `201 Created`.\n3. **Negative:** → `409 Conflict` (duplicated).\n4. **Upgrade:** → `202 Accepted`.\n5. **Downgrade:** → `200 OK`.\n6. **Unregister:** → `DELETE /register`."
    },
    {
      "question_id": "EQ4019-VN",
      "question": "Viết một **test chained** rất khó xác thực khả năng phục hồi sau thất bại một phần trong một **distributed order saga**.",
      "category": "Advanced Testing Strategies",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /order** → 201. 2) Đặt trước hàng tồn kho → 200. 3) Thanh toán thất bại → 402. 4) Xác minh việc đặt trước hàng tồn kho tự động bị hủy. 5) **GET /orders/{id}** → **status**=đã hủy.",
      "model_answer": "Distributed orders require multiple services and dependencies, making test chaining invalid for recovery tests. A simpler approach is to isolate the failed step and test recovery individually."
    },
    {
      "question_id": "EQ4021-VN",
      "question": "Viết một **test** rất khó xác minh việc đảo ngược giao dịch tài chính: ghi nợ → ghi có → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /debit** → 200. 2) **POST /credit** → 200. 3) Mô phỏng lỗi hệ thống. 4) **Rollback** cả ghi nợ và ghi có. 5) Xác minh số dư tài khoản không thay đổi.",
      "model_answer": "To design a test that verifies rollback of a financial transaction, you need to simulate a scenario where a debit (ghi nợ) is successfully recorded, followed by a credit (ghi có) to the exact opposite amount. After the system is configured to fail rollbacks, the test must inject a failure signal into the database or system state immediately after the debit is recorded. The expected outcome is that the debit transaction is reversed, and its records ( debit amount, timestamp) are removed from the database."
    },
    {
      "question_id": "EQ4023-VN",
      "question": "Thiết kế một **test state-machine** cho kho hàng: thêm hàng → phân bổ → vận chuyển → trả lại → đối chiếu.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /stock/add** → 200. 2) **POST /allocate** → 200. 3) **POST /ship** → 200. 4) **POST /return** → 200. 5) **GET /inventory** → số lượng cuối cùng được đối chiếu.",
      "model_answer": "Test case: 1) Đặt hàng → 2) Xác nhận phân bổ → 3) Vận chuyển → 4) Trả lại → 5) Ký hợp đồng → expected: hàng được phân bổ đúng cách."
    },
    {
      "question_id": "EQ4025-VN",
      "question": "Viết một **test chained** xác thực vòng đời **session mobile**: đăng nhập → làm mới **token** → đăng xuất → làm mới với **token** cũ → thất bại.",
      "category": "Authentication & Authorization",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /login** → **token**. 2) **POST /refresh** → **token** mới. 3) **POST /logout**. 4) Cố gắng làm mới lại với **token** cũ → **401 Unauthorized**.",
      "model_answer": "- **Action 1:** Triggers đăng nhập và mã hóa token.\n- **Action 2:** Triggers làm mới token.\n- **Action 3:** Triggers đăng xuất và xóa token.\n- **Action 4:** Triggers làm mới token với ID cũ → `401 Unauthorized` được trả về."
    },
    {
      "question_id": "EQ4027-VN",
      "question": "Viết một **test chained** xác thực API gửi email: gửi → theo dõi mở → hủy đăng ký → đảm bảo không gửi thêm email nào nữa.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /emails** → 202 Accepted. 2) **GET /tracking/{id}** → mở được ghi lại. 3) **POST /unsubscribe** → 200. 4) **POST /emails** → 202 nhưng không gửi cho người dùng đã hủy đăng ký.",
      "model_answer": "Chained test: 1) Đăng nhập, gửi email → mail sent là true. 2) Mở email → mail sent là false. 3) Hủy đăng ký → API không gửi email nữa."
    },
    {
      "question_id": "EQ4029-VN",
      "question": "Viết một **test chained** rất khó cho luồng mua hàng với việc áp dụng phiếu giảm giá và nhánh thất bại: áp dụng phiếu giảm giá → thanh toán → phiếu giảm giá không hợp lệ → **rollback**.",
      "category": "Test Case",
      "difficulty": "Very Hard",
      "gold_answer": "1) **POST /apply-coupon** → 400 không hợp lệ. 2) **POST /checkout** → bị từ chối. 3) Đảm bảo đơn hàng không được lưu trữ. 4) **GET /orders** → phiếu giảm giá không được áp dụng.",
      "model_answer": "Test chained: 1) Đưa hàng (shipment) và áp dụng giảm giá → 2) Thanh toán (payment) → 3) Giảm giá không hợp lệ → **rollback** (vệ sinh DB với mã giảm giá không tồn tại)."
    }
  ]
}